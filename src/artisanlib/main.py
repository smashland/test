# ABOUT
# This program shows how to plot the temperature and its rate of change from a
# Fuji PID or a thermocouple meter.

# LICENSE
# This program or module is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 2 of the License, or
# version 3 of the License, or (at your option) any later version. It is
# provided for educational purposes and is distributed in the hope that
# it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
# the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# MAINTAINER
# Marko Luther, 2023

# updateLargeLCDsReadings
# largeLCDs_dialog
import time as libtime
startup_time = libtime.process_time()

from artisanlib import __version__
from artisanlib import __revision__
from artisanlib import __build__

from artisanlib import __release_sponsor_name__
import gettext
import tkinter as tk
## Profiling: use @profile annotations
# import cProfile
# import io
# import pstats
# def profile(func):
#    def wrapper(*args, **kwargs):
#        pr = cProfile.Profile()
#        pr.enable()
#        retval = func(*args, **kwargs)
#        pr.disable()
#        s = io.StringIO()
#        sortby = pstats.SortKey.CUMULATIVE  # 'cumulative'
#        ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
#        ps.print_stats()
#        print(s.getvalue())
#        return retval
#    return wrapper

import os
import sys  # @UnusedImport
import http.client
import getpass
import json
import ast
import platform
import math
import datetime
import warnings
import numpy
import threading
import multiprocessing
import re
import random
import configparser
# import gc
import io
import functools
import dateutil.parser
import shutil
import copy as copyd
import arabic_reshaper  # type:ignore
from pathlib import Path
from bidi.algorithm import get_display  # type:ignore

# links CTR-C signals to the system default (ignore)
import signal

print('当前 Python 解释器路径：')
print(sys.executable)

print("当前工作目录:", os.getcwd())


signal.signal(signal.SIGINT, signal.SIG_DFL)

import logging.config
from yaml import safe_load as yaml_load
from typing import Final, Optional, List, Dict, Tuple, Union, cast, Any, Callable, \
    TYPE_CHECKING  # for Python >= 3.9: can remove 'List' since type hints can now use the generic 'list'

from functools import reduce as freduce

import numpy as np

import requests

## MONKEY PATCH BEGIN: importlib.metadata fix for macOS builds with py2app that fails to set proper metadata for prettytable >0.7.2 and thus fail
## on import with importlib.metadata.PackageNotFoundError: prettytable on __version__ = importlib_metadata.version(__name__)
try:
    import importlib.metadata as importlib_metadata  # @UnresolvedImport


    def md_version(distribution_name: str) -> str:
        if distribution_name == 'prettytable':
            return '2.1.0'
        return importlib_metadata.version(distribution_name)


    importlib_metadata.version = md_version
except Exception:  # pylint: disable=broad-except
    pass
## MONKEY PATCH END:

try:  # activate support for hiDPI screens on Windows
    if str(platform.system()).startswith('Windows'):
        os.environ['QT_AUTO_SCREEN_SCALE_FACTOR'] = '1'
        os.environ['QT_ENABLE_HIGHDPI_SCALING'] = '1'
except Exception:  # pylint: disable=broad-except
    pass

# write logtrace to Console on OS X:
# try:
# ..
# except Exception as e: # pylint: disable=broad-except
#    import syslog
#    syslog.openlog("artisan")
#    syslog.syslog(syslog.LOG_ALERT, str(e))
#    syslog.syslog(syslog.LOG_ALERT, str(traceback.format_exc()))

QtWebEngineSupport: bool = False  # set to True if the QtWebEngine was successfully imported
try:
    import importlib.metadata as importlib_metadata # @UnresolvedImport
    def md_version(distribution_name:str) -> str:
        if distribution_name == 'prettytable':
            return '2.1.0'
        return importlib_metadata.version(distribution_name)
    importlib_metadata.version = md_version
except Exception: # pylint: disable=broad-except
    pass
## MONKEY PATCH END:

try: # activate support for hiDPI screens on Windows
    if str(platform.system()).startswith('Windows'):
        os.environ['QT_AUTO_SCREEN_SCALE_FACTOR'] = '1'
        os.environ['QT_ENABLE_HIGHDPI_SCALING'] = '1'
except Exception: # pylint: disable=broad-except
    pass

# write logtrace to Console on OS X:
#try:
#..
#except Exception as e: # pylint: disable=broad-except
#    import syslog
#    syslog.openlog("artisan")
#    syslog.syslog(syslog.LOG_ALERT, str(e))
#    syslog.syslog(syslog.LOG_ALERT, str(traceback.format_exc()))

QtWebEngineSupport:bool = False # set to True if the QtWebEngine was successfully imported

try:
    from PyQt6.QtWidgets import (QApplication, QWidget, QMessageBox, QLabel, QMainWindow, QFileDialog,
                             QGraphicsDropShadowEffect,  # @Reimport @UnresolvedImport @UnusedImport # pylint: disable=import-error
                             QInputDialog, QGroupBox, QLineEdit,  # @Reimport @UnresolvedImport @UnusedImport
                             QSizePolicy, QVBoxLayout, QHBoxLayout,
                             QPushButton,  # @Reimport @UnresolvedImport @UnusedImport
                             QLCDNumber, QSpinBox, QComboBox,  # @Reimport @UnresolvedImport @UnusedImport
                             QSlider,  # @Reimport @UnresolvedImport @UnusedImport
                             QColorDialog, QFrame, QSplitter, QScrollArea,
                             QProgressDialog, QProgressBar,  # @Reimport @UnresolvedImport @UnusedImport
                             QStyleFactory, QMenu, QLayout, QCheckBox,QListWidget, QListWidgetItem,
                             QDateEdit, QSpacerItem, QGridLayout, QDialog, QCalendarWidget, QTimeEdit, QTextEdit, QSizePolicy,QDateTimeEdit) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt6.QtGui import (QScreen, QPageLayout, QAction, QImageReader,
                         QWindow,  # @Reimport @UnresolvedImport @UnusedImport
                         QKeySequence, QShortcut,  # @Reimport @UnresolvedImport @UnusedImport
                         QPixmap, QColor, QDesktopServices, QIcon, QFontDatabase,
                         QFont,  # @Reimport @UnresolvedImport @UnusedImport
                         QRegularExpressionValidator, QDoubleValidator, QPainter,
                         QCursor, QMovie, QPen, QFontMetrics, QBrush,QGuiApplication) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt6.QtPrintSupport import (QPrinter,QPrintDialog) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt6.QtCore import (QLibraryInfo, QTranslator, QLocale, QFileInfo, PYQT_VERSION_STR, pyqtSignal, pyqtSlot,
                          QtMsgType, QSize, # @Reimport @UnresolvedImport @UnusedImport
    #                              QSize, pyqtProperty, # type: ignore # @Reimport @UnresolvedImport @UnusedImport
                          qVersion, QVersionNumber, QTime, QTimer, QFile, QIODevice, QTextStream,
                          QSettings,  # @Reimport @UnresolvedImport @UnusedImport
                          QRegularExpression, QDate, QUrl, QUrlQuery, QDir, Qt, QPoint, QEvent, QDateTime, QThread,
                          qInstallMessageHandler, QBasicTimer, QDate, QRectF) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt6.QtNetwork import QLocalSocket, QNetworkAccessManager, QNetworkRequest, QNetworkReply # @Reimport @UnresolvedImport @UnusedImport
    #QtWebEngineWidgets must be imported before a QCoreApplication instance is created
    try:
        from PyQt6.QtWebEngineWidgets import QWebEngineView # @Reimport @UnresolvedImport @UnusedImport  # pylint: disable=import-error,no-name-in-module
        QtWebEngineSupport = True
    except ImportError:
        # on the RPi platform there is no native package PyQt-WebEngine nor PyQt6-WebEngine for Raspebarry 32bit
        pass
    from PyQt6 import sip # @Reimport @UnresolvedImport @UnusedImport
except ImportError:
    from PyQt5.QtWidgets import (QAction, QApplication, QWidget, QMessageBox, QLabel, QMainWindow, QFileDialog, QGraphicsDropShadowEffect,  # type: ignore  # @Reimport @UnresolvedImport @UnusedImport
                             QInputDialog, QGroupBox, QLineEdit, # @Reimport @UnresolvedImport @UnusedImport
                             QSizePolicy, QVBoxLayout, QHBoxLayout, QPushButton, # @Reimport @UnresolvedImport @UnusedImport
                             QLCDNumber, QSpinBox, QComboBox, # @Reimport @UnresolvedImport @UnusedImport
                             QSlider, # @Reimport @UnresolvedImport @UnusedImport
                             QColorDialog, QFrame, QSplitter, QScrollArea, QProgressDialog, # @Reimport @UnresolvedImport @UnusedImport
                             QStyleFactory, QMenu, QLayout, QShortcut) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt5.QtGui import (QScreen, QPageLayout, QImageReader, QWindow,  # type: ignore # @Reimport @UnresolvedImport @UnusedImport
                                QKeySequence, # @Reimport @UnresolvedImport @UnusedImport
                                QPixmap,QColor,QDesktopServices,QIcon, # @Reimport @UnresolvedImport @UnusedImport
                                QRegularExpressionValidator, QDoubleValidator, QPainter, QCursor) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt5.QtPrintSupport import (QPrinter,QPrintDialog) # type: ignore # @Reimport @UnresolvedImport @UnusedImport
    from PyQt5.QtCore import (QLibraryInfo, QTranslator, QLocale, QFileInfo, PYQT_VERSION_STR, pyqtSignal, pyqtSlot, QtMsgType, # type: ignore # @Reimport @UnresolvedImport @UnusedImport
                              qVersion, QVersionNumber, QTime, QTimer, QFile, QIODevice, QTextStream, QSettings, # @Reimport @UnresolvedImport @UnusedImport
                              QRegularExpression, QDate, QUrl, QUrlQuery, QDir, Qt, QPoint, QEvent, QDateTime, QThread, qInstallMessageHandler) # @Reimport @UnresolvedImport @UnusedImport
    from PyQt5.QtNetwork import QLocalSocket # type: ignore # @Reimport @UnresolvedImport @UnusedImport
    #QtWebEngineWidgets must be imported before a QCoreApplication instance is created
    try:
        from PyQt5.QtWebEngineWidgets import QWebEngineView # type: ignore # @Reimport @UnresolvedImport @UnusedImport # pylint: disable=import-error,no-name-in-module
        QtWebEngineSupport = True
    except ImportError:
        # on the RPi platform there is no native package PyQt-WebEngine nor PyQt6-WebEngine for Raspebarry 32bit
        pass
    try:
        from PyQt5 import sip # type: ignore # @Reimport @UnresolvedImport @UnusedImport
    except ImportError:
        import sip # type: ignore # @Reimport @UnresolvedImport @UnusedImport



from artisanlib.suppress_errors import suppress_stdout_stderr

with suppress_stdout_stderr():
    import matplotlib as mpl
    from matplotlib import colormaps
    import matplotlib.colors as mcolors

from artisanlib.suppress_errors import suppress_stdout_stderr

with suppress_stdout_stderr():
    import matplotlib as mpl
    from matplotlib import colormaps
    import matplotlib.colors as mcolors

# try:
#    mpl_version = [int(i) for i in mpl.__version__.split('.')]
# except Exception: # pylint: disable=broad-except
#    mpl_version = [7,7,7] # a trunk version

from matplotlib.backend_bases import _Mode as MPL_Mode  # @UnresolvedImport

# on OS X / PyQt5 one needs to
#   export DYLD_FRAMEWORK_PATH=~/Qt5.5.0/5.5/clang_64/lib/
# (see Mac OS X specific notes in the PyQt5 documentation)
# print(QImageReader.supportedImageFormats())
# print(QLibraryInfo.path(QLibraryInfo.LibraryLocation.PluginsPath))

svgsupport = next((x for x in QImageReader.supportedImageFormats() if x == b'svg'), None)

from matplotlib.figure import Figure
from matplotlib import rcParams, ticker
from matplotlib.font_manager import FontProperties, fontManager
from matplotlib.transforms import Bbox

from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas  # @Reimport
from matplotlib.backends.backend_qt import NavigationToolbar2QT as NavigationToolbar  # @Reimport
from matplotlib.backend_bases import LocationEvent as mplLocationevent

from matplotlib.backends.qt_editor import figureoptions
import matplotlib.backends.qt_editor._formlayout as formlayout

if TYPE_CHECKING:
    from types import TracebackType
    from artisanlib.types import ProfileData, ComputedProfileInformation, RecentRoast, ExtraDeviceSettings, Palette, \
        CurveSimilarity, ProductionData, ProductionDataStr, Wheel  # pylint: disable=unused-import
    from artisanlib.roast_properties import editGraphDlg  # pylint: disable=unused-import
    from artisanlib.comparator import roastCompareDlg  # pylint: disable=unused-import
    from artisanlib.wheels import WheelDlg  # pylint: disable=unused-import
    from artisanlib.hottop import Hottop  # pylint: disable=unused-import
    from artisanlib.weblcds import WebLCDs  # pylint: disable=unused-import
    from artisanlib.santoker import Santoker  # pylint: disable=unused-import
    from artisanlib.kaleido import KaleidoPort  # pylint: disable=unused-import
    from artisanlib.ikawa import IKAWA_BLE  # pylint: disable=unused-import
    from matplotlib.text import Annotation  # pylint: disable=unused-import
    from openpyxl.worksheet.worksheet import Worksheet  # pylint: disable=unused-import
    import numpy.typing as npt  # pylint: disable=unused-import
    from PyQt6.QtWidgets import QTableWidgetItem, QTableWidget, QScrollBar,QFileDialog  # pylint: disable=unused-import
    from PyQt6.QtGui import QStyleHints, QClipboard, QKeyEvent, QMouseEvent, QDropEvent, QDragEnterEvent, QCloseEvent, \
        QResizeEvent, QValidator  # pylint: disable=unused-import
    from PyQt6.QtCore import QObject, QPermission, QMessageLogContext  # noqa: F401 # pylint: disable=unused-import
    from PyQt6.QtWebEngineCore import QWebEnginePage  # noqa: F401 # pylint: disable=unused-import
    from matplotlib.backend_bases import Event as MplEvent, MouseEvent  # pylint: disable=unused-import
    from matplotlib.artist import Artist  # pylint: disable=unused-import
    from xml.etree.ElementTree import Element as XMLElement

# fix socket.inet_pton on Windows (used by pymodbus TCP/UDP)
try:
    if str(platform.system()).startswith('Windows'):
        import \
            win_inet_pton  # type: ignore # @UnresolvedImport @UnusedImport # pylint: disable=import-error,unused-import # noqa: F401
except Exception:  # pylint: disable=broad-except
    pass

from artisanlib.util import (appFrozen, uchr, decodeLocal, decodeLocalStrict, encodeLocal, encodeLocalStrict, s2a,
                             fill_gaps,
                             deltaLabelPrefix, deltaLabelUTF8, deltaLabelBigPrefix, stringfromseconds,
                             stringtoseconds,
                             fromFtoCstrict, fromCtoFstrict, RoRfromFtoCstrict, RoRfromCtoFstrict,
                             convertRoR, convertRoRstrict, convertTemp, path2url, toInt, toString, toList, toFloat,
                             toBool, toStringList, removeAll, application_name, application_viewer_name,
                             application_organization_name,
                             application_organization_domain, getAppPath, getResourcePath,
                             debugLogLevelToggle,
                             debugLogLevelActive, setDebugLogLevel, createGradient, natsort, setDeviceDebugLogLevel,
                             comma2dot, is_proper_temp)

from artisanlib.qtsingleapplication import QtSingleApplication

try:
    # spanning a second multiprocessing instance (Hottop server) on macOS falils to import the YAPI interface
    from yoctopuce.yocto_api import YAPI  # type: ignore
except ImportError:
    pass

# platform dependent imports:
if sys.platform.startswith('darwin'):
    # control app napping on OS X >= 10.9
    import appnope  # type: ignore # @UnresolvedImport # type: ignore # pylint: disable=import-error

    appnope.nope()
    if QVersionNumber.fromString(qVersion())[0] < QVersionNumber(6, 5, 0):
        # import darkdetect module to detect if macOS dark mode is active or not if Qt < 6.5.0, otherwise we related to QTs ColorScheme() mechanism
        import darkdetect  # type: ignore # type: ignore # @UnresolvedImport # pylint: disable=import-error

#######################################################################################
#################### Main Application  ################################################
#######################################################################################

appGuid: Final[str] = '9068bd2fa8e54945a6be1f1a0a589e92'
viewerAppGuid: Final[str] = '9068bd2fa8e54945a6be1f1a0a589e93'

token = None
class Artisan(QtSingleApplication):
    sendmessage2ArtisanInstanceSignal = pyqtSignal(str, str)
    sendmessage2ArtisanViewerSignal = pyqtSignal(str)

    __slots__ = ['sentToBackground', 'plus_sync_cache_expiration', 'artisanviewerMode', 'darkmode', 'style_hints']

    def __init__(self, args: Any) -> None:
        super().__init__(appGuid, viewerAppGuid, args)

        # with Qt.ConnectionType.QueuedConnection the signal is queued even if called from the same thread
        self.sendmessage2ArtisanInstanceSignal.connect(self._sendMessage2ArtisanInstanceSlot,
                                                       type=Qt.ConnectionType.QueuedConnection)  # type: ignore
        self.sendmessage2ArtisanViewerSignal.connect(self._sendMessage2ArtisanViewerSlot,
                                                     type=Qt.ConnectionType.QueuedConnection)  # type: ignore

        self.sentToBackground: Optional[
            float] = None  # set to timestamp on putting app to background without any open dialog
        self.plus_sync_cache_expiration = 1 * 60  # how long a plus sync is valid in seconds

        self.artisanviewerMode: bool = False  # true if this is the ArtianViewer running
        if multiprocessing.current_process().name == 'MainProcess' and self.isRunning():
            self.artisanviewerMode = True
            if str(platform.system()) != 'Windows' and self.isRunningViewer():
                sys.exit(0)  # there is already one ArtisanViewer running, we terminate

        self.darkmode: bool = False  # holds current darkmode state
        self.style_hints: Optional['QStyleHints'] = None  # holds the styleHints instance on Qt 6.5 and higher
        if QVersionNumber.fromString(qVersion())[0] < QVersionNumber(6, 5, 0):
            if sys.platform.startswith('darwin'):
                # remember darkmode using darkdetect on macOS Legacy with older Qt versions
                self.darkmode = darkdetect.isDark()  # pyright: ignore # "isDark" is not a known member of module "darkdetect" # pylint: disable=c-extension-no-member
            # otherwise we do not have any mean to detect the systems palette
        else:
            # we use the Qt 6.5 ColorScheme mechanism to detect dark mode
            self.style_hints = self.styleHints()
            if self.style_hints is not None:
                self.darkmode = self.style_hints.colorScheme() == Qt.ColorScheme.Dark
                self.style_hints.colorSchemeChanged.connect(self.colorSchemeChanged)

        self.messageReceived.connect(self.receiveMessage)
        self.focusChanged.connect(self.appRaised)

    try:
        @pyqtSlot('Qt::ColorScheme')
        def colorSchemeChanged(self, colorScheme: 'Qt.ColorScheme') -> None:
            aw: Optional['ApplicationWindow'] = self.activationWindow()
            if aw is not None and self.darkmode != bool(colorScheme == Qt.ColorScheme.Dark):
                self.darkmode = bool(colorScheme == Qt.ColorScheme.Dark)
                aw.updateCanvasColors()
    except Exception:  # pylint: disable=broad-except
        pass

    @pyqtSlot('QWidget*', 'QWidget*')
    def appRaised(self, oldFocusWidget: Optional[QWidget], newFocusWidget: Optional[QWidget]) -> None:
        try:
            aw: Optional['ApplicationWindow'] = self.activationWindow()
            if aw is not None and not sip.isdeleted(aw):  # sip not supported on older PyQt versions (eg. RPi)
                if oldFocusWidget is None and newFocusWidget is not None and aw.centralWidget() == newFocusWidget and self.sentToBackground is not None:
                    # focus gained
                    #                    _log.debug('focus gained')
                    try:
                        if aw.plus_account is not None and aw.qmc.roastUUID is not None and aw.curFile is not None and \
                                libtime.time() - self.sentToBackground > self.plus_sync_cache_expiration:
                            plus.sync.getUpdate(aw.qmc.roastUUID, aw.curFile)
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                    self.sentToBackground = None

                elif oldFocusWidget is not None and newFocusWidget is None and aw is not None and aw.centralWidget() == oldFocusWidget:
                    # focus released
                    self.sentToBackground = libtime.time()  # keep the timestamp on sending the app with the main window to background
                else:  # on raising another dialog/widget was open, reset timer
                    self.sentToBackground = None
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    # takes a QUrl and interprets it as follows
    # artisan://roast/<UUID>         : loads profile from path associated with the given roast <UUID>
    # artisan://template/<UUID>      : loads background profile from path associated with the given roast <UUID>
    # artisan://profile?url=<url>    : loads profile from given URL
    # file://<path>                  : loads file from path
    #                                  if query is "background" Artisan is not raised to the foreground
    #                                  if query is "template" and the file has an .alog extension, the profile is loaded as background profile
    def open_url(self, url: QUrl) -> None:
        _log.debug('open_url(%s)', url)
        aw: Optional['ApplicationWindow'] = self.activationWindow()
        if aw is not None and not aw.qmc.flagon and not aw.qmc.designerflag and not aw.qmc.wheelflag and aw.qmc.flavorchart_plot is None:  # only if not yet monitoring
            if url.scheme() == 'artisan' and url.authority() in {'roast', 'template'}:
                # we try to resolve this one into a file URL and recurse
                roast_UUID = url.toString(
                    QUrl.UrlFormattingOption.RemoveScheme | QUrl.UrlFormattingOption.RemoveAuthority | QUrl.UrlFormattingOption.RemoveQuery | QUrl.UrlFormattingOption.RemoveFragment | QUrl.UrlFormattingOption.StripTrailingSlash)[
                             1:]
                if aw.qmc.roastUUID is None or aw.qmc.roastUUID != roast_UUID:
                    # not yet open, lets try to find the path to that roastUUID and open it
                    profile_path = plus.register.getPath(roast_UUID)
                    if profile_path:
                        aw.sendmessage(QApplication.translate('Message', 'URL open profile: {0}').format(profile_path))
                        file_url = QUrl.fromLocalFile(profile_path)
                        if url.authority() == 'template':
                            file_url.setQuery('template')
                        self.open_url(file_url)
            elif url.scheme() == 'artisan' and url.authority() == 'profile' and url.hasQuery():
                try:
                    query = QUrlQuery(url.query())
                    if query.hasQueryItem('url'):
                        import requests
                        query_url = QUrl(requests.utils.unquote(
                            query.queryItemValue('url')))  # type: ignore # Module has no attribute "unquote"
                        if aw.comparator is not None:
                            aw.comparatorAddProfileURLSignal.emit(query_url)
                        else:
                            aw.importArtisanURLSignal.emit(query_url)
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
            elif url.scheme() == 'file':
                aw.sendmessage(QApplication.translate('Message', 'URL open profile: {0}').format(url.toDisplayString()))
                url_query = None
                if url.hasQuery():
                    url_query = url.query()
                if url_query is None or url_query != 'background':
                    # by default we raise Artisan to the foreground
                    self.activateWindowSignal.emit()
                url.setQuery(
                    None)  # Argument 1 to "setQuery" of "QUrl" has incompatible type "None"; expected "str" # remove any query to get a valid file path
                url.setFragment(
                    None)  # Argument 1 to "setFragment" of "QUrl" has incompatible type "None"; expected "str" # remove also any potential fragment
                filename = url.toString(QUrl.UrlFormattingOption.PreferLocalFile)
                qfile = QFileInfo(filename)
                file_suffix = qfile.suffix()

                if file_suffix == 'alog':
                    if aw.comparator is not None:
                        # add Artisan profile to the comparator selection
                        aw.comparatorAddProfileSignal.emit(filename)
                    # load Artisan profile on double-click on *.alog file
                    elif url_query is not None and url_query == 'template':
                        aw.loadBackgroundSignal.emit(filename)
                    else:
                        aw.loadFileSignal.emit(filename)
                elif file_suffix == 'alrm' and aw.app is not None and not aw.app.artisanviewerMode:
                    # load Artisan alarms on double-click on *.alrm file
                    aw.loadAlarmsSignal.emit(filename)
                elif file_suffix == 'apal' and aw.app is not None and not aw.app.artisanviewerMode:
                    # load Artisan palettes on double-click on *.apal file
                    aw.loadPalettesSignal.emit(filename)

        elif platform.system() == 'Windows' and not self.artisanviewerMode:
            msg = url.toString()  # here we don't want a local file, preserve the windows file:///
            self.sendMessage2ArtisanInstance(msg, self._viewer_id)

    @pyqtSlot(str)
    def receiveMessage(self, msg: str) -> None:
        url = QUrl()
        url.setUrl(msg)
        self.open_url(url)

    # to send message to main Artisan instance: id = appGuid
    # to send message to viewer:                id = viewerAppGuid
    def sendMessage2ArtisanInstance(self, message: str, instance_id: str) -> None:
        if platform.system() == 'Windows':
            try:
                res = None
                if instance_id == self._viewer_id:
                    res = self._sendMessage2ArtisanInstance(message, self._viewer_id)
                elif instance_id == self._id:
                    res = self._sendMessage2ArtisanInstance(message, self._id)
                if not res:
                    # get the path of the artisan.exe file
                    if getattr(sys, 'frozen', False):
                        application_path = os.path.dirname(sys.executable)
                        application_path += '\\artisan.exe'
                    # or the artisan py file if running from source
                    else:
                        application_path = os.path.dirname(
                            os.path.dirname(os.path.realpath(__file__)))  # grandparent path
                        application_path += '\\artisan.py'
                    application_path = re.sub(r'\\', r'/', application_path)
                    # must start viewer without an argv else it thinks it was started from a link and sends back to artisan
                    os.startfile(
                        application_path)  # type:ignore[unused-ignore,attr-defined] # @UndefinedVariable # pylint: disable=maybe-no-member
                    libtime.sleep(3)  # wait while the app opens
                    self.sendmessage2ArtisanInstanceSignal.emit(message, instance_id)
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
        else:
            self.sendmessage2ArtisanInstanceSignal.emit(message, instance_id)

    @pyqtSlot(str, str)
    def _sendMessage2ArtisanInstanceSlot(self, message: str, instance_id: str) -> None:
        self._sendMessage2ArtisanInstance(message, instance_id)

    @pyqtSlot(str)
    def _sendMessage2ArtisanViewerSlot(self, message: str) -> None:
        self._sendMessage2ArtisanInstance(message, self._viewer_id)

    def _sendMessage2ArtisanInstance(self, message: str, instance_id: str) -> bool:
        _log.debug('_sendMessage2ArtisanInstance(%s,%s)', message, instance_id)
        try:
            self._outSocket = QLocalSocket()
            self._outSocket.connectToServer(instance_id)
            self._isRunning = self._outSocket.waitForConnected(-1)
            if self.isRunning():
                self._outStream = QTextStream(self._outSocket)
                #                self._outStream.setCodec('UTF-8')
                return self.sendMessage(message)
            return False
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            return False
        finally:
            self._outSocket = None
            self._outStream = None

    def event(self, event: Optional[QEvent]) -> bool:
        if event is not None and event.type() == QEvent.Type.FileOpen:
            try:
                aw: Optional['ApplicationWindow'] = self.activationWindow()
                if aw is not None:
                    url = event.url()  # type: ignore # "QEvent" has no attribute "url"
                    # files cannot be opend while
                    # - sampling
                    # - in Designer mode
                    # - in Wheel graph mode
                    # - while editing the cup profile
                    can_open_mode = not aw.qmc.flagon and not aw.qmc.designerflag and not aw.qmc.wheelflag and aw.qmc.flavorchart_plot is None
                    if can_open_mode and aw.comparator is not None:
                        # while in comparator mode with the events file already open we rather send it to another instance
                        filename = url.toString(QUrl.UrlFormattingOption.PreferLocalFile)
                        can_open_mode = not any(p.filepath == filename for p in aw.comparator.profiles)
                    if can_open_mode:
                        self.open_url(url)
                    else:
                        message = url.toString()
                        # we send open file in the other instance if running
                        if self.artisanviewerMode:
                            # this is the Viewer, but we cannot open the file, send an open request to the main app if it is running
                            self.sendMessage2ArtisanInstance(message, self._id)
                        else:
                            # try to open the file in Viewer if it is running
                            self.sendMessage2ArtisanInstance(message, self._viewer_id)
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
            return True
        return super().event(event)

    # Requests the permission to communicate via Bluetooth, True or False, or if not yet granted, None. Returns the current permission status otherwise.
    # Currently this API is only supported on macOS. On all other platforms this returns always True
    def getBluetoothPermission(self, request: bool = False) -> Optional[bool]:
        if sys.platform.startswith('darwin') and QVersionNumber.fromString(qVersion())[0] > QVersionNumber(6, 5, 0):
            from PyQt6.QtCore import QBluetoothPermission  # pylint: disable=no-name-in-module
            try:
                def permissionUpdated(permission: 'QPermission') -> None:
                    if permission.status() == Qt.PermissionStatus.Granted:  # type:ignore[union-attr,unused-ignore]
                        _log.info('Bluetooth permission updated: granted')
                    else:
                        _log.info('Bluetooth permission updated: denied')

                bluetoothPermission = QBluetoothPermission()
                res: Qt.PermissionStatus = self.checkPermission(bluetoothPermission)
                if res == Qt.PermissionStatus.Undetermined:
                    _log.info('Bluetooth permission not granted. Requesting permission...')
                    if request:
                        self.requestPermission(bluetoothPermission, permissionUpdated)  # type:ignore[arg-type]
                    return None
                return res == Qt.PermissionStatus.Granted
            except Exception as e:
                _log.exception(e)
        return True


# configure multiprocessing
# if sys.platform.startswith('darwin'):
#    try:
#        # start method can only be set once!
##        if 'forkserver' in multiprocessing.get_all_start_methods(): # pylint: disable=condition-evals-to-constant,using-constant-test
##            # signed app with forkserver option fails with a MemoryError
##            multiprocessing.set_start_method('forkserver') # only available on Python3 on Unix, currently (Python 3.8) not supported by frozen executables generated with pyinstaller
#        if 'fork' in multiprocessing.get_all_start_methods():
#            multiprocessing.set_start_method('fork') # default on Python3.7 for macOS (and on Unix also under Python3.8), but considered unsafe,
#            # not available on Windows, on Python3.8 we have to explicitly set this
#            # https://bugs.python.org/issue33725
#            # this is the only option that works (Hottop communication & WebLCDs) in signed macOS apps
##        if 'spawn' in multiprocessing.get_all_start_methods():
##            multiprocessing.set_start_method('spawn') # default on Python3.8 for macOS (always default on Windows)
##            # this breaks on starting WebLCDs in macOS (and linux) builds with py2app, pyinstaller
##            # https://bugs.python.org/issue32146
##            # https://github.com/pyinstaller/pyinstaller/issues/4865
#    except Exception: # pylint: disable=broad-except
#        pass


app_args = sys.argv
if sys.platform.startswith('linux'):
    # avoid a GTK bug in Ubuntu Unity
    app_args = app_args + ['-style', 'Fusion']
# if platform.system() == 'Windows':
#    # highDPI support must be set before creating the Application instance
#    try:
#        # activate scaling for hiDPI screen support on Windows
#        QApplication.setAttribute(Qt.ApplicationAttribute.AA_EnableHighDpiScaling)
#        QApplication.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps)
#    except Exception as e: # pylint: disable=broad-except
#        pass
app = Artisan(app_args)

# On the first run if there are legacy settings under "YourQuest" but no new settings under "artisan-scope" then the legacy settings
# will be copied to the new settings location. Once settings exist under "artisan-scope" the legacy settings under "YourQuest" will
# no longer be read or saved.  At start-up, versions of Artisan before to v2.0 will no longer share settings with versions v2.0 and after.
# Settings can be shared among all versions of Artisan by explicitly saving and loading them using Help>Save/Load Settings.

settingsRelocated: bool = False
try:
    app.setApplicationName(application_name)  # needed by QSettings() to store windows geometry in operating system

    app.setOrganizationName('YourQuest')  # needed by QSettings() to store windows geometry in operating system
    app.setOrganizationDomain(
        'p.code.google.com')  # needed by QSettings() to store windows geometry in operating system
    legacysettings = QSettings()
    app.setOrganizationName(
        application_organization_name)  # needed by QSettings() to store windows geometry in operating system
    app.setOrganizationDomain(
        application_organization_domain)  # needed by QSettings() to store windows geometry in operating system
    newsettings = QSettings()

    # copy settings from legacy to new if newsettings do not exist, legacysettings do exist, and were not previously copied
    if not newsettings.contains('Mode') and legacysettings.contains('Mode') and legacysettings.contains(
            '_settingsCopied') and legacysettings.value('_settingsCopied') != 1:
        settingsRelocated = True
        # copy Artisan settings
        for key in legacysettings.allKeys():
            newsettings.setValue(key, legacysettings.value(key))
        legacysettings.setValue('_settingsCopied',
                                1)  # prevents copying again in the future, this key not cleared by a Factory Reset

        # copy ArtisanViewer settings
        app.setApplicationName(
            application_viewer_name)  # needed by QSettings() to store windows geometry in operating system

        app.setOrganizationName('YourQuest')  # needed by QSettings() to store windows geometry in operating system
        app.setOrganizationDomain(
            'p.code.google.com')  # needed by QSettings() to store windows geometry in operating system
        legacysettings = QSettings()
        app.setOrganizationName(
            application_organization_name)  # needed by QSettings() to store windows geometry in operating system
        app.setOrganizationDomain(
            application_organization_domain)  # needed by QSettings() to store windows geometry in operating system
        newsettings = QSettings()
        for key in legacysettings.allKeys():
            newsettings.setValue(key, legacysettings.value(key))
    del legacysettings  # free up memory?
    del newsettings  # free up memory?
except Exception:  # pylint: disable=broad-except
    pass

app.setApplicationName(application_name)  # needed by QSettings() to store windows geometry in operating system
app.setOrganizationName(
    application_organization_name)  # needed by QSettings() to store windows geometry in operating system
app.setOrganizationDomain(
    application_organization_domain)  # needed by QSettings() to store windows geometry in operating system

# replace revision string with git hash when running from source
if not appFrozen() and __revision__ in {'', '0'}:
    try:
        from subprocess import run as subprocessrun

        uncommittedChanges = subprocessrun(['git', 'status', '--porcelain=v1'], capture_output=True,
                                           check=True).stdout  # number of uncommitted changes
        uc = '+' if len(uncommittedChanges) > 0 else ''
        git_hash = subprocessrun(['git', 'rev-parse', 'HEAD'], capture_output=True, check=True).stdout.decode(
            'ascii').strip()[:7]  # git hash
        __revision__ = f'{git_hash}{uc}'
    except Exception:  # pylint: disable=broad-except
        pass

# configure logging
# try:
#     with open(os.path.join(getResourcePath(), 'logging.yaml'), encoding='utf-8') as logging_conf:
#         conf = yaml_load(logging_conf)
#         try:
#             # set log file to Artisan data directory
#             _datadir = getDataDirectory()
#             if _datadir is not None:
#                 if app.artisanviewerMode:
#                     conf['handlers']['file']['filename'] = os.path.join(_datadir, 'artisanViewer.log')
#                 else:
#                     conf['handlers']['file']['filename'] = os.path.join(_datadir, 'artisan.log')
#         except Exception:  # pylint: disable=broad-except
#             pass
#         logging.config.dictConfig(conf)
# except Exception:  # pylint: disable=broad-except
#     pass

_log: Final[logging.Logger] = logging.getLogger(__name__)

if multiprocessing.current_process().name == 'MainProcess':
    _log.info(
        '%s v%s (%s, %s)',
        ('ArtisanViewer' if app.artisanviewerMode else 'Artisan'),
        str(__version__),
        str(__revision__),
        str(__build__),
    )
    _log.info('date: %s', datetime.datetime.now(datetime.timezone.utc))
    _log.info('platform: %s', platform.platform())
    _log.info('exec: %s', sys.executable)
else:
    _log.info('child process loaded')

if platform.system().startswith('Windows'):
    # on Windows we use the Fusion style per default which supports the dark mode
    app.setStyle('Fusion')
    app.setWindowIcon(QIcon(os.path.join(getAppPath(), 'artisan.png')))
#    try:
#        # activate scaling for hiDPI screen support on Windows
#        app.setAttribute(Qt.ApplicationAttribute.AA_EnableHighDpiScaling)
#        if hasattr(QStyleFactory, 'AA_UseHighDpiPixmaps'):
#            app.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps)
#    except Exception as e: # pylint: disable=broad-except
#        pass

from artisanlib.s7port import s7port
from artisanlib.wsport import wsport
from artisanlib.modbusport import modbusport
from artisanlib.slider_style import artisan_slider_style
from artisanlib.event_button_style import artisan_event_button_style
from artisanlib.simulator import Simulator
from artisanlib.dialogs import HelpDlg, ArtisanInputDialog, ArtisanComboBoxDialog, ArtisanPortsDialog
from artisanlib.large_lcds import (LargeMainLCDs, LargeDeltaLCDs, LargePIDLCDs, LargeExtraLCDs, LargePhasesLCDs,
                                   LargeScaleLCDs)
from artisanlib.logs import (serialLogDlg, errorDlg, messageDlg)
from artisanlib.comm import serialport, colorport, scaleport
from artisanlib.pid_dialogs import (PXRpidDlgControl, PXG4pidDlgControl,
                                    PID_DlgControl, DTApidDlgControl)
from artisanlib.pid_control import FujiPID, PIDcontrol, DtaPID
from artisanlib.widgets import (MyQLCDNumber, EventPushButton, MajorEventPushButton,
                                AnimatedMajorEventPushButton, MinorEventPushButton, AuxEventPushButton,
                                ClickableLCDFrame)

from artisanlib.notifications import Notification, NotificationManager, NotificationType
from artisanlib.canvas import tgraphcanvas
from artisanlib.phases_canvas import tphasescanvas

# import artisan.plus module
import plus.config
import plus.util
import plus.sync
import plus.queue
import plus.controller
import plus.register
import plus.notifications
import plus.blend
import plus.stock


#######################################################################################
#####   temporary hack for windows till better solution found about toolbar icon problem with py2exe and svg
#######################################################################################


# def my_get_icon(name:str) -> Optional[QIcon]:
#    basedir = os.path.join(mpl.rcParams['datapath'], 'images')
#    p = os.path.join(basedir, name.replace('.svg','.png'))
#    if os.path.exists(p):
#        return QIcon(p)
#    return None


#####


class VMToolbar(NavigationToolbar):  # pylint: disable=abstract-method
    def __init__(self, plotCanvas: tgraphcanvas, parent: QWidget, white_icons: bool = False) -> None:

        # toolitem entries of the form (text, tooltip_text, image_file, callback)
        self.toolitems: Tuple[Union[Tuple[str, ...], Tuple[None, ...]], ...] = (
            ('Plus', QApplication.translate('Tooltip', 'Connect to plus service'), 'plus', 'plus'),
            ('', QApplication.translate('Tooltip', 'Subscription'), 'plus-pro', 'subscription'),
            (
                QApplication.translate('Toolbar', 'Home'), QApplication.translate('Tooltip', 'Reset original view'),
                'home',
                'home'),
            (QApplication.translate('Toolbar', 'Back'), QApplication.translate('Tooltip', 'Back to  previous view'),
             'back', 'back'),
            (QApplication.translate('Toolbar', 'Forward'), QApplication.translate('Tooltip', 'Forward to next view'),
             'forward', 'forward'),
            (None, None, None, None),
            (QApplication.translate('Toolbar', 'Pan'),
             QApplication.translate('Tooltip', 'Pan axes with left mouse, zoom with right'), 'move', 'pan'),
            (QApplication.translate('Toolbar', 'Zoom'), QApplication.translate('Tooltip', 'Zoom to rectangle'),
             'zoom_to_rect', 'zoom'),
        )

        self.qmc: tgraphcanvas = plotCanvas
        self.aw = self.qmc.aw

        # if true, we render Artisan-specific white versions of the icons
        self.white_icons = white_icons

        self.axis_ranges: List[float] = []  # holds the ranges of all axis to detect if it is zoomed in

        # holds the last known cursor event while mouse pointer is in canvas, set by mouse_move()
        self._last_event: Optional[mplLocationevent] = None

        NavigationToolbar.__init__(self, plotCanvas, parent)  # type:ignore[no-untyped-call]

        # lets make the font of the coordinates QLabel a little larger
        f = self.locLabel.font()

        if platform.system() == 'Linux':
            f.setPointSize(f.pointSize() + 2)
        else:
            f.setPointSize(f.pointSize() + 4)
        ##        f.setStyleHint(QFont.StyleHint.TypeWriter) # not monospaced!
        #        f.setStyleHint(QFont.StyleHint.Monospace)
        #        f.setFamily('monospace')
        ##        f.setWeight(QFont.Bold)
        ##        f.setBold(True)
        self.locLabel.setFont(f)

        # 在matplotlib v2.0和更高版本上添加绿色标志菜单
        self.edit_curve_parameters_action = None
        if len(self.actions()) > 0:
            # insert the "Green Flag" menu item before the last one (which is the x/y coordinate display)
            self.edit_curve_parameters_action = QAction(self._icon('qt4_editor_options.png'),
                                                        QApplication.translate('Toolbar', 'Lines'), self)
            self.edit_curve_parameters_action.triggered.connect(self.my_edit_parameters)
            self.edit_curve_parameters_action.setToolTip(QApplication.translate('Tooltip', 'Line styles'))
            self.insertAction(self.actions()[-1], self.edit_curve_parameters_action)

        # adjust for dark or light canvas and set hover/selection style
        for a in self.actions():
            if self.aw is not None:
                if self.qmc.palette['canvas'] is None or self.qmc.palette['canvas'] == 'None':
                    canvas_color = QColor('#ECECEC')
                else:
                    canvas_color = QColor(self.qmc.palette['canvas'])
                if canvas_color.name() == '#000000':  # on black we start with (1,1,1) for lighter
                    canvas_color = QColor('#222222')

                if self.white_icons:
                    selected_canvas_color = canvas_color.lighter(250)
                    border_color = '#ffffff'
                else:
                    selected_canvas_color = canvas_color.darker(120)
                    border_color = '#000000'
                self.widgetForAction(a).setStyleSheet(' \
                        QToolButton:checked {border:1px solid transparent; margin: 1px; padding: 2px; background-color:' + selected_canvas_color.name() + ';border-radius: 3px;} \
                        QToolButton:hover {border:1px solid ' + border_color + '; margin: 2px; padding: 2px; background-color:transparent;border-radius: 3px;} \
                        QToolButton:checked:hover {border:1px solid ' + border_color + '; margin: 2px; padding: 2px; background-color:' + selected_canvas_color.name() + ';border-radius: 3px;} \
                        QToolButton {border:1px solid transparent; margin: 2px; padding: 2px; background-color: transparent;border-radius: 3px;}')

        if self.aw is not None:
            self.aw.updatePlusStatus(self)

        self.update_view_org = self._update_view  # type: ignore # Cannot determine type of "_update_view"
        self._update_view = self.update_view_new  # pyright: ignore # Cannot assign to a method  [method-assign]

        self.release_pan_org = self.release_pan
        self.release_pan = self.release_pan_new  # type: ignore # Cannot assign to a method  [method-assign]
        self.release_zoom_org = self.release_zoom
        self.release_zoom = self.release_zoom_new  # type: ignore # Cannot assign to a method  [method-assign]

        #        # monkey patch matplotlib figureoptions that links to svg icon by default (crashes Windows Qt4 builds!)
        #        if not svgsupport:
        #            figureoptions.get_icon = my_get_icon
        # monkey patch _formlayout
        try:
            formlayout.fedit_org  # type: ignore #@UndefinedVariable # noqa: B018
        except Exception:  # pylint: disable=broad-except
            # not yet monkey patched
            formlayout.fedit_org = formlayout.fedit  # type: ignore
            formlayout.fedit = self.my_fedit

    #        # monkey patch _formlayout to work around a MPL3.5.1 issue on Qt6
    #        # (see https://github.com/matplotlib/matplotlib/issues/22471)
    #        if mpl_version in [[3,5,0], [3,5,1]]:
    #            formlayout.ColorButton = MPLColorButtonPatched

    #######################################################################################
    #####   temporary hack for windows till better solution found about toolbar icon problem with py2exe and svg
    #######################################################################################

    def my_fedit(self, data: Any, title: str = '', comment: str = '', icon: Optional[QIcon] = None,
                 parent: Optional[QWidget] = None, apply: Optional[Callable[..., None]] = None) -> None:
        del title
        del apply

        axes = self.aw.qmc.ax
        if axes is not None:
            figure = self.aw.qmc.fig
            orig_xlim = axes.get_xlim()
            orig_ylim = axes.get_ylim()
            linedict = {}
            for line in axes.get_lines():
                label: str = str(line.get_label())
                if label == '_nolegend_':
                    continue
                linedict[label] = line

            if len(data) > 1:
                # just take the Curve Styles and drop the Axis settings
                data = data[1][0]
                # add translations
                trans = {
                    'Label': QApplication.translate('Label', 'Label'),
                    '<b>Line</b>': f"<b>{QApplication.translate('Label', 'Line')}</b>",
                    'Line style': QApplication.translate('Label', 'Line style'),
                    'Draw style': QApplication.translate('Label', 'Draw style'),
                    'Width': QApplication.translate('Label', 'Width'),
                    'Color (RGBA)': QApplication.translate('Label', 'Color (RGBA)'),
                    '<b>Marker</b>': f"<b>{QApplication.translate('Label', 'Marker')}</b>",
                    'Style': QApplication.translate('Label', 'Symbol'),
                    'Size': QApplication.translate('Label', 'Size'),
                    'Face color (RGBA)': QApplication.translate('Label', 'Face color (RGBA)'),
                    'Edge color (RGBA)': QApplication.translate('Label', 'Edge color (RGBA)'),
                }
                try:
                    for l in data:
                        if isinstance(l, (list, tuple)) and len(l) > 0:
                            translated_tpls: List[Union[List[Any], Tuple[Any, ...]]] = []  # translated tuples l[0]
                            for tpl in l[0]:
                                if isinstance(tpl, list) and len(tpl) > 0:
                                    if tpl[0] in trans:
                                        tpl[0] = trans[tpl[0]]
                                    translated_tpls.append(tpl)
                                elif isinstance(tpl, tuple) and len(tpl) > 0:
                                    if tpl[0] in trans:
                                        tpl_list = list(tpl)
                                        tpl_list[0] = trans[tpl[0]]
                                        translated_tpls.append(tuple(tpl_list))
                                    elif len(tpl) > 1 and tpl[0] is None and tpl[1] is not None and tpl[1] in trans:
                                        tpl_list = list(tpl)
                                        tpl_list[1] = trans[tpl[1]]
                                        translated_tpls.append(tuple(tpl_list))
                                    else:
                                        translated_tpls.append(tpl)
                            l[
                                0] = translated_tpls  # type: ignore # Unsupported target for indexed assignment ("Union[List[Any], Tuple[Any, ...]]")
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)

                def my_apply(data: Dict[Any, Any]) -> None:
                    try:
                        # Set / Curves
                        for curve in data:
                            if curve[0] in linedict:
                                line = linedict[curve[0]]
                                (label, linestyle, drawstyle, linewidth, color, marker, markersize,
                                 markerfacecolor, markeredgecolor) = curve
                                line.set_label(label)
                                line.set_linestyle(linestyle)
                                line.set_drawstyle(drawstyle)
                                line.set_linewidth(linewidth)
                                rgba = mcolors.to_rgba(color)
                                line.set_alpha(None)
                                line.set_color(rgba)
                                if marker != 'none':
                                    line.set_marker(marker)
                                    line.set_markersize(markersize)
                                    line.set_markerfacecolor(markerfacecolor)
                                    line.set_markeredgecolor(markeredgecolor)
                        # Redraw
                        figure.canvas.draw()
                        if axes is not None and not (axes.get_xlim() == orig_xlim and axes.get_ylim() == orig_ylim):
                            tb = figure.canvas.toolbar
                            if tb is not None:
                                tb.push_current()
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)

                dialog = formlayout.FormDialog(data, QApplication.translate('Toolbar', 'Lines'), comment, icon, parent,
                                               my_apply)  # type: ignore
                dialog.exec()

    #######################################################################################
    #####   temporary hack end
    #######################################################################################

    def enable_edit_curve_parameters(self) -> None:
        if self.edit_curve_parameters_action is not None:
            self.edit_curve_parameters_action.setEnabled(True)

    def disable_edit_curve_parameters(self) -> None:
        if self.edit_curve_parameters_action is not None:
            self.edit_curve_parameters_action.setEnabled(False)

    # monkey patch matplotlib navigationbar zoom and pan to update background cache
    def release_pan_new(self, event: 'MplEvent') -> None:
        self.release_pan_org(event)
        if self.qmc.ai is not None and [round(r) for r in self.axis_ranges] != [round(r) for r in self.getAxisRanges()]:
            # only hide the background image if the axis ratio changed
            self.qmc.ai.set_visible(False)
        # as since MPL 3.5 release_pan calls self.canvas.draw_idle() instead of _draw() we just invalidate the background here instead of
        # updating it
        self.qmc.updateBackground()
        # self.qmc.ax_background = None

    def release_zoom_new(self, event: 'MplEvent') -> None:
        self.release_zoom_org(event)
        if self.qmc.ai is not None:
            self.qmc.ai.set_visible(False)
        # as since MPL 3.5 release_pan calls self.canvas.draw_idle() instead of _draw() we just invalidate the background here instead of
        # updating it
        self.qmc.updateBackground()
        # self.qmc.ax_background = None

    # monkey patch matplotlib navigationbar zoom (release_zoom) and pan (release_pan) to update background cache
    def update_view_new(self) -> None:
        self.update_view_org()
        self.qmc.updateBackground()

    def getAxisRanges(self) -> List[float]:
        res = []
        for ax in self.canvas.figure.axes:
            xlim = ax.get_xlim()
            ylim = ax.get_ylim()
            res.append(xlim[1] - xlim[0])
            res.append(ylim[1] - ylim[0])
        return res

    def press_pan(self, event: 'MplEvent') -> None:
        if self.qmc.ai is not None:
            # we remember the axis ranges before the pan-zoom to detect if it was zoomed
            self.axis_ranges = self.getAxisRanges()
        super().press_pan(event)

    def forward(self, *args: Any) -> None:
        if self.qmc.ai is not None:
            self.qmc.ai.set_visible(False)  # whenever forward is pressed the image will be hidden
        super().forward(*args)

    def back(self, *args: Any) -> None:
        if self.qmc.ai is not None and self._nav_stack._pos == 1:  # pylint: disable=protected-access
            self.qmc.ai.set_visible(True)
        super().back(*args)

    def home(self, *args: Any) -> None:
        """Restore the original view"""
        # show the background image again that was hidden on zoom-in
        if self.qmc.ai is not None:
            self.qmc.ai.set_visible(True)
        super().home(*args)

        # toggle zoom_follow if recording
        if self.qmc.flagstart:
            self.qmc.zoom_follow = not self.qmc.zoom_follow
            if self.qmc.zoom_follow:
                self.aw.sendmessage(QApplication.translate('Message', 'follow on'))
            else:
                self.aw.sendmessage(QApplication.translate('Message', 'follow off'))
        else:
            self.qmc.zoom_follow = False
        if self.qmc.zoom_follow:
            self.push_current()

    def _icon(self, name: str) -> QIcon:
        if self.aw is not None and name.startswith('plus'):
            basedir = os.path.join(getResourcePath(), 'Icons')
        else:
            basedir = os.path.join(mpl.get_data_path(), 'images')
        if name.startswith('plus') and not self.white_icons:
            name = 'white_' + name
        # dirty hack to prefer .svg over .png Toolbar icons
        if not svgsupport:
            name = name.replace('.svg', '.png')
        else:
            name = name.replace('.png', '.svg')
        # large png icons introduced in MPL 2.1 for Qt5
        name = name.replace('.png', '_large.png')
        p = os.path.join(basedir, name)
        pm = QPixmap(p)
        if not name.startswith('plus') and not name.startswith('white_plus'):
            if self.white_icons:
                pm = self.recolorIcon(pm, QColor('#dfdfdf'))
            else:
                pm = self.recolorIcon(pm, QColor('#424242'))
        #        if hasattr(pm, 'setDevicePixelRatio'):
        #            if mpl_version[0] > 2 and mpl_version[1] > 2:
        #                if mpl_version[1] > 3:
        #                    _setDevicePixelRatio(pm, _devicePixelRatioF(self)) # pylint: disable=protected-access
        #                else:
        #                    _setDevicePixelRatioF(pm, _devicePixelRatioF(self)) # pylint: disable=protected-access
        #            else:
        #                pm.setDevicePixelRatio(self.canvas._dpi_ratio) # pylint: disable=protected-access
        if hasattr(pm, 'setDevicePixelRatio'):
            pm.setDevicePixelRatio(self.devicePixelRatioF() or 1)

        return QIcon(pm)

    @staticmethod
    def recolorIcon(pixmap: QPixmap, color: QColor) -> QPixmap:
        tmp = pixmap.toImage()
        for y in range(tmp.height()):
            for x in range(tmp.width()):
                color.setAlpha(tmp.pixelColor(x, y).alpha())
                tmp.setPixelColor(x, y, color)
        return QPixmap.fromImage(tmp)

    def update_message(self) -> None:
        if not self.qmc.twoAxisMode():
            self.qmc.fmt_data_RoR = False
        xs: Optional[str] = None
        ys: Optional[float] = None
        timeindex = None  # caches the foreground timex index computed at x cursor position
        backgroundtimeindex = None  # caches the background timex index computed at x cursor position
        # update xy cursor position widget
        if self._last_event is None:
            self.set_message(f'<PRE>{self.mode}</PRE>')  # type:ignore
        else:
            if not self.qmc.fmt_data_ON:
                self.set_message(f'<PRE>{self.mode}</PRE>')  # type:ignore
            else:
                try:
                    channel = ''
                    inaxes = self._last_event.inaxes
                    if inaxes is not None and self._last_event.xdata is not None:
                        xs = inaxes.format_xdata(self._last_event.xdata)
                    if self.qmc.fmt_data_curve == 0 or self.qmc.designerflag:
                        if inaxes is not None and self._last_event.ydata is not None:
                            ys = float(inaxes.format_ydata(self._last_event.ydata))
                    else:
                        try:
                            if self.qmc.fmt_data_curve == 1 and self._last_event.xdata is not None:  # BT
                                timeindex = self.qmc.time2index(self._last_event.xdata, nearest=False)
                                if self.qmc.fmt_data_RoR:
                                    ys = self.qmc.delta2[timeindex]
                                else:
                                    ys = self.qmc.temp2[timeindex]
                                channel = self.aw.BTname
                            elif self.qmc.fmt_data_curve == 2 and self._last_event.xdata is not None:  # ET
                                timeindex = self.qmc.time2index(self._last_event.xdata, nearest=False)
                                if self.qmc.fmt_data_RoR:
                                    ys = self.qmc.delta1[timeindex]
                                else:
                                    ys = self.qmc.temp1[timeindex]
                                channel = self.aw.ETname
                            elif (self.qmc.fmt_data_curve == 3 and self.qmc.backgroundprofile is not None and
                                  self._last_event.xdata is not None):  # BTB
                                backgroundtimeindex = self.qmc.backgroundtime2index(self._last_event.xdata,
                                                                                    nearest=False)
                                if self.qmc.fmt_data_RoR:
                                    ys = self.qmc.delta2B[backgroundtimeindex]
                                else:
                                    ys = self.qmc.temp2B[backgroundtimeindex]
                                channel = 'BTB'
                            elif (self.qmc.fmt_data_curve == 4 and self.qmc.backgroundprofile is not None and
                                  self._last_event.xdata is not None):  # ETB
                                backgroundtimeindex = self.qmc.backgroundtime2index(self._last_event.xdata,
                                                                                    nearest=False)
                                if self.qmc.fmt_data_RoR:
                                    ys = self.qmc.delta1B[backgroundtimeindex]
                                else:
                                    ys = self.qmc.temp1B[backgroundtimeindex]
                                channel = 'ETB'
                            elif inaxes is not None and self._last_event.ydata is not None:
                                ys = float(inaxes.format_ydata(self._last_event.ydata))
                            if ys is not None:
                                if self.qmc.LCDdecimalplaces:
                                    ys = self.aw.float2float(ys)
                                else:
                                    ys = int(round(ys))
                        except Exception:  # pylint: disable=broad-except
                            if inaxes is not None and self._last_event.ydata is not None:
                                ys = float(inaxes.format_ydata(self._last_event.ydata))
                except Exception:  # pylint: disable=broad-except
                    self.set_message(f'<PRE>{self.mode}</PRE>')  # type:ignore
                else:
                    min_temp_digits = 5 if self.qmc.LCDdecimalplaces else 3
                    if self.qmc.fmt_data_RoR:
                        min_temp_digits -= 1
                    if self.mode:
                        self.set_message(
                            f"<PRE>{self.mode}  {xs: >5}\n{channel} {'' if ys is None else ys: >{min_temp_digits}}\u00B0{self.qmc.mode}{'/min' if self.qmc.fmt_data_RoR else ''}</PRE>")  # type:ignore
                    else:
                        self.set_message(
                            f"<PRE>{xs: >5}\n{channel} {'' if ys is None else ys: >{min_temp_digits}}\u00B0{self.qmc.mode}{'/min' if self.qmc.fmt_data_RoR else ''}</PRE>")  # type:ignore
            # update running LCDs
            if not self.qmc.flagon and self.aw.comparator is None and self._last_event.xdata is not None:
                if self.qmc.running_LCDs == 1:  # show foreground profile readings at cursor position in LCDs
                    if timeindex is None:
                        timeindex = self.qmc.time2index(self._last_event.xdata, nearest=False)
                    time = self._last_event.xdata
                    if time is not None:
                        if self.qmc.timeindex[0] != -1 and self.qmc.timeindex[0] < len(self.qmc.timex):
                            time -= self.qmc.timex[self.qmc.timeindex[0]]
                        self.qmc.updateLCDs(
                            time,
                            self.qmc.temp1,
                            self.qmc.temp2,
                            self.qmc.delta1,
                            self.qmc.delta2,
                            self.qmc.extratemp1,
                            self.qmc.extratemp2,
                            idx=(None if timeindex < 0 else timeindex))
                elif self.qmc.running_LCDs == 2:  # show background profile readings at cursor position in LCDs
                    try:
                        if backgroundtimeindex is None:
                            backgroundtimeindex = self.qmc.backgroundtime2index(self._last_event.xdata, nearest=False)
                        time = self._last_event.xdata
                        if time is not None:
                            if self.qmc.timeindexB[0] != -1 and self.qmc.timeindexB[0] < len(self.qmc.timeB):
                                time -= self.qmc.timeB[self.qmc.timeindexB[0]]
                            self.qmc.updateLCDs(
                                time,
                                self.qmc.temp1B,
                                self.qmc.temp2B,
                                self.qmc.delta1B,
                                self.qmc.delta2B,
                                self.qmc.temp1BX,
                                self.qmc.temp2BX,
                                idx=(None if backgroundtimeindex < 0 else backgroundtimeindex))
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)

    # overwritten from MPL v3.2.2 to get rid of that extra data printed
    def mouse_move(self, event: Optional['MplEvent']) -> None:
        try:
            self._update_cursor(event)  # not available in MPL v3.0.3 on Python3.5 for the RPi Stretch builds
        except Exception:  # pylint: disable=broad-except
            pass
        if event is not None and isinstance(event, mplLocationevent) and event.inaxes and event.inaxes.get_navigate():
            self._last_event = event
        else:
            self._last_event = None
        self.update_message()

    # PLUS
    def plus(self) -> None:
        print('000')
        # modifiers = QApplication.keyboardModifiers()
        # if modifiers in [(Qt.KeyboardModifier.AltModifier | Qt.KeyboardModifier.ControlModifier),
        #                  (Qt.KeyboardModifier.AltModifier | Qt.KeyboardModifier.ShiftModifier)]:
        #     # ALT+CTRL-CLICK (OPTION+COMMAND on macOS) toggles  or alternatively ALT-SHIFT-CLICK
        #     # toggle debug logging
        #     debug_level = debugLogLevelToggle()
        #     self.aw.sendmessage(
        #         QApplication.translate('Plus', 'debug logging ON') if debug_level else
        #         QApplication.translate('Plus', 'debug logging OFF')
        #     )
        # elif modifiers == Qt.KeyboardModifier.AltModifier:
        #     # ALT-click (OPTION on macOS) sends the log file by email
        #     self.aw.sendLog()
        # else:
        #     plus.controller.toggle(self.aw)

    def subscription(self) -> None:
        if self.aw.plus_paidUntil is not None:  # after reset and authentication, it might still take a moment until the paidUntil is set via its signal
            try:
                remaining_days = max(0, (
                        self.aw.plus_paidUntil.date() - datetime.datetime.now(datetime.timezone.utc).date()).days)
                if remaining_days == 1:
                    days = QApplication.translate('Plus', '1 day left')
                else:
                    days = QApplication.translate('Plus', '{} days left').format(remaining_days)
                pu = self.aw.plus_paidUntil.date()
                message = f'{QApplication.translate("Plus", "Paid until")} {QDate(pu.year, pu.month, pu.day).toString(QLocale().dateFormat(QLocale.FormatType.ShortFormat))}'
                reminder_message = ''
                percent_used_formatted = ''
                if self.aw.plus_rlimit > 0:
                    percent_used = self.aw.plus_used / (self.aw.plus_rlimit / 100)
                    unit = 1  # 1: kg, 2: lb
                    if self.qmc.weight[2] in {'lb', 'oz'}:
                        unit = 2
                    rlimit = plus.stock.renderAmount(self.aw.plus_rlimit, target_unit_idx=unit)
                    used = plus.stock.renderAmount(self.aw.plus_used, target_unit_idx=unit)
                    percent_used_formatted = f'{percent_used:.0f}% {QApplication.translate("Label", "roasted")} ({used} / {rlimit})'
                    # if 90% of quota is used, render usage in red
                    if percent_used >= 90:
                        style = 'background-color:#cc0f50;color:white;'
                    else:
                        style = ''
                    reminder_message += f'<blockquote><b><span style="{style}">{percent_used_formatted}</span></b></blockquote>'
                if remaining_days < 31:
                    if remaining_days <= 3:
                        style = 'background-color:#cc0f50;color:white;'
                    else:
                        style = ''
                    reminder_message += f'<blockquote><b><span style="{style}">{days}</span></b></blockquote>'
                if reminder_message == '':
                    message += '<br><br>'
                else:
                    message += reminder_message
                message += QApplication.translate('Plus',
                                                  'Please visit our {0}shop{1} to extend your subscription').format(
                    '<a href="' + plus.config.shop_base_url + '">', '</a>')
                #
                # if less then 31 days:
                # n days left <= red if <=3
                #  3 days, 2 days, 1 day, 0 days left
                #
                # no links in macOS style boxes
                #                subscription_message_box = ArtisanMessageBox(self.aw, QApplication.translate('Message', 'Subscription'), message)
                subscription_message_box = QMessageBox()  # only without super this one shows the native dialog on macOS under Qt 6.6.2
                #                subscription_message_box.setTextFormat(Qt.TextFormat.RichText)
                basedir = os.path.join(getResourcePath(), 'Icons')
                p = os.path.join(basedir, 'plus-notification.svg')
                subscription_message_box.setIconPixmap(QPixmap(p))
                if percent_used_formatted != '':
                    percent_used_formatted = '\n' + percent_used_formatted
                subscription_message_box.setText(
                    QApplication.translate('Plus', 'Do you want to extend your subscription?'))
                subscription_message_box.setInformativeText((QApplication.translate('Plus',
                                                                                    'Your subscription ends on') if remaining_days > 0 else QApplication.translate(
                    'Plus',
                    'Your subscription ended on')) + f' {QDate(pu.year, pu.month, pu.day).toString(QLocale().dateFormat(QLocale.FormatType.ShortFormat))}\n{days}{percent_used_formatted}')
                subscription_message_box.setStandardButtons(
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
                #                subscription_message_box.show()
                res = subscription_message_box.exec()
                plus_link = plus.config.shop_base_url
                if self.aw.plus_subscription == 'PRO':
                    plus_link += '/professional-roasters'
                elif self.aw.plus_subscription == 'HOME':
                    plus_link += '/home-roasters'
                if res == QMessageBox.StandardButton.Yes:
                    QDesktopServices.openUrl(QUrl(plus_link, QUrl.ParsingMode.TolerantMode))
            #                box = QMessageBox(self)
            #                box.about(self.aw, QApplication.translate('Message', 'Subscription'),message)
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def my_edit_parameters(self, _: bool = False) -> None:
        try:
            if self.qmc.ax is not None and not self.qmc.designerflag:  # deactivate figure_options in designer mode due to all kind of side effects
                allaxes = self.canvas.figure.get_axes()
                if len(allaxes) == 1:
                    pass
                elif self.qmc.flagstart:
                    # temporary set the axis to get proper menu items (same code as in redraw)
                    self.qmc.set_xlabel(self.aw.arabicReshape(QApplication.translate('Label', 'Time')))
                    y_label = self.qmc.ax.set_ylabel(self.qmc.mode)
                    try:
                        y_label.set_in_layout(False)  # remove x-axis labels from tight_layout calculation
                    except Exception:  # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                        pass
                    two_ax_mode = self.qmc.twoAxisMode() and not self.qmc.designerflag
                    if two_ax_mode and self.qmc.delta_ax is not None:
                        y_label = self.qmc.delta_ax.set_ylabel(self.qmc.mode + '/min')
                        try:
                            y_label.set_in_layout(False)  # remove x-axis labels from tight_layout calculation
                        except Exception:  # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                            pass

                axes = allaxes[0]

                try:

                    with warnings.catch_warnings():
                        warnings.filterwarnings('ignore')  # , category=numpy.VisibleDeprecationWarning)
                        figureoptions.figure_edit(axes)  # type:ignore
                #                        for line in steps_post_lines:
                #                            line.set_drawstyle("steps-post")

                except Exception:  # pylint: disable=broad-except
                    pass
                self.aw.fetchCurveStyles()
                # the redraw is mostly necessary to force a redraw of the legend to reflect the changed colors/styles/labels
                self.qmc.redraw_keep_view(recomputeAllDeltas=False)
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _type, _exc, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' edit_parameters() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))


#########################################################################################################
###     Event Action Thread
#########################################################################################################

class EventActionThread(
    QThread):  # pylint: disable=too-few-public-methods # pyright: ignore [reportGeneralTypeIssues] # Argument to class must be a base class

    def __init__(self, aw: 'ApplicationWindow', action: int, command: str, eventtype: Optional[int]) -> None:
        super().__init__()
        self.aw: 'ApplicationWindow' = aw
        self.action: int = action
        self.command: str = command
        self.eventtype: Optional[int] = eventtype

    def run(self) -> None:
        # as eventaction_internal is not running in the GUI thread we avoid doing graphic updates and run them instead after thread termination within
        # the GUI thread
        self.aw.eventaction_internal(self.action, self.command, self.eventtype)


#########################################################################################################

# applies comma2dot as fixup to automatically turn numbers like "1,2" into valid numbers like "1.0" and the empty entry into "0.0"
class MyQDoubleValidator(
    QDoubleValidator):  # pylint: disable=too-few-public-methods  # pyright: ignore [reportGeneralTypeIssues] # Argument to class must be a base class

    def __init__(self, bottom: float, top: float, decimals: int, lineedit: QLineEdit) -> None:
        super().__init__(bottom, top, decimals, lineedit)
        self.lineedit = lineedit

    def validate(self, _s: Optional[str], p: int) -> 'Tuple[QValidator.State, str, int]':
        return super().validate(self.lineedit.text(), p)

    def fixup(self, input_value: Optional[str]) -> Any:  # -> str/None, but also Optional[str] is not accepted!?
        try:
            if input_value is not None:
                input_value = '0' if input_value == '' else comma2dot(input_value)
                self.lineedit.setText(input_value)
        #            super().fixup(input_value)
        except Exception:  # pylint: disable=broad-except
            pass


########################################################################################
#################### MAIN APPLICATION WINDOW ###########################################
########################################################################################

class ScrollingLabel(QLabel):
    def __init__(self, text, parent=None):
        super().__init__(text, parent)
        self.setStyleSheet("color: #222222; border:none;")
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.scroll_text)
        self.scroll_position = 0
        self.text_spacing = 20  # 设置文字间距
        self.original_text = text  # 保存原始文本

        # 初始化文本和标签宽度
        self.font = self.font()  # 获取当前字体
        self.font_metrics = QFontMetrics(self.font)  # 计算文本宽度的工具
        self.update_text_dimensions()  # 计算文本宽度和标签宽度

        # 如果文本宽度小于或等于标签宽度，停止滚动
        if self.text_width <= self.label_width:
            self.timer.stop()

    def update_text_dimensions(self):
        """更新文本和标签的宽度"""
        self.text_width = self.font_metrics.horizontalAdvance(self.original_text)  # 获取文本宽度
        self.label_width = self.width()  # 标签宽度

    def scroll_text(self):
        if self.original_text:  # 确保 original_text 不为空
            display_text = self.original_text + " " * self.text_spacing + self.original_text
            self.scroll_position += 1

            # 当滚动到末尾时重置位置
            if self.scroll_position >= len(display_text):
                self.scroll_position = 0

            # 更新显示的文本
            visible_text = display_text[self.scroll_position:self.scroll_position + self.label_width // self.font_metrics.height()]
            self.setText(visible_text)

    def enterEvent(self, event: QEvent):
        """鼠标移入事件：启动滚动"""
        if self.text_width > self.label_width:  # 只有当文本宽度大于标签宽度时才开始滚动
            self.scroll_position = 0
            self.timer.start(100)  # 控制滚动速度
        super().enterEvent(event)

    def leaveEvent(self, event: QEvent):
        """鼠标移出事件：停止滚动并恢复原文本"""
        self.timer.stop()
        self.setText(self.original_text)  # 恢复原始文本
        super().leaveEvent(event)

    def resizeEvent(self, event):
        """重新计算标签宽度"""
        super().resizeEvent(event)
        self.label_width = self.width()  # 更新标签宽度
        self.text_width = self.font_metrics.horizontalAdvance(self.original_text)  # 更新文本宽度
        if self.text_width <= self.label_width:
            self.timer.stop()  # 如果文本宽度小于等于标签宽度，停止滚动

class MatplotlibWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QVBoxLayout(self)

        # 创建 Matplotlib Figure 对象
        self.figure = Figure()
        self.figure.patch.set_facecolor('#f0ece9')  # 设置背景为和底色一致
        self.canvas = FigureCanvas(self.figure)
        self.layout.addWidget(self.canvas)  # 将画布添加到布局中

    def update_plot(self, timex, temp1, temp2, temp3, temp4):
        """更新图表内容"""
        # 清理之前的图表内容
        self.figure.clear()

        # 创建新子图
        ax = self.figure.add_subplot(111)
        ax.set_facecolor('#f0ece9')  # 匹配背景颜色

        # 去掉四周的黑色实线边框
        for spine in ax.spines.values():
            spine.set_visible(False)

        # 绘制数据，并指定颜色
        ax.plot(timex[:len(temp1)], temp1, label="Temp1", color="#C8402C")
        ax.plot(timex[:len(temp2)], temp2, label="Temp2", color="#E5B547")
        ax.plot(timex[:len(temp3)], temp3, label="Temp3", color="#44AB6B")
        ax.plot(timex[:len(temp4)], temp4, label="Temp4", color="#258B96")

        # 设置网格样式
        ax.grid(color='gray', linestyle='--', linewidth=0.5, alpha=0.7)
        self.figure.subplots_adjust(left=0.05, right=0.95, bottom=0.05, top=0.95)

        # 动态调整x轴范围
        if len(timex) > 0:
            max_time = timex[min(len(temp1), len(temp2), len(temp3), len(temp4)) - 1]
            ax.set_xlim(0, max_time)  # 动态调整到有效数据长度
        else:
            ax.set_xlim(0, 600)  # 默认范围

        # 设置左侧y轴
        ax.set_ylim(0, 500)

        # 自定义x轴显示
        ax.set_xticks(np.arange(0, max(timex[-1] if len(timex) > 0 else 600, 601), 60))  # 每 60 秒一个刻度
        ax.set_xticklabels(
            [f"{int(x // 60)}" for x in np.arange(0, max(timex[-1] if len(timex) > 0 else 600, 601), 60)],
            ha='right'
        )
        ax.tick_params(axis='x', direction='out', pad=5)
        ax.tick_params(axis='y', direction='out', pad=5)

        # 去掉图例
        ax.legend().remove()

        # 右侧y轴
        ax2 = ax.twinx()
        right_y_ticks = range(0, 26, 5)
        ax2.set_ylim(0, 25)
        ax2.set_yticks(right_y_ticks)
        ax2.set_yticklabels([str(tick) for tick in right_y_ticks])
        ax2.tick_params(axis='y', direction='in', pad=5)

        # 刷新画布
        self.canvas.draw()



# NOTE: to have pylint to verify proper __slot__ definitions with pylint one has to remove the super class QMainWindow here temporarily
#   as this class does not has __slot__ definitions and thus __dict__ is contained which suppresses the warnings
class ApplicationWindow(
    QMainWindow):  # pyright: ignore [reportGeneralTypeIssues] # Argument to class must be a base class

    singleShotPhidgetsPulseOFF = pyqtSignal(int, int,
                                            str)  # signal to be called from the eventaction thread to realise Phidgets pulse via QTimer in the main thread
    singleShotPhidgetsPulseOFFSerial = pyqtSignal(int, int, str, str)
    # PLUS
    # 可以从其他线程或 QTimer 调用，用于触发更新加号图标状态。
    updatePlusStatusSignal = pyqtSignal()  # can be called from another thread or a QTimer to trigger to update the plus icon status
    # 可以从其他线程或 QTimer 调用，用于设置主 GUI 线程中的配置文件标题。
    setTitleSignal = pyqtSignal(str,
                                bool)  # can be called from another thread or a QTimer to set the profile title in the main GUI thread
    sendmessageSignal = pyqtSignal(str, bool, str)  # 发送消息的信号。
    openPropertiesSignal = pyqtSignal()  # 打开属性窗口的信号。
    soundpopSignal = pyqtSignal()  # 播放声音弹出窗口的信号。
    setCanvasColorSignal = pyqtSignal(str)  # 设置画布颜色的信号。
    resetCanvasColorSignal = pyqtSignal()  # 重置画布颜色的信号。
    setbuttonsfromSignal = pyqtSignal(int)  # 根据给定的整数设置按钮的信号。
    setExtraEventButtonStyleSignal = pyqtSignal(int, str)  # 设置额外事件按钮样式的信号。
    loadBackgroundSignal = pyqtSignal(str)  # 加载背景的信号。
    clearBackgroundSignal = pyqtSignal()  # 清除背景的信号。
    setTareSignal = pyqtSignal(int)  # 设置皮重的信号。
    adjustSVSignal = pyqtSignal(int)  # 调整某个设定值（SV）的信号。
    setSVSignal = pyqtSignal(int)  # 设置某个设定值（SV）的信号。
    fireslideractionSignal = pyqtSignal(int)  # 触发滑块操作的信号。
    moveButtonSignal = pyqtSignal(str)  # 移动按钮的信号。
    sendnotificationMessageSignal = pyqtSignal(str, str, NotificationType)  # 发送通知消息的信号，包含消息内容和通知类型。
    updateSubscriptionSignal = pyqtSignal(str)  # 更新订阅状态的信号。
    # 更新限制的信号，参数包括限制值、使用值、单位、通知次数等。
    updateLimitsSignal = pyqtSignal(float, float, str, int,
                                    list)  # rlimit:float, rused:float, pu:str, notifications:int
    updatePlaybackIndicatorSignal = pyqtSignal()  # 更新播放指示器的信号。
    pidOnSignal = pyqtSignal()  # 打开 PID 控制的信号。
    pidOffSignal = pyqtSignal()  # 打开 PID 控制的信号。
    pidToggleSignal = pyqtSignal()  # 切换 PID 控制状态的信号。
    notificationsSetEnabledSignal = pyqtSignal(bool)  # 设置通知启用状态的信号。
    santokerSendMessageSignal = pyqtSignal(bytes, int)  # 发送 Santoker 设备消息的信号。
    kaleidoSendMessageSignal = pyqtSignal(str, str)  # 发送 Kaleido 设备消息的信号。
    kaleidoSendMessageAwaitSignal = pyqtSignal(str, str, int, int)  # 发送并等待 Kaleido 设备消息的信号，包含额外的整数参数用于控制等待。
    addEventSignal = pyqtSignal(int, int, bool, bool, bool)  # 添加事件的信号。
    updateMessageLogSignal = pyqtSignal()  # 更新消息日志的信号。
    updateSerialLogSignal = pyqtSignal()  # 更新串行日志的信号。
    updateErrorLogSignal = pyqtSignal()  # 更新错误日志的信号。
    establishQuantifiedEventSignal = pyqtSignal(int, float)  # 建立量化事件的信号，带有事件 ID 和浮点值。
    updateExtraEventButtonsVisibilitySignal = pyqtSignal()  # 更新额外事件按钮可见性的信号。
    realignButtonsSignal = pyqtSignal()  # 重新对齐按钮的信号。
    loadAlarmsSignal = pyqtSignal(str)  # 加载警报的信号。
    loadFileSignal = pyqtSignal(str)  # 加载文件的信号。
    loadPalettesSignal = pyqtSignal(str)  # 加载调色板的信号。
    importArtisanURLSignal = pyqtSignal(QUrl)  # 导入 Artisan URL 的信号。
    comparatorAddProfileURLSignal = pyqtSignal(QUrl)  # 添加配置文件 URL 比较的信号。
    comparatorAddProfileSignal = pyqtSignal(str)  # 添加配置文件比较的信号。

    __slots__ = ['locale_str', 'app', 'superusermode', 'sample_loop_running', 'time_stopped', 'plus_account',
                 'plus_remember_credentials', 'plus_email', 'plus_language', 'plus_subscription',
                 'plus_paidUntil', 'plus_rlimit', 'plus_used', 'plus_readonly', 'plus_user_id', 'appearance',
                 'mpl_fontproperties', 'full_screen_mode_active', 'processingKeyEvent', 'quickEventShortCut',
                 'eventaction_running_threads', 'curFile', 'MaxRecentFiles', 'recentFileActs', 'recentSettingActs',
                 'recentThemeActs', 'applicationDirectory', 'helpdialog', 'redrawTimer', 'lastLoadedProfile',
                 'lastLoadedBackground', 'LargeScaleLCDsFlag', 'largeScaleLCDs_dialog',
                 'analysisresultsanno', 'segmentresultsanno', 'largeLCDs_dialog', 'LargeLCDsFlag',
                 'largeDeltaLCDs_dialog', 'LargeDeltaLCDsFlag', 'largePIDLCDs_dialog',
                 'LargePIDLCDsFlag', 'largeExtraLCDs_dialog', 'LargeExtraLCDsFlag', 'largePhasesLCDs_dialog',
                 'LargePhasesLCDsFlag', 'WebLCDs', 'WebLCDsPort', 'weblcds_server',
                 'WebLCDsAlerts', 'EventsDlg_activeTab', 'graphColorDlg_activeTab', 'PID_DlgControl_activeTab',
                 'CurveDlg_activeTab', 'editGraphDlg_activeTab',
                 'backgroundDlg_activeTab', 'DeviceAssignmentDlg_activeTab', 'AlarmDlg_activeTab', 'resetqsettings',
                 'settingspath', 'wheelpath', 'profilepath',
                 'userprofilepath', 'printer', 'main_widget', 'defaultdpi', 'dpi', 'qmc', 'HottopControlActive',
                 'AsyncSamplingTimer', 'wheeldialog',
                 'simulator', 'simulatorpath', 'comparator', 'stack', 'eventsbuttonflag', 'minieventsflags',
                 'seriallogflag',
                 'seriallog', 'ser', 'modbus', 'extraMODBUStemps', 'extraMODBUStx', 's7', 'extraS7tx', 'ws', 'scale',
                 'color', 'extraser', 'extracomport', 'extrabaudrate',
                 'extrabytesize', 'extraparity', 'extrastopbits', 'extratimeout', 'hottop', 'santokerHost',
                 'santokerPort', 'santokerSerial', 'santoker', 'fujipid', 'dtapid', 'pidcontrol', 'soundflag',
                 'recentRoasts', 'maxRecentRoasts',
                 'kaleido_default_host', 'kaleidoHost', 'kaleidoPort', 'kaleidoSerial', 'kaleidoPID', 'kaleido',
                 'ikawa',
                 'lcdpaletteB', 'lcdpaletteF', 'extraeventsbuttonsflags', 'extraeventslabels', 'extraeventbuttoncolor',
                 'extraeventsactionstrings',
                 'extraeventbuttonround', 'block_quantification_sampling_ticks',
                 'sampling_seconds_to_block_quantifiction', 'sampling_ticks_to_block_quantifiction',
                 'extraeventsactionslastvalue',
                 'org_extradevicesettings', 'eventslidervalues', 'eventslidervisibilities',
                 'eventsliderKeyboardControl', 'eventsliderAlternativeLayout', 'eventslideractions',
                 'eventslidercommands', 'eventslideroffsets',
                 'eventsliderfactors', 'eventslidermin', 'eventsMaxValue', 'eventslidermax', 'eventslidersflags',
                 'eventsliderBernoulli', 'eventslidercoarse',
                 'eventslidertemp', 'eventsliderunits', 'eventslidermoved', 'SVslidermoved', 'eventquantifieractive',
                 'eventquantifiersource', 'eventquantifierSV',
                 'eventquantifiermin', 'eventquantifiermax', 'eventquantifiercoarse', 'eventquantifieraction',
                 'clusterEventsFlag', 'eventquantifierlinspaces',
                 'eventquantifierthresholdfine', 'eventquantifierthresholdcoarse', 'eventquantifierthresholdmed',
                 'lastdigitizedvalue', 'lastdigitizedtemp',
                 'readingslcdsflags', 'logoimgalpha', 'logoimgflag', 'logofilename', 'redrawOnResize',
                 'searchtextartisansettings', 'fileMenu', 'editMenu',
                 'RoastMenu', 'ConfMenu', 'ToolkitMenu', 'viewMenu', 'helpMenu', 'newRoastMenu', 'fileLoadAction',
                 'openRecentMenu', 'importMenu',
                 'fileSaveAction', 'fileSaveCopyAsAction', 'exportMenu', 'convMenu', 'saveGraphMenu', 'reportMenu',
                 'htmlAction', 'productionMenu',
                 'productionWebAction', 'productionCsvAction', 'productionExcelAction', 'rankingMenu',
                 'rankingWebAction', 'rankingCsvAction', 'rankingExcelAction',
                 'savestatisticsAction', 'printAction', 'quitAction', 'cutAction', 'copyAction', 'pasteAction',
                 'editGraphAction', 'backgroundAction',
                 'flavorAction', 'switchAction', 'switchETBTAction', 'machineMenu', 'deviceAction', 'commportAction',
                 'calibrateDelayAction', 'curvesAction',
                 'eventsAction', 'alarmAction', 'phasesGraphAction', 'StatisticsAction', 'WindowconfigAction',
                 'colorsAction', 'themeMenu', 'autosaveAction',
                 'batchAction', 'temperatureConfMenu', 'FahrenheitAction', 'CelsiusAction', 'languageMenu',
                 'analyzeMenu', 'fitIdealautoAction',
                 'analyzeMenu', 'fitIdealx2Action', 'fitIdealx3Action', 'fitIdealx0Action', 'fitBkgndAction',
                 'clearresultsAction', 'roastCompareAction',
                 'designerAction', 'simulatorAction', 'wheeleditorAction', 'transformAction', 'temperatureMenu',
                 'ConvertToFahrenheitAction',
                 'ConvertToCelsiusAction', 'controlsAction', 'readingsAction', 'eventsEditorAction', 'buttonsAction',
                 'slidersAction', 'lcdsAction', 'deltalcdsAction',
                 'pidlcdsAction', 'scalelcdsAction', 'extralcdsAction', 'phaseslcdsAction', 'fullscreenAction',
                 'loadSettingsAction', 'openRecentSettingMenu',
                 'saveAsSettingsAction', 'resetAction', 'messagelabel', 'button_font_size_pt', 'button_font_size',
                 'button_font_size_small', 'button_font_size_small_selected',
                 'button_font_size_tiny', 'button_font_size_micro', 'main_button_min_width',
                 'standard_button_min_width', 'small_button_min_width', 'tiny_button_min_width',
                 'pushbuttonstyles_simulator', 'pushbuttonstyles', 'standard_button_tiny_height',
                 'standard_button_small_height', 'standard_button_height',
                 'buttonONOFF', 'buttonSTARTSTOP', 'buttonFCs', 'buttonFCe', 'buttonSCs', 'buttonSCe', 'buttonRESET',
                 'buttonCHARGE', 'buttonDROP',
                 'buttonCONTROL', 'buttonEVENT', 'buttonSVp5', 'buttonSVp10', 'buttonSVp20', 'buttonSVm20',
                 'buttonSVm10', 'buttonSVm5', 'buttonDRY',
                 'buttonCOOL', 'lcd1', 'lcd2', 'lcd3', 'lcd4', 'lcd5',
                 'lcd6', 'lcd7', 'label2', 'label3', 'label4', 'label5', 'label6', 'label7', 'extraLCD1', 'extraLCD2',
                 'extraLCDlabel1', 'extraLCDlabel2',
                 'extraLCDframe1', 'extraLCDframe2', 'extraLCDvisibility1', 'extraLCDvisibility2',
                 'extraCurveVisibility1', 'extraCurveVisibility2',
                 'extraDelta1', 'extraDelta2', 'extraFill1', 'extraFill2', 'channel_tare_values', 'messagehist',
                 'eventlabel', 'eNumberSpinBox',
                 'lineEvent', 'etypeComboBox', 'valueEdit', 'etimeline', 'buttonminiEvent', 'buttonlist',
                 'buttonStates', 'lastbuttonpressed', 'buttonlistmaxlen',
                 'buttonpalette_default_label', 'buttonpalette_label', 'buttonpalettemaxlen', 'buttonpalette_shortcuts',
                 'buttonsize', 'mark_last_button_pressed', 'show_extrabutton_tooltips', 'eventbuttontablecolumnwidths',
                 'lowerbuttondialogLayout', 'lowerbuttondialog', 'lowerbuttondialogLayout', 'e1buttonbarLayout',
                 'e1buttondialog', 'e2buttonbarLayout', 'e2buttondialog',
                 'e3buttonbarLayout', 'e3buttondialog', 'e4buttonbarLayout', 'e4buttondialog', 'keyboardmove',
                 'keyboardButtonList', 'keyboardmoveindex',
                 'keyboardmoveflag', 'lastkeyboardcmd', 'error_dlg', 'serial_dlg', 'message_dlg', 'ETname', 'BTname',
                 'level1frame', 'level1layout', 'qpc', 'splitter', 'scroller', 'EventsGroupLayout',
                 'LCD2frame', 'LCD3frame', 'LCD4frame', 'LCD5frame', 'LCD6frame', 'LCD7frame', 'TPlabel', 'TPlcd',
                 'TPlcdFrame', 'TP2DRYlabel', 'TP2DRYframe',
                 'DRYlabel', 'DRYlcd', 'DRYlcdFrame', 'DRY2FCslabel', 'DRY2FCsframe', 'FCslabel', 'FCslcd',
                 'FCslcdFrame', 'AUClabel', 'AUClcd', 'AUClcdFrame',
                 'AUCLCD', 'phasesLCDs', 'extrabuttonsLayout', 'extrabuttondialogs', 'slider1', 'slider2', 'slider3',
                 'slider4', 'sliderLCD1', 'sliderLCD2', 'sliderLCD3',
                 'sliderLCD4', 'sliderGrpBox1', 'sliderGrpBox2', 'sliderGrpBox3', 'sliderGrpBox4', 'sliderSV',
                 'sliderLCDSV', 'sliderGrpBoxSV', 'leftlayout',
                 'sliderFrame', 'lcdFrame', 'midlayout', 'editgraphdialog', 'html_loader', 'QtWebEngineSupport',
                 'artisanviewerFirstStart',
                 'buttonpalette', 'extraeventbuttontextcolor', 'extraeventsactions', 'extraeventsdescriptions',
                 'extraeventstypes', 'extraeventsvalues',
                 'extraeventsvisibility', 'fileSaveAction', 'fileSaveAsAction', 'keyboardButtonStyles',
                 'language_menu_actions', 'loadThemeAction', 'main_button_min_width_str',
                 'minieventleft', 'minieventright', 'nLCDS', 'notificationManager', 'notificationsflag', 'ntb',
                 'pdf_page_layout', 'pdf_rendering', 'productionPDFAction',
                 'rankingPDFAction', 'roastReportMenu', 'roastReportPDFAction', 'saveAsThemeAction', 'sliderGrp12',
                 'sliderGrp34', 'sliderGrpBox1x', 'sliderGrpBox2x', 'sliderGrpBox3x', 'sliderGrpBox4x',
                 'small_button_min_width_str', 'standard_button_min_width_px', 'tiny_button_min_width_str',
                 'recording_version', 'recording_revision', 'recording_build',
                 'lastIOResult', 'lastArtisanResult', 'max_palettes', 'palette_entries', 'eventsliders',
                 'defaultSettings', 'zoomInShortcut', 'zoomOutShortcut']

    def __init__(self, parent: Optional[QWidget] = None, *, locale: str, WebEngineSupport: bool,
                 artisanviewerFirstStart: bool) -> None:
        # 用于存储应用程序的默认设置。该字典将保存所有应用程序 QSettings 的默认值。
        self.defaultSettings: Dict[str, Any] = {}
        # holds default values of all app QSettings
        # filled on app start by calling self.saveAllSettings(QSettings(), self.defaultSettings) before self.settingsLoad()

        self.locale_str: str = locale  # locale_str 保存当前的区域语言设置
        self.app: Artisan = app  # 该属性 app 保存了应用程序的主对象 Artisan
        self.superusermode: bool = False  # 初始化时设为 False，表示默认情况下应用程序不以超级用户模式运行。

        self.sample_loop_running: bool = True  # 初始化为 True，表示样本循环在默认情况下是运行的。
        self.time_stopped: float = 0  # 初始化为 0，表示时间还没有停止或未开始计时。

        self.QtWebEngineSupport: bool = WebEngineSupport  # 是一个布尔值，指示是否启用了 Qt Web 引擎的支持。
        self.artisanviewerFirstStart: bool = artisanviewerFirstStart  # 也是一个布尔值，用于指示 Artisan Viewer 是否是首次启动

        # PLUS
        # 账户相关
        self.plus_account: Optional[str] = None  # if set to a login string, Artisan plus features are enabled
        self.plus_user_id: Optional[str] = None  # holds the UUID of the logged in user
        self.plus_remember_credentials: bool = True  # store plus account credentials in systems keychain
        self.plus_email: Optional[
            str] = None  # if self.plus_remember_credentials is ticked, we remember here the login to be pre-set as plus_account in the dialog
        self.plus_language: str = 'en'  # one of ["en", "de", "it", ..] indicates the language setting of the plus_account used on the artisan.plus platform,
        # used in links back to objects on the platform (see plus/util.py#storeLink() and similars)
        self.plus_subscription: Optional[str] = None  # one of [None, "HOME", "PRO"]
        self.plus_paidUntil: Optional[
            datetime.datetime] = None  # either None if unknown or otherwise a datetime.datetime object with indicating the expiration date of the account
        self.plus_rlimit: float = 0  # account amount limit (kg); if 0 then considered as not valid
        self.plus_used: float = 0  # account amount greens roasted within rlimit (kg); if 0 then considered as not valid
        self.plus_readonly: bool = False  # True if the plus user has only read rights to the plus account (account might be deactivated, or user might be a read-only user)

        self.appearance: str = ''
        # 在Windows上，我们默认使用支持黑暗模式的融合风格
        if platform.system().startswith('Windows'):
            self.appearance = 'fusion'

        # matplotlib字体属性:
        self.mpl_fontproperties = FontProperties()
        self.full_screen_mode_active: bool = False

        self.processingKeyEvent: bool = False
        # 它将保持为 None。如果设置了快捷方式
        self.quickEventShortCut: Optional[Tuple[int, str]] = None
        # this is None if inactive, or holds a tuple (n,s) with n a number {-1,..,4} indicating the custom event number (0-3), 4 for SV, or -1 for custom event buttons to be addressed
        # and s a string of length 0 (no digit yet), length 1 (if first digit is typed) or 2 (both digits are typed) indicating the value (00-99)

        # html2pdf() state:
        self.html_loader: Optional[
            QWebEngineView] = None  # pyright:ignore[reportPossiblyUnboundVariable] # holds the QWebEngineView during HTML2PDF generation in self.html2pdf()
        self.pdf_page_layout: Optional[
            QPageLayout] = None  # holds the QPageLayout used during HTML2PDF generation in self.html2pdf()
        self.pdf_rendering: bool = False  # True while PDF is rendered by QWebEngineView

        self.eventaction_running_threads: List[EventActionThread] = []

        #############################  定义在调用settingsload()之前需要存在的变量
        self.curFile: Optional[str] = None
        self.MaxRecentFiles = 20
        self.recentFileActs = []
        self.recentSettingActs = []
        self.recentThemeActs = []
        self.applicationDirectory = QDir().current().absolutePath()

        super().__init__(parent)

        self.helpdialog: Optional[HelpDlg] = None

        self.setAcceptDrops(True)  # 启用拖放

        # 通过调整主窗口大小来触发的计时器
        self.redrawTimer: QTimer = QTimer()
        self.redrawTimer.setSingleShot(True)
        self.redrawTimer.timeout.connect(self.redraw_action)

        # 用于启动时重新加载以前加载的配置文件
        self.lastLoadedProfile: str = ''
        self.lastLoadedBackground: str = ''

        # 分析者
        self.analysisresultsanno: Optional['Annotation'] = None
        self.segmentresultsanno: Optional['Annotation'] = None

        # 大型液晶显示器
        self.largeLCDs_dialog: Optional[LargeMainLCDs] = None
        self.LargeLCDsFlag: bool = False
        self.largeDeltaLCDs_dialog: Optional[LargeDeltaLCDs] = None
        self.LargeDeltaLCDsFlag: bool = False
        self.largePIDLCDs_dialog: Optional[LargePIDLCDs] = None
        self.LargePIDLCDsFlag: bool = False
        self.largeScaleLCDs_dialog: Optional[LargeScaleLCDs] = None
        self.LargeScaleLCDsFlag: bool = False
        self.largeExtraLCDs_dialog: Optional[LargeExtraLCDs] = None
        self.LargeExtraLCDsFlag: bool = False
        self.largePhasesLCDs_dialog: Optional[LargePhasesLCDs] = None
        self.LargePhasesLCDsFlag: bool = False
        self.WebLCDs: bool = False
        self.WebLCDsPort: int = 8080
        self.WebLCDsAlerts: bool = False

        # 活动标签
        self.EventsDlg_activeTab: int = 0
        self.graphColorDlg_activeTab: int = 0
        self.PID_DlgControl_activeTab: int = 0
        self.CurveDlg_activeTab: int = 0  # curves dialog
        self.editGraphDlg_activeTab: int = 0  # roast properties dialog
        self.backgroundDlg_activeTab: int = 0
        self.DeviceAssignmentDlg_activeTab: int = 0
        self.AlarmDlg_activeTab: int = 0

        # 重置设置的标志
        self.resetqsettings: int = 0
        # 上次加载设置的路径
        self.settingspath: str = ''  # if empty string, the settingspath will be ignored, otherwise it will be used to update the batchcounter of those settings

        # 上次加载车轮图的路径
        self.wheelpath: str = ''

        # 在dirstruct处获得self.profilepath() and points to profiles/year/month file-open/save will point to profilepath
        self.profilepath: str = ''
        if platform.system() in {'Darwin', 'Linux'}:
            self.profilepath = QDir().homePath() + '/Documents/'
        else:
            self.profilepath = QDir().homePath()

        # 在Mac上，首选项应该存储在用户应用程序之外 ~/Library/Preferences path
        if platform.system() == 'Darwin':
            preference_path = QDir().homePath() + '/Library/Preferences//'
            preference_dir = QDir()
            preference_dir.setPath(preference_path)
            if not preference_dir.exists():
                QDir().mkpath(preference_path)
            QDir().setCurrent(preference_path)

        # 将用户配置文件路径默认为标准配置文件路径 (incl. month/year subdirectories)
        self.userprofilepath: str = self.profilepath

        self.printer: Optional[QPrinter] = None

        self.main_widget: QWidget = QWidget(self)
        # 设置最小尺寸(主窗口可以更大，但不能更小)
        self.main_widget.setMinimumWidth(800)
        self.main_widget.setMinimumHeight(400)

        ####      create Matplotlib canvas widget
        # 解决
        self.defaultdpi: Final[int] = 100
        self.dpi: int = self.defaultdpi

        # mpl.rc_context({'toolbar': None}) # this does not work to remove the default toolbar
        # mpl.rcParams['toolbar'] is None # this does not work to remove the default toolbar
        # 默认工具栏
        settings = QSettings()
        if settings.contains('dpi') and (not settings.contains('resetqsettings') or toInt(
                settings.value('resetqsettings',
                               self.resetqsettings)) == 0) and QApplication.queryKeyboardModifiers() != Qt.KeyboardModifier.AltModifier:
            try:
                dpi = toInt(settings.value('dpi', self.dpi))
                if dpi >= 40:  # pylint: disable=consider-using-min-builtin
                    self.dpi = dpi
            except Exception:  # pylint: disable=broad-except
                pass

        self.nLCDS: Final[int] = 10  # LCD和额外设备的最大数量(总共2x10 => 20个！)

        # 设计的UI
        self.script_path = os.path.abspath(__file__)
        self.script_dir = os.path.dirname(self.script_path)
        self.parent_dir = os.path.dirname(self.script_dir)
        self.normalized_path = self.parent_dir.replace('\\', '/')
        # self.normalized_path ='G:/Vue/artisan/src'

        # font_path = resource_path('includes/Fonts/ARLRDBD.TTF')
        font_id = QFontDatabase.addApplicationFont(self.normalized_path + '/includes/Fonts/ARLRDBD.TTF')
        self.font_family = QFontDatabase.applicationFontFamilies(font_id)[0]

        font_id2 = QFontDatabase.addApplicationFont(self.normalized_path + '/includes/Fonts/OPPOSANS-H.TTF')
        self.font_family2 = QFontDatabase.applicationFontFamilies(font_id2)[0]

        font_id3 = QFontDatabase.addApplicationFont(self.normalized_path + '/includes/Fonts/OPPOSANS-B.TTF')
        self.font_family3 = QFontDatabase.applicationFontFamilies(font_id3)[0]

        font_id4 = QFontDatabase.addApplicationFont(self.normalized_path + '/includes/Fonts/OPPOSANS-M.TTF')
        self.font_family4 = QFontDatabase.applicationFontFamilies(font_id4)[0]

        font_id5 = QFontDatabase.addApplicationFont(self.normalized_path + '/includes/Fonts/方正兰亭特黑简体.TTF')
        self.font_family5 = QFontDatabase.applicationFontFamilies(font_id5)[0]

        font_id6 = QFontDatabase.addApplicationFont(self.normalized_path + '/includes/Fonts/OPPOSANS-R.TTF')
        self.font_family6 = QFontDatabase.applicationFontFamilies(font_id6)[0]

        # screen = app.primaryScreen()
        # if screen is not None:
        #     # 获取屏幕大小
        #     self.screen_size = screen.size()
        #     # logical_dpi = screen.logicalDotsPerInch()
        #     # physical_dpi = screen.physicalDotsPerInch()
        #     #
        #     # scale_factor = logical_dpi / physical_dpi  # 计算缩放比例
        #     self.width_scale = self.screen_size.width() / 1920
        #     self.height_scale = self.screen_size.height() / 1080
        #     # sys.stdout = open("outputttttttttttt.log", "w")
        # print(f"屏幕分辨率: {self.screen_size.width()}x{self.screen_size.height()}")
        # print(f"屏幕缩放比例: {self.width_scale:.2f}x{self.height_scale:.2f}")

        # self.resize(self.screen_size.width(), self.screen_size.height())
        # self.setWindowFlags(Qt.WindowType.FramelessWindowHint)

        # 获取所有屏幕
        screens = QGuiApplication.screens()

        # 选择一个屏幕，这里假设你想获取主屏幕的信息
        screen = screens[0]  # 如果你希望选择主屏幕，可以使用 screens[0]

        if screen is not None:
            # 获取当前屏幕的分辨率
            self.screen_size = screen.size()

            # 获取当前屏幕的逻辑DPI和物理DPI
            self.logical_dpi = screen.logicalDotsPerInch()
            self.physical_dpi = screen.physicalDotsPerInch()

            # 计算缩放比例
            scale_factor = self.logical_dpi / self.physical_dpi
            scale_factor2 = (scale_factor-0.61)

            # 根据屏幕的分辨率计算缩放比例，假设1920x1080是你的参考分辨率
            self.width_scale = self.screen_size.width() / 1920
            self.height_scale = self.screen_size.height() / 1080

            # 输出屏幕信息
            print(f"当前屏幕分辨率: {self.screen_size.width()}x{self.screen_size.height()}")
            print(f"当前屏幕缩放比例: {self.width_scale:.2f}x{self.height_scale:.2f}")
            print(f"当前屏幕DPI: logical DPI = {self.logical_dpi}, physical DPI = {self.physical_dpi}")
            print(f"计算的缩放比例: {scale_factor:.2f}")
        else:
            print("无法获取屏幕信息")

        self.resize(self.screen_size.width(), self.screen_size.height())


        self.central_widget = QLabel(self)
        self.central_widget.setGeometry(0, 0, 1920*self.width_scale, 1080*self.height_scale)
        self.pixmap = QPixmap(self.normalized_path + '/includes/Icons/general/background.png')  # 背景图
        self.central_widget.setPixmap(self.pixmap)
        self.central_widget.setScaledContents(True)
        # self.central_widget.lower()

        self.logoLabel = QLabel(self)
        self.logoLabel.setGeometry(33*self.width_scale, 45*self.height_scale, 88*self.width_scale, 88*self.height_scale)  # Position and size of the label
        logoPixmap = QPixmap(self.normalized_path + '/includes/Icons/general/logo.png')  # Path to your icon image
        self.logoLabel.setPixmap(logoPixmap)
        self.logoLabel.setScaledContents(True)  # Scale pixmap to fit QLabel

        self.zuoyeLabel = QPushButton(self)
        self.zuoyeLabel.setGeometry(64*self.width_scale, 368*self.height_scale, 50*self.width_scale, 50*self.height_scale)
        self.zuoyeLabel.setStyleSheet("""
                                                  QPushButton {
                                                      background-color: transparent;
                                                      border: none;
                                                  }
                                              """)
        self.zuoyePixmap = QIcon(self.normalized_path + '/includes/Icons/general/zuoyeHover.png')
        self.zuoyeLabel.setIcon(self.zuoyePixmap)
        self.zuoyeLabel.setIconSize(QSize(32*self.width_scale, 32*self.width_scale))
        self.zuoyeLabel.clicked.connect(self.zuoyeClicked)

        # self.lzLabel = QPushButton(self)
        # self.lzLabel.setGeometry(64*self.width_scale, 718*self.height_scale, 30*self.width_scale, 30*self.height_scale)
        # self.lzLabel.setStyleSheet("""
        #                                                   QPushButton {
        #                                                       background-color: transparent;
        #                                                       border: none;
        #                                                   }
        #                                               """)
        # self.lzPixmap = QIcon(self.normalized_path + '/includes/Icons/general/zuoye.png')
        # self.lzLabel.setIcon(self.lzPixmap)
        # self.lzLabel.setIconSize(QSize(32*self.width_scale, 32*self.width_scale))
        # self.lzLabel.clicked.connect(self.lzDetailClick)

        self.historyLabel = QPushButton(self)
        self.historyLabel.setGeometry(64*self.width_scale, 468*self.height_scale, 50*self.width_scale, 50*self.height_scale)
        self.historyLabel.setStyleSheet("""
                                                          QPushButton {
                                                              background-color: transparent;
                                                              border: none;
                                                          }
                                                      """)
        self.historyLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/history.png')
        self.historyLabel.setIcon(self.historyLabelPixmap)
        self.historyLabel.setIconSize(QSize(32*self.width_scale, 32*self.width_scale))
        self.historyLabel.clicked.connect(self.historyClicked)

        self.monitorLabel = QPushButton(self)
        self.monitorLabel.setGeometry(64*self.width_scale, 569*self.height_scale, 50*self.width_scale, 50*self.height_scale)  # Position and size of the label
        self.monitorLabel.setStyleSheet("""
                                                                  QPushButton {
                                                                      background-color: transparent;
                                                                      border: none;
                                                                  }
                                                              """)
        self.monitorPixmap = QIcon(self.normalized_path + '/includes/Icons/general/monitor.png')  # Path to your icon image
        self.monitorLabel.setIcon(self.monitorPixmap)
        self.monitorLabel.setIconSize(QSize(32*self.width_scale, 32*self.width_scale))
        self.monitorLabel.clicked.connect(self.monitorClicked)

        self.setLabel = QPushButton(self)
        self.setLabel.setGeometry(64*self.width_scale, 679*self.height_scale, 50*self.width_scale, 50*self.height_scale)  # Position and size of the label
        self.setLabel.setStyleSheet("""
                                                                          QPushButton {
                                                                              background-color: transparent;
                                                                              border: none;
                                                                          }
                                                                      """)
        self.setLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/set.png')  # Path to your icon image
        self.setLabel.setIcon(self.setLabelPixmap)
        self.setLabel.setIconSize(QSize(32*self.width_scale, 32*self.width_scale))
        self.setLabel.clicked.connect(self.setLabelClicked)



        self.shuxian = QLabel(self)
        self.shuxian.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.shuxian.setGeometry(2*self.width_scale, 353*self.height_scale, 3*self.width_scale, 60*self.height_scale)
        self.shuxian.setStyleSheet("""
                                    color: #ffffff;
                                    border: none;  /* 去掉按钮的边框 */
                                    background-color: #ffffff;  /* 设置背景为透明 */
                                """)



        self.closeLabel = QPushButton(self)
        self.closeLabel.setGeometry(64*self.width_scale, 963*self.height_scale, 30*self.width_scale, 30*self.width_scale)
        self.closeLabel.setStyleSheet(f"""
            QPushButton {{
                border-image: url('{self.normalized_path}/includes/Icons/general/close.png');
                border: none;
            }}
        """)
        self.closeLabel.clicked.connect(self.closeClicked)

        self.shebeiLabel = QLabel(self)  # 第一行设备名称
        self.shebeiLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.shebeiLabel.setGeometry(231*self.width_scale, 74*self.height_scale, 390*self.width_scale, 30*self.height_scale)
        self.shebeiLabel.setStyleSheet("""
                    color: #000000;
                    border: none;  /* 去掉按钮的边框 */
                    background-color: transparent;  /* 设置背景为透明 */
                """)

        self.shebeiLabel.setText("Giesen")
        shebeifont = QFont(self.font_family, 24*self.width_scale)
        shebeifont.setBold(True)
        self.shebeiLabel.setFont(shebeifont)
        self.shebeiLabel.setVisible(True)

        self.sheibeiButton = QPushButton(self.shebeiLabel)
        self.sheibeiButton.setGeometry(0, 0, 390*self.width_scale, 30*self.height_scale)
        self.sheibeiButton.setStyleSheet("""
                                            border: none;  /* 去掉按钮的边框 */
                                            background-color: transparent;  /* 设置背景为透明 */
                                        """)
        self.sheibeiButton.setCursor(Qt.CursorShape.PointingHandCursor)
        self.sheibeiButton.clicked.connect(self.getShebeiList)

        self.shebeiLabel2 = QLabel(self)  # 第一行设备名称
        self.shebeiLabel2.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.shebeiLabel2.setGeometry(231*self.width_scale, 74*self.height_scale, 390*self.width_scale, 38*self.height_scale)
        self.shebeiLabel2.setStyleSheet("""
                            color: #222222;
                            border: none;  /* 去掉按钮的边框 */
                            background-color: transparent;  /* 设置背景为透明 */
                        """)
        self.shebeiLabel2.setText("Giesen")
        shebeifont = QFont(self.font_family2, 24*self.width_scale)
        # shebeifont.setBold(True)
        self.shebeiLabel2.setFont(shebeifont)
        self.shebeiLabel2.setVisible(False)

        self.todayTime = QLabel(self)  # 切换页面显示当前时间
        self.todayTime.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.todayTime.setGeometry(231*self.width_scale, 138*self.height_scale, 390*self.width_scale, 45*self.height_scale)
        self.todayTime.setStyleSheet("""
                                    color: #222222;
                                    border: none;  /* 去掉按钮的边框 */
                                    background-color: transparent;  /* 设置背景为透明 */
                                """)
        self.todayTime.setText("Giesen")
        shebeifont = QFont(self.font_family3, 14*self.width_scale)
        # shebeifont.setBold(True)
        self.todayTime.setFont(shebeifont)
        self.todayTime.setVisible(False)

        # 设置定时器更新当前时间
        self.todayTimer = QTimer(self)
        self.todayTimer.timeout.connect(self.updatetodayTime)
        self.todayTimer.start(1000)  # 每1000毫秒（1秒）触发一次
        # 初始化显示时间
        self.updatetodayTime()




        self.blink_timer = QTimer(self)
        self.blink_timer.timeout.connect(self.blink_text)  # 当定时器超时时，调用 blink_text 方法
        # self.blink_timer.start(200)  # 启动定时器，间隔 500 毫秒（0.5 秒）

        # # 创建计时器，用于停止闪烁
        # self.stop_timer = QTimer(self)
        # self.stop_timer.timeout.connect(self.stop_blinking)  # 当计时器超时时，停止闪烁
        # self.stop_timer.setSingleShot(True)  # 设置为单次触发
        # self.stop_timer.start(5000)  # 启动计时器，5秒后触发

        upPixmap = QPixmap(self.normalized_path + '/includes/Icons/general/up.png')
        downPixmap = QPixmap(self.normalized_path + '/includes/Icons/general/down.png')  # Path to your icon image

        border1 = int(15 * self.height_scale)
        self.kpa = QWidget(self)  # kpa显示
        self.kpa.setStyleSheet(f'border: 1px solid #BBA0FD;border-radius: {15*self.height_scale}px;')
        self.kpa.setGeometry(647*self.width_scale, 68*self.height_scale, 134*self.width_scale, 41*self.height_scale)

        self.kpaNum: QLabel = QLabel(self.kpa)
        self.kpaNum.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.kpaNum.setGeometry(15*self.width_scale, 12*self.height_scale, 72*self.width_scale, 20*self.height_scale)
        self.kpaNum.setStyleSheet("color: #6A00FF;border: none;")
        self.kpaNum.setText("101.325")
        kpaNumfont = QFont(self.font_family5, 12*self.width_scale)
        self.kpaNum.setFont(kpaNumfont)

        self.kpaText: QLabel = QLabel(self.kpa)
        self.kpaText.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.kpaText.setGeometry(87*self.width_scale, 10*self.height_scale, 25*self.width_scale, 20*self.height_scale)
        self.kpaText.setStyleSheet("color: #BEA5FB;border: none;")
        self.kpaText.setText("kpa")
        kpaTextfont = QFont(self.font_family5, 8*self.width_scale)
        self.kpaText.setFont(kpaTextfont)

        self.kpaUpLabel = QLabel(self.kpa)
        self.kpaUpLabel.setGeometry(115*self.width_scale, 17*self.height_scale, 6*self.width_scale, 9*self.height_scale)  # Position and size of the label
        self.kpaUpLabel.setStyleSheet("border: none;")  # Path to your icon image
        self.kpaUpLabel.setPixmap(upPixmap)
        self.kpaUpLabel.setScaledContents(True)

        self.wd = QWidget(self)  # 温度显示
        self.wd.setStyleSheet(f'border: 1px solid #F9B79B;border-radius: {15*self.height_scale}px;')
        self.wd.setGeometry(792*self.width_scale, 68*self.height_scale, 134*self.width_scale, 41*self.height_scale)

        self.wdNum: QLabel = QLabel(self.wd)
        self.wdNum.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignRight)
        self.wdNum.setGeometry(15*self.width_scale, 12*self.height_scale, 52*self.width_scale, 20*self.height_scale)
        self.wdNum.setStyleSheet("color: #FC6C03;border: none;")
        self.wdNum.setText("25")
        wdNumfont = QFont(self.font_family5, 12*self.width_scale)
        self.wdNum.setFont(wdNumfont)

        self.wdNum: QLabel = QLabel(self.wd)
        self.wdNum.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.wdNum.setGeometry(87*self.width_scale, 10*self.height_scale, 25*self.width_scale, 20*self.height_scale)
        self.wdNum.setStyleSheet("color: #F9B79B;border: none;")
        self.wdNum.setText("℃")
        wdNumfont = QFont(self.font_family5, 8*self.width_scale)
        self.wdNum.setFont(wdNumfont)

        self.wdupLabel = QLabel(self.wd)
        self.wdupLabel.setGeometry(115*self.width_scale, 17*self.height_scale, 6*self.width_scale, 9*self.height_scale)  # Position and size of the label
        self.wdupLabel.setStyleSheet("border: none;")
        self.wdupLabel.setPixmap(downPixmap)
        self.wdupLabel.setScaledContents(True)

        self.rh = QWidget(self)  # rh
        self.rh.setStyleSheet(f'border: 1px solid #A3C7F8;border-radius: {15*self.height_scale}px;')
        self.rh.setGeometry(938*self.width_scale, 68*self.height_scale, 134*self.width_scale, 41*self.height_scale)

        self.rhNum: QLabel = QLabel(self.rh)
        self.rhNum.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignRight)
        self.rhNum.setGeometry(15*self.width_scale, 12*self.height_scale, 42*self.width_scale, 20*self.height_scale)
        self.rhNum.setStyleSheet("color: #0488F9;border: none;")
        self.rhNum.setText("40")
        rhNumfont = QFont(self.font_family5, 12*self.width_scale)
        self.rhNum.setFont(rhNumfont)

        self.rhNum: QLabel = QLabel(self.rh)
        self.rhNum.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.rhNum.setGeometry(80*self.width_scale, 10*self.height_scale, 30*self.width_scale, 20*self.height_scale)
        self.rhNum.setStyleSheet("color: #97C1FB;border: none;")
        self.rhNum.setText("RH%")
        rhNumfont = QFont(self.font_family5, 8*self.width_scale)
        self.rhNum.setFont(rhNumfont)

        self.upLabel = QLabel(self.rh)
        self.upLabel.setGeometry(115*self.width_scale, 17*self.height_scale, 6*self.width_scale, 9*self.height_scale)  # Position and size of the label
        self.upLabel.setStyleSheet("border: none;")
        self.upLabel.setPixmap(upPixmap)
        self.upLabel.setScaledContents(True)

        # 个人
        self.aiLabel = QPushButton(self)
        self.aiLabel.setGeometry(1656*self.width_scale, 60*self.height_scale, 58*self.width_scale, 58*self.height_scale)
        self.aiLabel.setStyleSheet("""
                                                                          QPushButton {
                                                                              background-color: transparent;
                                                                              border: none;
                                                                          }
                                                                      """)
        self.aiLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/AI.png')
        self.aiLabel.setIcon(self.aiLabelPixmap)
        self.aiLabel.setIconSize(QSize(58 * self.width_scale, 58 * self.width_scale))
        self.aiLabel.clicked.connect(self.openAiWidget)

        self.sfxxLabel = QLabel(self)
        self.sfxxLabel.setGeometry(1742*self.width_scale, 60*self.height_scale, 58*self.width_scale, 58*self.width_scale)  # Position and size of the label
        sfxxPixmap = QPixmap(self.normalized_path + '/includes/Icons/general/info1.png')  # Path to your icon image
        self.sfxxLabel.setPixmap(sfxxPixmap)
        self.sfxxLabel.setScaledContents(True)  # Scale pixmap to fit QLabel

        # self.nameLabel: QLabel = QLabel(self)
        # self.nameLabel.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.nameLabel.setGeometry(1650*self.width_scale, 60*self.height_scale, 180*self.width_scale, 60*self.height_scale)
        # self.nameLabel.setStyleSheet(f"color: #090101;border-radius: {30*self.height_scale}px;background-color: #F8F2ED;")
        # self.nameLabel.setText("YIFAN Z. ")
        # namefont = QFont(self.font_family3, 12*self.width_scale)
        # self.nameLabel.setFont(namefont)

        # self.touxiang = QLabel(self)
        # self.touxiang.setGeometry(1633*self.width_scale, 55*self.height_scale, 61*self.width_scale, 68*self.height_scale)  # Position and size of the label
        # touxiangPixmap = QPixmap(
        #     self.normalized_path + '/includes/Icons/general/touxiang.png')  # Path to your icon image
        # self.touxiang.setPixmap(touxiangPixmap)
        # self.touxiang.setScaledContents(True)  # Scale pixmap to fit QLabel

        # self.xiala = QLabel(self)
        # self.xiala.setGeometry(1784*self.width_scale, 86*self.height_scale, 12*self.width_scale, 8*self.height_scale)  # Position and size of the label
        # xialaPixmap = QPixmap(self.normalized_path + '/includes/Icons/general/xiala.png')  # Path to your icon image
        # self.xiala.setPixmap(xialaPixmap)
        # self.xiala.setScaledContents(True)  # Scale pixmap to fit QLabel

        self.xinghaoLabel: QLabel = QLabel(self)  # 第二行设备型号
        self.xinghaoLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.xinghaoLabel.setGeometry(232*self.width_scale, 109*self.height_scale, 390*self.width_scale, 23*self.height_scale)
        self.xinghaoLabel.setStyleSheet("color: #B2B1B1;")
        self.xinghaoLabel.setText("WxA")
        xinghaofont = QFont(self.font_family, 14*self.width_scale)
        self.xinghaoLabel.setFont(xinghaofont)

        self.statusLabel: QLabel = QLabel(self)  # 第二行设备状态
        self.statusLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.statusLabel.setGeometry(235*self.width_scale, 142*self.height_scale, 390*self.width_scale, 45*self.height_scale)
        self.statusLabel.setStyleSheet("color: #000000;")
        self.statusLabel.setText("预热准备")
        statusfont = QFont(self.font_family2, 22*self.width_scale)
        # statusfont.setBold(True)
        self.statusLabel.setFont(statusfont)

        self.statusCard = QLabel(self)  # 开始预热
        self.statusCard.setGeometry(231*self.width_scale, 201*self.height_scale, 290*self.width_scale, 200*self.height_scale)
        statusCardPixmap = QPixmap(self.normalized_path + '/includes/Icons/yrzb/back.png')
        self.statusCard.setPixmap(statusCardPixmap)
        self.statusCard.setScaledContents(True)
        # self.statusCard.clicked.connect()

        self.sswd = QLabel(self.statusCard)
        self.sswd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.sswd.setText('0')
        self.sswd.setGeometry(18*self.width_scale, 24*self.height_scale, 90*self.width_scale, 40*self.height_scale)
        self.sswd.setStyleSheet("color: #222222;")
        sswdfont = QFont(self.font_family2, 24*self.width_scale)
        self.sswd.setFont(sswdfont)

        self.sswdText = QLabel(self.statusCard)
        self.sswdText.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.sswdText.setText('实 时 温 度')
        self.sswdText.setGeometry(18*self.width_scale, 57*self.height_scale, 90*self.width_scale, 40*self.height_scale)
        self.sswdText.setStyleSheet("color: #222222;")
        sswdTextfont = QFont(self.font_family4, 10*self.width_scale)
        self.sswdText.setFont(sswdTextfont)

        self.temperaturePixmap = QPixmap(self.normalized_path + '/includes/Icons/yrzb/temperatureXS.png')
        self.temperaturePixmap2 = QPixmap(self.normalized_path + '/includes/Icons/yrzb/temperatureS.png')
        self.temperaturePixmap3 = QPixmap(self.normalized_path + '/includes/Icons/yrzb/temperatureM.png')
        self.temperaturePixmap4 = QPixmap(self.normalized_path + '/includes/Icons/yrzb/temperatureL.png')

        self.temperatureImg = QLabel(self.statusCard)
        self.temperatureImg.setGeometry(209*self.width_scale, 23*self.height_scale, 56*self.width_scale, 56*self.height_scale)
        # self.temperatureImg.setPixmap(temperaturePixmap)
        self.temperatureImg.setScaledContents(True)

        if float(self.sswd.text()) == 0:
            self.temperatureImg.setPixmap(self.temperaturePixmap)
        elif float(self.sswd.text()) > 0 and float(self.sswd.text()) < 80:
            self.temperatureImg.setPixmap(self.temperaturePixmap2)
        elif float(self.sswd.text()) >= 80 and float(self.sswd.text()) < 120:
            self.temperatureImg.setPixmap(self.temperaturePixmap3)
        else:
            self.temperatureImg.setPixmap(self.temperaturePixmap4)

        self.temperatureEdit = QLabel(self.statusCard)
        self.temperatureEdit.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.temperatureEdit.setText('180°')
        self.temperatureEdit.setGeometry(209*self.width_scale, 145 *self.height_scale, 56*self.width_scale, 24*self.height_scale)
        self.temperatureEdit.setStyleSheet(
            f"color: #222222;background-color: #ffffff;border: {2* self.height_scale}px solid #F32B16;border-radius: {11*self.height_scale}px;")
        temperatureTextfont = QFont(self.font_family2, 9*self.width_scale)
        self.temperatureEdit.setFont(temperatureTextfont)



        # 设置字体
        # temperatureTextfont = QFont(self.font_family2, 9 * self.height_scale)
        # self.temperatureEdit.setFont(temperatureTextfont)

        self.ksyrBtn = QPushButton(self.statusCard)
        # self.ksyrBtn.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.ksyrBtn.setText('开始预热')
        self.ksyrBtn.setGeometry(25*self.width_scale, 137*self.height_scale, 110*self.width_scale, 40*self.height_scale)
        self.ksyrBtn.setStyleSheet(f"QPushButton{{color: #ffffff;background-color: #393939;border-radius: {19*self.height_scale}px;}}")
        ksyrBtnfont = QFont(self.font_family2, 12*self.width_scale)
        self.ksyrBtn.setFont(ksyrBtnfont)
        self.ksyrBtn.clicked.connect(self.ksyrBtnState)

        # self.ksyrBtnQSQ = QLabel("00:00:00", self.statusCard)
        # self.ksyrBtnQSQ.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.ksyrBtnQSQ.setGeometry(125, 137, 110, 40)
        # self.ksyrBtnQSQ.setStyleSheet("font-size: 12px;color: #ffffff")  # 设置字体大小

        self.intoTime = QTime(0, 0, 0)
        self.intoTime2 = QTime(0, 0, 0)
        self.intoTime3 = QTime(0, 0, 0)

        self.ksyrtimer = QTimer(self)
        self.ksyrtimer.timeout.connect(self.update_time)  # 定时器超时时更新时间

        self.yrqk = QWidget(self)  # 预热情况
        self.yrqk.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #EEF3F7;')
        self.yrqk.setGeometry(231*self.width_scale, 436*self.height_scale, 290*self.width_scale, 120*self.height_scale)

        self.yrqkLabel = QLabel(self.yrqk)
        self.yrqkLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.yrqkLabel.setText('预热情况')
        self.yrqkLabel.setGeometry(25*self.width_scale, 20*self.height_scale, 290*self.width_scale, 45*self.height_scale)
        self.yrqkLabel.setStyleSheet("color: #222222;")
        yrqkfont = QFont(self.font_family3, 14*self.width_scale)
        self.yrqkLabel.setFont(yrqkfont)

        self.yrqkLabelTime = QLabel(self.yrqk)
        self.yrqkLabelTime.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.yrqkLabelTime.setText('00：00')
        self.yrqkLabelTime.setGeometry(25*self.width_scale, 55*self.height_scale, 39*self.width_scale, 19*self.height_scale)
        self.yrqkLabelTime.setStyleSheet("color: #222222;")
        yrqkfont2 = QFont(self.font_family3, 8*self.width_scale)
        self.yrqkLabelTime.setFont(yrqkfont2)

        self.yrqkLabel = QLabel(self.yrqk)
        self.yrqkLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.yrqkLabel.setText('30：00')
        self.yrqkLabel.setGeometry(226*self.width_scale, 55*self.height_scale, 39*self.width_scale, 19*self.height_scale)
        self.yrqkLabel.setStyleSheet("color: #8A929C;")
        self.yrqkLabel.setFont(yrqkfont2)

        self.jdtbk = QWidget(self.yrqk)  # 进度条边框
        self.jdtbk.setGeometry(25 * self.width_scale, 73 * self.height_scale, 240 * self.width_scale,
                               20 * self.height_scale)
        self.jdtbk.setStyleSheet(f'border-radius: {9 * self.height_scale}px;border: 1px solid #CAD6E5;')


        self.jdt = QProgressBar(self.yrqk)
        self.jdt.setGeometry(31*self.width_scale, 80*self.height_scale, 228*self.width_scale, 6*self.height_scale)
        self.jdt.setStyleSheet(
            f"QProgressBar {{border-radius: {3*self.height_scale}px;background-color: #CAD6E5; text-align:center; font-size:0px; color: transparent}}"
            "QProgressBar::chunk {{border-radius: {3*self.height_scale}px;background-color: #72AFFF;}}"
        )

        self.jdtTimer = QBasicTimer()
        self.jdtStep = 0
        # self.jdtTimer.timeout.connect(self.updateJdtBar)

        # 锅间协议
        self.gjxy = QWidget(self)
        self.gjxy.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #EEF3F7;')
        self.gjxy.setGeometry(231*self.width_scale, 436*self.height_scale, 290*self.width_scale, 120*self.height_scale)
        self.gjxy.setVisible(False)

        self.gjxyLabel = QLabel(self.gjxy)
        self.gjxyLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.gjxyLabel.setText('锅间协议')
        self.gjxyLabel.setGeometry(25*self.width_scale, 20*self.height_scale, 290*self.width_scale, 45*self.height_scale)
        self.gjxyLabel.setStyleSheet("color: #222222;")
        self.gjxyLabel.setFont(yrqkfont)

        self.temperature = QLabel(self.gjxy)
        self.temperature.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.temperature.setText('185°')
        self.temperature.setGeometry(106*self.width_scale, 21*self.height_scale, 56*self.width_scale, 24*self.height_scale)
        self.temperature.setStyleSheet(
            f"color: #222222;background-color: #ffffff;border: 2px solid #F32B16;border-radius: {12*self.height_scale}px;")
        temperatureTextfont = QFont(self.font_family2, 9*self.width_scale)
        self.temperature.setFont(temperatureTextfont)

        self.gjxyTimeTxt = QLabel(self.gjxy)
        self.gjxyTimeTxt.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.gjxyTimeTxt.setText(self.intoTime3.toString("mm:ss"))
        self.gjxyTimeTxt.setGeometry(171*self.width_scale, 53*self.height_scale, 49*self.width_scale, 19*self.height_scale)
        self.gjxyTimeTxt.setStyleSheet("color: #222222;")
        yrqkfont3 = QFont(self.font_family3, 10*self.width_scale)
        self.gjxyTimeTxt.setFont(yrqkfont3)

        self.gjxyLabel = QLabel(self.gjxy)
        self.gjxyLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.gjxyLabel.setText('| 8：00')
        self.gjxyLabel.setGeometry(226*self.width_scale, 55*self.height_scale, 39*self.width_scale, 19*self.height_scale)
        self.gjxyLabel.setStyleSheet("color: #8A929C;")
        self.gjxyLabel.setFont(yrqkfont2)

        self.gjxy_jdtbk = QWidget(self.gjxy)  # 锅间协议进度条边框
        self.gjxy_jdtbk.setStyleSheet(f'border-radius: {9*self.height_scale}px;border: 1px solid #CAD6E5;')
        self.gjxy_jdtbk.setGeometry(25*self.width_scale, 73*self.height_scale, 240*self.width_scale, 20*self.height_scale)

        self.jdtGJXY = QProgressBar(self.gjxy)
        self.jdtGJXY.setGeometry(31*self.width_scale, 80*self.height_scale, 228*self.width_scale, 6*self.height_scale)
        self.jdtGJXY.setStyleSheet(
            "QProgressBar {border-radius: 3px;background-color: #CAD6E5; text-align:center; font-size:0px; color: transparent}"
            "QProgressBar::chunk {border-radius: 3px;background-color: #72AFFF;}"
        )
        self.jdtGJXYTimer = QBasicTimer()
        self.jdtGJXYStep = 0

        self.gjxytimer = QTimer(self)
        self.gjxytimer.timeout.connect(self.gjxy_update_time)  # 定时器超时时更新时间


        # 进度情况
        self.jdqk = QWidget(self)
        self.jdqk.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #EEF3F7;')
        self.jdqk.setGeometry(231*self.width_scale, 436*self.height_scale, 290*self.width_scale, 120*self.height_scale)
        self.jdqk.setVisible(False)

        self.jdqkLabel = QLabel(self.jdqk)
        self.jdqkLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.jdqkLabel.setText('进度情况')
        self.jdqkLabel.setGeometry(25*self.width_scale, 20*self.height_scale, 290*self.width_scale, 45*self.height_scale)
        self.jdqkLabel.setStyleSheet("color: #222222;")
        self.jdqkLabel.setFont(yrqkfont)

        self.jdqkLabelTime = QLabel(self.jdqk)
        self.jdqkLabelTime.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.jdqkLabelTime.setText('00:00')
        self.jdqkLabelTime.setGeometry(190*self.width_scale, 55*self.height_scale, 39*self.width_scale, 19*self.height_scale)
        self.jdqkLabelTime.setStyleSheet("color: #222222;")  # 仅在初始化时设置样式
        self.jdqkLabelTime.setFont(yrqkfont2)

        self.gjxyLabel = QLabel(self.jdqk)
        self.gjxyLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.gjxyLabel.setText('| 15min')
        self.gjxyLabel.setGeometry(226*self.width_scale, 55*self.height_scale, 39*self.width_scale, 19*self.height_scale)
        self.gjxyLabel.setStyleSheet("color: #8A929C;")
        self.gjxyLabel.setFont(yrqkfont2)

        # 设置布局和进度条
        self.jdqk_jdtbk = QWidget(self.jdqk)  # 进度条容器
        self.jdqk_jdtbk.setStyleSheet(f'border-radius: {9*self.height_scale}px; border: 1px solid #CAD6E5;')
        self.jdqk_jdtbk.setGeometry(25*self.width_scale, 73*self.height_scale, 240*self.width_scale, 20*self.height_scale)

        # 创建一个 QVBoxLayout，确保进度条可以垂直居中
        outer_layout = QVBoxLayout(self.jdqk_jdtbk)
        outer_layout.setContentsMargins(6*self.width_scale, 0, 6*self.width_scale, 0)  # 去掉边距
        outer_layout.setAlignment(Qt.AlignmentFlag.AlignVCenter)  # 垂直居中

        # 创建一个水平布局用于放置进度条
        self.jdqkProgressLayout = QHBoxLayout()
        self.jdqkProgressLayout.setAlignment(Qt.AlignmentFlag.AlignCenter)  # 水平居中
        self.progress_bars = []
        colors = ['#72AFFF', '#428AE9', '#1472EF', 'blue']

        for color in colors:
            progress_bar = QProgressBar()
            progress_bar.setValue(0)  # 初始值为 0
            progress_bar.setStyleSheet(
                f"QProgressBar {{border-radius: {3*self.height_scale}px; background-color: #cccccc; text-align: center; font-size: 0px; color: transparent}}"
                f"QProgressBar::chunk {{ background-color: {color}; }}"
            )
            progress_bar.setFixedHeight(6*self.height_scale)  # 设置进度条高度
            self.progress_bars.append(progress_bar)
            self.jdqkProgressLayout.addWidget(progress_bar)

        # 将水平布局添加到垂直布局中
        outer_layout.addLayout(self.jdqkProgressLayout)
        self.jdqk_jdtbk.setLayout(outer_layout)

        # 初始化状态
        self.current_progress = 0
        self.current_bar_index = 0

        # 设置进度条更新的间隔（例如 50 毫秒）
        self.fourInterval = 900
        self.total_steps = 1000  # 每个进度条分 100 个步骤

        # 创建 QTimer 控制进度条的更新
        self.fourTimer = QTimer(self)
        self.fourTimer.timeout.connect(self.update_progress)

        self.colorChangeTimer = QTimer(self)
        self.colorChangeTimer.setSingleShot(True)  # 只触发一次
        self.colorChangeTimer.timeout.connect(self.change_last_bar_color)
        self.colorChangeTimer.start(15 * 60 * 1000)  # 15 分钟（900,000 毫秒）

        self.user_interacted = False  # 默认为 False


        # 情况反馈-----
        self.qkfk = QWidget(self)
        self.qkfk.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #EEF3F7;')
        self.qkfk.setGeometry(231*self.width_scale, 436*self.height_scale, 290*self.width_scale, 120*self.height_scale)
        self.qkfk.setVisible(False)

        self.qkfkLabel = QLabel(self.qkfk)
        self.qkfkLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.qkfkLabel.setText('情况反馈')
        self.qkfkLabel.setGeometry(25*self.width_scale, 20*self.height_scale, 290*self.width_scale, 45*self.height_scale)
        self.qkfkLabel.setStyleSheet("color: #222222;")
        yrqkfont = QFont(self.font_family3, 14*self.width_scale)
        self.qkfkLabel.setFont(yrqkfont)

        self.srkBack = QWidget(self.qkfk)
        self.srkBack.setStyleSheet(f'border-radius: {12*self.height_scale}px;border: 1px solid #CAD6E5;background-color: transparent')
        self.srkBack.setGeometry(25*self.width_scale, 60*self.height_scale, 240*self.width_scale, 32*self.height_scale)

        self.line_label = QLabel(self.srkBack)
        self.line_label.setGeometry(18*self.width_scale, 11*self.height_scale, 1*self.width_scale, 9*self.height_scale)
        self.line_label.setStyleSheet("background-color: #CAD6E5;")

        self.line_edit = QLineEdit(self.srkBack)
        # self.line_edit.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.line_edit.setPlaceholderText("请输入烘焙情况...")
        self.line_edit.setAlignment(Qt.AlignmentFlag.AlignLeft)
        self.line_edit.setStyleSheet("""
                                                           QLineEdit {
                                                               background-color: transparent;  /* 设置背景颜色 */
                                                               color: #8A929C;             /* 设置文字颜色 */
                                                               font-size: 12px;            /* 设置字体大小 */
                                                               border: none;               /* 移除边框 */
                                                           }
                                                       """)
        line_editfont = QFont(self.font_family4, 12*self.width_scale)
        self.line_edit.setFont(line_editfont)
        self.line_edit.setGeometry(24*self.width_scale, 8*self.height_scale, 175*self.width_scale, 14*self.height_scale)

        self.icon_label = QLabel(self.srkBack)
        self.icon_label.setStyleSheet('border: none;')
        self.icon_label.setPixmap(QIcon(self.normalized_path + '/includes/Icons/yrzb/temperatureM.png').pixmap(17, 17))
        self.icon_label.setGeometry(210*self.width_scale, 6*self.height_scale, 17*self.width_scale, 17*self.height_scale)

        # self.orderList = QListWidget(self)
        # self.orderList.setGeometry(231, 591, 290, 406)
        # # 设置滚动条策略为始终隐藏
        # self.orderList.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        # self.orderList.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        # # 隐藏边框 (设置无边框样式)
        # self.orderList.setStyleSheet("""
        #                     QListWidget {
        #                         background-color: transparent;
        #                         border: none;
        #                     }
        #                     QListWidget::item:selected {
        #                         background-color: transparent;
        #                         border: none;
        #                     }
        #                     QListWidget::item:hover {
        #                         background-color: transparent;
        #                         border: none;
        #                     }
        #                 """)

        self.orderWidget = QWidget(self)
        self.orderWidget.setStyleSheet('border: none;background-color: transparent;')
        self.orderWidget.setGeometry(231 * self.width_scale, 591 * self.height_scale, 290 * self.width_scale,
                                     406 * self.height_scale)

        self.orderLayout = QVBoxLayout(self.orderWidget)
        self.orderLayout.setContentsMargins(0, 0, 0, 56 * self.height_scale)

        # 加载订单列表的 JSON 数据
        self.load_order_json()

        # # 添加按钮
        # self.addButton = QPushButton(self.orderWidget)
        # self.addButton.setStyleSheet('''
        #     QPushButton {
        #         border-radius: 25px;
        #         background-color: #f5f8fb;
        #         border: 1px solid #e1f0fe;
        #         padding: 0px;  /* 确保图片不会被拉伸 */
        #         qproperty-icon: url('src/includes/Icons/general/addProject.png');
        #         qproperty-iconSize: 100px 100px; /* 调整图片尺寸 */
        #     }
        #     QPushButton:hover {
        #         background-color: #DEEEFE;
        #         border: 1px solid #b5d5fd; /* 改变边框颜色 */
        #     }
        #     QPushButton:pressed {
        #         background-color: #e1f0fe;
        #         border: 1px solid #91c6fc; /* 按下时的边框颜色 */
        #     }
        # ''')
        # self.addButton.setIcon(QIcon('src/includes/Icons/general/addProject.png'))  # 设置图标
        # self.addButton.setIconSize(QSize(100 * self.height_scale, 100 * self.height_scale))  # 调整图标大小
        # self.addButton.setMinimumSize(290 * self.width_scale, 185 * self.height_scale)  # 按钮大小
        # self.addButton.setMaximumSize(290 * self.width_scale, 185 * self.height_scale)  # 固定按钮大小
        # self.addButton.clicked.connect(self.add_orderDiolog)  # 绑定点击事件
        #
        # # 将按钮添加到布局中
        # self.orderLayout.addWidget(self.addButton, alignment=Qt.AlignmentFlag.AlignBottom)

        # 将布局设置到 orderWidget
        self.orderWidget.setLayout(self.orderLayout)

        # 初始化 QScrollArea
        self.orderScroll = QScrollArea(self)  # self 指向当前窗口
        self.orderScroll.setWidgetResizable(True)  # 自动调整大小以适应内容
        self.orderScroll.setGeometry(231 * self.width_scale, 591 * self.height_scale, 290 * self.width_scale,
                                     406 * self.height_scale)
        self.orderScroll.setStyleSheet('border: none;background-color: transparent; ')
        self.orderScroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # 隐藏横向滚动条
        self.orderScroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # 隐藏纵向滚动条

        # 设置 orderWidget 为 QScrollArea 的内容
        self.orderScroll.setWidget(self.orderWidget)

        # self.id_value = []
        # self.chucangValue = []

        self.ordersRect = QWidget(self)  # 咖啡订单卡片
        self.ordersRect.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #f5f8fb; border: 1px solid #e1f0fe;')
        self.ordersRect.setGeometry(231*self.width_scale, 201*self.height_scale, 290*self.width_scale, 185*self.height_scale)
        self.ordersRect.setVisible(False)

        self.yrqkLabel = QLabel(self.ordersRect)
        self.yrqkLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.yrqkLabel.setText('01-玫瑰谷咖啡')
        self.yrqkLabel.setGeometry(25*self.width_scale, 20*self.height_scale, 250*self.width_scale, 45*self.height_scale)
        self.yrqkLabel.setStyleSheet("color: #222222;border:none;")
        yrqkfont = QFont(self.font_family3, 12*self.width_scale)
        self.yrqkLabel.setFont(yrqkfont)

        self.moreSet = QPushButton(self.ordersRect)
        self.moreSet.setGeometry(260*self.width_scale, 25*self.height_scale, 9*self.width_scale, 23*self.height_scale)
        self.moreSet.setStyleSheet(f"""
            QPushButton {{
                border-image: url('{self.normalized_path}/includes/Icons/yrzb/more.png');
                border: none;
            }}
        """)
        # self.moreSet.setStyleSheet("")
        # self.moreSet.clicked.connect(self.orderMoreClicked)

        self.yrqkLabel = QLabel(self.ordersRect)
        self.yrqkLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.yrqkLabel.setText('任务订单：2024PG-0001')
        self.yrqkLabel.setGeometry(24*self.width_scale, 68*self.height_scale, 250*self.width_scale, 45*self.height_scale)
        self.yrqkLabel.setStyleSheet("color: #222222;border:none;")
        yrqkfont = QFont(self.font_family4, 12*self.width_scale)
        self.yrqkLabel.setFont(yrqkfont)

        self.yrqkLabel = QLabel(self.ordersRect)
        self.yrqkLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.yrqkLabel.setText('截止日期：2024/07/23/12:00')
        self.yrqkLabel.setGeometry(24*self.width_scale, 103*self.height_scale, 250*self.width_scale, 45*self.height_scale)
        self.yrqkLabel.setStyleSheet("color: #222222;border:none;")
        yrqkfont = QFont(self.font_family4, 12*self.width_scale)
        self.yrqkLabel.setFont(yrqkfont)

        self.yrqkLabel = QLabel(self.ordersRect)
        self.yrqkLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.yrqkLabel.setText('订单数量：01/30')
        self.yrqkLabel.setGeometry(24*self.width_scale, 138*self.height_scale, 250*self.width_scale, 45*self.height_scale)
        self.yrqkLabel.setStyleSheet("color: #222222;border:none;")
        yrqkfont = QFont(self.font_family4, 12*self.width_scale)
        self.yrqkLabel.setFont(yrqkfont)

        # self.yrqkLabel = QLabel(self.ordersRect)
        # self.yrqkLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        # self.yrqkLabel.setText('状态：')
        # self.yrqkLabel.setGeometry(24, 138, 250, 45)
        # self.yrqkLabel.setStyleSheet("color: #222222;border:none;")
        # yrqkfont = QFont(self.font_family4, 12)
        # self.yrqkLabel.setFont(yrqkfont)
        self.ordering = QWidget(self)  # 咖啡订单卡片
        self.ordering.setStyleSheet(
            f'border-radius: {25 * self.height_scale}px;background-color: #E5F2FE; border: 1px solid #70D0A3;')
        self.ordering.setGeometry(231 * self.width_scale, 201 * self.height_scale, 290 * self.width_scale,
                                  185 * self.height_scale)

        self.getTPMark = []

        self.task_name_label2 = QLabel(self.ordering)
        self.task_name_label2.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.task_name_label2.setText('02-玫瑰谷咖啡')
        self.task_name_label2.setGeometry(25 * self.width_scale, 20 * self.height_scale, 250 * self.width_scale,
                                          45 * self.height_scale)
        self.task_name_label2.setStyleSheet("color: #222222;border:none;")
        yrqkfont = QFont(self.font_family3, 14 * self.width_scale)
        self.task_name_label2.setFont(yrqkfont)
        self.ordering.setVisible(False)

        self.moreSet = QPushButton(self.ordering)
        self.moreSet.setGeometry(260 * self.width_scale, 25 * self.height_scale, 9 * self.width_scale,
                                 23 * self.height_scale)
        self.moreSet.setStyleSheet(f"""
                            QPushButton {{
                                border-image: url('{self.normalized_path}/includes/Icons/yrzb/more.png');
                                border: none;
                            }}
                        """)
        # self.moreSet.setStyleSheet("")
        self.moreSet.clicked.connect(self.orderMoreClicked)

        # self.task_no_label2 = ScrollingLabel('任务订单：', self.ordering)
        # self.task_no_label2.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        # self.task_no_label2.setGeometry(24 * self.width_scale, 68 * self.height_scale, 62 * self.width_scale,
        #                                 45 * self.height_scale)
        # self.task_no_label2.setStyleSheet("color: #222222;border:none;")
        # yrqkfont = QFont(self.font_family4, 12 * self.width_scale)
        # self.task_no_label2.setFont(yrqkfont)

        self.task_no_label2 = ScrollingLabel('2024PG-0001', self.ordering)
        self.task_no_label2.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.task_no_label2.setGeometry(24 * self.width_scale, 68 * self.height_scale, 250 * self.width_scale,
                                        45 * self.height_scale)
        self.task_no_label2.setStyleSheet("color: #222222;border:none;")
        yrqkfont = QFont(self.font_family4, 10 * self.width_scale)
        self.task_no_label2.setFont(yrqkfont)

        self.deadline_label2 = QLabel(self.ordering)
        self.deadline_label2.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.deadline_label2.setText('截止日期：2024/07/23/12:00')
        self.deadline_label2.setGeometry(24 * self.width_scale, 103 * self.height_scale, 250 * self.width_scale,
                                         45 * self.height_scale)
        self.deadline_label2.setStyleSheet("color: #222222;border:none;")
        self.deadline_label2.setFont(yrqkfont)

        self.order_id_label2 = QLabel(self.ordering)
        self.order_id_label2.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.order_id_label2.setText('订单状态：')
        self.order_id_label2.setGeometry(24 * self.width_scale, 138 * self.height_scale, 250 * self.width_scale,
                                         45 * self.height_scale)
        self.order_id_label2.setStyleSheet("color: #222222;border:none;")
        self.order_id_label2.setFont(yrqkfont)

        self.status_label2 = QLabel(self.ordering)
        self.status_label2.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.status_label2.setText('进行中')
        self.status_label2.setGeometry(87 * self.width_scale, 136 * self.height_scale, 60 * self.width_scale,
                                       22 * self.height_scale)
        self.status_label2.setStyleSheet(
            f"color: #ffffff;border:none;background-color: #222222; border-radius: {10 * self.height_scale}px")
        self.status_label2.setFont(yrqkfont)

        self.ordersRect_More = QWidget(self)  # 咖啡订单卡片
        self.ordersRect_More.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #f5f8fb; border: 1px solid #70D0A3;')
        self.ordersRect_More.setGeometry(231*self.width_scale, 201*self.height_scale, 290*self.width_scale, 575*self.height_scale)
        self.ordersRect_More.setVisible(False)

        self.shouqi = QPushButton(self.ordersRect_More)
        self.shouqi.setGeometry(241*self.width_scale, 25*self.height_scale, 23*self.width_scale, 23*self.height_scale)
        self.shouqi.setStyleSheet(f"""
                                    QPushButton {{
                                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/moreandmore.png');
                                        border: none;
                                    }}
                                """)
        # self.moreSet.setStyleSheet("")
        self.shouqi.clicked.connect(self.orderShouqiClicked)

        self.more_jd = QLabel(self.ordersRect_More)
        self.more_jd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.more_jd.setText('阶段')
        self.more_jd.setGeometry(21*self.width_scale, 70*self.height_scale, 50*self.width_scale, 50*self.height_scale)
        self.more_jd.setStyleSheet(f"color: #ffffff; background-color: #222222; border:none;border-radius: {15*self.height_scale}px;")
        more_jdfont = QFont(self.font_family3, 10*self.width_scale)
        self.more_jd.setFont(more_jdfont)

        self.more_jdTitle = QLabel(self.ordersRect_More)
        self.more_jdTitle.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.more_jdTitle.setGeometry(75*self.width_scale, 70*self.height_scale, 196*self.width_scale, 50*self.height_scale)
        self.more_jdTitle.setStyleSheet(f"color: #ffffff; background-color: #222222; border:none;border-radius: {15*self.height_scale}px;")

        self.more_mbwd = QLabel(self.more_jdTitle)
        self.more_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.more_mbwd.setText('目标温度')
        self.more_mbwd.setGeometry(15*self.width_scale, 9*self.height_scale, 27*self.width_scale, 32*self.height_scale)
        self.more_mbwd.setStyleSheet("color: #ffffff; background-color: #222222; border:none;")
        self.more_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 10*self.width_scale)
        self.more_mbwd.setFont(more_jdTitlefont)

        self.more_mbwd = QLabel(self.more_jdTitle)
        self.more_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.more_mbwd.setText('参考值')
        self.more_mbwd.setGeometry(52*self.width_scale, 9*self.height_scale, 27*self.width_scale, 32*self.height_scale)
        self.more_mbwd.setStyleSheet("color: #ffffff; background-color: #222222; border:none;")
        self.more_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 10*self.width_scale)
        self.more_mbwd.setFont(more_jdTitlefont)

        self.more_mbwd = QLabel(self.more_jdTitle)
        self.more_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.more_mbwd.setText('火力')
        self.more_mbwd.setGeometry(86*self.width_scale, 9*self.height_scale, 27*self.width_scale, 32*self.height_scale)
        self.more_mbwd.setStyleSheet("color: #ffffff; background-color: #222222; border:none;")
        self.more_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 10*self.width_scale)
        self.more_mbwd.setFont(more_jdTitlefont)

        self.more_mbwd = QLabel(self.more_jdTitle)
        self.more_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.more_mbwd.setText('风门')
        self.more_mbwd.setGeometry(121*self.width_scale, 9*self.height_scale, 27*self.width_scale, 32*self.height_scale)
        self.more_mbwd.setStyleSheet("color: #ffffff; background-color: #222222; border:none;")
        self.more_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 10*self.width_scale)
        self.more_mbwd.setFont(more_jdTitlefont)

        self.more_mbwd = QLabel(self.more_jdTitle)
        self.more_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.more_mbwd.setText('转速')
        self.more_mbwd.setGeometry(156*self.width_scale, 9*self.height_scale, 27*self.width_scale, 32*self.height_scale)
        self.more_mbwd.setStyleSheet("color: #ffffff; background-color: #222222; border:none;")
        self.more_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 10*self.width_scale)
        self.more_mbwd.setFont(more_jdTitlefont)

        self.setjieduanNum = 1

        self.showjd1 = QLabel(self.ordersRect_More)
        self.showjd1.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjd1.setText(str(self.setjieduanNum))
        self.showjd1.setGeometry(21*self.width_scale, 125*self.height_scale, 50*self.width_scale, 28*self.height_scale)
        self.showjd1.setStyleSheet(
            f"color: #222222; background-color: #F6F9FC; border-radius: {13*self.height_scale}px; border: 1px solid #D9E4F4")
        showjd1dfont = QFont(self.font_family3, 10*self.width_scale)
        self.showjd1.setFont(showjd1dfont)

        self.showjdInfo1 = QLabel(self.ordersRect_More)
        self.showjdInfo1.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo1.setGeometry(75*self.width_scale, 125*self.height_scale, 196*self.width_scale, 28*self.height_scale)
        self.showjdInfo1.setStyleSheet(
            f"color: #222222; background-color: #D9E4F4; border-radius: {13*self.height_scale}px; border: 1px solid #D9E4F4")

        self.setmuwdNum = 108
        self.setckzNum = 30
        self.setHuoliNum = 20
        self.setFengmenNum = 30
        self.setzhuansuNum = 62

        self.showjdInfo1_mbwd = QLabel(self.showjdInfo1)
        self.showjdInfo1_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo1_mbwd.setText(str(self.setmuwdNum))
        self.showjdInfo1_mbwd.setGeometry(15*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo1_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo1_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo1_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo2_mbwd = QLabel(self.showjdInfo1)
        self.showjdInfo2_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo2_mbwd.setText(str(self.setckzNum))
        self.showjdInfo2_mbwd.setGeometry(52*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo2_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo2_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo2_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo3_mbwd = QLabel(self.showjdInfo1)
        self.showjdInfo3_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo3_mbwd.setText(str(self.setHuoliNum))
        self.showjdInfo3_mbwd.setGeometry(86*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo3_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo3_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo3_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo4_mbwd = QLabel(self.showjdInfo1)
        self.showjdInfo4_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo4_mbwd.setText(str(self.setFengmenNum))
        self.showjdInfo4_mbwd.setGeometry(121*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo4_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo4_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo4_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo5_mbwd = QLabel(self.showjdInfo1)
        self.showjdInfo5_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo5_mbwd.setText(str(self.setzhuansuNum))
        self.showjdInfo5_mbwd.setGeometry(156*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo5_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo5_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo5_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo2 = QLabel(self.ordersRect_More)
        self.showjdInfo2.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo2.setGeometry(75*self.width_scale, 160*self.height_scale, 196*self.width_scale, 28*self.height_scale)
        self.showjdInfo2.setStyleSheet(
            f"color: #222222; background-color: #D9E4F4; border-radius: {13*self.height_scale}px; border: 1px solid #D9E4F4")

        self.showjdInfo1_mbwd = QLabel(self.showjdInfo2)
        self.showjdInfo1_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo1_mbwd.setText('148')
        self.showjdInfo1_mbwd.setGeometry(15*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo1_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo1_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo1_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo2_mbwd = QLabel(self.showjdInfo2)
        self.showjdInfo2_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo2_mbwd.setText('30')
        self.showjdInfo2_mbwd.setGeometry(52*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo2_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo2_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo2_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo3_mbwd = QLabel(self.showjdInfo2)
        self.showjdInfo3_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo3_mbwd.setText('10')
        self.showjdInfo3_mbwd.setGeometry(86*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo3_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo3_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo3_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo4_mbwd = QLabel(self.showjdInfo2)
        self.showjdInfo4_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo4_mbwd.setText('30')
        self.showjdInfo4_mbwd.setGeometry(121*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo4_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo4_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo4_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo5_mbwd = QLabel(self.showjdInfo2)
        self.showjdInfo5_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo5_mbwd.setText('62')
        self.showjdInfo5_mbwd.setGeometry(156*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo5_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo5_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo5_mbwd.setFont(more_jdTitlefont)

        self.showjd2 = QLabel(self.ordersRect_More)
        self.showjd2.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjd2.setText('2')
        self.showjd2.setGeometry(21*self.width_scale, 160*self.height_scale, 50*self.width_scale, 28*self.height_scale)
        self.showjd2.setStyleSheet(
            f"color: #222222; background-color: #F6F9FC; border-radius: {13*self.height_scale}px; border: 1px solid #D9E4F4")
        showjd2font = QFont(self.font_family3, 10*self.width_scale)
        self.showjd2.setFont(showjd2font)

        self.showjd3 = QLabel(self.ordersRect_More)
        self.showjd3.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjd3.setText('3')
        self.showjd3.setGeometry(21*self.width_scale, 195*self.height_scale, 50*self.width_scale, 28*self.height_scale)
        self.showjd3.setStyleSheet(
            f"color: #222222; background-color: #F6F9FC; border-radius: {13*self.height_scale}px; border: 1px solid #D9E4F4")
        showjd3font = QFont(self.font_family3, 10*self.width_scale)
        self.showjd3.setFont(showjd3font)

        self.showjdInfo3 = QLabel(self.ordersRect_More)
        self.showjdInfo3.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo3.setGeometry(75*self.width_scale, 195*self.height_scale, 196*self.width_scale, 28*self.height_scale)
        self.showjdInfo3.setStyleSheet(
            f"color: #222222; background-color: #D9E4F4; border-radius: {13*self.height_scale}px; border: 1px solid #D9E4F4")

        self.showjdInfo1_mbwd = QLabel(self.showjdInfo3)
        self.showjdInfo1_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo1_mbwd.setText('170')
        self.showjdInfo1_mbwd.setGeometry(15*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo1_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo1_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo1_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo2_mbwd = QLabel(self.showjdInfo3)
        self.showjdInfo2_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo2_mbwd.setText('30')
        self.showjdInfo2_mbwd.setGeometry(52*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo2_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo2_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo2_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo3_mbwd = QLabel(self.showjdInfo3)
        self.showjdInfo3_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo3_mbwd.setText('15')
        self.showjdInfo3_mbwd.setGeometry(86*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo3_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo3_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo3_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo4_mbwd = QLabel(self.showjdInfo3)
        self.showjdInfo4_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo4_mbwd.setText('30')
        self.showjdInfo4_mbwd.setGeometry(121*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo4_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo4_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo4_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo5_mbwd = QLabel(self.showjdInfo3)
        self.showjdInfo5_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo5_mbwd.setText('62')
        self.showjdInfo5_mbwd.setGeometry(156*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo5_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo5_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo5_mbwd.setFont(more_jdTitlefont)

        self.showjd4 = QLabel(self.ordersRect_More)
        self.showjd4.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjd4.setText('4')
        self.showjd4.setGeometry(21*self.width_scale, 230*self.height_scale, 50*self.width_scale, 28*self.height_scale)
        self.showjd4.setStyleSheet(
            f"color: #222222; background-color: #F6F9FC; border-radius: {13*self.height_scale}px; border: 1px solid #D9E4F4")
        showjd4font = QFont(self.font_family3, 10*self.width_scale)
        self.showjd4.setFont(showjd4font)

        self.showjdInfo4 = QLabel(self.ordersRect_More)
        self.showjdInfo4.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo4.setGeometry(75*self.width_scale, 230*self.height_scale, 196*self.width_scale, 28*self.height_scale)
        self.showjdInfo4.setStyleSheet(
            f"color: #222222; background-color: #D9E4F4; border-radius: {13*self.height_scale}px; border: 1px solid #D9E4F4")

        self.showjdInfo1_mbwd = QLabel(self.showjdInfo4)
        self.showjdInfo1_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo1_mbwd.setText('173')
        self.showjdInfo1_mbwd.setGeometry(15*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo1_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo1_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo1_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo2_mbwd = QLabel(self.showjdInfo4)
        self.showjdInfo2_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo2_mbwd.setText('30')
        self.showjdInfo2_mbwd.setGeometry(52*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo2_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo2_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo2_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo3_mbwd = QLabel(self.showjdInfo4)
        self.showjdInfo3_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo3_mbwd.setText('15')
        self.showjdInfo3_mbwd.setGeometry(86*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo3_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo3_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo3_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo4_mbwd = QLabel(self.showjdInfo4)
        self.showjdInfo4_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo4_mbwd.setText('30')
        self.showjdInfo4_mbwd.setGeometry(121*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo4_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo4_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo4_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo5_mbwd = QLabel(self.showjdInfo4)
        self.showjdInfo5_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo5_mbwd.setText('62')
        self.showjdInfo5_mbwd.setGeometry(156*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo5_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo5_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo5_mbwd.setFont(more_jdTitlefont)

        self.showjd5 = QLabel(self.ordersRect_More)
        self.showjd5.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjd5.setText('5')
        self.showjd5.setGeometry(21*self.width_scale, 265*self.height_scale, 50*self.width_scale, 28*self.height_scale)
        self.showjd5.setStyleSheet(
            f"color: #222222; background-color: #F6F9FC; border-radius: {13*self.height_scale}px; border: 1px solid #D9E4F4")
        showjd5font = QFont(self.font_family3, 10*self.width_scale)
        self.showjd5.setFont(showjd5font)

        self.showjdInfo5 = QLabel(self.ordersRect_More)
        self.showjdInfo5.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo5.setGeometry(75*self.width_scale, 265*self.height_scale, 196*self.width_scale, 28*self.height_scale)
        self.showjdInfo5.setStyleSheet(
            f"color: #222222; background-color: #D9E4F4; border-radius: {13*self.height_scale}px; border: 1px solid #D9E4F4")

        self.showjdInfo1_mbwd = QLabel(self.showjdInfo5)
        self.showjdInfo1_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo1_mbwd.setText('188')
        self.showjdInfo1_mbwd.setGeometry(15*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo1_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo1_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo1_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo2_mbwd = QLabel(self.showjdInfo5)
        self.showjdInfo2_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo2_mbwd.setText('30')
        self.showjdInfo2_mbwd.setGeometry(52*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo2_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo2_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo2_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo3_mbwd = QLabel(self.showjdInfo5)
        self.showjdInfo3_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo3_mbwd.setText('1')
        self.showjdInfo3_mbwd.setGeometry(86*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo3_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo3_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo3_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo4_mbwd = QLabel(self.showjdInfo5)
        self.showjdInfo4_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo4_mbwd.setText('30')
        self.showjdInfo4_mbwd.setGeometry(121*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo4_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo4_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo4_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo5_mbwd = QLabel(self.showjdInfo5)
        self.showjdInfo5_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo5_mbwd.setText('62')
        self.showjdInfo5_mbwd.setGeometry(156*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo5_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo5_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo5_mbwd.setFont(more_jdTitlefont)

        self.showjd6 = QLabel(self.ordersRect_More)
        self.showjd6.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjd6.setText('6')
        self.showjd6.setGeometry(21*self.width_scale, 300*self.height_scale, 50*self.width_scale, 28*self.height_scale)
        self.showjd6.setStyleSheet(
            f"color: #222222; background-color: #F6F9FC; border-radius: {13*self.height_scale}px; border: 1px solid #D9E4F4")
        showjd6font = QFont(self.font_family3, 10*self.width_scale)
        self.showjd6.setFont(showjd6font)

        self.showjdInfo6 = QLabel(self.ordersRect_More)
        self.showjdInfo6.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo6.setGeometry(75*self.width_scale, 300*self.height_scale, 196*self.width_scale, 28*self.height_scale)
        self.showjdInfo6.setStyleSheet(
            f"color: #222222; background-color: #D9E4F4; border-radius: {13*self.height_scale}px; border: 1px solid #D9E4F4")

        self.showjdInfo1_mbwd = QLabel(self.showjdInfo6)
        self.showjdInfo1_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo1_mbwd.setText('196')
        self.showjdInfo1_mbwd.setGeometry(15*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo1_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo1_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo1_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo2_mbwd = QLabel(self.showjdInfo6)
        self.showjdInfo2_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo2_mbwd.setText('30')
        self.showjdInfo2_mbwd.setGeometry(52*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo2_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo2_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo2_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo3_mbwd = QLabel(self.showjdInfo6)
        self.showjdInfo3_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo3_mbwd.setText('1')
        self.showjdInfo3_mbwd.setGeometry(86*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo3_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo3_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo3_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo4_mbwd = QLabel(self.showjdInfo6)
        self.showjdInfo4_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo4_mbwd.setText('30')
        self.showjdInfo4_mbwd.setGeometry(121*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo4_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo4_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo4_mbwd.setFont(more_jdTitlefont)

        self.showjdInfo5_mbwd = QLabel(self.showjdInfo6)
        self.showjdInfo5_mbwd.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.showjdInfo5_mbwd.setText('62')
        self.showjdInfo5_mbwd.setGeometry(156*self.width_scale, 0, 27*self.width_scale, 28*self.height_scale)
        self.showjdInfo5_mbwd.setStyleSheet("color: #222222; border:none;")
        self.showjdInfo5_mbwd.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 8*self.width_scale)
        self.showjdInfo5_mbwd.setFont(more_jdTitlefont)

        self.zysxRect = QLabel(self.ordersRect_More)
        self.zysxRect.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.zysxRect.setGeometry(21*self.width_scale, 364*self.height_scale, 247*self.width_scale, 92*self.height_scale)
        self.zysxRect.setStyleSheet(
            f"color: #222222; background-color: #F6F9FC; border-radius: {15*self.height_scale}px; border: 1px solid #DF7A7A")

        self.zysxRectText = QLabel(self.zysxRect)
        self.zysxRectText.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.zysxRectText.setText('一爆后请注意观察豆子的实时情况目标色值：60')
        self.zysxRectText.setGeometry(18*self.width_scale, 28*self.height_scale, 214*self.width_scale, 92*self.height_scale)
        self.zysxRectText.setStyleSheet("color: #222222; background-color: transparent; border:none;")
        self.zysxRectText.setWordWrap(True)
        more_jdTitlefont = QFont(self.font_family3, 10*self.width_scale)
        # more_jdTitlefont.setBold(True)
        self.zysxRectText.setFont(more_jdTitlefont)

        self.zysxTitle = QLabel(self.ordersRect_More)
        self.zysxTitle.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.zysxTitle.setGeometry(98*self.width_scale, 350*self.height_scale, 94*self.width_scale, 30*self.height_scale)
        self.zysxTitle.setText('注意事项')
        self.zysxTitle.setStyleSheet(f"background-color: #DF7A7A; border-radius: {15*self.height_scale}px;border:none;color: #ffffff")
        more_jdfont = QFont(self.font_family3, 12*self.width_scale)
        self.zysxTitle.setFont(more_jdfont)

        self.more_ddxq = QLabel(self.ordersRect_More)
        self.more_ddxq.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.more_ddxq.setGeometry(18*self.width_scale, 468*self.height_scale, 70*self.width_scale, 20*self.height_scale)
        self.more_ddxq.setText('订单详情')
        self.more_ddxq.setStyleSheet("background-color: transparent; border:none;color: #222222")
        more_jdfont = QFont(self.font_family3, 12*self.width_scale)
        self.more_ddxq.setFont(more_jdfont)

        self.ddxq_pz1 = QLabel(self.ordersRect_More)
        self.ddxq_pz1.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.ddxq_pz1.setGeometry(18*self.width_scale, 506*self.height_scale, 100*self.width_scale, 20*self.height_scale)
        self.ddxq_pz1.setText('品种：埃塞G')
        self.ddxq_pz1.setStyleSheet("background-color: transparent; border:none;color: #222222")
        ddxq_pz1font = QFont(self.font_family3, 10*self.width_scale)
        self.ddxq_pz1.setFont(ddxq_pz1font)

        self.ddxq_zl1 = QLabel(self.ordersRect_More)
        self.ddxq_zl1.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.ddxq_zl1.setGeometry(180*self.width_scale, 506*self.height_scale, 100*self.width_scale, 20*self.height_scale)
        self.ddxq_zl1.setText('重量：10kg')
        self.ddxq_zl1.setStyleSheet("background-color: transparent; border:none;color: #222222")
        ddxq_zl1font = QFont(self.font_family3, 10*self.width_scale)
        self.ddxq_zl1.setFont(ddxq_zl1font)

        self.ddxq_pz1 = QLabel(self.ordersRect_More)
        self.ddxq_pz1.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.ddxq_pz1.setGeometry(18*self.width_scale, 540*self.height_scale, 100*self.width_scale, 20*self.height_scale)
        self.ddxq_pz1.setText('品种：埃塞G')
        self.ddxq_pz1.setStyleSheet("background-color: transparent; border:none;color: #222222")
        ddxq_pz1font = QFont(self.font_family3, 10*self.width_scale)
        self.ddxq_pz1.setFont(ddxq_pz1font)

        self.ddxq_zl1 = QLabel(self.ordersRect_More)
        self.ddxq_zl1.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.ddxq_zl1.setGeometry(180*self.width_scale, 540*self.height_scale, 100*self.width_scale, 20*self.height_scale)
        self.ddxq_zl1.setText('重量：10kg')
        self.ddxq_zl1.setStyleSheet("background-color: transparent; border:none;color: #222222")
        ddxq_zl1font = QFont(self.font_family3, 10*self.width_scale)
        self.ddxq_zl1.setFont(ddxq_zl1font)



        self.processInfo1 = QLabel(self)  # 豆温|风温
        self.processInfo1.setStyleSheet(f"border-radius: {25*self.height_scale}px;background-color: #f5f2ee;")
        self.processInfo1.setGeometry(561*self.width_scale, 811*self.height_scale, 224*self.width_scale, 185*self.height_scale)
        # self.processInfo1Img = QPixmap(self.normalized_path + '/includes/Icons/yrzb/bottomBack.png')
        # self.processInfo1.setPixmap(QIcon(self.normalized_path + '/includes/Icons/yrzb/bottomBack.png').pixmap(224*self.width_scale, 185*self.height_scale))

        self.processInfoLabel = QLabel(self.processInfo1)
        self.processInfoLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.processInfoLabel.setText('105.5')
        self.processInfoLabel.setGeometry(24*self.width_scale, 29*self.height_scale, 200*self.width_scale, 58*self.height_scale)
        self.processInfoLabel.setStyleSheet("color: #252525;font-weight: 400;background-color: transparent;")
        processInfofont = QFont(self.font_family5, 28*self.width_scale)
        self.processInfoLabel.setFont(processInfofont)

        self.ssdLabel = QLabel(self.processInfo1)
        self.ssdLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.ssdLabel.setText('℃')
        self.ssdLabel.setGeometry(145*self.width_scale, 26*self.height_scale, 16*self.width_scale, 18*self.height_scale)
        self.ssdLabel.setStyleSheet("color: #C8C8C8;")
        ssdfont = QFont(self.font_family4, 12*self.width_scale)
        self.ssdLabel.setFont(ssdfont)

        self.lineLabel = QWidget(self.processInfo1)
        self.lineLabel.setStyleSheet('background-color: #C8C8C8;')
        self.lineLabel.setGeometry(138*self.width_scale, 68*self.height_scale, 1*self.width_scale, 18*self.height_scale)

        self.processInfo1WD = QLabel(self.processInfo1)
        self.processInfo1WD.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.processInfo1WD.setText('192.5')
        self.processInfo1WD.setGeometry(141*self.width_scale, 68*self.height_scale, 46*self.width_scale, 18*self.height_scale)
        self.processInfo1WD.setStyleSheet("color: #616265;")
        ssdfont = QFont(self.font_family4, 12*self.width_scale)
        self.processInfo1WD.setFont(ssdfont)

        self.ssdLabel = QLabel(self.processInfo1)
        self.ssdLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.ssdLabel.setText('℃')
        self.ssdLabel.setGeometry(187*self.width_scale, 62*self.height_scale, 16*self.width_scale, 18*self.height_scale)
        self.ssdLabel.setStyleSheet("color: #C8C8C8;")
        ssdfont = QFont(self.font_family4, 8*self.width_scale)
        self.ssdLabel.setFont(ssdfont)

        self.processInfoImg = QLabel(self.processInfo1)
        self.processInfoImg.setGeometry(28*self.width_scale, 109*self.height_scale, 50*self.width_scale, 50*self.width_scale)  # Position and size of the label
        douwenPixmap = QPixmap(self.normalized_path + '/includes/Icons/yrzb/douwen.png')  # Path to your icon image
        self.processInfoImg.setPixmap(douwenPixmap)
        self.processInfoImg.setScaledContents(True)  # Scale pixmap to fit QLabel

        self.processInfoLabel2 = QLabel(self.processInfo1)
        self.processInfoLabel2.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.processInfoLabel2.setText('豆温|风温')
        self.processInfoLabel2.setGeometry(140*self.width_scale, 127*self.height_scale, 80*self.width_scale, 24*self.height_scale)
        self.processInfoLabel2.setStyleSheet("color: #616265;font-weight: 400;")
        processInfofont2 = QFont(self.font_family3, 10*self.width_scale)
        self.processInfoLabel2.setFont(processInfofont2)

        self.processInfo2 = QLabel(self)  # ROR
        self.processInfo2.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #f5f2ee;')
        self.processInfo2.setGeometry(820*self.width_scale, 811*self.height_scale, 224*self.width_scale, 185*self.height_scale)
        # self.processInfo2.setPixmap(
        #     QIcon(self.normalized_path + '/includes/Icons/yrzb/bottomBack.png').pixmap(224 * self.width_scale,
        #                                                                                185 * self.height_scale))

        self.processInfo2ROR = QLabel(self.processInfo2)
        self.processInfo2ROR.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.processInfo2ROR.setText('50')
        self.processInfo2ROR.setGeometry(24*self.width_scale, 29*self.height_scale, 200*self.width_scale, 58*self.height_scale)
        self.processInfo2ROR.setStyleSheet("color: #252525;font-weight: 400;")
        processInfofont = QFont(self.font_family5, 28*self.width_scale)
        self.processInfo2ROR.setFont(processInfofont)

        self.processInfoImg = QLabel(self.processInfo2)
        self.processInfoImg.setGeometry(28*self.width_scale, 109*self.height_scale, 50*self.width_scale, 50*self.width_scale)  # Position and size of the label
        douwenPixmap = QPixmap(self.normalized_path + '/includes/Icons/yrzb/ROR.png')  # Path to your icon image
        self.processInfoImg.setPixmap(douwenPixmap)
        self.processInfoImg.setScaledContents(True)  # Scale pixmap to fit QLabel

        self.processInfoLabel2 = QLabel(self.processInfo2)
        self.processInfoLabel2.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.processInfoLabel2.setText('ROR')
        self.processInfoLabel2.setGeometry(169*self.width_scale, 127*self.height_scale, 80*self.width_scale, 24*self.height_scale)
        self.processInfoLabel2.setStyleSheet("color: #616265;font-weight: 400;")
        processInfofont2 = QFont(self.font_family3, 10*self.width_scale)
        self.processInfoLabel2.setFont(processInfofont2)

        self.processInfo3 = QLabel(self)  # Agtron色值
        self.processInfo3.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #f5f2ee;')
        self.processInfo3.setGeometry(1079*self.width_scale, 811*self.height_scale, 224*self.width_scale, 185*self.height_scale)
        # self.processInfo3.setPixmap(
        #     QIcon(self.normalized_path + '/includes/Icons/yrzb/bottomBack.png').pixmap(224 * self.width_scale,
        #                                                                                185 * self.height_scale))

        self.agtronNum = QLabel(self.processInfo3)
        self.agtronNum.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.agtronNum.setText('42.6')
        self.agtronNum.setGeometry(24*self.width_scale, 29*self.height_scale, 200*self.width_scale, 58*self.height_scale)
        self.agtronNum.setStyleSheet("color: #252525;font-weight: 400;")
        processInfofont = QFont(self.font_family5, 28*self.width_scale)
        self.agtronNum.setFont(processInfofont)

        self.processInfoImg = QLabel(self.processInfo3)
        self.processInfoImg.setGeometry(28*self.width_scale, 109*self.height_scale, 50*self.width_scale, 50*self.width_scale)  # Position and size of the label
        douwenPixmap = QPixmap(self.normalized_path + '/includes/Icons/yrzb/sezhi.png')  # Path to your icon image
        self.processInfoImg.setPixmap(douwenPixmap)
        self.processInfoImg.setScaledContents(True)  # Scale pixmap to fit QLabel

        self.processInfoLabel2 = QLabel(self.processInfo3)
        self.processInfoLabel2.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.processInfoLabel2.setText('Agtron色值')
        self.processInfoLabel2.setGeometry(124*self.width_scale, 127*self.height_scale, 80*self.width_scale, 24*self.height_scale)
        self.processInfoLabel2.setStyleSheet("color: #616265;font-weight: 400;")
        processInfofont2 = QFont(self.font_family3, 10*self.width_scale)
        self.processInfoLabel2.setFont(processInfofont2)

        self.processInfo4 = QLabel(self)  # 排气湿度
        self.processInfo4.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #f5f2ee;')
        self.processInfo4.setGeometry(1338*self.width_scale, 811*self.height_scale, 224*self.width_scale, 185*self.height_scale)
        # self.processInfo4.setPixmap(
        #     QIcon(self.normalized_path + '/includes/Icons/yrzb/bottomBack.png').pixmap(224 * self.width_scale,
        #                                                                                185 * self.height_scale))

        self.processInfo4rhNum = QLabel(self.processInfo4)
        self.processInfo4rhNum.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.processInfo4rhNum.setText('35')
        self.processInfo4rhNum.setGeometry(24*self.width_scale, 29*self.height_scale, 200*self.width_scale, 58*self.height_scale)
        self.processInfo4rhNum.setStyleSheet("color: #252525;font-weight: 400;")
        processInfofont = QFont(self.font_family5, 28*self.width_scale)
        self.processInfo4rhNum.setFont(processInfofont)

        self.ssdLabel = QLabel(self.processInfo4)
        self.ssdLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.ssdLabel.setText('RH%')
        self.ssdLabel.setGeometry(93*self.width_scale, 26*self.height_scale, 40*self.width_scale, 18*self.height_scale)
        self.ssdLabel.setStyleSheet("color: #C8C8C8;")
        ssdfont = QFont(self.font_family4, 12*self.width_scale)
        self.ssdLabel.setFont(ssdfont)

        self.lineLabel = QWidget(self.processInfo4)
        self.lineLabel.setStyleSheet('background-color: #C8C8C8;')
        self.lineLabel.setGeometry(145*self.width_scale, 68*self.height_scale, 1*self.width_scale, 18*self.height_scale)

        self.rhWendu = QLabel(self.processInfo4)
        self.rhWendu.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.rhWendu.setText('41.2')
        self.rhWendu.setGeometry(149*self.width_scale, 68*self.height_scale, 39*self.width_scale, 18*self.height_scale)
        self.rhWendu.setStyleSheet("color: #616265;")
        ssdfont = QFont(self.font_family4, 12*self.width_scale)
        self.rhWendu.setFont(ssdfont)

        self.ssdLabel = QLabel(self.processInfo4)
        self.ssdLabel.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.ssdLabel.setText('℃')
        self.ssdLabel.setGeometry(187*self.width_scale, 62*self.height_scale, 16*self.width_scale, 18*self.height_scale)
        self.ssdLabel.setStyleSheet("color: #C8C8C8;")
        ssdfont = QFont(self.font_family4, 8*self.width_scale)
        self.ssdLabel.setFont(ssdfont)

        self.processInfoImg = QLabel(self.processInfo4)
        self.processInfoImg.setGeometry(28*self.width_scale, 109*self.height_scale, 50*self.width_scale, 50*self.width_scale)  # Position and size of the label
        douwenPixmap = QPixmap(self.normalized_path + '/includes/Icons/yrzb/pqsd.png')  # Path to your icon image
        self.processInfoImg.setPixmap(douwenPixmap)
        self.processInfoImg.setScaledContents(True)  # Scale pixmap to fit QLabel

        self.processInfoLabel2 = QLabel(self.processInfo4)
        self.processInfoLabel2.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.processInfoLabel2.setText('排气湿度 温度')
        self.processInfoLabel2.setGeometry(119*self.width_scale, 127*self.height_scale, 93*self.width_scale, 24*self.height_scale)
        self.processInfoLabel2.setStyleSheet("color: #616265;font-weight: 400;")
        processInfofont2 = QFont(self.font_family3, 10*self.width_scale)
        self.processInfoLabel2.setFont(processInfofont2)

        self.rightTop = QWidget(self)  # 右上
        self.rightTop.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #EEF3F7;')
        self.rightTop.setGeometry(1601*self.width_scale, 201*self.height_scale, 230*self.width_scale, 270*self.height_scale)

        self.rightTopLabel1 = QLabel(self.rightTop)
        self.rightTopLabel1.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.rightTopLabel1.setText('2024PG-001')
        self.rightTopLabel1.setGeometry(25*self.width_scale, 25*self.height_scale, 180*self.width_scale, 29*self.height_scale)
        self.rightTopLabel1.setStyleSheet(f"background-color: #393939;color:white;border-radius: {14*self.height_scale}px;")
        rightTopFont1 = QFont(self.font_family3, 12*self.width_scale)
        self.rightTopLabel1.setFont(rightTopFont1)

        self.rightTopLabel2 = QLabel(self.rightTop)
        # self.rightTopLabel2.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.rightTopLabel2.setText('    阶段：')
        self.rightTopLabel2.setGeometry(25*self.width_scale, 57*self.height_scale, 180*self.width_scale, 29*self.height_scale)
        self.rightTopLabel2.setStyleSheet(
            f"QLabel{{background-color: #D9E4F4;color:#222222;border-radius: {14*self.height_scale}px;}}"
            f"QLabel:hover{{background-color: #89B8EE;color:#222222;border-radius: {14*self.height_scale}px;}}"
        )
        rightTopFont2 = QFont(self.font_family3, 12*self.width_scale)
        self.rightTopLabel2.setFont(rightTopFont2)

        self.jieduanNum = QLabel(self.rightTopLabel2)
        self.jieduanNum.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignRight)
        self.jieduanNum.setText('1')
        self.jieduanNum.setGeometry(140*self.width_scale, 0, 30*self.width_scale, 29*self.height_scale)
        self.jieduanNum.setStyleSheet(
            f"QLabel{{background-color: transparent;color:#222222;border-radius: {14*self.height_scale}px;}}"
            f"QLabel:hover{{background-color: transparent;color:#222222;border-radius: {14*self.height_scale}px;}}"
        )
        rightTopFont2 = QFont(self.font_family3, 12*self.width_scale)
        self.jieduanNum.setFont(rightTopFont2)

        self.rightTopLabel3 = QLabel(self.rightTop)
        # rightTopLabel3.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.rightTopLabel3.setText('    目标温度：')
        self.rightTopLabel3.setGeometry(25*self.width_scale, 89*self.height_scale, 180*self.width_scale, 29*self.height_scale)
        self.rightTopLabel3.setStyleSheet(
            f"QLabel{{background-color: #D9E4F4;color:#222222;border-radius: {14*self.height_scale}px;}}"
            f"QLabel:hover{{background-color: #89B8EE;color:#222222;border-radius: {14*self.height_scale}px;}}"
        )
        rightTopFont3 = QFont(self.font_family3, 12*self.width_scale)
        self.rightTopLabel3.setFont(rightTopFont3)

        self.mbwdNum = QLabel(self.rightTopLabel3)
        self.mbwdNum.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignRight)
        self.mbwdNum.setText(str(self.setmuwdNum))
        self.mbwdNum.setGeometry(140*self.width_scale, 0, 30*self.width_scale, 29*self.height_scale)
        self.mbwdNum.setStyleSheet(
            f"QLabel{{background-color: transparent;color:#222222;border-radius: 14px;}}"
            f"QLabel:hover{{background-color: transparent;color:#222222;border-radius: 14px;}}"
        )
        rightTopFont2 = QFont(self.font_family3, 12*self.width_scale)
        self.mbwdNum.setFont(rightTopFont2)

        self.rightTopLabel4 = QLabel(self.rightTop)
        # rightTopLabel3.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.rightTopLabel4.setText('    参考值：')
        self.rightTopLabel4.setGeometry(25*self.width_scale, 121*self.height_scale, 180*self.width_scale, 29*self.height_scale)
        self.rightTopLabel4.setStyleSheet(
            f"QLabel{{background-color: #D9E4F4;color:#222222;border-radius: {14*self.height_scale}px;}}"
            f"QLabel:hover{{background-color: #89B8EE;color:#222222;border-radius: {14*self.height_scale}px;}}"
        )
        rightTopFont3 = QFont(self.font_family3, 12*self.width_scale)
        self.rightTopLabel4.setFont(rightTopFont3)

        self.ckzNumR = QLabel(self.rightTopLabel4)
        self.ckzNumR.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignRight)
        self.ckzNumR.setText(str(self.setckzNum))
        self.ckzNumR.setGeometry(140*self.width_scale, 0, 30*self.width_scale, 29*self.height_scale)
        self.ckzNumR.setStyleSheet(
            f"QLabel{{background-color: transparent;color:#222222;border-radius: {14*self.height_scale}px;}}"
            f"QLabel:hover{{background-color: transparent;color:#222222;border-radius: {14*self.height_scale}px;}}"
        )
        rightTopFont2 = QFont(self.font_family3, 12*self.width_scale)
        self.ckzNumR.setFont(rightTopFont2)

        self.rightTopLabel5 = QLabel(self.rightTop)
        # rightTopLabel3.stAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.rightTopLabel5.setText('    火力：')
        self.rightTopLabel5.setGeometry(25*self.width_scale, 153*self.height_scale, 180*self.width_scale, 29*self.height_scale)
        self.rightTopLabel5.setStyleSheet(
            f"QLabel{{background-color: #D9E4F4;color:#222222;border-radius: {14*self.height_scale}px;}}"
            f"QLabel:hover{{background-color: #89B8EE;color:#222222;border-radius: {14*self.height_scale}px;}}"
        )
        rightTopFont3 = QFont(self.font_family3, 12*self.width_scale)
        self.rightTopLabel5.setFont(rightTopFont3)

        self.hlNumR = QLabel(self.rightTopLabel5)
        self.hlNumR.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignRight)
        self.hlNumR.setText(str(self.setHuoliNum))
        self.hlNumR.setGeometry(140*self.width_scale, 0, 30*self.width_scale, 29*self.height_scale)
        self.hlNumR.setStyleSheet(
            f"QLabel{{background-color: transparent;color:#222222;border-radius: {14*self.height_scale}px;}}"
            f"QLabel:hover{{background-color: transparent;color:#222222;border-radius: {14*self.height_scale}px;}}"
        )
        rightTopFont2 = QFont(self.font_family3, 12*self.width_scale)
        self.hlNumR.setFont(rightTopFont2)

        self.rightTopLabel6 = QLabel(self.rightTop)
        # rightTopLabel3.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.rightTopLabel6.setText('    风门：')
        self.rightTopLabel6.setGeometry(25*self.width_scale, 184*self.height_scale, 180*self.width_scale, 29*self.height_scale)
        self.rightTopLabel6.setStyleSheet(
            f"QLabel{{background-color: #D9E4F4;color:#222222;border-radius: {14*self.height_scale}px;}}"
            f"QLabel:hover{{background-color: #89B8EE;color:#222222;border-radius: {14*self.height_scale}px;}}"
        )
        rightTopFont3 = QFont(self.font_family3, 12*self.width_scale)
        self.rightTopLabel6.setFont(rightTopFont3)

        self.fmNumR = QLabel(self.rightTopLabel6)
        self.fmNumR.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignRight)
        self.fmNumR.setText(str(self.setFengmenNum))
        self.fmNumR.setGeometry(140*self.width_scale, 0, 30*self.width_scale, 29*self.height_scale)
        self.fmNumR.setStyleSheet(
            f"QLabel{{background-color: transparent;color:#222222;border-radius: {14*self.height_scale}px;}}"
            f"QLabel:hover{{background-color: transparent;color:#222222;border-radius: {14*self.height_scale}px;}}"
        )
        rightTopFont2 = QFont(self.font_family3, 12*self.width_scale)
        self.fmNumR.setFont(rightTopFont2)

        self.rightTopLabel7 = QLabel(self.rightTop)
        # rightTopLabel3.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.rightTopLabel7.setText('    转速：')
        self.rightTopLabel7.setGeometry(25*self.width_scale, 216*self.height_scale, 180*self.width_scale, 29*self.height_scale)
        self.rightTopLabel7.setStyleSheet(
            f"QLabel{{background-color: #D9E4F4;color:#222222;border-radius: {14*self.height_scale}px;}}"
            f"QLabel:hover{{background-color: #89B8EE;color:#222222;border-radius: {14*self.height_scale}px;}}"
        )
        rightTopFont3 = QFont(self.font_family3, 12*self.width_scale)
        self.rightTopLabel7.setFont(rightTopFont3)

        self.zsNumR = QLabel(self.rightTopLabel7)
        self.zsNumR.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignRight)
        self.zsNumR.setText(str(self.setzhuansuNum))
        self.zsNumR.setGeometry(140*self.width_scale, 0, 30*self.width_scale, 29*self.height_scale)
        self.zsNumR.setStyleSheet(
            f"QLabel{{background-color: transparent;color:#222222;border-radius: {14*self.height_scale}px;}}"
            f"QLabel:hover{{background-color: transparent;color:#222222;border-radius: {14*self.height_scale}px;}}"
        )
        rightTopFont2 = QFont(self.font_family3, 12*self.width_scale)
        self.zsNumR.setFont(rightTopFont2)

        self.rightCenter = QWidget(self)  # 右中
        self.rightCenter.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #EEF3F7;')
        self.rightCenter.setGeometry(1601*self.width_scale, 506*self.height_scale, 230*self.width_scale, 270*self.height_scale)

        self.setPoint = QLabel(self.rightCenter)
        self.setPoint.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.setPoint.setText('·')
        self.setPoint.setGeometry(25*self.width_scale, 30*self.height_scale, 6*self.width_scale, 6)
        self.setPoint.setStyleSheet("color: #89B8EE;")
        pointfont = QFont(self.font_family2, 22*self.width_scale)
        self.setPoint.setFont(pointfont)

        self.setHuoli = 0
        self.setFengmen = 30
        self.setZhuansu = 30

        self.setHl = QLabel(self.rightCenter)
        self.setHl.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.setHl.setText('1')
        self.setHl.setGeometry(37*self.width_scale, 25*self.height_scale, 35*self.width_scale, 16*self.height_scale)
        self.setHl.setStyleSheet(
            f"color: #222222;background-color: #F0F3F7;border-radius: {7*self.height_scale}px;border: 1px solid #222222;")
        setHlfont = QFont(self.font_family2, 10*self.width_scale)
        self.setHl.setFont(setHlfont)

        self.hl = QLabel(self.rightCenter)
        self.hl.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.hl.setText('火力')
        self.hl.setGeometry(38*self.width_scale, 52*self.height_scale, 35*self.width_scale, 18*self.height_scale)
        self.hl.setStyleSheet("color: #222222;")
        hlfont = QFont(self.font_family2, 14*self.width_scale)
        self.hl.setFont(hlfont)

        self.jiaImg = QPushButton(self.rightCenter)
        self.jiaImg.setGeometry(98*self.width_scale, 40*self.height_scale, 38*self.width_scale, 38*self.width_scale)
        # jiaPixmap = QPixmap('G:/Vue/artisan/src/includes/Icons/yrzb/jia.png')
        # self.jiaImg.setPixmap(jiaPixmap)
        self.jiaImg.setStyleSheet(f"""
                    QPushButton {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jia.png');
                    }}
                    QPushButton:hover {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jiaClick.png');
                    }}
                    QPushButton:pressed {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jiaClick.png');
                    }}
                """)

        self.jiaImg.clicked.connect(self.huoli_jia_clicked)

        # self.jianPixmap = QPixmap('G:/Vue/artisan/src/includes/Icons/yrzb/jian.png')
        # self.jianPixmap2 = QPixmap('G:/Vue/artisan/src/includes/Icons/yrzb/jianClick.png')
        self.jianImg = QPushButton(self.rightCenter)
        self.jianImg.setGeometry(154*self.width_scale, 40*self.height_scale, 38*self.width_scale, 38*self.width_scale)  # 设置按钮位置和大小
        self.jianImg.setStyleSheet(f"""
                    QPushButton {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jian.png');
                    }}
                    QPushButton:hover {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jianClick.png');
                    }}
                    QPushButton:pressed {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jianClick.png');
                    }}
                """)
        # self.jianImg.setIcon(QIcon(self.jianPixmap))  # 设置按钮图标
        # self.jianImg.setIconSize(self.jianImg.size())  # 设置图标大小与按钮一致
        self.jianImg.clicked.connect(self.huoli_jian_clicked)

        self.setPoint = QLabel(self.rightCenter)
        self.setPoint.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.setPoint.setText('·')
        self.setPoint.setGeometry(25*self.width_scale, 114*self.height_scale, 6*self.width_scale, 6*self.height_scale)
        self.setPoint.setStyleSheet("color: #89B8EE;")
        pointfont = QFont(self.font_family2, 22*self.width_scale)
        self.setPoint.setFont(pointfont)

        self.setFm = QLabel(self.rightCenter)
        self.setFm.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.setFm.setText('30')
        self.setFm.setGeometry(37*self.width_scale, 109*self.height_scale, 35*self.width_scale, 16*self.height_scale)
        self.setFm.setStyleSheet(
            f"color: #222222;background-color: #F0F3F7;border-radius: {7*self.height_scale}px;border: 1px solid #222222;")
        setHlfont = QFont(self.font_family2, 10*self.width_scale)
        self.setFm.setFont(setHlfont)

        self.hl = QLabel(self.rightCenter)
        self.hl.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.hl.setText('风门')
        self.hl.setGeometry(38*self.width_scale, 136*self.height_scale, 35*self.width_scale, 18*self.height_scale)
        self.hl.setStyleSheet("color: #222222;")
        hlfont = QFont(self.font_family2, 14*self.width_scale)
        self.hl.setFont(hlfont)

        self.jiaImg = QPushButton(self.rightCenter)
        self.jiaImg.setGeometry(98*self.width_scale, 124*self.height_scale, 38*self.width_scale, 38*self.width_scale)
        self.jiaImg.setStyleSheet(f"""
                    QPushButton {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jia.png');
                    }}
                    QPushButton:hover {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jiaClick.png');
                    }}
                    QPushButton:pressed {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jiaClick.png');
                    }}
                """)
        self.jiaImg.clicked.connect(self.fengmen_jia_clicked)

        self.jianImg = QPushButton(self.rightCenter)
        self.jianImg.setGeometry(154*self.width_scale, 124*self.height_scale, 38*self.width_scale, 38*self.width_scale)  # 设置按钮位置和大小
        self.jianImg.setStyleSheet(f"""
                    QPushButton {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jian.png');
                    }}
                    QPushButton:hover {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jianClick.png');
                    }}
                    QPushButton:pressed {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jianClick.png');
                    }}
                """)
        self.jianImg.clicked.connect(self.fengmen_jian_clicked)

        self.setPoint = QLabel(self.rightCenter)
        self.setPoint.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.setPoint.setText('·')
        self.setPoint.setGeometry(25*self.width_scale, 196*self.height_scale, 6*self.width_scale, 6*self.height_scale)
        self.setPoint.setStyleSheet("color: #89B8EE;")
        pointfont = QFont(self.font_family2, 22*self.width_scale)
        self.setPoint.setFont(pointfont)

        self.setZs = QLabel(self.rightCenter)
        self.setZs.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.setZs.setText('30')
        self.setZs.setGeometry(37*self.width_scale, 192*self.height_scale, 35*self.width_scale, 16*self.height_scale)
        self.setZs.setStyleSheet(
            f"color: #222222;background-color: #F0F3F7;border-radius: {7*self.height_scale}px;border: 1px solid #222222;")
        setHlfont = QFont(self.font_family2, 10*self.width_scale)
        self.setZs.setFont(setHlfont)

        self.hl = QLabel(self.rightCenter)
        self.hl.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.hl.setText('转速')
        self.hl.setGeometry(38*self.width_scale, 219*self.height_scale, 35*self.width_scale, 18*self.height_scale)
        self.hl.setStyleSheet("color: #222222;")
        hlfont = QFont(self.font_family2, 14*self.width_scale)
        self.hl.setFont(hlfont)

        self.jiaImg = QPushButton(self.rightCenter)
        self.jiaImg.setGeometry(98*self.width_scale, 207*self.height_scale, 38*self.width_scale, 38*self.width_scale)
        self.jiaImg.setStyleSheet(f"""
                    QPushButton {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jia.png');
                    }}
                    QPushButton:hover {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jiaClick.png');
                    }}
                    QPushButton:pressed {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jiaClick.png');
                    }}
                """)
        self.jiaImg.clicked.connect(self.zhuansu_jia_clicked)
        self.jianImg = QPushButton(self.rightCenter)
        self.jianImg.setGeometry(154*self.width_scale, 207*self.height_scale, 38*self.width_scale, 38*self.width_scale)  # 设置按钮位置和大小
        self.jianImg.setStyleSheet(f"""
                    QPushButton {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jian.png');
                    }}
                    QPushButton:hover {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jianClick.png');
                    }}
                    QPushButton:pressed {{
                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/jianClick.png');
                    }}
                """)
        self.jianImg.clicked.connect(self.zhuansu_jian_clicked)

        self.chartRect = QLabel(self)  # 统计图
        self.chartRect.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #f1ebe7;')
        self.chartRect.setGeometry(566*self.width_scale, 201*self.height_scale, 996*self.width_scale, 575*self.height_scale)
        # self.chartRectImg = QPixmap(self.normalized_path + '/includes/Icons/yrzb/hbdt.png')
        # self.chartRect.setPixmap(self.chartRectImg)
        # self.chartRect.setPixmap(
        #     QIcon(self.normalized_path + '/includes/Icons/yrzb/hbdt.png').pixmap(996 * self.width_scale,
        #                                                                                575 * self.height_scale))
        # self.chartRect.lower()

        self.qmc: tgraphcanvas = tgraphcanvas(self.chartRect, self.dpi, locale, self)
        self.qmc.setGeometry(56*self.width_scale, 50*self.height_scale, 884*self.width_scale, 360*self.height_scale)
        self.qmc.setVisible(True)

        print('canvas=', self.dpi, locale)


        self.chartKey = QLabel(self.chartRect)
        self.chartKey.setGeometry(54 * self.width_scale, 420 * self.height_scale, 891 * self.width_scale,
                                  34 * self.height_scale)
        self.chartKey.setStyleSheet(f'border-radius: {16*self.height_scale}px;background-color: #e8e1dd;')


        self.chartKey_dw = QLabel(self.chartKey)
        self.chartKey_dw.setStyleSheet(f'border-radius: {2*self.height_scale}px;background-color: #D18F65;')
        self.chartKey_dw.setGeometry(154*self.width_scale, 11*self.height_scale, 7*self.width_scale, 12*self.height_scale)
        self.chartKey_dwText = QLabel(self.chartKey)
        self.chartKey_dwText.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.chartKey_dwText.setText('豆温')
        self.chartKey_dwText.setGeometry(170*self.width_scale, 9*self.height_scale, 28*self.width_scale, 18*self.height_scale)
        self.chartKey_dwText.setStyleSheet("color: #292827;border:none;")
        chartKeyfont = QFont(self.font_family4, 10*self.width_scale)
        self.chartKey_dwText.setFont(chartKeyfont)

        self.chartKey_fw = QLabel(self.chartKey)
        self.chartKey_fw.setStyleSheet(f'border-radius: {2*self.height_scale}px;background-color: #AC3230;')
        self.chartKey_fw.setGeometry(256*self.width_scale, 11*self.height_scale, 7*self.width_scale, 12*self.height_scale)
        self.chartKey_fwText = QLabel(self.chartKey)
        self.chartKey_fwText.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.chartKey_fwText.setText('风温')
        self.chartKey_fwText.setGeometry(272*self.width_scale, 9*self.height_scale, 28*self.width_scale, 18*self.height_scale)
        self.chartKey_fwText.setStyleSheet("color: #292827;border:none;")
        chartKeyfont = QFont(self.font_family4, 10*self.width_scale)
        self.chartKey_fwText.setFont(chartKeyfont)

        self.chartKey_ror = QLabel(self.chartKey)
        self.chartKey_ror.setStyleSheet(f'border-radius: {2*self.height_scale}px;background-color: #7864AA;')
        self.chartKey_ror.setGeometry(358*self.width_scale, 11*self.height_scale, 7*self.width_scale, 12*self.height_scale)
        self.chartKey_rorText = QLabel(self.chartKey)
        self.chartKey_rorText.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.chartKey_rorText.setText('ROR')
        self.chartKey_rorText.setGeometry(373*self.width_scale, 9*self.height_scale, 30*self.width_scale, 18*self.height_scale)
        self.chartKey_rorText.setStyleSheet("color: #292827;border:none;")
        chartKeyfont = QFont(self.font_family4, 10*self.width_scale)
        self.chartKey_rorText.setFont(chartKeyfont)

        self.chartKey_sz = QLabel(self.chartKey)
        self.chartKey_sz.setStyleSheet('border-radius: 2px;background-color: #6BAE76;')
        self.chartKey_sz.setGeometry(460*self.width_scale, 11*self.height_scale, 7*self.width_scale, 12*self.height_scale)
        self.chartKey_szText = QLabel(self.chartKey)
        self.chartKey_szText.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.chartKey_szText.setText('色值')
        self.chartKey_szText.setGeometry(476*self.width_scale, 9*self.height_scale, 28*self.width_scale, 18*self.height_scale)
        self.chartKey_szText.setStyleSheet("color: #292827;border:none;")
        chartKeyfont = QFont(self.font_family4, 10*self.width_scale)
        self.chartKey_szText.setFont(chartKeyfont)

        self.chartKey_pqsd = QLabel(self.chartKey)
        self.chartKey_pqsd.setStyleSheet(f'border-radius: {2*self.height_scale}px;background-color: #1EA1A9;')
        self.chartKey_pqsd.setGeometry(563*self.width_scale, 11*self.height_scale, 7*self.width_scale, 12*self.height_scale)
        self.chartKey_pqsdText = QLabel(self.chartKey)
        self.chartKey_pqsdText.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.chartKey_pqsdText.setText('排气湿度')
        self.chartKey_pqsdText.setGeometry(581*self.width_scale, 9*self.height_scale, 62*self.width_scale, 18*self.height_scale)
        self.chartKey_pqsdText.setStyleSheet("color: #292827;border:none;")
        chartKeyfont = QFont(self.font_family4, 10*self.width_scale)
        self.chartKey_pqsdText.setFont(chartKeyfont)

        self.chartKey_pqwd = QLabel(self.chartKey)
        self.chartKey_pqwd.setStyleSheet(f'border-radius: {2*self.height_scale}px;background-color: #D0B53F;')
        self.chartKey_pqwd.setGeometry(665*self.width_scale, 11*self.height_scale, 7*self.width_scale, 12*self.height_scale)
        self.chartKey_pqwdText = QLabel(self.chartKey)
        self.chartKey_pqwdText.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.chartKey_pqwdText.setText('排气温度')
        self.chartKey_pqwdText.setGeometry(683*self.width_scale, 9*self.height_scale, 62*self.width_scale, 18*self.height_scale)
        self.chartKey_pqwdText.setStyleSheet("color: #292827;border:none;")
        chartKeyfont = QFont(self.font_family4, 10*self.width_scale)
        self.chartKey_pqwdText.setFont(chartKeyfont)

        self.chartjdt = QLabel(self.chartRect)
        self.chartjdt.setStyleSheet(f'border-radius: {3*self.height_scale}px;background-color: #D3C9C2;')
        self.chartjdt.setGeometry(54*self.width_scale, 508*self.height_scale, 891*self.width_scale, 6*self.height_scale)

        self.rudouBarBack = QLabel(self.chartRect)
        self.rudouBarBack.setStyleSheet(f'border-radius: {3*self.height_scale}px;background-color: #D3C9C2;')
        self.rudouBarBack.setGeometry(88*self.width_scale, 508*self.height_scale, 301*self.width_scale, 6*self.height_scale)

        self.rudouBar = QProgressBar(self.chartRect)
        self.rudouBar.setGeometry(88*self.width_scale, 508*self.height_scale, 803*self.width_scale, 6*self.height_scale)
        self.rudouBar.setStyleSheet(
            f"QProgressBar {{border-radius: {1*self.height_scale}px; background-color: #D3C9C2; text-align:center; font-size:0px; color: transparent}}"
            f"QProgressBar::chunk {{border-radius: {1*self.height_scale}px; background-color: #986C4D; }}"
        )

        self.rudouTimer = QBasicTimer()
        self.rudouStep = 0
        # self.rudouTimer.timeout.connect(self.updateRudouBar)

        self.rudouImg = QLabel(self.chartRect)  # 入豆
        self.rudouImg.setGeometry(54*self.width_scale, 491*self.height_scale, 41*self.width_scale, 41*self.width_scale)
        self.rudouPixmap = QPixmap(self.normalized_path + '/includes/Icons/yrzb/rd.png')
        self.rudouImg.setPixmap(self.rudouPixmap)
        self.rudouImg.setScaledContents(True)

        self.rudouImg_up = QLabel(self.chartRect)
        self.rudouImg_up.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.rudouImg_up.setGeometry(54*self.width_scale, 471*self.height_scale, 41*self.width_scale, 15*self.height_scale)
        self.rudouImg_up.setText('入豆')
        self.rudouImg_up.setStyleSheet("background-color: transparent; border:none;color: #292827")
        rudouImg_upfont = QFont(self.font_family3, 10*self.width_scale)
        self.rudouImg_up.setFont(rudouImg_upfont)

        self.rudouImg_down = QLabel(self.chartRect)
        self.rudouImg_down.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.rudouImg_down.setGeometry(54*self.width_scale, 543*self.height_scale, 41*self.width_scale, 15*self.height_scale)
        self.rudouImg_down.setText('160℃')
        self.rudouImg_down.setStyleSheet("background-color: transparent; border:none;color: #66605B")
        rudouImg_downfont = QFont(self.font_family3, 10*self.width_scale)
        self.rudouImg_down.setFont(rudouImg_downfont)

        self.zhdImg = QPushButton(self.chartRect)  # 转黄点
        self.zhdImg.setGeometry(375*self.width_scale, 491*self.height_scale, 41*self.width_scale, 41*self.width_scale)
        # self.zhdPixmap = QPixmap(self.normalized_path + '/includes/Icons/yrzb/zhd.png')
        # self.zhdImg.setPixmap(self.zhdPixmap)
        self.zhdImg.setStyleSheet(f"""
                            QPushButton {{
                                border-image: url('{self.normalized_path}/includes/Icons/yrzb/zhd.png');
                            }}
                        """)
        # self.zhdImg.setScaledContents(True)
        self.zhdImg.clicked.connect(self.markDryEndClick)
        # self.zhdImg.setCursor(QCursor(Qt.PointingHandCursor))self.qmc.markDryEnd

        # self.zhdBar = QProgressBar(self.chartRect)
        # self.zhdBar.setGeometry(88, 508, 251, 6)
        # self.zhdBar.setStyleSheet(
        #     "QProgressBar {border-radius: 1px; background-color: #D3C9C2; text-align:center; font-size:0px; color: transparent}"
        #     "QProgressBar::chunk {border-radius: 1px; background-color: #986C4D; }"
        # )
        #
        # self.zhdTimer = QBasicTimer()
        # self.zhdStep = 0

        self.zhd_up = QLabel(self.chartRect)
        self.zhd_up.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.zhd_up.setGeometry(375*self.width_scale, 471*self.height_scale, 41*self.width_scale, 15*self.height_scale)
        self.zhd_up.setText('转黄点')
        self.zhd_up.setStyleSheet("background-color: transparent; border:none;color: #292827")
        zhd_upfont = QFont(self.font_family3, 10*self.width_scale)
        self.zhd_up.setFont(zhd_upfont)

        self.zhd_down = QLabel(self.chartRect)
        self.zhd_down.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.zhd_down.setGeometry(366*self.width_scale, 543*self.height_scale, 60*self.width_scale, 15*self.height_scale)
        self.zhd_down.setText('30(RH%)')
        self.zhd_down.setStyleSheet("background-color: transparent; border:none;color: #66605B")
        zhd_downfont = QFont(self.font_family3, 10*self.width_scale)
        self.zhd_down.setFont(zhd_downfont)

        self.yibaoImg = QPushButton(self.chartRect) # 一爆
        self.yibaoImg.setGeometry(652*self.width_scale, 491*self.height_scale, 41*self.width_scale, 41*self.width_scale)
        self.yibaoImg.setStyleSheet(f"""
                                    QPushButton {{
                                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/yb.png');
                                    }}
                                """)
        self.yibaoImg.clicked.connect(self.markyibaoClick)

        self.yb_up = QLabel(self.chartRect)
        self.yb_up.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.yb_up.setGeometry(652*self.width_scale, 471*self.height_scale, 41*self.width_scale, 15*self.height_scale)
        self.yb_up.setText('一爆')
        self.yb_up.setStyleSheet("background-color: transparent; border:none;color: #292827")
        yb_upfont = QFont(self.font_family3, 10*self.width_scale)
        self.yb_up.setFont(yb_upfont)

        self.yb_up = QLabel(self.chartRect)
        self.yb_up.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.yb_up.setGeometry(890 * self.width_scale, 471 * self.height_scale, 41 * self.width_scale,
                               15 * self.height_scale)
        self.yb_up.setText('出仓')
        self.yb_up.setStyleSheet("background-color: transparent; border:none;color: #292827")
        yb_upfont = QFont(self.font_family3, 10 * self.width_scale)
        self.yb_up.setFont(yb_upfont)

        self.zhd_down = QLabel(self.chartRect)
        self.zhd_down.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.zhd_down.setGeometry(652*self.width_scale, 543*self.height_scale, 41*self.width_scale, 15*self.height_scale)
        self.zhd_down.setText('#80')
        self.zhd_down.setStyleSheet("background-color: transparent; border:none;color: #66605B")
        zhd_downfont = QFont(self.font_family3, 10*self.width_scale)
        self.zhd_down.setFont(zhd_downfont)

        self.chukuImg = QPushButton(self.chartRect)  # 出库
        self.chukuImg.setGeometry(890*self.width_scale, 491*self.height_scale, 41*self.width_scale, 41*self.width_scale)
        self.chukuImg.setStyleSheet(f"""
                                            QPushButton {{
                                                border-image: url('{self.normalized_path}/includes/Icons/yrzb/ck.png');
                                            }}
                                        """)

        self.zhd_down = QLabel(self.chartRect)
        self.zhd_down.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.zhd_down.setGeometry(890*self.width_scale, 543*self.height_scale, 41*self.width_scale, 15*self.height_scale)
        self.zhd_down.setText('#65')
        self.zhd_down.setStyleSheet("background-color: transparent; border:none;color: #66605B")
        zhd_downfont = QFont(self.font_family3, 10*self.width_scale)
        self.zhd_down.setFont(zhd_downfont)

        self.diologRect = QLabel(self.chartRect)  # 入豆提醒
        self.diologRect.setStyleSheet(f'border-radius: {25 * self.height_scale}px;background-color: transparent;')
        self.diologRect.setGeometry(
            363 * self.width_scale,
            152 * self.height_scale,
            270 * self.width_scale,
            270 * self.width_scale  # 确保宽高比一致
        )

        # 加载图片并动态缩放
        self.rdtcImg = QPixmap(self.normalized_path + '/includes/Icons/yrzb/diolog.png')
        scaled_img = self.rdtcImg.scaled(
            self.diologRect.width(),
            self.diologRect.height(),
        )

        # 设置缩放后的图片
        self.diologRect.setPixmap(scaled_img)
        self.diologRect.setVisible(False)

        self.jbLbel = QLabel(self.diologRect)
        self.jbLbel.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.jbLbel.setGeometry(0, 63*self.height_scale, 270*self.width_scale, 35*self.height_scale)
        self.jbLbel.setText('警 报')
        self.jbLbel.setStyleSheet("background-color: transparent; border:none;color: #ffffff")
        jbLbelfont = QFont(self.font_family3, 16*self.width_scale)
        self.jbLbel.setFont(jbLbelfont)

        self.jbCentent = QLabel(self.diologRect)
        self.jbCentent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.jbCentent.setGeometry(0, 88*self.height_scale, 270*self.width_scale, 117*self.height_scale)
        self.jbCentent.setText('准备入豆')
        self.jbCentent.setStyleSheet("background-color: transparent; border:none;color: #222222")
        jbCententfont = QFont(self.font_family3, 16*self.width_scale)
        self.jbCentent.setFont(jbCententfont)

        self.rightBottom = QWidget(self)  # 右下
        self.rightBottom.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #EEF3F7;')
        self.rightBottom.setGeometry(1601*self.width_scale, 811*self.height_scale, 230*self.width_scale, 185*self.height_scale)

        self.rdBtn = QPushButton(self.rightBottom)
        # self.rdBtn.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.rdBtn.setText('入 豆')
        self.rdBtn.setGeometry(30*self.width_scale, 40*self.height_scale, 76*self.width_scale, 40*self.height_scale)
        self.rdBtn.setStyleSheet(
            f"QPushButton{{color: #222222;background-color: #F0F3F7;border-radius: {19*self.height_scale}px;border: 1px solid #222222}}"
            f"QPushButton:hover{{color: #ffffff;background-color: #393939;border-radius: {19*self.height_scale}px;}}"
        )
        rdfont = QFont(self.font_family2, 12*self.width_scale)
        self.rdBtn.setFont(rdfont)
        # self.rdBtn.clicked.connect(self.fileLoad)
        self.rdBtn.clicked.connect(self.qmc.markCharge)

        self.ccBtn = QPushButton(self.rightBottom)
        # self.ccBtn.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.ccBtn.setText('出 仓')
        self.ccBtn.setGeometry(124*self.width_scale, 40*self.height_scale, 76*self.width_scale, 40*self.height_scale)
        self.ccBtn.setStyleSheet(
            f"QPushButton{{color: #222222;background-color: #F0F3F7;border-radius: {19*self.height_scale}px;border: 1px solid #222222}}"
            f"QPushButton:hover{{color: #ffffff;background-color: #393939;border-radius: {19*self.height_scale}px;}}"
        )
        ccfont = QFont(self.font_family2, 12*self.width_scale)
        self.ccBtn.setFont(ccfont)
        self.ccBtn.clicked.connect(self.qmc.markDrop)
        # self.ccBtn.clicked.connect(self.markDropClick)

        self.lqBtn = QLabel(self.rightBottom)
        self.lqBtn.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.lqBtn.setText('冷 却')
        self.lqBtn.setGeometry(29*self.width_scale, 106*self.height_scale, 76*self.width_scale, 40*self.height_scale)
        self.lqBtn.setStyleSheet(
            f"QLabel{{color: #222222;background-color: #F0F3F7;border-radius: {19*self.height_scale}px;border: 1px solid #222222}}"
            f"QLabel:hover{{color: #ffffff;background-color: #393939;border-radius: {19*self.height_scale}px;}}"
        )
        lqfont = QFont(self.font_family2, 12*self.width_scale)
        self.lqBtn.setFont(lqfont)
        # self.lqBtn.clicked.connect(self.submitInfo)

        self.jbBtn = QLabel(self.rightBottom)
        self.jbBtn.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.jbBtn.setText('搅 拌')
        self.jbBtn.setGeometry(125*self.width_scale, 106*self.height_scale, 76*self.width_scale, 40*self.height_scale)
        self.jbBtn.setStyleSheet(
            f"QLabel{{color: #222222;background-color: #F0F3F7;border-radius: {19*self.height_scale}px;border: 1px solid #222222}}"
            f"QLabel:hover{{color: #ffffff;background-color: #393939;border-radius: {19*self.height_scale}px;}}"
        )
        jbfont = QFont(self.font_family2, 12*self.width_scale)
        self.jbBtn.setFont(jbfont)

        self.sblb = QLabel(self)
        self.sblb.setStyleSheet('background-color: #eeebe7;border-radius: 0px;')
        self.sblb.setGeometry(231*self.width_scale, 109*self.height_scale, 240*self.width_scale, 160*self.height_scale)
        self.sblb.hide()

        self.sheibeiId = "0"
        self.sblbList = QListWidget(self.sblb)
        self.sblbList.setStyleSheet("""
                    QListWidget::item {
                        height: 20px; /* 设置每项高度 */
                    }
                    QListWidget::item {
                        text-align: center; /* 文字居中 */
                    }
                """)
        # 连接点击事件到槽函数
        self.sblbList.itemClicked.connect(self.on_item_clicked)

        self.zhezhaoWidget = QWidget(self)
        self.zhezhaoWidget.setStyleSheet('background-color: rgba(0, 0, 0, 128); border: none; ')
        self.zhezhaoWidget.setGeometry(0, 0, 1920*self.width_scale, 1080*self.height_scale)
        self.zhezhaoWidget.setVisible(False)

        self.ccjlWidget = QWidget(self)
        self.ccjlWidget.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #ffffff; border: none; ')
        self.ccjlWidget.setGeometry(739*self.width_scale, 312*self.height_scale, 442*self.width_scale, 430*self.height_scale)
        self.ccjlWidget.setVisible(False)
        shadow_effect = QGraphicsDropShadowEffect(self.ccjlWidget)
        shadow_effect.setColor(QColor(0, 0, 0, 160))  # 设置阴影颜色为半透明黑色
        shadow_effect.setBlurRadius(30)  # 增大模糊半径，使阴影分布更广
        shadow_effect.setOffset(0, 0)  # 偏移量为0，使阴影在四周均匀分布
        self.ccjlWidget.setGraphicsEffect(shadow_effect)

        self.ccjlTitle = QLabel(self.ccjlWidget)
        self.ccjlTitle.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.ccjlTitle.setText('出仓记录')
        self.ccjlTitle.setGeometry(45*self.width_scale, 30*self.height_scale, 83*self.width_scale, 19*self.height_scale)
        self.ccjlTitle.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        ccjlTitlefont = QFont(self.font_family4, 16*self.width_scale)
        self.ccjlTitle.setFont(ccjlTitlefont)

        # self.hcsjTxt = QLabel(self.ccjlWidget)
        # self.hcsjTxt.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        # self.hcsjTxt.setText('缓存时间')
        # self.hcsjTxt.setGeometry(47*self.width_scale, 89*self.height_scale, 74*self.width_scale, 19*self.height_scale)
        # self.hcsjTxt.setStyleSheet(
        #     "color: #333333;background-color:transparent; border: none"
        # )
        hcsjTxtfont = QFont(self.font_family4, 12*self.width_scale)
        # self.hcsjTxt.setFont(hcsjTxtfont)

        # self.hcsjContent = QLineEdit(self.ccjlWidget)
        # self.hcsjContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        # self.hcsjContent.setStyleSheet("""
        #                                     QLineEdit {
        #                                         background-color: #EEF3F7;  /* 设置背景颜色 */
        #                                         color: #333333;             /* 设置文字颜色 */
        #                                         padding-left: 9px;         /* 设置文字左边距 */
        #                                         font-size: 12px;            /* 设置字体大小 */
        #                                         border: none;               /* 移除边框 */
        #                                         border-radius: 10px;
        #                                     }
        #                                 """)
        hcsjContentfont = QFont(self.font_family4, 14*self.width_scale)
        # self.hcsjContent.setFont(hcsjContentfont)
        # self.hcsjContent.setGeometry(48*self.width_scale, 117*self.height_scale, 132*self.width_scale, 32*self.height_scale)

        # self.hcsjTxt = QLabel(self.ccjlWidget)
        # self.hcsjTxt.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        # self.hcsjTxt.setText('分')
        # self.hcsjTxt.setGeometry(176*self.width_scale, 117*self.height_scale, 32*self.width_scale, 32*self.width_scale)
        # self.hcsjTxt.setStyleSheet(
        #     "color: #333333;background-color:transparent; border: none"
        # )
        hcsjTxtfont2 = QFont(self.font_family6, 10*self.width_scale)
        # self.hcsjTxt.setFont(hcsjTxtfont2)

        self.ccjlTxt = QLabel(self.ccjlWidget)
        self.ccjlTxt.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.ccjlTxt.setText('瑕疵率')
        self.ccjlTxt.setGeometry(47*self.width_scale, 176*self.height_scale, 74*self.width_scale, 19*self.height_scale)
        self.ccjlTxt.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        self.ccjlTxt.setFont(hcsjTxtfont)

        self.xclContent = QLineEdit(self.ccjlWidget)
        self.xclContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.xclContent.setStyleSheet(f"""
                                                    QLineEdit {{
                                                        background-color: #EEF3F7;  /* 设置背景颜色 */
                                                        color: #333333;             /* 设置文字颜色 */
                                                        padding-left: 9px;         /* 设置文字左边距 */
                                                        font-size: 12px;            /* 设置字体大小 */
                                                        border: none;               /* 移除边框 */
                                                        border-radius: {10*self.height_scale}px;
                                                    }}
                                                """)
        self.xclContent.setFont(hcsjContentfont)
        self.xclContent.setGeometry(48*self.width_scale, 204*self.height_scale, 132*self.width_scale, 32*self.height_scale)

        self.hcsjTxt = QLabel(self.ccjlWidget)
        self.hcsjTxt.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.hcsjTxt.setText('%')
        self.hcsjTxt.setGeometry(176*self.width_scale, 204*self.height_scale, 32*self.width_scale, 32*self.width_scale)
        self.hcsjTxt.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        self.hcsjTxt.setFont(hcsjTxtfont2)


        self.ccjlTxt = QLabel(self.ccjlWidget)
        self.ccjlTxt.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.ccjlTxt.setText('脱水率')
        self.ccjlTxt.setGeometry(47*self.width_scale, 89*self.height_scale, 74*self.width_scale, 19*self.height_scale)
        self.ccjlTxt.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        self.ccjlTxt.setFont(hcsjTxtfont)

        self.tslContent = QLineEdit(self.ccjlWidget)
        self.tslContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.tslContent.setStyleSheet(f"""
                                                            QLineEdit {{
                                                                background-color: #EEF3F7;  /* 设置背景颜色 */
                                                                color: #333333;             /* 设置文字颜色 */
                                                                padding-left: 9px;         /* 设置文字左边距 */
                                                                font-size: 12px;            /* 设置字体大小 */
                                                                border: none;               /* 移除边框 */
                                                                border-radius: {10*self.height_scale}px;
                                                            }}
                                                        """)
        self.tslContent.setFont(hcsjContentfont)
        self.tslContent.setGeometry(48*self.width_scale, 117*self.height_scale, 132*self.width_scale, 32*self.height_scale)

        self.hcsjTxt = QLabel(self.ccjlWidget)
        self.hcsjTxt.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.hcsjTxt.setText('%')
        self.hcsjTxt.setGeometry(176*self.width_scale, 117*self.height_scale, 32*self.width_scale, 32*self.width_scale)
        self.hcsjTxt.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        self.hcsjTxt.setFont(hcsjTxtfont2)

        self.ccjlTxt = QLabel(self.ccjlWidget)
        self.ccjlTxt.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.ccjlTxt.setText('熟豆数量')
        self.ccjlTxt.setGeometry(236*self.width_scale, 89*self.height_scale, 74*self.width_scale, 19*self.height_scale)
        self.ccjlTxt.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        self.ccjlTxt.setFont(hcsjTxtfont)

        self.slContent = QLineEdit(self.ccjlWidget)
        self.slContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.slContent.setStyleSheet(f"""
                                                                    QLineEdit {{
                                                                        background-color: #EEF3F7;  /* 设置背景颜色 */
                                                                        color: #333333;             /* 设置文字颜色 */
                                                                        padding-left: 9px;         /* 设置文字左边距 */
                                                                        font-size: 12px;            /* 设置字体大小 */
                                                                        border: none;               /* 移除边框 */
                                                                        border-radius: {10*self.height_scale}px;
                                                                    }}
                                                                """)
        self.slContent.setFont(hcsjContentfont)
        self.slContent.setGeometry(237*self.width_scale, 117*self.height_scale, 132*self.width_scale, 32*self.height_scale)

        self.hcsjTxt = QLabel(self.ccjlWidget)
        self.hcsjTxt.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.hcsjTxt.setText('kg')
        self.hcsjTxt.setGeometry(365*self.width_scale, 117*self.height_scale, 32*self.width_scale, 32*self.height_scale)
        self.hcsjTxt.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        self.hcsjTxt.setFont(hcsjTxtfont2)

        self.ccjlTxt = QLabel(self.ccjlWidget)
        self.ccjlTxt.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.ccjlTxt.setText('情况反馈')
        self.ccjlTxt.setGeometry(47*self.width_scale, 262*self.height_scale, 74*self.width_scale, 19*self.height_scale)
        self.ccjlTxt.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        self.ccjlTxt.setFont(hcsjTxtfont)

        self.qkfhContent = QTextEdit(self.ccjlWidget)
        self.qkfhContent.setAlignment(Qt.AlignmentFlag.AlignLeft)
        self.qkfhContent.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.qkfhContent.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.qkfhContent.setStyleSheet(f"""
                                                                                    QTextEdit {{
                                                                                        background-color: #EEF3F7;  /* 设置背景颜色 */
                                                                                        color: #333333;             /* 设置文字颜色 */
                                                                                        padding-left: 9px;         /* 设置文字左边距 */
                                                                                        font-size: 12px;            /* 设置字体大小 */
                                                                                        border: none;               /* 移除边框 */
                                                                                        border-radius: {10*self.height_scale}px;
                                                                                    }}
                                                                                """)
        self.qkfhContent.setFont(hcsjContentfont)
        self.qkfhContent.setGeometry(48*self.width_scale, 290*self.height_scale, 347*self.width_scale, 52*self.height_scale)

        self.ccjlBtn = QPushButton(self.ccjlWidget)
        # self.rdBtn.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.ccjlBtn.setText('确定')
        self.ccjlBtn.setGeometry(176*self.width_scale, 370*self.height_scale, 90*self.width_scale, 40*self.height_scale)
        self.ccjlBtn.setStyleSheet(
            f"QPushButton{{color: #ffffff;background-color: #393939;border-radius: {20*self.height_scale}px;border: none}}"
            f"QPushButton:hover{{color: #ffffff;background-color: #8C6348;border-radius: {20*self.height_scale}px;border: none;}}"
        )
        ccjlBtnfont = QFont(self.font_family4, 14*self.width_scale)
        self.ccjlBtn.setFont(ccjlBtnfont)
        self.ccjlBtn.clicked.connect(self.submitCCJL)


        # 流转记录页 lzTabel

        self.lzTabel = QWidget(self)
        self.lzTabel.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #ffffff; border: 1px solid #DEE0E3; ')
        self.lzTabel.setGeometry(231, 200, 1600, 796)
        self.lzTabel.setVisible(False)

        self.lzGridLayout = QGridLayout(self.lzTabel)
        self.lzGridLayout.setContentsMargins(0, 0, 35, 35)

        # 设置每个组件之间的水平和垂直间距
        self.lzGridLayout.setHorizontalSpacing(35)
        self.lzGridLayout.setVerticalSpacing(35)

        # 设置布局
        self.lzTabel.setLayout(self.lzGridLayout)

        self.lzScroll = QScrollArea(self)  # self 指向当前窗口
        self.lzScroll.setWidgetResizable(True)  # 自动调整大小以适应内容
        self.lzScroll.setGeometry(231, 200, 1600, 796)
        self.lzScroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # 隐藏横向滚动条
        self.lzScroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # 隐藏纵向滚动条
        # 将 QWidget 设置为 QScrollArea 的 widget
        self.lzScroll.setWidget(self.lzTabel)
        self.lzScroll.setVisible(False)



        self.zhezhaoWidget_addOrder = QWidget(self)
        self.zhezhaoWidget_addOrder.setStyleSheet('background-color: rgba(0, 0, 0, 128); border: none; ')
        self.zhezhaoWidget_addOrder.setGeometry(0, 0, 1920 * self.width_scale, 1080 * self.height_scale)
        self.zhezhaoWidget_addOrder.setVisible(False)

        self.addOrderWidget = QWidget(self)
        self.addOrderWidget.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #ffffff; border: none; ')
        self.addOrderWidget.setGeometry(739 * self.width_scale, 312 * self.height_scale, 442 * self.width_scale,
                                        430 * self.height_scale)
        self.addOrderWidget.setVisible(False)
        shadow_effect_order = QGraphicsDropShadowEffect(self.addOrderWidget)
        shadow_effect_order.setColor(QColor(0, 0, 0, 160))  # 设置阴影颜色为半透明黑色
        shadow_effect_order.setBlurRadius(30)  # 增大模糊半径，使阴影分布更广
        shadow_effect_order.setOffset(0, 0)  # 偏移量为0，使阴影在四周均匀分布
        self.addOrderWidget.setGraphicsEffect(shadow_effect_order)

        self.addOrderTitle = QLabel(self.addOrderWidget)
        self.addOrderTitle.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.addOrderTitle.setText('添加订单')
        self.addOrderTitle.setGeometry(45 * self.width_scale, 30 * self.height_scale, 85 * self.width_scale,
                                       22 * self.height_scale)
        self.addOrderTitle.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        addOrderTitlefont = QFont(self.font_family4, 16 * self.width_scale)
        self.addOrderTitle.setFont(addOrderTitlefont)

        addTaskfont = QFont(self.font_family4, 12 * self.width_scale)
        addTaskContentfont = QFont(self.font_family4, 12 * self.width_scale)

        self.taskNameTxt = QLabel(self.addOrderWidget)
        self.taskNameTxt.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.taskNameTxt.setText('任务名称')
        self.taskNameTxt.setGeometry(47 * self.width_scale, 79 * self.height_scale, 64 * self.width_scale,
                                     32 * self.height_scale)
        self.taskNameTxt.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        self.taskNameTxt.setFont(addTaskfont)

        self.taskNameContent = QLineEdit(self.addOrderWidget)
        self.taskNameContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.taskNameContent.setStyleSheet(f"""
                                                            QLineEdit {{
                                                                background-color: #EEF3F7;  /* 设置背景颜色 */
                                                                color: #333333;             /* 设置文字颜色 */
                                                                padding-left: 9px;         /* 设置文字左边距 */
                                                                border: none;               /* 移除边框 */
                                                                border-radius: {5*self.height_scale}px;
                                                            }}
                                                        """)
        self.taskNameContent.setFont(addTaskContentfont)
        # self.taskNameContent.setText()
        self.taskNameContent.setGeometry(133 * self.width_scale, 79 * self.height_scale, 232 * self.width_scale,
                                         32 * self.height_scale)
        # self.taskNameContent.setReadOnly(True)

        self.numberTxt = QLabel(self.addOrderWidget)
        self.numberTxt.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.numberTxt.setText('生豆重量')
        self.numberTxt.setGeometry(47 * self.width_scale, 133 * self.height_scale, 64 * self.width_scale,
                                   32 * self.height_scale)
        self.numberTxt.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        self.numberTxt.setFont(addTaskfont)

        self.numberContent = QLineEdit(self.addOrderWidget)
        self.numberContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.numberContent.setStyleSheet(f"""
                                                                            QLineEdit {{
                                                                                background-color: #EEF3F7;  /* 设置背景颜色 */
                                                                                color: #333333;             /* 设置文字颜色 */
                                                                                padding-left: 9px;         /* 设置文字左边距 */
                                                                                border: none;               /* 移除边框 */
                                                                                border-radius: {5*self.height_scale}px;
                                                                            }}
                                                                        """)
        self.numberContent.setFont(addTaskContentfont)
        self.numberContent.setGeometry(133 * self.width_scale, 133 * self.height_scale, 232 * self.width_scale,
                                       32 * self.height_scale)

        self.nobTxt = QLabel(self.addOrderWidget)
        self.nobTxt.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.nobTxt.setText('含水量')
        self.nobTxt.setGeometry(47 * self.width_scale, 187 * self.height_scale, 64 * self.width_scale,
                                32 * self.height_scale)
        self.nobTxt.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        self.nobTxt.setFont(addTaskfont)

        self.nobContent = QLineEdit(self.addOrderWidget)
        self.nobContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.nobContent.setStyleSheet(f"""
                                                                    QLineEdit {{
                                                                        background-color: #EEF3F7;  /* 设置背景颜色 */
                                                                        color: #333333;             /* 设置文字颜色 */
                                                                        padding-left: 9px;         /* 设置文字左边距 */
                                                                        border: none;               /* 移除边框 */
                                                                        border-radius: {5*self.height_scale}px;
                                                                    }}
                                                                """)
        self.nobContent.setFont(addTaskContentfont)
        self.nobContent.setGeometry(133 * self.width_scale, 187 * self.height_scale, 232 * self.width_scale,
                                    32 * self.height_scale)

        self.nobTxt = QLabel(self.addOrderWidget)
        self.nobTxt.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.nobTxt.setText('kg')
        self.nobTxt.setGeometry(375 * self.width_scale, 187 * self.height_scale, 64 * self.width_scale,
                                32 * self.height_scale)
        self.nobTxt.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        self.nobTxt.setFont(addTaskfont)

        self.finishTxt = QLabel(self.addOrderWidget)
        self.finishTxt.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.finishTxt.setText('截止时间')
        self.finishTxt.setGeometry(47 * self.width_scale, 241 * self.height_scale, 64 * self.width_scale,
                                   32 * self.height_scale)
        self.finishTxt.setStyleSheet(
            "color: #333333;background-color:transparent; border: none"
        )
        self.finishTxt.setFont(addTaskfont)

        self.finishContent = QDateTimeEdit(self.addOrderWidget)
        self.finishContent.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.finishContent.setStyleSheet(f"""
            QDateTimeEdit {{
                background-color: #EEF3F7;  /* 设置背景颜色 */
                color: #333333;             /* 设置文字颜色 */
                padding-left: 9px;         /* 设置文字左边距 */
                border: none;               /* 移除边框 */
                border-radius: {5*self.height_scale}px;
            }}
        """)
        self.finishContent.setFont(addTaskContentfont)
        self.finishContent.setGeometry(133 * self.width_scale, 241 * self.height_scale, 232 * self.width_scale,
                                       32 * self.height_scale)
        self.finishContent.setCalendarPopup(True)  # 启用日历弹出窗口

        # 设置默认日期时间为当前日期并将时间部分设置为 23:59
        current_date_add = QDateTime.currentDateTime()
        default_time_add = current_date_add.toString("yyyy-MM-dd") + " 23:59"  # 拼接默认时间
        self.finishContent.setDateTime(QDateTime.fromString(default_time_add, "yyyy-MM-dd HH:mm"))

        # 设置显示格式，确保下拉框中年份、月份、日期、时间可见
        self.finishContent.setDisplayFormat("yyyy-MM-dd HH:mm")

        # 创建下拉列表（QComboBox）
        self.stage_combo_box = QComboBox(self.addOrderWidget)

        # 设置样式，解决文本颜色问题
        self.stage_combo_box.setStyleSheet("""
                   QComboBox {
                       background-color: white;
                       color: black;
                       padding: 5px;
                       border-radius: 5px;
                   }
                   QComboBox:hover {
                       border: 1px solid #8f8f8f;
                   }
                   QComboBox QAbstractItemView {
                       background-color: white;
                       selection-background-color: #2A85FF;
                       selection-color: white;
                       color: black;
                   }
                   QComboBox QAbstractItemView:hover {
                       background-color: #dcdcdc;
                   }
               """)

        # 添加选项到下拉列表
        self.stage_combo_box.addItem("stage1")
        self.stage_combo_box.addItem("stage2")
        self.stage_combo_box.addItem("stage3")
        self.stage_combo_box.addItem("stage4")
        self.stage_combo_box.addItem("stage5")
        self.stage_combo_box.addItem("stage6")

        self.stage_combo_box.setGeometry(27 * self.width_scale, 295 * self.height_scale, 84 * self.width_scale,
                                   32 * self.height_scale)
        self.stage_data = {
            "stage1": [0, 0, 0, 0],
            "stage2": [0, 0, 0, 0],
            "stage3": [0, 0, 0, 0],
            "stage4": [0, 0, 0, 0],
            "stage5": [0, 0, 0, 0],
            "stage6": [0, 0, 0, 0]
        }

        self.current_stage = "stage1"

        self.stage_combo_box.currentTextChanged.connect(self.on_stage_combobox_changed)

        self.stage_one_bContent = QLineEdit(self.addOrderWidget)
        self.stage_one_bContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.stage_one_bContent.setStyleSheet(f"""
                                                                            QLineEdit {{
                                                                                background-color: #EEF3F7;  /* 设置背景颜色 */
                                                                                color: #333333;             /* 设置文字颜色 */   /* 设置文字左边距 */
                                                                                border: none;               /* 移除边框 */
                                                                                border-radius: {5 * self.height_scale}px;
                                                                            }}
                                                                        """)
        self.stage_one_bContent.setFont(addTaskContentfont)
        self.stage_one_bContent.setGeometry(133 * self.width_scale, 295 * self.height_scale, 50 * self.width_scale,
                                    32 * self.height_scale)

        self.stage_two_bContent = QLineEdit(self.addOrderWidget)
        self.stage_two_bContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.stage_two_bContent.setStyleSheet(f"""
                                                                                    QLineEdit {{
                                                                                        background-color: #EEF3F7;  /* 设置背景颜色 */
                                                                                        color: #333333;             /* 设置文字颜色 */
                                                                                        border: none;               /* 移除边框 */
                                                                                        border-radius: {5 * self.height_scale}px;
                                                                                    }}
                                                                                """)
        self.stage_two_bContent.setFont(addTaskContentfont)
        self.stage_two_bContent.setGeometry(193 * self.width_scale, 295 * self.height_scale, 50 * self.width_scale,
                                            32 * self.height_scale)

        self.stage_three_bContent = QLineEdit(self.addOrderWidget)
        self.stage_three_bContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.stage_three_bContent.setStyleSheet(f"""
                                                                                            QLineEdit {{
                                                                                                background-color: #EEF3F7;  /* 设置背景颜色 */
                                                                                                color: #333333;             /* 设置文字颜色 */
                                                                                                border: none;               /* 移除边框 */
                                                                                                border-radius: {5 * self.height_scale}px;
                                                                                            }}
                                                                                        """)
        self.stage_three_bContent.setFont(addTaskContentfont)
        self.stage_three_bContent.setGeometry(253 * self.width_scale, 295 * self.height_scale, 50 * self.width_scale,
                                            32 * self.height_scale)

        self.stage_four_bContent = QLineEdit(self.addOrderWidget)
        self.stage_four_bContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.stage_four_bContent.setStyleSheet(f"""
                                                                                                    QLineEdit {{
                                                                                                        background-color: #EEF3F7;  /* 设置背景颜色 */
                                                                                                        color: #333333;             /* 设置文字颜色 */
                                                                                                        border: none;               /* 移除边框 */
                                                                                                        border-radius: {5 * self.height_scale}px;
                                                                                                    }}
                                                                                                """)
        self.stage_four_bContent.setFont(addTaskContentfont)
        self.stage_four_bContent.setGeometry(313 * self.width_scale, 295 * self.height_scale, 50 * self.width_scale,
                                              32 * self.height_scale)


        self.addOrderBtn = QPushButton(self.addOrderWidget)
        self.addOrderBtn.setText('确定')
        self.addOrderBtn.setGeometry(173 * self.width_scale, 380 * self.height_scale, 100 * self.width_scale,
                                     40 * self.height_scale)
        self.addOrderBtn.setStyleSheet(
            f"QPushButton{{color: #ffffff;background-color: #393939;border-radius: {20*self.height_scale}px;border: none;}}"
        )
        self.addOrderBtn.setFont(addTaskContentfont)
        self.addOrderBtn.clicked.connect(self.addOrder_Json)

        self.jiankongTabel = QWidget(self)
        self.jiankongTabel.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #ffffff; border: none; ')
        self.jiankongTabel.setGeometry(226 * self.width_scale, 197 * self.height_scale, 1610 * self.width_scale,
                                       800 * self.height_scale)
        self.jiankongTabel.setVisible(False)







        # 设备管理页 deviceTabel
        self.deviceTabel = QWidget(self)
        self.deviceTabel.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: transparent; border: none; ')
        self.deviceTabel.setGeometry(231*self.width_scale, 200*self.height_scale, 1600*self.width_scale, 796*self.height_scale)
        self.deviceTabel.setVisible(False)

        self.deviceGridLayout = QGridLayout(self.deviceTabel)
        self.deviceGridLayout.setContentsMargins(0, 0, 35*self.width_scale, 35*self.width_scale)

        # 设置每个组件之间的水平和垂直间距
        self.deviceGridLayout.setHorizontalSpacing(35*self.width_scale)
        self.deviceGridLayout.setVerticalSpacing(35*self.width_scale)

        # 设置布局
        self.deviceTabel.setLayout(self.deviceGridLayout)

        self.deviceScroll = QScrollArea(self)
        self.deviceScroll.setWidgetResizable(True)
        self.deviceScroll.setGeometry(231*self.width_scale, 200*self.height_scale, 1600*self.width_scale, 796*self.height_scale)
        self.deviceScroll.setStyleSheet('border: none;background-color: #ffffff; ')
        self.deviceScroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # 隐藏横向滚动条
        self.deviceScroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # 隐藏纵向滚动条
        # 将 QWidget 设置为 QScrollArea 的 widget
        self.deviceScroll.setWidget(self.deviceTabel)
        self.deviceScroll.setVisible(False)

        # 设备详情页
        self.deviceDetail = QWidget(self)
        self.deviceDetail.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #DEEEFE; border: 1px solid #DEE0E3; ')
        self.deviceDetail.setGeometry(231 * self.width_scale, 200 * self.height_scale, 1600 * self.width_scale,
                                      796 * self.height_scale)
        self.deviceDetail.setVisible(False)

        self.deviceDetailTouxiang = QLabel(self.deviceDetail)
        self.deviceDetailTouxiang.setStyleSheet(
            f'border-radius: {25*self.height_scale}px;background-color: #DEEEFE; border: 1px solid #DEE0E3; ')
        self.deviceDetailTouxiang.setGeometry(753 * self.width_scale, 107 * self.height_scale, 90 * self.width_scale,
                                              90 * self.height_scale)

        # 监听双击事件
        self.deviceDetailTouxiang.mouseDoubleClickEvent = self.openFileDialog

        self.deviceName = QLabel(self.deviceDetail)
        self.deviceName.setAlignment(Qt.AlignmentFlag.AlignLeft)
        self.deviceName.setGeometry(409 * self.width_scale, 263 * self.height_scale, 100 * self.width_scale,
                                    32 * self.height_scale)
        self.deviceName.setStyleSheet(
            f"QLabel{{background-color: transparent; border-radius: {16*self.height_scale}px; border: none;}}"
        )
        self.deviceName.setText("名称：")
        deviceNameFont = QFont(self.font_family4, 14 * self.width_scale)
        self.deviceName.setFont(deviceNameFont)

        self.deviceNameLineEdit = QLineEdit(self.deviceDetail)
        self.deviceNameLineEdit.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        # self.deviceNameEdit.setText('185°')
        self.deviceNameLineEdit.setStyleSheet(f"""
                                            QLineEdit {{
                                                background-color: #FFFFFF;  /* 设置背景颜色 */
                                                color: #393939;             /* 设置文字颜色 */
                                                padding-left: 21px;         /* 设置文字左边距 */
                                                border: 1px solid #DEE0E3;               /* 移除边框 */
                                                border-radius: {12*self.height_scale}px;
                                            }}
                                        """)
        deviceNameEditfont = QFont(self.font_family4, 14 * self.width_scale)
        self.deviceNameLineEdit.setFont(deviceNameEditfont)
        self.deviceNameLineEdit.setGeometry(407 * self.width_scale, 301 * self.height_scale, 374 * self.width_scale,
                                            60 * self.height_scale)  # 设置控件的固定大小为56x24px

        self.deviceNameEdit = QComboBox(self.deviceDetail)
        # self.deviceNameEdit.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.deviceNameEdit.setStyleSheet(f"""
                            QComboBox {{
                                background-color: #FFFFFF;
                                color: #393939;
                                border: 1px solid #DEE0E3;
                                border-radius: {12*self.height_scale}px;
                                padding-left: {24*self.height_scale}px;
                            }}
                            QComboBox::drop-down {{  /* 隐藏默认下拉按钮 */
                                border: 0px;
                            }}
                            QComboBox::down-arrow {{ /* 替换为自定义小三角 */
                                image: url('{self.normalized_path}/includes/Icons/general/xiala.png'); /* 替换为你的小三角图片路径 */
                                width: {12*self.height_scale}px;
                                height: {12*self.height_scale}px;
                                margin-right: {12*self.height_scale}px; /* 调整三角形与边界的间距 */
                            }}
                        """)

        # 设置字体
        deviceNameEditfont = QFont(self.font_family4, 14 * self.width_scale)
        self.deviceNameEdit.setFont(deviceNameEditfont)
        self.deviceNameEdit.setGeometry(407 * self.width_scale, 301 * self.height_scale, 374 * self.width_scale,
                                        60 * self.height_scale)  # 设置控件的固定大小为56x24px
        self.load_files("Machines")

        self.deviceModel = QLabel(self.deviceDetail)
        self.deviceModel.setAlignment(Qt.AlignmentFlag.AlignLeft)
        self.deviceModel.setGeometry(820 * self.width_scale, 264 * self.height_scale, 100 * self.width_scale,
                                     32 * self.height_scale)
        self.deviceModel.setStyleSheet(
            f"QLabel{{background-color: transparent; border-radius: {16*self.height_scale}px; border: none;}}"
        )
        self.deviceModel.setText("机型：")
        self.deviceModel.setFont(deviceNameFont)

        self.deviceModelEdit = QComboBox(self.deviceDetail)
        self.deviceModelEdit.setStyleSheet(f"""
                            QComboBox {{
                                background-color: #FFFFFF;
                                color: #393939;
                                border: 1px solid #DEE0E3;
                                border-radius: {12*self.height_scale}px;
                                padding-left: {24*self.height_scale}px;
                            }}
                            QComboBox::drop-down {{  /* 隐藏默认下拉按钮 */
                                border: 0px;
                            }}
                            QComboBox::down-arrow {{ /* 替换为自定义小三角 */
                                image: url('{self.normalized_path}/includes/Icons/general/xiala.png'); /* 替换为你的小三角图片路径 */
                                width: {12*self.height_scale}px;
                                height: {12*self.height_scale}px;
                                margin-right: {12*self.height_scale}px; /* 调整三角形与边界的间距 */
                            }}
                        """)
        self.deviceModelEdit.setFont(QFont(self.font_family4, 14 * self.width_scale))
        self.deviceModelEdit.setGeometry(820 * self.width_scale, 301 * self.height_scale, 374 * self.width_scale,
                                         60 * self.height_scale)

        self.deviceModelLineEdit = QLineEdit(self.deviceDetail)
        self.deviceModelLineEdit.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        # self.deviceNameEdit.setText('185°')
        self.deviceModelLineEdit.setStyleSheet(f"""
                                                            QLineEdit {{
                                                                background-color: #FFFFFF;  /* 设置背景颜色 */
                                                                color: #393939;             /* 设置文字颜色 */
                                                                padding-left: 21px;         /* 设置文字左边距 */
                                                                border: 1px solid #DEE0E3;               /* 移除边框 */
                                                                border-radius: {12*self.height_scale}px;
                                                            }}
                                                        """)
        self.deviceModelLineEdit.setFont(deviceNameEditfont)
        self.deviceModelLineEdit.setGeometry(820 * self.width_scale, 301 * self.height_scale, 374 * self.width_scale,
                                             60 * self.height_scale)  # 设置控件的固定大小为56x24px

        self.deviceNameEdit.currentTextChanged.connect(self.load_files_from_folder)
        self.deviceModelEdit.currentTextChanged.connect(self.load_modbus_host)

        self.deviceXLH = QLabel(self.deviceDetail)
        self.deviceXLH.setAlignment(Qt.AlignmentFlag.AlignLeft)
        self.deviceXLH.setGeometry(409 * self.width_scale, 389 * self.height_scale, 150 * self.width_scale,
                                   32 * self.height_scale)
        self.deviceXLH.setStyleSheet(
            f"QLabel{{background-color: transparent; border-radius: {16*self.height_scale}px; border: none;}}"
        )
        self.deviceXLH.setText("设备序列号：")
        self.deviceXLH.setFont(deviceNameFont)

        self.deviceXLHEdit = QLineEdit(self.deviceDetail)
        self.deviceXLHEdit.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        # self.deviceNameEdit.setText('185°')
        self.deviceXLHEdit.setStyleSheet(f"""
                                                            QLineEdit {{
                                                                background-color: #FFFFFF;  /* 设置背景颜色 */
                                                                color: #393939;             /* 设置文字颜色 */
                                                                padding-left: 21px;         /* 设置文字左边距 */
                                                                border: 1px solid #DEE0E3;               /* 移除边框 */
                                                                border-radius: {12*self.height_scale}px;
                                                            }}
                                                        """)
        self.deviceXLHEdit.setFont(deviceNameEditfont)
        self.deviceXLHEdit.setGeometry(409 * self.width_scale, 429 * self.height_scale, 374 * self.width_scale,
                                       60 * self.height_scale)  # 设置控件的固定大小为56x24px

        self.deviceAddress = QLabel(self.deviceDetail)
        self.deviceAddress.setAlignment(Qt.AlignmentFlag.AlignLeft)
        self.deviceAddress.setGeometry(820 * self.width_scale, 389 * self.height_scale, 150 * self.width_scale,
                                       32 * self.height_scale)
        self.deviceAddress.setStyleSheet(
            f"QLabel{{background-color: transparent; border-radius: {16*self.height_scale}px; border: none;}}"
        )
        self.deviceAddress.setText("设备IP：")
        self.deviceAddress.setFont(deviceNameFont)

        self.deviceAddressEdit = QLineEdit(self.deviceDetail)
        self.deviceAddressEdit.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        # self.deviceNameEdit.setText('185°')
        self.deviceAddressEdit.setStyleSheet(f"""
                                                                    QLineEdit {{
                                                                        background-color: #FFFFFF;  /* 设置背景颜色 */
                                                                        color: #393939;             /* 设置文字颜色 */
                                                                        padding-left: {21*self.height_scale}px;         /* 设置文字左边距 */
                                                                        border: 1px solid #DEE0E3;               /* 移除边框 */
                                                                        border-radius: {12*self.height_scale}px;
                                                                    }}
                                                                """)
        self.deviceAddressEdit.setFont(deviceNameEditfont)
        self.deviceAddressEdit.setGeometry(820 * self.width_scale, 429 * self.height_scale, 374 * self.width_scale,
                                           60 * self.height_scale)  # 设置控件的固定大小为56x24px

        self.devicejrfs = QLabel(self.deviceDetail)
        self.devicejrfs.setAlignment(Qt.AlignmentFlag.AlignLeft)
        self.devicejrfs.setGeometry(409 * self.width_scale, 515 * self.height_scale, 150 * self.width_scale,
                                    32 * self.height_scale)
        self.devicejrfs.setStyleSheet(
            f"QLabel{{background-color: transparent; border-radius: {16*self.height_scale}px; border: none;}}"
        )
        self.devicejrfs.setText("加热方式：")
        self.devicejrfs.setFont(deviceNameFont)

        # self.deviceHeating = QLineEdit(self.deviceDetail)

        self.deviceHeating = QComboBox(self.deviceDetail)
        self.deviceHeating.setStyleSheet(f"""
                            QComboBox {{
                                background-color: #FFFFFF;
                                color: #393939;
                                border: 1px solid #DEE0E3;
                                border-radius: {12*self.height_scale}px;
                                padding-left: {24*self.height_scale}px;
                            }}
                            QComboBox::drop-down {{  /* 隐藏默认下拉按钮 */
                                border: 0px;
                            }}
                            QComboBox::down-arrow {{ /* 替换为自定义小三角 */
                                image: url('{self.normalized_path}/includes/Icons/general/xiala.png'); /* 替换为你的小三角图片路径 */
                                width: {12*self.height_scale}px;
                                height: {12*self.height_scale}px;
                                margin-right: {12*self.height_scale}px; /* 调整三角形与边界的间距 */
                            }}
                        """)
        self.deviceHeating.setFont(QFont(self.font_family4, 14 * self.width_scale))
        self.deviceHeating.setGeometry(409 * self.width_scale, 557 * self.height_scale, 374 * self.width_scale,
                                       60 * self.height_scale)
        self.deviceHeating.addItems(self.qmc.heating_types)

        self.deviceDZ = QLabel(self.deviceDetail)
        self.deviceDZ.setAlignment(Qt.AlignmentFlag.AlignLeft)
        self.deviceDZ.setGeometry(820 * self.width_scale, 515 * self.height_scale, 150 * self.width_scale,
                                   32 * self.height_scale)
        self.deviceDZ.setStyleSheet(
            f"QLabel{{background-color: transparent; border-radius: {16 * self.height_scale}px; border: none;}}"
        )
        self.deviceDZ.setText("设备地址：")
        self.deviceDZ.setFont(deviceNameFont)

        self.deviceDZEdit = QLineEdit(self.deviceDetail)
        self.deviceDZEdit.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        # self.deviceNameEdit.setText('185°')
        self.deviceDZEdit.setStyleSheet(f"""
                                                                    QLineEdit {{
                                                                        background-color: #FFFFFF;  /* 设置背景颜色 */
                                                                        color: #393939;             /* 设置文字颜色 */
                                                                        padding-left: 21px;         /* 设置文字左边距 */
                                                                        border: 1px solid #DEE0E3;               /* 移除边框 */
                                                                        border-radius: {12 * self.height_scale}px;
                                                                    }}
                                                                """)
        self.deviceDZEdit.setFont(deviceNameEditfont)
        self.deviceDZEdit.setGeometry(820 * self.width_scale, 557 * self.height_scale, 374 * self.width_scale,
                                       60 * self.height_scale)  # 设置控件的固定大小为56x24px

        self.deviceBtn = QPushButton(self.deviceDetail)
        self.deviceBtn.setText('确定')
        self.deviceBtn.setGeometry(672 * self.width_scale, 703 * self.height_scale, 120 * self.width_scale,
                                   50 * self.height_scale)
        self.deviceBtn.setStyleSheet(
            f"QPushButton{{color: #ffffff;background-color: #393939;border-radius: {24*self.height_scale}px;border: none;}}"
            f"QPushButton:hover{{color: #ffffff;background-color: #222222;border-radius: {24*self.height_scale}px;border: none;}}"
        )
        deviceBtnfont = QFont(self.font_family4, 12 * self.width_scale)
        self.deviceBtn.setFont(deviceBtnfont)
        self.deviceBtn.clicked.connect(self.onConfirmClick)

        self.d_deviceBtn = QPushButton(self.deviceDetail)
        self.d_deviceBtn.setText('删除')
        self.d_deviceBtn.setGeometry(802 * self.width_scale, 703 * self.height_scale, 120 * self.width_scale,
                                     50 * self.height_scale)
        self.d_deviceBtn.setStyleSheet(
            f"QPushButton{{color: #ffffff;background-color: #393939;border-radius: {24*self.height_scale}px;border: none;}}"
            f"QPushButton:hover{{color: #ffffff;background-color: #DD5D5B;border-radius: {24*self.height_scale}px;border: none;}}"
        )
        self.d_deviceBtn.setFont(deviceBtnfont)
        # self.d_deviceBtn.clicked.connect(self.onDelectMachinesClick)

        self.fh_deviceBtn = QPushButton(self.deviceDetail)
        self.fh_deviceBtn.setText('<')
        self.fh_deviceBtn.setGeometry(35 * self.width_scale, 24 * self.height_scale, 60 * self.width_scale,
                                      60 * self.height_scale)
        self.fh_deviceBtn.setStyleSheet(
            f"QPushButton{{color: #A6AFB8;background-color: transparent;border-radius: {25*self.height_scale}px;border: none;}}"
        )
        fh_deviceBtnfont = QFont(self.font_family4, 24 * self.width_scale)
        fh_deviceBtnfont.setBold(True)
        self.fh_deviceBtn.setFont(fh_deviceBtnfont)
        self.fh_deviceBtn.clicked.connect(self.fhMachinesClick)






        # 历史记录
        self.historyTabel = QWidget(self)
        self.historyTabel.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #ffffff; border: 1px solid #DEE0E3; ')
        self.historyTabel.setGeometry(226*self.width_scale, 196*self.height_scale, 1610*self.width_scale, 800*self.height_scale)
        self.historyTabel.setVisible(False)

        self.todayBtn = QPushButton(self.historyTabel)
        self.todayBtn.setText('今天')
        self.todayBtn.setGeometry(20*self.width_scale, 18*self.height_scale, 56*self.width_scale, 33*self.height_scale)
        self.todayBtn.setStyleSheet(
            f"QPushButton{{color: #090101;background-color: #DEE0E3;border-radius: {12*self.height_scale}px;border: none;}}"
        )
        todayBtnfont = QFont(self.font_family4, 10*self.width_scale)
        self.todayBtn.setFont(todayBtnfont)
        self.todayBtn.clicked.connect(self.todayClick)

        self.fxBtn = QPushButton(self.historyTabel)
        self.fxBtn.setText('分析')
        self.fxBtn.setGeometry(1523*self.width_scale, 18*self.height_scale, 56*self.width_scale, 33*self.height_scale)
        self.fxBtn.setStyleSheet(
            f"QPushButton{{color: #ffffff;background-color: #393939;border-radius: {12*self.height_scale}px;border: none;}}"
        )
        # todayBtnfont = QFont(self.font_family4, 10)
        self.fxBtn.setFont(todayBtnfont)
        self.fxBtn.clicked.connect(self.analyseClick)

        self.orderID = []
        self.orderDetail = []

        # 创建 QDateEdit 日期选择器
        self.date_edit = QDateEdit(self.historyTabel)
        self.date_edit.setGeometry(162*self.width_scale, 25*self.height_scale, 173*self.width_scale, 17*self.height_scale)
        self.date_edit.setStyleSheet(f"""
            QDateEdit {{
                border: none;  /* 去掉边框 */
                color: #378AF6;
            }}

            QDateEdit::drop-down {{
                border: none;
            }}

            QDateEdit::down-arrow {{
                image: url('{self.normalized_path}/includes/Icons/general/xiala.png');  /* 使用你自己的下拉箭头图标路径 */
                width: 10px;
                height: 10px;
            }}
        """)

        # 设置初始日期为今天
        current_date = QDate.currentDate()
        self.date_edit.setDate(current_date)
        date_editfont = QFont(self.font_family3, 12*self.width_scale)
        self.date_edit.setFont(date_editfont)

        self.midnight = QDateTime(current_date, QTime(0, 0))

        self.end_of_day = QDateTime(current_date, QTime(23, 59))

        # 允许弹出日历控件
        self.date_edit.setCalendarPopup(True)

        # 设置日历弹出窗口的大小
        calendar_widget = self.date_edit.calendarWidget()
        calendar_widget.setFixedSize(280*self.width_scale, 320*self.height_scale)

        calendar_widget.setStyleSheet(f"""
                    QCalendarWidget QToolButton {{
                        background-color: #ffffff;        /* 月份和年份导航按钮的背景色 */
                        color: #090101;                     /* 按钮文字颜色 */
                        border: none;
                        width: {80*self.height_scale}px;                      /* 按钮宽度 */
                        height: {25*self.height_scale}px;                     /* 按钮高度 */
                    }}
                    QCalendarWidget QToolButton:hover {{
                        background-color: #285a9e;        /* 悬停时的背景色 */
                        color: #090101;    
                    }}
                    QCalendarWidget QToolButton#qt_calendar_prevmonth, 
                    QCalendarWidget QToolButton#qt_calendar_nextmonth {{
                        width: {24*self.height_scale}px;                      /* 上下月按钮的宽度 */
                        background-color: #ffffff;        /* 上下月按钮的背景色 */
                        color: #378AF6;                   /* 上下月按钮的文字颜色 */
                        border-radius: {12*self.height_scale}px;              /* 圆形按钮 */
                    }}
                    QCalendarWidget QToolButton::menu-indicator {{ 
                        subcontrol-origin: padding; 
                        subcontrol-position: bottom right; /* 菜单指示器的位置 */
                        width: 0px;  /* 隐藏下拉指示器 */
                    }}
                    QCalendarWidget QSpinBox {{ 
                        margin: {2*self.height_scale}px; 
                        border: 1px solid #378AF6; 
                        border-radius: {5*self.height_scale}px;
                    }}
                    QCalendarWidget QSpinBox::up-button {{ 
                        subcontrol-origin: border; 
                        subcontrol-position: top right; 
                        width: {15*self.height_scale}px; 
                    }}
                    QCalendarWidget QSpinBox::down-button {{ 
                        subcontrol-origin: border; 
                        subcontrol-position: bottom right; 
                        width: {15*self.height_scale}px; 
                    }}
                    QCalendarWidget QTableView {{
                        background-color: #ffffff;       /* 日历背景色 */
                        border: none;
                        gridline-color: transparent;        /* 网格线颜色 */
                        selection-background-color: #378AF6;  /* 选中的背景色 */
                        selection-color: #090101;          /* 选中的文字颜色 */
                        border-radius: 100%;
                    }}
                    QCalendarWidget QHeaderView::section {{
                        background-color: #ffffff;       /* 周几的背景色 */
                        color: #707070;                  /* 周几的文字颜色 */
                    }}
                    QCalendarWidget QTableView::item {{
                        color: #707070;                    /* 日期的文字颜色 */
                        height: {40*self.height_scale}px;                    /* 每个日期的高度 */
                    }}
                    QCalendarWidget QWidget#qt_calendar_navigationbar {{
                        background-color: #ffffff;       /* 顶部导航栏背景色 */
                    }}
                """)

        # 设置日期格式
        self.date_edit.setDisplayFormat("yyyy-MM-dd")

        # 连接信号槽，当日期变化时调用函数
        self.date_edit.dateChanged.connect(self.update_display_with_weekday)
        # 初始化时手动更新文本框内容以显示星期几
        self.update_display_with_weekday(current_date)

        # 布局
        layout = QVBoxLayout()
        layout.addWidget(self.date_edit)
        self.setLayout(layout)

        # 连接日期变化信号
        self.date_edit.dateChanged.connect(self.date_changed)

        # 创建 QLabel 作为背景
        self.searchBack = QLabel(self.historyTabel)
        self.searchBack.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.searchBack.setGeometry(1284*self.width_scale, 16*self.height_scale, 220*self.width_scale, 32*self.height_scale)
        self.searchBack.setStyleSheet(
            f"background-color: #393939; border-radius: {15*self.height_scale}px; border: none;"
        )

        self.comBoxLabel = QPushButton(self.searchBack)
        self.comBoxLabel.setGeometry(4*self.width_scale, 3*self.height_scale, 87*self.width_scale, 26*self.height_scale)
        self.comBoxLabel.setText('任务名称')
        self.comBoxLabel.setStyleSheet(
            f"QPushButton{{background-color: #393939; border-radius: {12*self.height_scale}px; border: 1px solid #FAFBFD;color: #FCFCFC}}"
        )

        self.comBoxLabel.clicked.connect(self.comBoxLabelClick)



        self.tabelTitle = QLabel(self.historyTabel)
        # self.tabelTitle.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.tabelTitle.setGeometry(2*self.width_scale, 72*self.height_scale, 1607*self.width_scale, 54*self.height_scale)
        self.tabelTitle.setStyleSheet(
            "background-color: #FAFBFD;border: none;border-radius: 0px;"
        )

        self.tabelTitleLine1 = QLabel(self.historyTabel)
        self.tabelTitleLine1.setGeometry(0, 71*self.height_scale, 1607*self.width_scale, 1*self.height_scale)
        self.tabelTitleLine1.setStyleSheet(
            "background-color: #DEE0E3;border: none;"
        )
        self.tabelTitleLine2 = QLabel(self.historyTabel)
        self.tabelTitleLine2.setGeometry(0, 124*self.height_scale, 1607*self.width_scale, 1*self.height_scale)
        self.tabelTitleLine2.setStyleSheet(
            "background-color: #DEE0E3;border: none;"
        )

        self.selectList = QLabel(self.historyTabel)
        self.selectList.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.selectList.setGeometry(1286*self.width_scale, 50*self.height_scale, 91*self.width_scale, 113*self.height_scale)  # #FDFDFD
        self.selectList.setStyleSheet(
            f"QLabel{{background-color: #FDFDFD; border-radius: {13*self.height_scale}px; border: 1px solid #FDFDFD;}}"
        )
        self.selectList.raise_()
        self.selectList.setVisible(False)

        self.selectItem1 = QPushButton(self.selectList)
        self.selectItem1.setGeometry(2*self.width_scale, 2*self.height_scale, 87*self.width_scale, 26*self.height_scale)
        self.selectItem1.setText('任务名称')
        self.selectItem1.setStyleSheet(
            f"QPushButton{{background-color: #FDFDFD; border-radius: {13*self.height_scale}px; border: none;color: #393939}}"
            f"QPushButton:hover{{background-color: #393939; border-radius: {13*self.height_scale}px; border: none;color: #FDFDFD}}"
        )
        self.selectItem1.clicked.connect(self.selectItem1Changed)

        self.selectItem2 = QPushButton(self.selectList)
        self.selectItem2.setGeometry(2*self.width_scale, 28*self.height_scale, 87*self.width_scale, 26*self.height_scale)
        self.selectItem2.setText('任务时长')
        self.selectItem2.setStyleSheet(
            f"QPushButton{{background-color: #FDFDFD; border-radius: {13*self.height_scale}px; border: none;color: #393939}}"
            f"QPushButton:hover{{background-color: #393939; border-radius: {13*self.height_scale}px; border: none;color: #FDFDFD}}"
        )
        self.selectItem2.clicked.connect(self.selectItem2Changed)

        self.selectItem3 = QPushButton(self.selectList)
        self.selectItem3.setGeometry(2*self.width_scale, 54*self.height_scale, 87*self.width_scale, 26*self.height_scale)
        self.selectItem3.setText('Agtron值')
        self.selectItem3.setStyleSheet(
            f"QPushButton{{background-color: #FDFDFD; border-radius: {13*self.height_scale}px; border: none;color: #393939}}"
            f"QPushButton:hover{{background-color: #393939; border-radius: {13*self.height_scale}px; border: none;color: #FDFDFD}}"
        )
        self.selectItem3.clicked.connect(self.selectItem3Changed)

        self.selectItem4 = QPushButton(self.selectList)
        self.selectItem4.setGeometry(2*self.width_scale, 80*self.height_scale, 87*self.width_scale, 26*self.height_scale)
        self.selectItem4.setText('反馈情况')
        self.selectItem4.setStyleSheet(
            f"QPushButton{{background-color: #FDFDFD; border-radius: {13*self.height_scale}px; border: none;color: #393939}}"
            f"QPushButton:hover{{background-color: #393939; border-radius: {13*self.height_scale}px; border: none;color: #FDFDFD}}"
        )
        self.selectItem4.clicked.connect(self.selectItem4Changed)






        self.timeTitle = QLabel(self.tabelTitle)
        self.timeTitle.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.timeTitle.setText('GMT+8')
        self.timeTitle.setGeometry(1*self.width_scale, 0, 60*self.width_scale, 54*self.height_scale)
        self.timeTitle.setStyleSheet(
            "color: #8F9195;background-color:transparent; border: none"
        )
        timeTitlefont = QFont(self.font_family4, 10*self.width_scale)
        self.timeTitle.setFont(timeTitlefont)

        self.timeTitle = QLabel(self.tabelTitle)
        self.timeTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
        self.timeTitle.setText('#')
        self.timeTitle.setGeometry(95*self.width_scale, 0, 40*self.width_scale, 54*self.height_scale)
        self.timeTitle.setStyleSheet(
            "color: #8F9195;background-color: transparent; border: none"
        )
        timeTitlefont = QFont(self.font_family4, 10*self.width_scale)
        self.timeTitle.setFont(timeTitlefont)

        self.timeTitle = QLabel(self.tabelTitle)
        self.timeTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
        self.timeTitle.setText('反馈情况')
        self.timeTitle.setGeometry(184*self.width_scale, 0, 90*self.width_scale, 54*self.height_scale)
        self.timeTitle.setStyleSheet(
            "color: #8F9195;background-color: transparent; border: none"
        )
        timeTitlefont = QFont(self.font_family4, 10*self.width_scale)
        self.timeTitle.setFont(timeTitlefont)

        self.timeTitle = QLabel(self.tabelTitle)
        self.timeTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
        self.timeTitle.setText('任务编号')
        self.timeTitle.setGeometry(316*self.width_scale, 0, 90*self.width_scale, 54*self.height_scale)
        self.timeTitle.setStyleSheet(
            "color: #8F9195;background-color: transparent; border: none"
        )
        timeTitlefont = QFont(self.font_family4, 10*self.width_scale)
        self.timeTitle.setFont(timeTitlefont)

        self.timeTitle = QLabel(self.tabelTitle)
        self.timeTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
        self.timeTitle.setText('任务名称')
        self.timeTitle.setGeometry(596*self.width_scale, 0, 90*self.width_scale, 54*self.height_scale)
        self.timeTitle.setStyleSheet(
            "color: #8F9195;background-color: transparent; border: none"
        )
        timeTitlefont = QFont(self.font_family4, 10*self.width_scale)
        self.timeTitle.setFont(timeTitlefont)

        self.timeTitle = QLabel(self.tabelTitle)
        self.timeTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
        self.timeTitle.setText('任务时长')
        self.timeTitle.setGeometry(875*self.width_scale, 0, 90*self.width_scale, 54*self.height_scale)
        self.timeTitle.setStyleSheet(
            "color: #8F9195;background-color: transparent; border: none"
        )
        timeTitlefont = QFont(self.font_family4, 10*self.width_scale)
        self.timeTitle.setFont(timeTitlefont)

        self.timeTitle = QLabel(self.tabelTitle)
        self.timeTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
        self.timeTitle.setText('任务时段')
        self.timeTitle.setGeometry(1116*self.width_scale, 0, 90*self.width_scale, 54*self.height_scale)
        self.timeTitle.setStyleSheet(
            "color: #8F9195;background-color: transparent; border: none"
        )
        timeTitlefont = QFont(self.font_family4, 10*self.width_scale)
        self.timeTitle.setFont(timeTitlefont)

        self.timeTitle = QLabel(self.tabelTitle)
        self.timeTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
        self.timeTitle.setText('Agtron值')
        self.timeTitle.setGeometry(1358*self.width_scale, 0, 90*self.width_scale, 54*self.height_scale)
        self.timeTitle.setStyleSheet(
            "color: #8F9195;background-color: transparent; border: none"
        )
        timeTitlefont = QFont(self.font_family4, 10*self.width_scale)
        self.timeTitle.setFont(timeTitlefont)

        # 创建 QListWidget
        self.list_widget2 = QListWidget(self.historyTabel)
        self.list_widget2.setGeometry(13*self.width_scale, 145*self.height_scale, 1598*self.width_scale, 620*self.height_scale)
        self.list_widget2.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.list_widget2.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.list_widget2.setStyleSheet("""
                    QListWidget {
                        background-color: transparent;
                        border: none;
                    }
                    QListWidget::item:selected {
                        background-color: transparent;   /* 设置选中背景颜色为半透明 */
                        color: black;                     /* 保持文字颜色为黑色 */
                    }
                    QListWidget::item:selected:active {
                        background-color: transparent;
                    }
                """)

        # 循环添加24小时的时间段
        for hour in range(24):
            list_item = QListWidgetItem(f"{hour:02d}:00")
            list_item.setSizeHint(QSize(1598*self.width_scale, 48*self.height_scale))
            list_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
            self.list_widget2.addItem(list_item)

        # self.timeScroll = QScrollArea(self.historyTabel)  # self 指向当前窗口
        # self.timeScroll.setWidgetResizable(True)  # 自动调整大小以适应内容
        # self.timeScroll.setGeometry(1, 164, 1598, 620)
        # self.timeScroll.setStyleSheet('border: none;background-color: transparent; ')
        # self.timeScroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # 隐藏横向滚动条
        # self.timeScroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # 隐藏纵向滚动条
        # # 将 QWidget 设置为 QScrollArea 的 widget
        # self.timeScroll.setWidget(self.orderWidget)



        self.list_widget = QListWidget(self.historyTabel)
        self.list_widget.setGeometry(61*self.width_scale, 164*self.height_scale, 1537*self.width_scale, 620*self.height_scale)

        # 设置滚动条策略为始终隐藏
        self.list_widget.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.list_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.list_widget.itemClicked.connect(self.showHistorydetail)
        # 隐藏边框 (设置无边框样式)
        self.list_widget.setStyleSheet("""
                    QListWidget {
                        border: none;
                        font-size: 10px;
                        height: 36px;
                        color: #ABB0B7;
                        background-color: transparent;
                    }
                    QListWidget::item {
                        /* border-bottom: 1px solid #DEE0E3;  /* 添加下划线 */ 
                        /* padding: 10px;                   调整内边距 */
                    }
                    QListWidget::item:selected {
                        background-color: #ffffff;      /* 选中的项目背景颜色 */
                        /* color: white;                    选中的项目字体颜色 */
                    }
                """)
        self.list_widget.verticalScrollBar().valueChanged.connect(self.syncScrollBar)
        self.list_widget2.verticalScrollBar().valueChanged.connect(self.syncScrollBar)



        self.painter = QPainter(self.historyTabel)
        pen = QPen(Qt.GlobalColor.black, 1)  # 设置画笔颜色和线条宽度
        self.painter.setPen(pen)

        start_x = 70*self.width_scale  # 起始X坐标
        start_y = 167*self.height_scale  # 起始Y坐标
        line_length = 1541*self.width_scale  # 线条长度
        spacing = 48*self.height_scale  # 每条线之间的间距

        for i in range(13):  # 画13条线
            # self.painter.drawLine(start_x, start_y + i * spacing, start_x + line_length, start_y + i * spacing)

            self.tabelTitleLine4 = QLabel(self.historyTabel)
            self.tabelTitleLine4.setGeometry(start_x, start_y + i * spacing, line_length, 1)
            self.tabelTitleLine4.setStyleSheet(
                "background-color: #DEE0E3;border: none;"
            )

        self.tabelTitleLine3 = QLabel(self.historyTabel)
        self.tabelTitleLine3.setGeometry(60 * self.width_scale, 71 * self.height_scale, 1 * self.width_scale,
                                         724 * self.height_scale)
        self.tabelTitleLine3.setStyleSheet(
            "background-color: #DEE0E3;border: none;"
        )
        #
        #
        #
        # self.timeNum1 = QLabel(self.historyTabel)
        # self.timeNum1.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum1.setText('08:00')
        # self.timeNum1.setGeometry(1, 160, 60, 30)
        # self.timeNum1.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # timeNumfont = QFont(self.font_family4, 8)
        # self.timeNum1.setFont(timeNumfont)
        #
        # self.timeNum2 = QLabel(self.historyTabel)
        # self.timeNum2.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum2.setText('09:00')
        # self.timeNum2.setGeometry(1, 208, 60, 30)
        # self.timeNum2.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # self.timeNum2.setFont(timeNumfont)
        #
        # self.timeNum3 = QLabel(self.historyTabel)
        # self.timeNum3.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum3.setText('10:00')
        # self.timeNum3.setGeometry(1, 256, 60, 30)
        # self.timeNum3.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # self.timeNum3.setFont(timeNumfont)
        #
        # self.timeNum13 = QLabel(self.historyTabel)
        # self.timeNum13.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum13.setText('11:00')
        # self.timeNum13.setGeometry(1, 304, 60, 30)
        # self.timeNum13.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # self.timeNum13.setFont(timeNumfont)
        #
        # self.timeNum4 = QLabel(self.historyTabel)
        # self.timeNum4.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum4.setText('12:00')
        # self.timeNum4.setGeometry(1, 352, 60, 30)
        # self.timeNum4.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # self.timeNum4.setFont(timeNumfont)
        #
        # self.timeNum5 = QLabel(self.historyTabel)
        # self.timeNum5.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum5.setText('13:00')
        # self.timeNum5.setGeometry(1, 400, 60, 30)
        # self.timeNum5.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # self.timeNum5.setFont(timeNumfont)
        #
        # self.timeNum6 = QLabel(self.historyTabel)
        # self.timeNum6.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum6.setText('14:00')
        # self.timeNum6.setGeometry(1, 448, 60, 30)
        # self.timeNum6.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # self.timeNum6.setFont(timeNumfont)
        #
        # self.timeNum7 = QLabel(self.historyTabel)
        # self.timeNum7.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum7.setText('15:00')
        # self.timeNum7.setGeometry(1, 496, 60, 30)
        # self.timeNum7.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # self.timeNum7.setFont(timeNumfont)
        #
        # self.timeNum8 = QLabel(self.historyTabel)
        # self.timeNum8.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum8.setText('16:00')
        # self.timeNum8.setGeometry(1, 544, 60, 30)
        # self.timeNum8.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # self.timeNum8.setFont(timeNumfont)
        #
        # self.timeNum9 = QLabel(self.historyTabel)
        # self.timeNum9.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum9.setText('17:00')
        # self.timeNum9.setGeometry(1, 592, 60, 30)
        # self.timeNum9.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # self.timeNum9.setFont(timeNumfont)
        #
        # self.timeNum10 = QLabel(self.historyTabel)
        # self.timeNum10.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum10.setText('18:00')
        # self.timeNum10.setGeometry(1, 640, 60, 30)
        # self.timeNum10.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # self.timeNum10.setFont(timeNumfont)
        #
        # self.timeNum11 = QLabel(self.historyTabel)
        # self.timeNum11.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum11.setText('19:00')
        # self.timeNum11.setGeometry(1, 688, 60, 30)
        # self.timeNum11.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # self.timeNum11.setFont(timeNumfont)
        #
        # self.timeNum12 = QLabel(self.historyTabel)
        # self.timeNum12.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.timeNum12.setText('20:00')
        # self.timeNum12.setGeometry(1, 736, 60, 30)
        # self.timeNum12.setStyleSheet(
        #     "color: #8F9195;background-color:transparent; border: none"
        # )
        # self.timeNum12.setFont(timeNumfont)

        self.historyInfo = QLabel(self)  # 历史记录-展开
        self.historyInfo.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #ffffff; border: 1px solid #A7A8AC; ')
        self.historyInfo.setGeometry(231*self.width_scale, 200*self.height_scale, 1600*self.width_scale, 2739*self.height_scale)
        self.historyInfoImg = QPixmap(self.normalized_path + '/includes/Icons/history/back_L.png')
        self.historyInfo.setPixmap(self.historyInfoImg)
        self.historyInfo.setScaledContents(True)
        self.historyInfo.setVisible(False)

        self.historyDetail_sheibei = QLabel(self.historyInfo)
        self.historyDetail_sheibei.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.historyDetail_sheibei.setStyleSheet(f'border-radius: {19*self.height_scale}px;background-color: #D3C9C2; border: none; ')
        self.historyDetail_sheibei.setGeometry(60*self.width_scale, 30*self.height_scale, 330*self.width_scale, 38*self.height_scale)
        self.historyDetail_sheibei.setText('-')
        history_sheibeifont = QFont(self.font_family4, 12*self.width_scale)
        self.historyDetail_sheibei.setFont(history_sheibeifont)


        self.updateCloud = QPushButton(self.historyInfo)
        self.updateCloud.setGeometry(1440*self.width_scale, 30*self.height_scale, 40*self.width_scale, 40*self.height_scale)
        self.updateCloud.setCheckable(True)
        self.updateCloud.setStyleSheet(f"""
                                    QPushButton {{
                                        border-image: url('{self.normalized_path}/includes/Icons/history/down.png');
                                        border: none;background-color:transparent;
                                    }}
                                """)
        # self.updateCloud.clicked.connect(self.toggle_updateCloud)
        self.updateCloud.clicked.connect(self.submitInfo)

        self.closeHistory = QPushButton(self.historyInfo)
        self.closeHistory.setGeometry(1500*self.width_scale, 30*self.height_scale, 40*self.width_scale, 40*self.width_scale)
        self.closeHistory.setCheckable(True)
        self.closeHistory.setStyleSheet(f"""
                                            QPushButton {{
                                                border-image: url('{self.normalized_path}/includes/Icons/history/close.png');
                                                border: none;background-color:transparent;
                                            }}
                                        """)
        self.closeHistory.clicked.connect(self.closeHistoryClick)

        # 创建一个 QScrollArea
        self.scroll_area = QScrollArea(self)
        # 设置 QScrollArea 的属性
        self.scroll_area.setWidgetResizable(True)  # 自动调整内容大小
        self.scroll_area.setWidget(self.historyInfo)
        self.scroll_area.setFrameStyle(QFrame.Shape.NoFrame)
        self.scroll_area.setGeometry(231*self.width_scale, 200*self.height_scale, 1600*self.width_scale, 796*self.height_scale)
        self.scroll_area.setStyleSheet(f"""
                    QScrollArea {{
                        background-color: rgba(255, 255, 255, 0);  /* 完全透明的背景 */
                        border: none;  /* 移除边框 */
                        border-radius: {25*self.height_scale}px;  /* 圆角设置 */
                    }}
                    QWidget {{
                        border: none;  # 去掉内部 QWidget 的边框
                        background-color: transparent;  # 可选，确保背景透明
                        border-radius: {25*self.height_scale}px;
                    }}
                    QScrollBar:vertical, QScrollBar:horizontal {{
                        background: transparent;  /* 隐藏滚动条背景 */
                    }}
                """)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # 隐藏横向滚动条
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # 隐藏纵向滚动条
        self.scroll_area.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        # self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setVisible(False)

        # self.qmc: tgraphcanvas = tgraphcanvas(self.historyInfo, self.dpi, locale, self)
        # self.qmc.setGeometry(60, 142, 1480, 550)

        self.hfChartKey = QLabel(self.historyInfo)
        self.hfChartKey.setStyleSheet(f'border-radius: {28*self.height_scale}px;background-color: #D3C9C2;border: none')
        self.hfChartKey.setGeometry(60*self.width_scale, 731*self.height_scale, 1481*self.width_scale, 56*self.height_scale)

        self.hfChartKey_dw = QLabel(self.hfChartKey)
        self.hfChartKey_dw.setStyleSheet(f'border-radius: {2*self.height_scale}px;background-color: #D18F65;')
        self.hfChartKey_dw.setGeometry(256*self.width_scale, 18*self.height_scale, 11*self.width_scale, 19*self.height_scale)
        self.hfChartKey_dwText = QLabel(self.hfChartKey)
        self.hfChartKey_dwText.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.hfChartKey_dwText.setText('豆温')
        self.hfChartKey_dwText.setGeometry(283*self.width_scale, 18*self.height_scale, 60*self.width_scale, 20*self.height_scale)
        self.hfChartKey_dwText.setStyleSheet("color: #292827;border:none;")
        hfChartKeyfont = QFont(self.font_family4, 16*self.width_scale)
        self.hfChartKey_dwText.setFont(hfChartKeyfont)

        self.hfChartKey_dw = QLabel(self.hfChartKey)
        self.hfChartKey_dw.setStyleSheet(f'border-radius: {2*self.height_scale}px;background-color: #AC3230;')
        self.hfChartKey_dw.setGeometry(426*self.width_scale, 18*self.height_scale, 11*self.width_scale, 19*self.height_scale)
        self.hfChartKey_dwText = QLabel(self.hfChartKey)
        self.hfChartKey_dwText.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.hfChartKey_dwText.setText('风温')
        self.hfChartKey_dwText.setGeometry(452*self.width_scale, 18*self.height_scale, 60*self.width_scale, 20*self.height_scale)
        self.hfChartKey_dwText.setStyleSheet("color: #292827;border:none;")
        hfChartKeyfont = QFont(self.font_family4, 16*self.width_scale)
        self.hfChartKey_dwText.setFont(hfChartKeyfont)

        self.hfChartKey_dw = QLabel(self.hfChartKey)
        self.hfChartKey_dw.setStyleSheet(f'border-radius: {2*self.height_scale}px;background-color: #7864AA;')
        self.hfChartKey_dw.setGeometry(596*self.width_scale, 18*self.height_scale, 11*self.width_scale, 19*self.height_scale)
        self.hfChartKey_dwText = QLabel(self.hfChartKey)
        self.hfChartKey_dwText.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.hfChartKey_dwText.setText('ROC')
        self.hfChartKey_dwText.setGeometry(621*self.width_scale, 18*self.height_scale, 60*self.width_scale, 20*self.height_scale)
        self.hfChartKey_dwText.setStyleSheet("color: #292827;border:none;")
        hfChartKeyfont = QFont(self.font_family4, 16*self.width_scale)
        self.hfChartKey_dwText.setFont(hfChartKeyfont)

        self.hfChartKey_dw = QLabel(self.hfChartKey)
        self.hfChartKey_dw.setStyleSheet(f'border-radius: {2*self.height_scale}px;background-color: #6BAE76;')
        self.hfChartKey_dw.setGeometry(765*self.width_scale, 18*self.height_scale, 11*self.width_scale, 19*self.height_scale)
        self.hfChartKey_dwText = QLabel(self.hfChartKey)
        self.hfChartKey_dwText.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.hfChartKey_dwText.setText('色值')
        self.hfChartKey_dwText.setGeometry(791*self.width_scale, 18*self.height_scale, 60*self.width_scale, 20*self.height_scale)
        self.hfChartKey_dwText.setStyleSheet("color: #292827;border:none;")
        hfChartKeyfont = QFont(self.font_family4, 16*self.width_scale)
        self.hfChartKey_dwText.setFont(hfChartKeyfont)

        self.hfChartKey_dw = QLabel(self.hfChartKey)
        self.hfChartKey_dw.setStyleSheet(f'border-radius: {2*self.height_scale}px;background-color: #1EA1A9;')
        self.hfChartKey_dw.setGeometry(936*self.width_scale, 18*self.height_scale, 11*self.width_scale, 19*self.height_scale)
        self.hfChartKey_dwText = QLabel(self.hfChartKey)
        self.hfChartKey_dwText.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.hfChartKey_dwText.setText('排气湿度')
        self.hfChartKey_dwText.setGeometry(966*self.width_scale, 18*self.height_scale, 90*self.width_scale, 20*self.height_scale)
        self.hfChartKey_dwText.setStyleSheet("color: #292827;border:none;")
        hfChartKeyfont = QFont(self.font_family4, 16*self.width_scale)
        self.hfChartKey_dwText.setFont(hfChartKeyfont)

        self.hfChartKey_dw = QLabel(self.hfChartKey)
        self.hfChartKey_dw.setStyleSheet(f'border-radius: {2*self.height_scale}px;background-color: #D0B53F;')
        self.hfChartKey_dw.setGeometry(1106*self.width_scale, 18*self.height_scale, 11*self.width_scale, 19*self.height_scale)
        self.hfChartKey_dwText = QLabel(self.hfChartKey)
        self.hfChartKey_dwText.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        self.hfChartKey_dwText.setText('排气温度')
        self.hfChartKey_dwText.setGeometry(1135*self.width_scale, 18*self.height_scale, 90*self.width_scale, 20*self.height_scale)
        self.hfChartKey_dwText.setStyleSheet("color: #292827;border:none;")
        hfChartKeyfont = QFont(self.font_family4, 16*self.width_scale)
        self.hfChartKey_dwText.setFont(hfChartKeyfont)

        self.hbscContent = '15:30'
        self.hongbeishichang = QLabel(self.historyInfo)
        self.hongbeishichang.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.hongbeishichang.setText('烘焙时长：' + self.hbscContent)
        self.hongbeishichang.setGeometry(60*self.width_scale, 840*self.height_scale, 260*self.width_scale, 30*self.height_scale)
        self.hongbeishichang.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        hbscfont = QFont(self.font_family4, 18*self.width_scale)
        self.hongbeishichang.setFont(hbscfont)

        self.rdwdContent = '162℃'
        self.rudouwendu = QLabel(self.historyInfo)
        self.rudouwendu.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.rudouwendu.setText('入豆温度：' + self.rdwdContent)
        self.rudouwendu.setGeometry(379*self.width_scale, 840*self.height_scale, 240*self.width_scale, 30*self.height_scale)
        self.rudouwendu.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        self.rudouwendu.setFont(hbscfont)

        self.hwdContent = '80℃/01:30'
        self.huiwendian = QLabel(self.historyInfo)
        self.huiwendian.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.huiwendian.setText('回温点：' + self.hwdContent)
        self.huiwendian.setGeometry(740*self.width_scale, 840*self.height_scale, 240*self.width_scale, 30*self.height_scale)
        self.huiwendian.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        self.huiwendian.setFont(hbscfont)

        self.zhdContent = '80℃/01:30'
        self.zhuanhuangdian = QLabel(self.historyInfo)
        self.zhuanhuangdian.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.zhuanhuangdian.setText('转黄点：' + self.zhdContent)
        self.zhuanhuangdian.setGeometry(1107*self.width_scale, 840*self.height_scale, 240*self.width_scale, 30*self.height_scale)
        self.zhuanhuangdian.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        self.zhuanhuangdian.setFont(hbscfont)

        self.ybContent = '80℃/01:30'
        self.yibao = QLabel(self.historyInfo)
        self.yibao.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.yibao.setText('一爆：' + self.ybContent)
        self.yibao.setGeometry(60*self.width_scale, 906*self.height_scale, 240*self.width_scale, 30*self.height_scale)
        self.yibao.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        self.yibao.setFont(hbscfont)

        self.fzscContent = '01:30'
        self.fazhanshichang = QLabel(self.historyInfo)
        self.fazhanshichang.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.fazhanshichang.setText('发展时长：' + self.fzscContent)
        self.fazhanshichang.setGeometry(379*self.width_scale, 906*self.height_scale, 240*self.width_scale, 30*self.height_scale)
        self.fazhanshichang.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        self.fazhanshichang.setFont(hbscfont)

        self.dtrContent = '25%'
        self.dtrTxt = QLabel(self.historyInfo)
        self.dtrTxt.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.dtrTxt.setText('DTR：' + self.dtrContent)
        self.dtrTxt.setGeometry(740*self.width_scale, 906*self.height_scale, 240*self.width_scale, 30*self.height_scale)
        self.dtrTxt.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        self.dtrTxt.setFont(hbscfont)

        self.yuanliaopeibi = QLabel(self.historyInfo)
        self.yuanliaopeibi.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.yuanliaopeibi.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.yuanliaopeibi.setGeometry(60*self.width_scale, 978*self.height_scale, 1479*self.width_scale, 75*self.height_scale)
        self.yuanliaopeibi.setText('原料配比')
        yuanliaopeibifont = QFont(self.font_family4, 18*self.width_scale)
        self.yuanliaopeibi.setFont(yuanliaopeibifont)

        self.pfTitle = QLabel(self.yuanliaopeibi)
        self.pfTitle.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.pfTitle.setText('配方1')
        self.pfTitle.setGeometry(1239*self.width_scale, 0, 240*self.width_scale, 75*self.height_scale)
        self.pfTitle.setStyleSheet("background-color: transparent; border:none;color: #222222;padding-right: 20px;")
        self.pfTitle.setFont(hbscfont)

        self.zhongliang = QLabel(self.historyInfo)
        self.zhongliang.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.zhongliang.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.zhongliang.setGeometry(60*self.width_scale, 1059*self.height_scale, 239*self.width_scale, 75*self.height_scale)
        self.zhongliang.setText('重量')
        zhongliangfont = QFont(self.font_family4, 18*self.width_scale)
        self.zhongliang.setFont(zhongliangfont)

        self.shengdou = QLabel(self.historyInfo)
        self.shengdou.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.shengdou.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.shengdou.setGeometry(303*self.width_scale, 1059*self.height_scale, 406*self.width_scale, 75*self.height_scale)
        self.shengdou.setText('生豆')
        shengdoufont = QFont(self.font_family4, 18*self.width_scale)
        self.shengdou.setFont(shengdoufont)

        self.sdzl = QLabel(self.shengdou)
        self.sdzl.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sdzl.setText('600g')
        self.sdzl.setGeometry(266*self.width_scale, 0, 140*self.width_scale, 75*self.height_scale)
        self.sdzl.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sdzl.setFont(hbscfont)

        self.hanshuiliang = QLabel(self.historyInfo)
        self.hanshuiliang.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.hanshuiliang.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.hanshuiliang.setGeometry(718*self.width_scale, 1059*self.height_scale, 406*self.width_scale, 75*self.height_scale)
        self.hanshuiliang.setText('含水量')
        hanshuiliangfont = QFont(self.font_family4, 18*self.width_scale)
        self.hanshuiliang.setFont(hanshuiliangfont)

        self.hslTxt = QLabel(self.hanshuiliang)
        self.hslTxt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.hslTxt.setText('600g')
        self.hslTxt.setGeometry(266*self.width_scale, 0, 140*self.width_scale, 75*self.height_scale)
        self.hslTxt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.hslTxt.setFont(hbscfont)

        self.midu = QLabel(self.historyInfo)
        self.midu.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.midu.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.midu.setGeometry(1132*self.width_scale, 1059*self.height_scale, 406*self.width_scale, 75*self.height_scale)
        self.midu.setText('密度')
        midufont = QFont(self.font_family4, 18*self.width_scale)
        self.midu.setFont(midufont)

        self.miduNUM = QLabel(self.midu)
        self.miduNUM.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.miduNUM.setText('150g/L')
        self.miduNUM.setGeometry(266*self.width_scale, 0, 140*self.width_scale, 75*self.height_scale)
        self.miduNUM.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.miduNUM.setFont(hbscfont)

        self.mbzTxt = QLabel(self.historyInfo)
        self.mbzTxt.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.mbzTxt.setText('目标值')
        self.mbzTxt.setGeometry(60*self.width_scale, 1160*self.height_scale, 240*self.width_scale, 30*self.height_scale)
        self.mbzTxt.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        self.mbzTxt.setFont(hbscfont)

        self.sjzTxt = QLabel(self.historyInfo)
        self.sjzTxt.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.sjzTxt.setText('实际值')
        self.sjzTxt.setGeometry(721*self.width_scale, 1160*self.height_scale, 240*self.width_scale, 30*self.height_scale)
        self.sjzTxt.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        self.sjzTxt.setFont(hbscfont)

        self.stage1 = QLabel(self.historyInfo)
        self.stage1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.stage1.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.stage1.setGeometry(60*self.width_scale, 1208*self.height_scale, 135*self.width_scale, 75*self.height_scale)
        self.stage1.setText('阶段1')
        self.stage1.setFont(zhongliangfont)

        self.wendu1 = QLabel(self.historyInfo)
        self.wendu1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.wendu1.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.wendu1.setGeometry(198*self.width_scale, 1208*self.height_scale, 253*self.width_scale, 75*self.height_scale)
        self.wendu1.setText('温度')
        wendu1font = QFont(self.font_family4, 18*self.width_scale)
        self.wendu1.setFont(wendu1font)

        self.wendu1Txt = QLabel(self.wendu1)
        self.wendu1Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.wendu1Txt.setText('130℃')
        self.wendu1Txt.setGeometry(133*self.width_scale, 0, 120*self.width_scale, 75*self.height_scale)
        self.wendu1Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.wendu1Txt.setFont(hbscfont)

        self.ckz1 = QLabel(self.historyInfo)
        self.ckz1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.ckz1.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.ckz1.setGeometry(457*self.width_scale, 1208*self.height_scale, 253*self.width_scale, 75*self.height_scale)
        self.ckz1.setText('参考值')
        self.ckz1.setFont(wendu1font)

        self.ckz1Txt = QLabel(self.ckz1)
        self.ckz1Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.ckz1Txt.setText('30RH%')
        self.ckz1Txt.setGeometry(103*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.ckz1Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.ckz1Txt.setFont(hbscfont)

        self.stage2 = QLabel(self.historyInfo)
        self.stage2.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.stage2.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.stage2.setGeometry(60*self.width_scale, 1289*self.height_scale, 135*self.width_scale, 75*self.height_scale)
        self.stage2.setText('阶段2')
        self.stage2.setFont(zhongliangfont)

        self.wendu2 = QLabel(self.historyInfo)
        self.wendu2.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.wendu2.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.wendu2.setGeometry(198*self.width_scale, 1289*self.height_scale, 253*self.width_scale, 75*self.height_scale)
        self.wendu2.setText('温度')
        wendu2font = QFont(self.font_family4, 18*self.width_scale)
        self.wendu2.setFont(wendu2font)

        self.wendu2Txt = QLabel(self.wendu2)
        self.wendu2Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.wendu2Txt.setText('130℃')
        self.wendu2Txt.setGeometry(133*self.width_scale, 0, 120*self.width_scale, 75*self.height_scale)
        self.wendu2Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.wendu2Txt.setFont(hbscfont)

        self.ckz2 = QLabel(self.historyInfo)
        self.ckz2.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.ckz2.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.ckz2.setGeometry(457*self.width_scale, 1289*self.height_scale, 253*self.width_scale, 75*self.height_scale)
        self.ckz2.setText('参考值')
        self.ckz2.setFont(wendu2font)

        self.ckz2Txt = QLabel(self.ckz2)
        self.ckz2Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.ckz2Txt.setText('30RH%')
        self.ckz2Txt.setGeometry(103*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.ckz2Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.ckz2Txt.setFont(hbscfont)

        self.stage3 = QLabel(self.historyInfo)
        self.stage3.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.stage3.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.stage3.setGeometry(60*self.width_scale, 1370*self.height_scale, 135*self.width_scale, 75*self.height_scale)
        self.stage3.setText('阶段3')
        self.stage3.setFont(zhongliangfont)

        self.wendu3 = QLabel(self.historyInfo)
        self.wendu3.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.wendu3.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.wendu3.setGeometry(198*self.width_scale, 1370*self.height_scale, 253*self.width_scale, 75*self.height_scale)
        self.wendu3.setText('温度')
        wendu3font = QFont(self.font_family4, 18*self.width_scale)
        self.wendu3.setFont(wendu3font)

        self.wendu3Txt = QLabel(self.wendu3)
        self.wendu3Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.wendu3Txt.setText('130℃')
        self.wendu3Txt.setGeometry(133*self.width_scale, 0, 120*self.width_scale, 75*self.height_scale)
        self.wendu3Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.wendu3Txt.setFont(hbscfont)

        self.ckz3 = QLabel(self.historyInfo)
        self.ckz3.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.ckz3.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.ckz3.setGeometry(457*self.width_scale, 1370*self.height_scale, 253*self.width_scale, 75*self.height_scale)
        self.ckz3.setText('参考值')
        self.ckz3.setFont(wendu3font)

        self.ckz3Txt = QLabel(self.ckz3)
        self.ckz3Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.ckz3Txt.setText('30RH%')
        self.ckz3Txt.setGeometry(103*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.ckz3Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.ckz3Txt.setFont(hbscfont)

        self.stage4 = QLabel(self.historyInfo)
        self.stage4.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.stage4.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.stage4.setGeometry(60*self.width_scale, 1451*self.height_scale, 135*self.width_scale, 75*self.height_scale)
        self.stage4.setText('阶段4')
        self.stage4.setFont(zhongliangfont)

        self.wendu4 = QLabel(self.historyInfo)
        self.wendu4.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.wendu4.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.wendu4.setGeometry(198*self.width_scale, 1451*self.height_scale, 253*self.width_scale, 75*self.height_scale)
        self.wendu4.setText('温度')
        wendu4font = QFont(self.font_family4, 18*self.width_scale)
        self.wendu4.setFont(wendu4font)

        self.wendu4Txt = QLabel(self.wendu4)
        self.wendu4Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.wendu4Txt.setText('130℃')
        self.wendu4Txt.setGeometry(133*self.width_scale, 0, 120*self.width_scale, 75*self.height_scale)
        self.wendu4Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.wendu4Txt.setFont(hbscfont)

        self.ckz4 = QLabel(self.historyInfo)
        self.ckz4.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.ckz4.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.ckz4.setGeometry(457*self.width_scale, 1451*self.height_scale, 253*self.width_scale, 75*self.height_scale)
        self.ckz4.setText('参考值')
        self.ckz4.setFont(wendu4font)

        self.ckz4Txt = QLabel(self.ckz4)
        self.ckz4Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.ckz4Txt.setText('30RH%')
        self.ckz4Txt.setGeometry(103*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.ckz4Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.ckz4Txt.setFont(hbscfont)

        self.stage5 = QLabel(self.historyInfo)
        self.stage5.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.stage5.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.stage5.setGeometry(60*self.width_scale, 1532*self.height_scale, 135*self.width_scale, 75*self.height_scale)
        self.stage5.setText('阶段5')
        self.stage5.setFont(zhongliangfont)

        self.wendu5 = QLabel(self.historyInfo)
        self.wendu5.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.wendu5.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.wendu5.setGeometry(198*self.width_scale, 1532*self.height_scale, 253*self.width_scale, 75*self.height_scale)
        self.wendu5.setText('温度')
        wendu5font = QFont(self.font_family4, 18*self.width_scale)
        self.wendu5.setFont(wendu5font)

        self.wendu5Txt = QLabel(self.wendu5)
        self.wendu5Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.wendu5Txt.setText('130℃')
        self.wendu5Txt.setGeometry(133*self.width_scale, 0, 120*self.width_scale, 75*self.height_scale)
        self.wendu5Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.wendu5Txt.setFont(hbscfont)

        self.ckz5 = QLabel(self.historyInfo)
        self.ckz5.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.ckz5.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.ckz5.setGeometry(457*self.width_scale, 1532*self.height_scale, 253*self.width_scale, 75*self.height_scale)
        self.ckz5.setText('参考值')
        self.ckz5.setFont(wendu5font)

        self.ckz5Txt = QLabel(self.ckz5)
        self.ckz5Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.ckz5Txt.setText('30RH%')
        self.ckz5Txt.setGeometry(103*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.ckz5Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.ckz5Txt.setFont(hbscfont)

        self.stage6 = QLabel(self.historyInfo)
        self.stage6.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.stage6.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.stage6.setGeometry(60*self.width_scale, 1613*self.height_scale, 135*self.width_scale, 75*self.height_scale)
        self.stage6.setText('阶段6')
        self.stage6.setFont(zhongliangfont)

        self.wendu6 = QLabel(self.historyInfo)
        self.wendu6.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.wendu6.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.wendu6.setGeometry(198*self.width_scale, 1613*self.height_scale, 253*self.width_scale, 75*self.height_scale)
        self.wendu6.setText('温度')
        wendu6font = QFont(self.font_family4, 18*self.width_scale)
        self.wendu6.setFont(wendu6font)

        self.wendu6Txt = QLabel(self.wendu6)
        self.wendu6Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.wendu6Txt.setText('130℃')
        self.wendu6Txt.setGeometry(133*self.width_scale, 0, 120*self.width_scale, 75*self.height_scale)
        self.wendu6Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.wendu6Txt.setFont(hbscfont)

        self.ckz6 = QLabel(self.historyInfo)
        self.ckz6.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.ckz6.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.ckz6.setGeometry(457*self.width_scale, 1613*self.height_scale, 253*self.width_scale, 75*self.height_scale)
        self.ckz6.setText('参考值')
        self.ckz6.setFont(wendu6font)

        self.ckz6Txt = QLabel(self.ckz6)
        self.ckz6Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.ckz6Txt.setText('30RH%')
        self.ckz6Txt.setGeometry(103*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.ckz6Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.ckz6Txt.setFont(hbscfont)

        self.sjStage1 = QLabel(self.historyInfo)
        self.sjStage1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjStage1.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.sjStage1.setGeometry(718*self.width_scale, 1208*self.height_scale, 135*self.width_scale, 75*self.height_scale)
        self.sjStage1.setText('阶段1')
        self.sjStage1.setFont(zhongliangfont)

        self.sjwendu1 = QLabel(self.historyInfo)
        self.sjwendu1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjwendu1.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #FBBE9A; color:#A8A8A8;padding-left: 20px;')
        self.sjwendu1.setGeometry(857*self.width_scale, 1208*self.height_scale, 235*self.width_scale, 75*self.height_scale)
        self.sjwendu1.setText('温度')
        sjwendu1font = QFont(self.font_family4, 18*self.width_scale)
        self.sjwendu1.setFont(sjwendu1font)

        self.sjwendu1Txt = QLabel(self.sjwendu1)
        self.sjwendu1Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjwendu1Txt.setText('130℃')
        self.sjwendu1Txt.setGeometry(115*self.width_scale, 0, 120*self.width_scale, 75*self.height_scale)
        self.sjwendu1Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjwendu1Txt.setFont(hbscfont)

        self.sjckz1 = QLabel(self.historyInfo)
        self.sjckz1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjckz1.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #9AD8FB; color:#A8A8A8;padding-left: 20px;')
        self.sjckz1.setGeometry(1098*self.width_scale, 1208*self.height_scale, 235*self.width_scale, 75*self.height_scale)
        self.sjckz1.setText('参考值')
        self.sjckz1.setFont(sjwendu1font)

        self.sjckz1Txt = QLabel(self.sjckz1)
        self.sjckz1Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjckz1Txt.setText('30RH%')
        self.sjckz1Txt.setGeometry(85*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.sjckz1Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjckz1Txt.setFont(hbscfont)

        self.sjpc1 = QLabel(self.historyInfo)
        self.sjpc1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjpc1.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #FC958A; color:#A8A8A8;padding-left: 20px;')
        self.sjpc1.setGeometry(1338*self.width_scale, 1208*self.height_scale, 200*self.width_scale, 75*self.height_scale)
        self.sjpc1.setText('偏差')
        self.sjpc1.setFont(sjwendu1font)

        self.sjpc1Txt = QLabel(self.sjpc1)
        self.sjpc1Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjpc1Txt.setText('1%')
        self.sjpc1Txt.setGeometry(50*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.sjpc1Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjpc1Txt.setFont(hbscfont)

        self.sjStage2 = QLabel(self.historyInfo)
        self.sjStage2.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjStage2.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.sjStage2.setGeometry(718*self.width_scale, 1289*self.height_scale, 135*self.width_scale, 75*self.height_scale)
        self.sjStage2.setText('阶段2')
        self.sjStage2.setFont(zhongliangfont)

        self.sjwendu2 = QLabel(self.historyInfo)
        self.sjwendu2.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjwendu2.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #FBBE9A; color:#A8A8A8;padding-left: 20px;')
        self.sjwendu2.setGeometry(857*self.width_scale, 1289*self.height_scale, 235*self.width_scale, 75*self.height_scale)
        self.sjwendu2.setText('温度')
        sjwendu2font = QFont(self.font_family4, 18*self.width_scale)
        self.sjwendu2.setFont(sjwendu2font)

        self.sjwendu2Txt = QLabel(self.sjwendu2)
        self.sjwendu2Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjwendu2Txt.setText('130℃')
        self.sjwendu2Txt.setGeometry(115*self.width_scale, 0, 120*self.width_scale, 75*self.height_scale)
        self.sjwendu2Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjwendu2Txt.setFont(hbscfont)

        self.sjckz2 = QLabel(self.historyInfo)
        self.sjckz2.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjckz2.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #9AD8FB; color:#A8A8A8;padding-left: 20px;')
        self.sjckz2.setGeometry(1098*self.width_scale, 1289*self.height_scale, 235*self.width_scale, 75*self.height_scale)
        self.sjckz2.setText('参考值')
        self.sjckz2.setFont(sjwendu2font)

        self.sjckz2Txt = QLabel(self.sjckz2)
        self.sjckz2Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjckz2Txt.setText('30RH%')
        self.sjckz2Txt.setGeometry(85*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.sjckz2Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjckz2Txt.setFont(hbscfont)

        self.sjpc2 = QLabel(self.historyInfo)
        self.sjpc2.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjpc2.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #FC958A; color:#A8A8A8;padding-left: 20px;')
        self.sjpc2.setGeometry(1338*self.width_scale, 1289*self.height_scale, 200*self.width_scale, 75*self.height_scale)
        self.sjpc2.setText('偏差')
        self.sjpc2.setFont(sjwendu2font)

        self.sjpc2Txt = QLabel(self.sjpc2)
        self.sjpc2Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjpc2Txt.setText('1%')
        self.sjpc2Txt.setGeometry(50*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.sjpc2Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjpc2Txt.setFont(hbscfont)

        self.sjStage3 = QLabel(self.historyInfo)
        self.sjStage3.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjStage3.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.sjStage3.setGeometry(718*self.width_scale, 1370*self.height_scale, 135*self.width_scale, 75*self.height_scale)
        self.sjStage3.setText('阶段3')
        self.sjStage3.setFont(zhongliangfont)

        self.sjwendu3 = QLabel(self.historyInfo)
        self.sjwendu3.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjwendu3.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #FBBE9A; color:#A8A8A8;padding-left: 20px;')
        self.sjwendu3.setGeometry(857*self.width_scale, 1370*self.height_scale, 235*self.width_scale, 75*self.height_scale)
        self.sjwendu3.setText('温度')
        sjwendu3font = QFont(self.font_family4, 18*self.width_scale)
        self.sjwendu3.setFont(sjwendu3font)

        self.sjwendu3Txt = QLabel(self.sjwendu3)
        self.sjwendu3Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjwendu3Txt.setText('130℃')
        self.sjwendu3Txt.setGeometry(115*self.width_scale, 0, 120*self.width_scale, 75*self.height_scale)
        self.sjwendu3Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjwendu3Txt.setFont(hbscfont)

        self.sjckz3 = QLabel(self.historyInfo)
        self.sjckz3.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjckz3.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #9AD8FB; color:#A8A8A8;padding-left: 20px;')
        self.sjckz3.setGeometry(1098*self.width_scale, 1370*self.height_scale, 235*self.width_scale, 75*self.height_scale)
        self.sjckz3.setText('参考值')
        self.sjckz3.setFont(sjwendu3font)

        self.sjckz3Txt = QLabel(self.sjckz3)
        self.sjckz3Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjckz3Txt.setText('30RH%')
        self.sjckz3Txt.setGeometry(85*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.sjckz3Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjckz3Txt.setFont(hbscfont)

        self.sjpc3 = QLabel(self.historyInfo)
        self.sjpc3.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjpc3.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #FC958A; color:#A8A8A8;padding-left: 20px;')
        self.sjpc3.setGeometry(1338*self.width_scale, 1370*self.height_scale, 200*self.width_scale, 75*self.height_scale)
        self.sjpc3.setText('偏差')
        self.sjpc3.setFont(sjwendu3font)

        self.sjpc3Txt = QLabel(self.sjpc3)
        self.sjpc3Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjpc3Txt.setText('1%')
        self.sjpc3Txt.setGeometry(50*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.sjpc3Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjpc3Txt.setFont(hbscfont)

        self.sjStage4 = QLabel(self.historyInfo)
        self.sjStage4.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjStage4.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.sjStage4.setGeometry(718*self.width_scale, 1451*self.height_scale, 135*self.width_scale, 75*self.height_scale)
        self.sjStage4.setText('阶段4')
        self.sjStage4.setFont(zhongliangfont)

        self.sjwendu4 = QLabel(self.historyInfo)
        self.sjwendu4.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjwendu4.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #FBBE9A; color:#A8A8A8;padding-left: 20px;')
        self.sjwendu4.setGeometry(857*self.width_scale, 1451*self.height_scale, 235*self.width_scale, 75*self.height_scale)
        self.sjwendu4.setText('温度')
        sjwendu4font = QFont(self.font_family4, 18*self.width_scale)
        self.sjwendu4.setFont(sjwendu4font)

        self.sjwendu4Txt = QLabel(self.sjwendu4)
        self.sjwendu4Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjwendu4Txt.setText('130℃')
        self.sjwendu4Txt.setGeometry(115*self.width_scale, 0, 120*self.width_scale, 75*self.height_scale)
        self.sjwendu4Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjwendu4Txt.setFont(hbscfont)

        self.sjckz4 = QLabel(self.historyInfo)
        self.sjckz4.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjckz4.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #9AD8FB; color:#A8A8A8;padding-left: 20px;')
        self.sjckz4.setGeometry(1098*self.width_scale, 1451*self.height_scale, 235*self.width_scale, 75*self.height_scale)
        self.sjckz4.setText('参考值')
        self.sjckz4.setFont(sjwendu4font)

        self.sjckz4Txt = QLabel(self.sjckz4)
        self.sjckz4Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjckz4Txt.setText('30RH%')
        self.sjckz4Txt.setGeometry(85*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.sjckz4Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjckz4Txt.setFont(hbscfont)

        self.sjpc4 = QLabel(self.historyInfo)
        self.sjpc4.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjpc4.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #FC958A; color:#A8A8A8;padding-left: 20px;')
        self.sjpc4.setGeometry(1338*self.width_scale, 1451*self.height_scale, 200*self.width_scale, 75*self.height_scale)
        self.sjpc4.setText('偏差')
        self.sjpc4.setFont(sjwendu4font)

        self.sjpc4Txt = QLabel(self.sjpc4)
        self.sjpc4Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjpc4Txt.setText('1%')
        self.sjpc4Txt.setGeometry(50*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.sjpc4Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjpc4Txt.setFont(hbscfont)

        self.sjStage5 = QLabel(self.historyInfo)
        self.sjStage5.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjStage5.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.sjStage5.setGeometry(718*self.width_scale, 1532*self.height_scale, 135*self.width_scale, 75*self.height_scale)
        self.sjStage5.setText('阶段5')
        self.sjStage5.setFont(zhongliangfont)

        self.sjwendu5 = QLabel(self.historyInfo)
        self.sjwendu5.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjwendu5.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #FBBE9A; color:#A8A8A8;padding-left: 20px;')
        self.sjwendu5.setGeometry(857*self.width_scale, 1532*self.height_scale, 235*self.width_scale, 75*self.height_scale)
        self.sjwendu5.setText('温度')
        sjwendu5font = QFont(self.font_family4, 18*self.width_scale)
        self.sjwendu5.setFont(sjwendu5font)

        self.sjwendu5Txt = QLabel(self.sjwendu5)
        self.sjwendu5Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjwendu5Txt.setText('130℃')
        self.sjwendu5Txt.setGeometry(115*self.width_scale, 0, 120*self.width_scale, 75*self.height_scale)
        self.sjwendu5Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjwendu5Txt.setFont(hbscfont)

        self.sjckz5 = QLabel(self.historyInfo)
        self.sjckz5.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjckz5.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #9AD8FB; color:#A8A8A8;padding-left: 20px;')
        self.sjckz5.setGeometry(1098*self.width_scale, 1532*self.height_scale, 235*self.width_scale, 75*self.height_scale)
        self.sjckz5.setText('参考值')
        self.sjckz5.setFont(sjwendu5font)

        self.sjckz5Txt = QLabel(self.sjckz5)
        self.sjckz5Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjckz5Txt.setText('30RH%')
        self.sjckz5Txt.setGeometry(85*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.sjckz5Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjckz5Txt.setFont(hbscfont)

        self.sjpc5 = QLabel(self.historyInfo)
        self.sjpc5.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjpc5.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #FC958A; color:#A8A8A8;padding-left: 20px;')
        self.sjpc5.setGeometry(1338*self.width_scale, 1532*self.height_scale, 200*self.width_scale, 75*self.height_scale)
        self.sjpc5.setText('偏差')
        self.sjpc5.setFont(sjwendu5font)

        self.sjpc5Txt = QLabel(self.sjpc5)
        self.sjpc5Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjpc5Txt.setText('1%')
        self.sjpc5Txt.setGeometry(50*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.sjpc5Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjpc5Txt.setFont(hbscfont)

        self.sjStage6 = QLabel(self.historyInfo)
        self.sjStage6.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjStage6.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.sjStage6.setGeometry(718*self.width_scale, 1613*self.height_scale, 135*self.width_scale, 75*self.height_scale)
        self.sjStage6.setText('阶段6')
        self.sjStage6.setFont(zhongliangfont)

        self.sjwendu6 = QLabel(self.historyInfo)
        self.sjwendu6.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjwendu6.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #FBBE9A; color:#A8A8A8;padding-left: 20px;')
        self.sjwendu6.setGeometry(857*self.width_scale, 1613*self.height_scale, 235*self.width_scale, 75*self.height_scale)
        self.sjwendu6.setText('温度')
        sjwendu6font = QFont(self.font_family4, 18*self.width_scale)
        self.sjwendu6.setFont(sjwendu6font)

        self.sjwendu6Txt = QLabel(self.sjwendu6)
        self.sjwendu6Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjwendu6Txt.setText('130℃')
        self.sjwendu6Txt.setGeometry(115*self.width_scale, 0, 120*self.width_scale, 75*self.height_scale)
        self.sjwendu6Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjwendu6Txt.setFont(hbscfont)

        self.sjckz6 = QLabel(self.historyInfo)
        self.sjckz6.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjckz6.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #9AD8FB; color:#A8A8A8;padding-left: 20px;')
        self.sjckz6.setGeometry(1098*self.width_scale, 1613*self.height_scale, 235*self.width_scale, 75*self.height_scale)
        self.sjckz6.setText('参考值')
        self.sjckz6.setFont(sjwendu6font)

        self.sjckz6Txt = QLabel(self.sjckz6)
        self.sjckz6Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjckz6Txt.setText('30RH%')
        self.sjckz6Txt.setGeometry(85*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.sjckz6Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjckz6Txt.setFont(hbscfont)

        self.sjpc6 = QLabel(self.historyInfo)
        self.sjpc6.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.sjpc6.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #FC958A; color:#A8A8A8;padding-left: 20px;')
        self.sjpc6.setGeometry(1338*self.width_scale, 1613*self.height_scale, 200*self.width_scale, 75*self.height_scale)
        self.sjpc6.setText('偏差')
        self.sjpc6.setFont(sjwendu6font)

        self.sjpc6Txt = QLabel(self.sjpc6)
        self.sjpc6Txt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sjpc6Txt.setText('1%')
        self.sjpc6Txt.setGeometry(50*self.width_scale, 0, 150*self.width_scale, 75*self.height_scale)
        self.sjpc6Txt.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.sjpc6Txt.setFont(hbscfont)

        self.qingkaungfankui = QLabel(self.historyInfo)
        self.qingkaungfankui.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.qingkaungfankui.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.qingkaungfankui.setGeometry(60*self.width_scale, 1713*self.height_scale, 1479*self.width_scale, 75*self.height_scale)
        self.qingkaungfankui.setText('情况反馈')
        qingkaungfankuifont = QFont(self.font_family4, 18*self.width_scale)
        self.qingkaungfankui.setFont(qingkaungfankuifont)

        self.qkfkContent = QLabel(self.qingkaungfankui)
        self.qkfkContent.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.qkfkContent.setText('配方1')
        self.qkfkContent.setGeometry(1239*self.width_scale, 0, 240*self.width_scale, 75*self.height_scale)
        self.qkfkContent.setStyleSheet("background-color: transparent; border:none;color: #222222;padding-right: 20px;")
        self.qkfkContent.setFont(hbscfont)

        self.zhongliang = QLabel(self.historyInfo)
        self.zhongliang.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.zhongliang.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.zhongliang.setGeometry(60*self.width_scale, 1794*self.height_scale, 239*self.width_scale, 75*self.height_scale)
        self.zhongliang.setText('重量')
        zhongliangfont = QFont(self.font_family4, 18*self.width_scale)
        self.zhongliang.setFont(zhongliangfont)

        self.shoudou = QLabel(self.historyInfo)
        self.shoudou.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.shoudou.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.shoudou.setGeometry(303*self.width_scale, 1794*self.height_scale, 356*self.width_scale, 75*self.height_scale)
        self.shoudou.setText('熟豆')
        shoudoufont = QFont(self.font_family4, 18*self.width_scale)
        self.shoudou.setFont(shoudoufont)

        self.shoudouNum = QLabel(self.shoudou)
        self.shoudouNum.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.shoudouNum.setText('600g')
        self.shoudouNum.setGeometry(216*self.width_scale, 0, 140*self.width_scale, 75*self.height_scale)
        self.shoudouNum.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.shoudouNum.setFont(hbscfont)

        self.hbssl = QLabel(self.historyInfo)
        self.hbssl.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.hbssl.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.hbssl.setGeometry(666*self.width_scale, 1794*self.height_scale, 356*self.width_scale, 75*self.height_scale)
        self.hbssl.setText('烘焙损失率')
        hbsslfont = QFont(self.font_family4, 18*self.width_scale)
        self.hbssl.setFont(hbsslfont)

        self.hbsslNum = QLabel(self.hbssl)
        self.hbsslNum.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.hbsslNum.setText('600g')
        self.hbsslNum.setGeometry(216*self.width_scale, 0, 140*self.width_scale, 75*self.height_scale)
        self.hbsslNum.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.hbsslNum.setFont(hbscfont)

        self.hbrq = QLabel(self.historyInfo)
        self.hbrq.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.hbrq.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.hbrq.setGeometry(1028*self.width_scale, 1794*self.height_scale, 510*self.width_scale, 75*self.height_scale)
        self.hbrq.setText('烘焙日期')
        hbrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.hbrq.setFont(hbrqfont)

        self.hbrqNum = QLabel(self.hbrq)
        self.hbrqNum.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.hbrqNum.setText('-')
        self.hbrqNum.setGeometry(200*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.hbrqNum.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.hbrqNum.setFont(hbscfont)

        self.bcpf = QLabel(self.historyInfo)
        self.bcpf.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.bcpf.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.bcpf.setGeometry(60*self.width_scale, 1896*self.height_scale, 734*self.width_scale, 75*self.height_scale)
        self.bcpf.setText('杯测评分')
        bcpffont = QFont(self.font_family4, 18*self.width_scale)
        self.bcpf.setFont(bcpffont)

        self.bcpfNum = QLabel(self.bcpf)
        self.bcpfNum.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.bcpfNum.setText('80分')
        self.bcpfNum.setGeometry(534*self.width_scale, 0, 210*self.width_scale, 75*self.height_scale)
        self.bcpfNum.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.bcpfNum.setFont(hbscfont)

        self.hbpf = QLabel(self.historyInfo)
        self.hbpf.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.hbpf.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.hbpf.setGeometry(804*self.width_scale, 1896*self.height_scale, 734*self.width_scale, 75*self.height_scale)
        self.hbpf.setText('烘焙评分')
        hbpffont = QFont(self.font_family4, 18*self.width_scale)
        self.hbpf.setFont(hbpffont)

        self.hbpfNum = QLabel(self.hbpf)
        self.hbpfNum.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.hbpfNum.setText('80分')
        self.hbpfNum.setGeometry(534*self.width_scale, 0, 210*self.width_scale, 75*self.height_scale)
        self.hbpfNum.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.hbpfNum.setFont(hbscfont)

        self.agtronzhi = QLabel(self.historyInfo)
        self.agtronzhi.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.agtronzhi.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.agtronzhi.setGeometry(60*self.width_scale, 1977*self.height_scale, 734*self.width_scale, 75*self.height_scale)
        self.agtronzhi.setText('Agtron值')
        agtronzhifont = QFont(self.font_family4, 18*self.width_scale)
        self.agtronzhi.setFont(agtronzhifont)

        self.agtronzhiNum = QLabel(self.agtronzhi)
        self.agtronzhiNum.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.agtronzhiNum.setText('80分')
        self.agtronzhiNum.setGeometry(534*self.width_scale, 0, 210*self.width_scale, 75*self.height_scale)
        self.agtronzhiNum.setStyleSheet(
            "background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.agtronzhiNum.setFont(agtronzhifont)

        self.bcrq = QLabel(self.historyInfo)
        self.bcrq.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.bcrq.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.bcrq.setGeometry(804*self.width_scale, 1977*self.height_scale, 734*self.width_scale, 75*self.height_scale)
        self.bcrq.setText('杯测日期')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.bcrq.setFont(bcrqfont)

        self.bcrqNum = QLabel(self.bcrq)
        self.bcrqNum.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.bcrqNum.setText('80分')
        self.bcrqNum.setGeometry(434*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.bcrqNum.setStyleSheet(
            "background-color: transparent; border:none;color: #A8A8A8;padding-right: 20px;")
        self.bcrqNum.setFont(bcrqfont)

        self.pkfk = QLabel(self.historyInfo)
        self.pkfk.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.pkfk.setStyleSheet(
            f'border-radius: {10*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #DAD6D3; color:#A8A8A8;padding-left: 20px;')
        self.pkfk.setGeometry(60*self.width_scale, 2058*self.height_scale, 1479*self.width_scale, 75*self.height_scale)
        self.pkfk.setText('品控反馈')
        pkfkfont = QFont(self.font_family4, 18*self.width_scale)
        self.pkfk.setFont(pkfkfont)

        self.pkfkTxt = QLabel(self.pkfk)
        self.pkfkTxt.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.pkfkTxt.setText('配方1')
        self.pkfkTxt.setGeometry(1239 * self.width_scale, 0, 340 * self.width_scale, 75 * self.height_scale)
        self.pkfkTxt.setStyleSheet("background-color: transparent; border:none;color: #222222;padding-right: 20px;")
        self.pkfkTxt.setFont(hbscfont)

        self.zhezhaoLabel = QLabel(self.historyInfo)
        self.zhezhaoLabel.setGeometry(0, 0, 1600*self.width_scale, 2739*self.height_scale)
        self.zhezhaoLabel.setStyleSheet(f"background-color: rgba(0, 0, 0, 0);border-radius: {25*self.height_scale}px;")
        self.zhezhao = QPixmap(self.normalized_path + '/includes/Icons/history/back_L2.png')
        self.zhezhaoLabel.setPixmap(self.zhezhao)
        self.zhezhaoLabel.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.zhezhaoLabel.setScaledContents(True)


        self.historyAnalyse = QLabel(self)  # 历史记录-分析
        self.historyAnalyse.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #ffffff; border: 1px solid #A7A8AC; ')
        self.historyAnalyse.setGeometry(231*self.width_scale, 200*self.height_scale, 1600*self.width_scale, 2739*self.height_scale)
        self.historyAnalyseImg = QPixmap(self.normalized_path + '/includes/Icons/history/back_L.png')
        self.historyAnalyse.setScaledContents(True)
        self.historyAnalyse.setPixmap(self.historyAnalyseImg)
        self.historyAnalyse.setMinimumSize(1600*self.width_scale, 2739*self.height_scale)
        self.historyAnalyse.setVisible(False)

        self.history_sheibei1 = QLabel(self.historyAnalyse)
        self.history_sheibei1.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.history_sheibei1.setStyleSheet(f'border-radius: {19*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #C8402C; ')
        self.history_sheibei1.setGeometry(60*self.width_scale, 30*self.height_scale, 265*self.width_scale, 38*self.height_scale)
        self.history_sheibei1.setText('-')
        history_sheibeifont = QFont(self.font_family4, 10*self.width_scale)
        self.history_sheibei1.setFont(history_sheibeifont)

        self.history_sheibei2 = QLabel(self.historyAnalyse)
        self.history_sheibei2.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.history_sheibei2.setStyleSheet(f'border-radius: {19*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #E5B547; ')
        self.history_sheibei2.setGeometry(340 * self.width_scale, 30 * self.height_scale, 265 * self.width_scale,
                                          38 * self.height_scale)
        self.history_sheibei2.setText('-')
        self.history_sheibei2.setFont(history_sheibeifont)

        self.history_sheibei3 = QLabel(self.historyAnalyse)
        self.history_sheibei3.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.history_sheibei3.setStyleSheet(f'border-radius: {19*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #44AB6B; ')
        self.history_sheibei3.setGeometry(621 * self.width_scale, 30 * self.height_scale, 265 * self.width_scale,
                                          38 * self.height_scale)
        self.history_sheibei3.setText('-')
        self.history_sheibei3.setFont(history_sheibeifont)

        self.history_sheibei4 = QLabel(self.historyAnalyse)
        self.history_sheibei4.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.history_sheibei4.setStyleSheet(f'border-radius: {19*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #258B96; ')
        self.history_sheibei4.setGeometry(902 * self.width_scale, 30 * self.height_scale, 265 * self.width_scale,
                                          38 * self.height_scale)
        self.history_sheibei4.setText('-')
        self.history_sheibei4.setFont(history_sheibeifont)

        self.updateCloud = QPushButton(self.historyAnalyse)
        self.updateCloud.setGeometry(1440*self.width_scale, 30*self.height_scale, 40*self.width_scale, 40*self.height_scale)
        self.updateCloud.setCheckable(True)
        self.updateCloud.setStyleSheet(f"""
                                            QPushButton {{
                                                border-image: url('{self.normalized_path}//includes/Icons/history/down.png');
                                                border: none;background-color:transparent;
                                            }}
                                        """)
        # self.updateCloud.clicked.connect(self.toggle_password_visibility)

        self.closeAnalyse = QPushButton(self.historyAnalyse)
        self.closeAnalyse.setGeometry(1500*self.width_scale, 30*self.height_scale, 40*self.width_scale, 40*self.height_scale)
        self.closeAnalyse.setCheckable(True)
        self.closeAnalyse.setStyleSheet(f"""
                                                    QPushButton {{
                                                        border-image: url('{self.normalized_path}/includes/Icons/history/fanhui.png');
                                                        border: none;background-color:transparent;
                                                    }}
                                                """)
        self.closeAnalyse.clicked.connect(self.closeAnalyseClick)

        self.hfChartKey2 = QLabel(self.historyAnalyse)
        self.hfChartKey2.setStyleSheet(f'border-radius: {28*self.height_scale}px;background-color: #D3C9C2;border: none')
        self.hfChartKey2.setGeometry(60*self.width_scale, 731*self.height_scale, 1481*self.width_scale, 56*self.height_scale)

        self.matplotlib_widget = MatplotlibWidget(self.historyAnalyse)
        self.matplotlib_widget.setGeometry(35*self.width_scale, 104*self.height_scale, 1541*self.width_scale, 600*self.height_scale)

        # self.timex_dw = [[], [], [], []]  # 存储豆温的 timex 数据
        # self.temp_dw = [[], [], [], []]  # 存储豆温的温度数据
        # self.timex_fw = [[], [], [], []]  # 存储风温的 timex 数据
        # self.temp_fw = [[], [], [], []]  # 存储风温的温度数据

        self.analyse_dw = QPushButton(self.hfChartKey2)
        self.analyse_dw.setStyleSheet(f'border-radius: {16*self.height_scale}px;background-color: #FBF8F5;border: 2px solid #D18F65')
        self.analyse_dw.setGeometry(271*self.width_scale, 13*self.height_scale, 64*self.width_scale, 32*self.height_scale)
        self.analyse_dw.setText("豆温")
        analyse_dwfont = QFont(self.font_family4, 14 * self.width_scale)
        self.analyse_dw.setFont(analyse_dwfont)
        # self.analyse_dw.clicked.connect(self.toggle_analyse_dw)

        self.analyse_fw = QPushButton(self.hfChartKey2)
        self.analyse_fw.setStyleSheet(f'border-radius: {16*self.height_scale}px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
        self.analyse_fw.setGeometry(441 * self.width_scale, 13 * self.height_scale, 64 * self.width_scale,
                                    32 * self.height_scale)
        self.analyse_fw.setText("风温")
        self.analyse_fw.setFont(analyse_dwfont)
        # self.analyse_fw.clicked.connect(self.toggle_analyse_fw)



        self.analyse_ROR = QPushButton(self.hfChartKey2)
        self.analyse_ROR.setStyleSheet(f'border-radius: {16*self.height_scale}px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
        self.analyse_ROR.setGeometry(610 * self.width_scale, 13 * self.height_scale, 64 * self.width_scale,
                                     32 * self.height_scale)
        self.analyse_ROR.setText("ROR")
        self.analyse_ROR.setFont(analyse_dwfont)
        # self.analyse_ROR.clicked.connect(self.toggle_analyse_ROR)

        self.analyse_Agtron = QPushButton(self.hfChartKey2)
        self.analyse_Agtron.setStyleSheet(f'border-radius: {16*self.height_scale}px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
        self.analyse_Agtron.setGeometry(780 * self.width_scale, 13 * self.height_scale, 64 * self.width_scale,
                                        32 * self.height_scale)
        self.analyse_Agtron.setText("色值")
        self.analyse_Agtron.setFont(analyse_dwfont)
        # self.analyse_Agtron.clicked.connect(self.toggle_analyse_Agtron)

        self.analyse_pqsd = QPushButton(self.hfChartKey2)
        self.analyse_pqsd.setStyleSheet(f'border-radius: {16*self.height_scale}px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
        self.analyse_pqsd.setGeometry(957 * self.width_scale, 13 * self.height_scale, 100 * self.width_scale,
                                      32 * self.height_scale)
        self.analyse_pqsd.setText("排气湿度")
        self.analyse_pqsd.setFont(analyse_dwfont)
        # self.analyse_pqsd.clicked.connect(self.toggle_analyse_pqsd)

        self.analyse_pqwd = QPushButton(self.hfChartKey2)
        self.analyse_pqwd.setStyleSheet(f'border-radius: {16*self.height_scale}px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
        self.analyse_pqwd.setGeometry(1126 * self.width_scale, 13 * self.height_scale, 100 * self.width_scale,
                                      32 * self.height_scale)
        self.analyse_pqwd.setText("排气温度")
        self.analyse_pqwd.setFont(analyse_dwfont)
        # self.analyse_pqwd.clicked.connect(self.toggle_analyse_pqwd)


        self.kstTxt = QLabel(self.historyAnalyse)
        self.kstTxt.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.kstTxt.setText('可视图')
        self.kstTxt.setGeometry(60*self.width_scale, 868*self.height_scale, 240*self.width_scale, 30*self.height_scale)
        self.kstTxt.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        self.kstTxt.setFont(hbscfont)

        self.kstTxt = QLabel(self.historyAnalyse)
        self.kstTxt.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.kstTxt.setText('AI值')
        self.kstTxt.setGeometry(58*self.width_scale, 930*self.height_scale, 90*self.width_scale, 66*self.height_scale)
        self.kstTxt.setStyleSheet("background-color: transparent; border:none;color: #2187F9;")
        self.kstTxt.setFont(hbscfont)

        self.aikst = QLabel(self.historyAnalyse)
        self.aikst.setGeometry(136*self.width_scale, 930*self.height_scale, 1403*self.width_scale, 66*self.height_scale)
        self.aikst.setStyleSheet(f"background-color: transparent; border:1px solid #DAD6D3; border-radius: {10*self.height_scale}px;")

        self.aikstColor = QLabel(self.aikst)
        self.aikstColor.setGeometry(5*self.width_scale, 15*self.height_scale, 10*self.width_scale, 36*self.height_scale)
        self.aikstColor.setStyleSheet(f"background-color: #2187F9; border:none;border-radius: {5*self.height_scale}px;")

        self.aikstTxt1 = QLabel(self.aikst)
        self.aikstTxt1.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.aikstTxt1.setText('入豆温度: 165℃   回温点: 80℃/01:30')
        self.aikstTxt1.setGeometry(16*self.width_scale, 3*self.height_scale, 647*self.width_scale, 60*self.height_scale)
        self.aikstTxt1.setStyleSheet(f"background-color: #DFD6C9; border:none;color: #9C6D4E;border-radiu: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        kstTxtFont = QFont(self.font_family4, 14*self.width_scale)
        self.aikstTxt1.setFont(kstTxtFont)

        self.aikstTxt2 = QLabel(self.aikst)
        self.aikstTxt2.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.aikstTxt2.setText('转黄点: 150℃/05:30')
        self.aikstTxt2.setGeometry(664*self.width_scale, 3*self.height_scale, 378*self.width_scale, 60*self.height_scale)
        self.aikstTxt2.setStyleSheet(f"background-color: #D6C590; border:none;color: #B97A0A;border-radius: {8*self.height_scale}px;px;padding-left:9px")
        self.aikstTxt2.setFont(kstTxtFont)

        self.aikstTxt3 = QLabel(self.aikst)
        self.aikstTxt3.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.aikstTxt3.setText('一爆: 220℃/12:00')
        self.aikstTxt3.setGeometry(1043*self.width_scale, 3*self.height_scale, 357*self.width_scale, 60*self.height_scale)
        self.aikstTxt3.setStyleSheet(f"background-color: #BFA585; border:none;color: #945726;border-radius: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        self.aikstTxt3.setFont(kstTxtFont)

        self.kstTxt = QLabel(self.historyAnalyse)
        self.kstTxt.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.kstTxt.setText('No.1')
        self.kstTxt.setGeometry(58*self.width_scale, 1000*self.height_scale, 90*self.width_scale, 60*self.height_scale)
        self.kstTxt.setStyleSheet("background-color: transparent; border:none;color: #C8402C;")
        self.kstTxt.setFont(hbscfont)

        self.oneKST = QLabel(self.historyAnalyse)
        self.oneKST.setGeometry(136*self.width_scale, 999*self.height_scale, 1403*self.width_scale, 66*self.height_scale)
        self.oneKST.setStyleSheet(f"background-color: transparent; border:1px solid #DAD6D3; border-radius: {10*self.height_scale}px;")

        self.oneKSTColor = QLabel(self.oneKST)
        self.oneKSTColor.setGeometry(5*self.width_scale, 15*self.height_scale, 10*self.width_scale, 36*self.height_scale)
        self.oneKSTColor.setStyleSheet(f"background-color: #C8402C; border:none;border-radius: {5*self.height_scale}px;")

        self.onekstTxt1 = QLabel(self.oneKST)
        self.onekstTxt1.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.onekstTxt1.setText('入豆温度: 168℃   回温点: 80℃/01:30')
        self.onekstTxt1.setGeometry(16*self.width_scale, 3*self.height_scale, 647*self.width_scale, 60*self.height_scale)
        self.onekstTxt1.setStyleSheet(
            f"background-color: #DFD6C9; border:none;color: #9C6D4E;border-radius: 8px;padding-left:{9*self.height_scale}px")
        kstTxtFont = QFont(self.font_family4, 14*self.width_scale)
        self.onekstTxt1.setFont(kstTxtFont)

        self.onekstTxt2 = QLabel(self.oneKST)
        self.onekstTxt2.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.onekstTxt2.setText('转黄点: 150℃/05:30')
        self.onekstTxt2.setGeometry(664*self.width_scale, 3*self.height_scale, 378*self.width_scale, 60*self.height_scale)
        self.onekstTxt2.setStyleSheet(
            f"background-color: #D6C590; border:none;color: #B97A0A;border-radius: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        self.onekstTxt2.setFont(kstTxtFont)

        self.onekstTxt3 = QLabel(self.oneKST)
        self.onekstTxt3.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.onekstTxt3.setText('一爆: 220℃/12:00')
        self.onekstTxt3.setGeometry(1043*self.width_scale, 3*self.height_scale, 357*self.width_scale, 60*self.height_scale)
        self.onekstTxt3.setStyleSheet(
            f"background-color: #BFA585; border:none;color: #945726;border-radius: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        self.onekstTxt3.setFont(kstTxtFont)

        self.kstTxt = QLabel(self.historyAnalyse)
        self.kstTxt.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.kstTxt.setText('No.2')
        self.kstTxt.setGeometry(58*self.width_scale, 1070*self.height_scale, 90*self.width_scale, 60*self.height_scale)
        self.kstTxt.setStyleSheet("background-color: transparent; border:none;color: #E5B547;")
        self.kstTxt.setFont(hbscfont)

        self.twoKST = QLabel(self.historyAnalyse)
        self.twoKST.setGeometry(136*self.width_scale, 1068*self.height_scale, 1403*self.width_scale, 66*self.height_scale)
        self.twoKST.setStyleSheet(f"background-color: transparent; border:1px solid #DAD6D3; border-radius: {10*self.height_scale}px;")

        self.twoKSTColor = QLabel(self.twoKST)
        self.twoKSTColor.setGeometry(5*self.width_scale, 15*self.height_scale, 10*self.width_scale, 36*self.height_scale)
        self.twoKSTColor.setStyleSheet(f"background-color: #E5B547; border:none;border-radius: {5*self.height_scale}px")

        self.twokstTxt1 = QLabel(self.twoKST)
        self.twokstTxt1.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.twokstTxt1.setText('入豆温度: 168℃   回温点: 80℃/01:30')
        self.twokstTxt1.setGeometry(16*self.width_scale, 3*self.height_scale, 647*self.width_scale, 60*self.height_scale)
        self.twokstTxt1.setStyleSheet(
            f"background-color: #DFD6C9; border:none;color: #9C6D4E;border-radius: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        self.twokstTxt1.setFont(kstTxtFont)

        self.twokstTxt2 = QLabel(self.twoKST)
        self.twokstTxt2.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.twokstTxt2.setText('转黄点: 150℃/05:30')
        self.twokstTxt2.setGeometry(664*self.width_scale, 3*self.height_scale, 378*self.width_scale, 60*self.height_scale)
        self.twokstTxt2.setStyleSheet(
            f"background-color: #D6C590; border:none;color: #B97A0A;border-radius: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        self.twokstTxt2.setFont(kstTxtFont)

        self.twokstTxt3 = QLabel(self.twoKST)
        self.twokstTxt3.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.twokstTxt3.setText('一爆: 220℃/12:00')
        self.twokstTxt3.setGeometry(1043*self.width_scale, 3*self.height_scale, 357*self.width_scale, 60*self.height_scale)
        self.twokstTxt3.setStyleSheet(
            f"background-color: #BFA585; border:none;color: #945726;border-radius: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        self.twokstTxt3.setFont(kstTxtFont)

        self.kstTxt = QLabel(self.historyAnalyse)
        self.kstTxt.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.kstTxt.setText('No.3')
        self.kstTxt.setGeometry(58*self.width_scale, 1140*self.height_scale, 90*self.width_scale, 60*self.height_scale)
        self.kstTxt.setStyleSheet("background-color: transparent; border:none;color: #44AB6B;")
        self.kstTxt.setFont(hbscfont)

        self.threeKST = QLabel(self.historyAnalyse)
        self.threeKST.setGeometry(136*self.width_scale, 1137*self.height_scale, 1403*self.width_scale, 66*self.height_scale)
        self.threeKST.setStyleSheet(f"background-color: transparent; border:1px solid #DAD6D3; border-radius: {10*self.height_scale}px;")

        self.threeKSTColor = QLabel(self.threeKST)
        self.threeKSTColor.setGeometry(5*self.width_scale, 15*self.height_scale, 10*self.width_scale, 36*self.height_scale)
        self.threeKSTColor.setStyleSheet(f"background-color: #44AB6B; border:none;border-radius: {5*self.height_scale}px")

        self.threekstTxt1 = QLabel(self.threeKST)
        self.threekstTxt1.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.threekstTxt1.setText('入豆温度: 168℃   回温点: 80℃/01:30')
        self.threekstTxt1.setGeometry(16*self.width_scale, 3*self.height_scale, 647*self.width_scale, 60*self.height_scale)
        self.threekstTxt1.setStyleSheet(
            f"background-color: #DFD6C9; border:none;color: #9C6D4E;border-radius: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        self.threekstTxt1.setFont(kstTxtFont)

        self.threekstTxt2 = QLabel(self.threeKST)
        self.threekstTxt2.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.threekstTxt2.setText('转黄点: 150℃/05:30')
        self.threekstTxt2.setGeometry(664*self.width_scale, 3*self.height_scale, 378*self.width_scale, 60*self.height_scale)
        self.threekstTxt2.setStyleSheet(
            f"background-color: #D6C590; border:none;color: #B97A0A;border-radius: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        self.threekstTxt2.setFont(kstTxtFont)

        self.threekstTxt3 = QLabel(self.threeKST)
        self.threekstTxt3.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.threekstTxt3.setText('一爆: 220℃/12:00')
        self.threekstTxt3.setGeometry(1043*self.width_scale, 3*self.height_scale, 357*self.width_scale, 60*self.height_scale)
        self.threekstTxt3.setStyleSheet(
            f"background-color: #BFA585; border:none;color: #945726;border-radius: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        self.threekstTxt3.setFont(kstTxtFont)

        self.kstTxt = QLabel(self.historyAnalyse)
        self.kstTxt.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.kstTxt.setText('No.4')
        self.kstTxt.setGeometry(58*self.width_scale, 1210*self.height_scale, 90*self.width_scale, 60*self.height_scale)
        self.kstTxt.setStyleSheet("background-color: transparent; border:none;color: #258B96;")
        self.kstTxt.setFont(hbscfont)

        self.fourKST = QLabel(self.historyAnalyse)
        self.fourKST.setGeometry(136*self.width_scale, 1206*self.height_scale, 1403*self.width_scale, 66*self.height_scale)
        self.fourKST.setStyleSheet(f"background-color: transparent; border:1px solid #DAD6D3; border-radius: {10*self.height_scale}px;")

        self.fourKSTColor = QLabel(self.fourKST)
        self.fourKSTColor.setGeometry(5*self.width_scale, 15*self.height_scale, 10*self.width_scale, 36*self.height_scale)
        self.fourKSTColor.setStyleSheet(f"background-color: #258B96; border:none;border-radius: {5*self.height_scale}")

        self.fourkstTxt1 = QLabel(self.fourKST)
        self.fourkstTxt1.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.fourkstTxt1.setText('入豆温度: 168℃   回温点: 80℃/01:30')
        self.fourkstTxt1.setGeometry(16*self.width_scale, 3*self.height_scale, 647*self.width_scale, 60*self.height_scale)
        self.fourkstTxt1.setStyleSheet(
            f"background-color: #DFD6C9; border:none;color: #9C6D4E;border-radius: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        self.fourkstTxt1.setFont(kstTxtFont)

        self.fourkstTxt2 = QLabel(self.fourKST)
        self.fourkstTxt2.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.fourkstTxt2.setText('转黄点: 150℃/05:30')
        self.fourkstTxt2.setGeometry(664*self.width_scale, 3*self.height_scale, 378*self.width_scale, 60*self.height_scale)
        self.fourkstTxt2.setStyleSheet(
            f"background-color: #D6C590; border:none;color: #B97A0A;border-radius: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        self.fourkstTxt2.setFont(kstTxtFont)

        self.fourkstTxt3 = QLabel(self.fourKST)
        self.fourkstTxt3.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        self.fourkstTxt3.setText('一爆: 220℃/12:00')
        self.fourkstTxt3.setGeometry(1043*self.width_scale, 3*self.height_scale, 357*self.width_scale, 60*self.height_scale)
        self.fourkstTxt3.setStyleSheet(
            f"background-color: #BFA585; border:none;color: #945726;border-radius: {8*self.height_scale}px;padding-left:{9*self.height_scale}px")
        self.fourkstTxt3.setFont(kstTxtFont)

        # self.analyseTimeNum = QLabel(self.historyAnalyse)
        # self.analyseTimeNum.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        # self.analyseTimeNum.setText('0')
        # self.analyseTimeNum.setGeometry(0, 0, 30*self.width_scale, 24*self.height_scale)
        # self.analyseTimeNum.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        # analyseTimeNumfont = QFont(self.font_family4, 18*self.width_scale)
        # self.analyseTimeNum.setFont(analyseTimeNumfont)

        self.tsqColor1 = QLabel(self.historyAnalyse)
        self.tsqColor1.setGeometry(409*self.width_scale, 1371*self.height_scale, 20*self.width_scale, 20*self.height_scale)
        self.tsqColor1.setStyleSheet(f"background-color: #DFD6C9; border:none;border-radius: {10*self.height_scale}px;")

        self.tsqText1 = QLabel(self.historyAnalyse)
        self.tsqText1.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.tsqText1.setText('脱水期')
        self.tsqText1.setGeometry(439*self.width_scale, 1369*self.height_scale, 60*self.width_scale, 24*self.height_scale)
        self.tsqText1.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        tsqText1font = QFont(self.font_family4, 14*self.width_scale)
        self.tsqText1.setFont(tsqText1font)

        self.tsqColor2 = QLabel(self.historyAnalyse)
        self.tsqColor2.setGeometry(727*self.width_scale, 1371*self.height_scale, 20*self.width_scale, 20*self.height_scale)
        self.tsqColor2.setStyleSheet(f"background-color: #D4C28B; border:none;border-radius: {10*self.height_scale}px;")

        self.tsqText2 = QLabel(self.historyAnalyse)
        self.tsqText2.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.tsqText2.setText('转黄点')
        self.tsqText2.setGeometry(757*self.width_scale, 1369*self.height_scale, 60*self.width_scale, 24*self.height_scale)
        self.tsqText2.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        tsqText2font = QFont(self.font_family4, 14*self.width_scale)
        self.tsqText2.setFont(tsqText2font)

        self.tsqColor2 = QLabel(self.historyAnalyse)
        self.tsqColor2.setGeometry(1044*self.width_scale, 1371*self.height_scale, 20*self.width_scale, 20*self.height_scale)
        self.tsqColor2.setStyleSheet(f"background-color: #C9AA8E; border:none;border-radius: {10*self.height_scale}px;")

        self.tsqText2 = QLabel(self.historyAnalyse)
        self.tsqText2.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.tsqText2.setText('发展期')
        self.tsqText2.setGeometry(1074*self.width_scale, 1369*self.height_scale, 60*self.width_scale, 24*self.height_scale)
        self.tsqText2.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        tsqText2font = QFont(self.font_family4, 14*self.width_scale)
        self.tsqText2.setFont(tsqText2font)



        self.historyOrder1 = QLabel(self.historyAnalyse)
        self.historyOrder1.setStyleSheet(
            f'border-radius: {25*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #C8402C;')
        self.historyOrder1.setGeometry(60*self.width_scale, 1436*self.height_scale, 724*self.width_scale, 495*self.height_scale)
        # self.historyOrder1.setGeometry(60*self.width_scale, 1436, 724, 495)

        self.historyOrder1_Num = QLabel(self.historyOrder1)
        self.historyOrder1_Num.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.historyOrder1_Num.setText('No.1')
        self.historyOrder1_Num.setGeometry(52*self.width_scale, 55*self.height_scale, 65*self.width_scale, 35*self.height_scale)
        self.historyOrder1_Num.setStyleSheet("background-color: transparent; border:none;color: #C8402C;")
        historyOrder1_Numfont = QFont(self.font_family4, 24*self.width_scale)
        self.historyOrder1_Num.setFont(historyOrder1_Numfont)

        self.fengedian = QLabel(self.historyOrder1)
        self.fengedian.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.fengedian.setText('·')
        self.fengedian.setGeometry(126*self.width_scale, 55*self.height_scale, 5*self.width_scale, 35*self.height_scale)
        self.fengedian.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        fengedianfont = QFont(self.font_family4, 24*self.width_scale)
        self.fengedian.setFont(fengedianfont)

        self.historyOrder1_Title = QLabel(self.historyOrder1)
        self.historyOrder1_Title.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder1_Title.setText('-')
        self.historyOrder1_Title.setGeometry(140*self.width_scale, 55*self.height_scale, 450*self.width_scale, 35*self.height_scale)
        self.historyOrder1_Title.setStyleSheet("background-color: transparent; border:none;color: #090101;")
        historyOrder1_Titlefont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder1_Title.setFont(historyOrder1_Titlefont)

        self.historyOrder1_Time = QLabel(self.historyOrder1)
        self.historyOrder1_Time.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder1_Time.setText('16:20')
        self.historyOrder1_Time.setGeometry(574*self.width_scale, 55*self.height_scale, 100*self.width_scale, 35*self.height_scale)
        self.historyOrder1_Time.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        historyOrder1_Timefont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder1_Time.setFont(historyOrder1_Timefont)

        self.historyOrder1_pl1 = QLabel(self.historyOrder1)
        self.historyOrder1_pl1.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder1_pl1.setText('-')
        self.historyOrder1_pl1.setGeometry(378*self.width_scale, 100*self.height_scale, 100*self.width_scale, 25*self.height_scale)
        self.historyOrder1_pl1.setStyleSheet("background-color: transparent; border:none;color: #090101;")
        historyOrder1_pl1font = QFont(self.font_family4, 14*self.width_scale)
        self.historyOrder1_pl1.setFont(historyOrder1_pl1font)

        self.historyOrder1_pl2 = QLabel(self.historyOrder1)
        self.historyOrder1_pl2.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder1_pl2.setText('')
        self.historyOrder1_pl2.setGeometry(485*self.width_scale, 100*self.height_scale, 180*self.width_scale, 25*self.height_scale)
        self.historyOrder1_pl2.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;")
        historyOrder1_pl2font = QFont(self.font_family4, 14*self.width_scale)
        self.historyOrder1_pl2.setFont(historyOrder1_pl2font)

        self.historyOrder_hbrq1 = QLabel(self.historyOrder1)
        self.historyOrder_hbrq1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbrq1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_hbrq1.setGeometry(57*self.width_scale, 142*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbrq1.setText('烘焙日期:')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_hbrq1.setFont(bcrqfont)

        self.historyOrder_hbrq1_Data = QLabel(self.historyOrder_hbrq1)
        self.historyOrder_hbrq1_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbrq1_Data.setText('-')
        self.historyOrder_hbrq1_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbrq1_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #A8A8A8;")
        self.historyOrder_hbrq1_Data.setFont(bcrqfont)

        self.historyOrder_hbssl1 = QLabel(self.historyOrder1)
        self.historyOrder_hbssl1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbssl1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_hbssl1.setGeometry(57*self.width_scale, 190*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbssl1.setText('烘焙损失率:')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_hbssl1.setFont(bcrqfont)

        self.historyOrder_hbssl1_Data = QLabel(self.historyOrder_hbssl1)
        self.historyOrder_hbssl1_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbssl1_Data.setText('-')
        self.historyOrder_hbssl1_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbssl1_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_hbssl1_Data.setFont(bcrqfont)

        self.historyOrder_hbpf1 = QLabel(self.historyOrder1)
        self.historyOrder_hbpf1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbpf1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_hbpf1.setGeometry(57*self.width_scale, 238*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbpf1.setText('烘焙评分：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_hbpf1.setFont(bcrqfont)

        self.historyOrder_hbpf1_Data = QLabel(self.historyOrder_hbpf1)
        self.historyOrder_hbpf1_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbpf1_Data.setText('-')
        self.historyOrder_hbpf1_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbpf1_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_hbpf1_Data.setFont(bcrqfont)

        self.historyOrder_Agtron1 = QLabel(self.historyOrder1)
        self.historyOrder_Agtron1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_Agtron1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_Agtron1.setGeometry(57*self.width_scale, 286*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_Agtron1.setText('Agtron值：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_Agtron1.setFont(bcrqfont)

        self.historyOrder_Agtron1_Data = QLabel(self.historyOrder_Agtron1)
        self.historyOrder_Agtron1_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_Agtron1_Data.setText('-')
        self.historyOrder_Agtron1_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_Agtron1_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_Agtron1_Data.setFont(bcrqfont)

        self.historyOrder_bcpf1 = QLabel(self.historyOrder1)
        self.historyOrder_bcpf1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcpf1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_bcpf1.setGeometry(57*self.width_scale, 334*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcpf1.setText('杯测评分：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_bcpf1.setFont(bcrqfont)

        self.historyOrder_bcpf1_Data = QLabel(self.historyOrder_bcpf1)
        self.historyOrder_bcpf1_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcpf1_Data.setText('-')
        self.historyOrder_bcpf1_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcpf1_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_bcpf1_Data.setFont(bcrqfont)

        self.historyOrder_bcrq1 = QLabel(self.historyOrder1)
        self.historyOrder_bcrq1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcrq1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_bcrq1.setGeometry(57*self.width_scale, 385*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcrq1.setText('杯测日期：')
        bcrqfont = QFont(self.font_family4, 18)
        self.historyOrder_bcrq1.setFont(bcrqfont)

        self.historyOrder_bcrq1_Data = QLabel(self.historyOrder_bcrq1)
        self.historyOrder_bcrq1_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcrq1_Data.setText('-')
        self.historyOrder_bcrq1_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcrq1_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #A8A8A8;")
        self.historyOrder_bcrq1_Data.setFont(bcrqfont)






        self.historyOrder2 = QLabel(self.historyAnalyse)
        self.historyOrder2.setStyleSheet(
            f'border-radius: {25*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #E5B547;')
        self.historyOrder2.setGeometry(814*self.width_scale, 1436*self.height_scale, 724*self.width_scale, 495*self.height_scale)

        self.historyOrder1_Num = QLabel(self.historyOrder2)
        self.historyOrder1_Num.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.historyOrder1_Num.setText('No.2')
        self.historyOrder1_Num.setGeometry(52*self.width_scale, 55*self.height_scale, 70*self.width_scale, 35*self.height_scale)
        self.historyOrder1_Num.setStyleSheet("background-color: transparent; border:none;color: #C8402C;")
        historyOrder1_Numfont = QFont(self.font_family4, 24*self.width_scale)
        self.historyOrder1_Num.setFont(historyOrder1_Numfont)

        self.fengedian = QLabel(self.historyOrder2)
        self.fengedian.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.fengedian.setText('·')
        self.fengedian.setGeometry(126*self.width_scale, 55*self.height_scale, 5*self.width_scale, 35*self.height_scale)
        self.fengedian.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        fengedianfont = QFont(self.font_family4, 24*self.width_scale)
        self.fengedian.setFont(fengedianfont)

        self.historyOrder2_Title = QLabel(self.historyOrder2)
        self.historyOrder2_Title.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder2_Title.setText('-')
        self.historyOrder2_Title.setGeometry(140*self.width_scale, 55*self.height_scale, 450*self.width_scale, 35*self.height_scale)
        self.historyOrder2_Title.setStyleSheet("background-color: transparent; border:none;color: #090101;")
        historyOrder1_Titlefont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder2_Title.setFont(historyOrder1_Titlefont)

        self.historyOrder2_Time = QLabel(self.historyOrder2)
        self.historyOrder2_Time.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder2_Time.setText('16:20')
        self.historyOrder2_Time.setGeometry(574*self.width_scale, 55*self.height_scale, 100*self.width_scale, 35*self.height_scale)
        self.historyOrder2_Time.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        historyOrder1_Timefont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder2_Time.setFont(historyOrder1_Timefont)

        self.historyOrder2_pl1 = QLabel(self.historyOrder2)
        self.historyOrder2_pl1.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder2_pl1.setText('-')
        self.historyOrder2_pl1.setGeometry(378*self.width_scale, 100*self.height_scale, 100*self.width_scale, 25*self.height_scale)
        self.historyOrder2_pl1.setStyleSheet("background-color: transparent; border:none;color: #090101;")
        historyOrder1_pl1font = QFont(self.font_family4, 14*self.width_scale)
        self.historyOrder2_pl1.setFont(historyOrder1_pl1font)

        self.historyOrder2_pl2 = QLabel(self.historyOrder2)
        self.historyOrder2_pl2.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder2_pl2.setText('')
        self.historyOrder2_pl2.setGeometry(485*self.width_scale, 100*self.height_scale, 180*self.width_scale, 25*self.height_scale)
        self.historyOrder2_pl2.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;")
        historyOrder1_pl2font = QFont(self.font_family4, 14*self.width_scale)
        self.historyOrder2_pl2.setFont(historyOrder1_pl2font)

        self.historyOrder_hbrq1 = QLabel(self.historyOrder2)
        self.historyOrder_hbrq1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbrq1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_hbrq1.setGeometry(57*self.width_scale, 142*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbrq1.setText('烘焙日期:')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_hbrq1.setFont(bcrqfont)

        self.historyOrder_hbrq2_Data = QLabel(self.historyOrder_hbrq1)
        self.historyOrder_hbrq2_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbrq2_Data.setText('-')
        self.historyOrder_hbrq2_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbrq2_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #A8A8A8;")
        self.historyOrder_hbrq2_Data.setFont(bcrqfont)

        self.historyOrder_hbssl1 = QLabel(self.historyOrder2)
        self.historyOrder_hbssl1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbssl1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_hbssl1.setGeometry(57*self.width_scale, 190*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbssl1.setText('烘焙损失率:')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_hbssl1.setFont(bcrqfont)

        self.historyOrder_hbssl2_Data = QLabel(self.historyOrder_hbssl1)
        self.historyOrder_hbssl2_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbssl2_Data.setText('-')
        self.historyOrder_hbssl2_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbssl2_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_hbssl2_Data.setFont(bcrqfont)

        self.historyOrder_hbpf1 = QLabel(self.historyOrder2)
        self.historyOrder_hbpf1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbpf1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_hbpf1.setGeometry(57*self.width_scale, 238*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbpf1.setText('烘焙评分：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_hbpf1.setFont(bcrqfont)

        self.historyOrder_hbpf2_Data = QLabel(self.historyOrder_hbpf1)
        self.historyOrder_hbpf2_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbpf2_Data.setText('-')
        self.historyOrder_hbpf2_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbpf2_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_hbpf2_Data.setFont(bcrqfont)

        self.historyOrder_Agtron1 = QLabel(self.historyOrder2)
        self.historyOrder_Agtron1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_Agtron1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_Agtron1.setGeometry(57*self.width_scale, 286*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_Agtron1.setText('Agtron值：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_Agtron1.setFont(bcrqfont)

        self.historyOrder_Agtron2_Data = QLabel(self.historyOrder_Agtron1)
        self.historyOrder_Agtron2_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_Agtron2_Data.setText('-')
        self.historyOrder_Agtron2_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_Agtron2_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_Agtron2_Data.setFont(bcrqfont)

        self.historyOrder_bcpf1 = QLabel(self.historyOrder2)
        self.historyOrder_bcpf1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcpf1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_bcpf1.setGeometry(57*self.width_scale, 334*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcpf1.setText('杯测评分：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_bcpf1.setFont(bcrqfont)

        self.historyOrder_bcpf2_Data = QLabel(self.historyOrder_bcpf1)
        self.historyOrder_bcpf2_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcpf2_Data.setText('-')
        self.historyOrder_bcpf2_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcpf2_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_bcpf2_Data.setFont(bcrqfont)

        self.historyOrder_bcrq1 = QLabel(self.historyOrder2)
        self.historyOrder_bcrq1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcrq1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_bcrq1.setGeometry(57*self.width_scale, 385*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcrq1.setText('杯测日期：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_bcrq1.setFont(bcrqfont)

        self.historyOrder_bcrq2_Data = QLabel(self.historyOrder_bcrq1)
        self.historyOrder_bcrq2_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcrq2_Data.setText('-')
        self.historyOrder_bcrq2_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcrq2_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #A8A8A8;")
        self.historyOrder_bcrq2_Data.setFont(bcrqfont)

        self.historyOrder3 = QLabel(self.historyAnalyse)
        self.historyOrder3.setStyleSheet(
            f'border-radius: {25*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #44AB6B;')
        self.historyOrder3.setGeometry(60*self.width_scale, 1962*self.height_scale, 724*self.width_scale, 495*self.height_scale)

        self.historyOrder1_Num = QLabel(self.historyOrder3)
        self.historyOrder1_Num.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.historyOrder1_Num.setText('No.3')
        self.historyOrder1_Num.setGeometry(52*self.width_scale, 55*self.height_scale, 70*self.width_scale, 35*self.height_scale)
        self.historyOrder1_Num.setStyleSheet("background-color: transparent; border:none;color: #C8402C;")
        historyOrder1_Numfont = QFont(self.font_family4, 24*self.width_scale)
        self.historyOrder1_Num.setFont(historyOrder1_Numfont)

        self.fengedian = QLabel(self.historyOrder3)
        self.fengedian.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.fengedian.setText('·')
        self.fengedian.setGeometry(126*self.width_scale, 55*self.height_scale, 5*self.width_scale, 35*self.height_scale)
        self.fengedian.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        fengedianfont = QFont(self.font_family4, 24*self.width_scale)
        self.fengedian.setFont(fengedianfont)

        self.historyOrder3_Title = QLabel(self.historyOrder3)
        self.historyOrder3_Title.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder3_Title.setText('-')
        self.historyOrder3_Title.setGeometry(140*self.width_scale, 55*self.height_scale, 450*self.width_scale, 35*self.height_scale)
        self.historyOrder3_Title.setStyleSheet("background-color: transparent; border:none;color: #090101;")
        historyOrder1_Titlefont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder3_Title.setFont(historyOrder1_Titlefont)

        self.historyOrder3_Time = QLabel(self.historyOrder3)
        self.historyOrder3_Time.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder3_Time.setText('16:20')
        self.historyOrder3_Time.setGeometry(574*self.width_scale, 55*self.height_scale, 100*self.width_scale, 35*self.height_scale)
        self.historyOrder3_Time.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        historyOrder1_Timefont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder3_Time.setFont(historyOrder1_Timefont)

        self.historyOrder3_pl1 = QLabel(self.historyOrder3)
        self.historyOrder3_pl1.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder3_pl1.setText('-')
        self.historyOrder3_pl1.setGeometry(378*self.width_scale, 100*self.height_scale, 100*self.width_scale, 25*self.height_scale)
        self.historyOrder3_pl1.setStyleSheet("background-color: transparent; border:none;color: #090101;")
        historyOrder1_pl1font = QFont(self.font_family4, 14*self.width_scale)
        self.historyOrder3_pl1.setFont(historyOrder1_pl1font)

        self.historyOrder3_pl2 = QLabel(self.historyOrder3)
        self.historyOrder3_pl2.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder3_pl2.setText('')
        self.historyOrder3_pl2.setGeometry(485*self.width_scale, 100*self.height_scale, 180*self.width_scale, 25*self.height_scale)
        self.historyOrder3_pl2.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;")
        historyOrder1_pl2font = QFont(self.font_family4, 14*self.width_scale)
        self.historyOrder3_pl2.setFont(historyOrder1_pl2font)

        self.historyOrder_hbrq1 = QLabel(self.historyOrder3)
        self.historyOrder_hbrq1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbrq1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_hbrq1.setGeometry(57*self.width_scale, 142*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbrq1.setText('烘焙日期:')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_hbrq1.setFont(bcrqfont)

        self.historyOrder_hbrq3_Data = QLabel(self.historyOrder_hbrq1)
        self.historyOrder_hbrq3_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbrq3_Data.setText('-')
        self.historyOrder_hbrq3_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbrq3_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #A8A8A8;")
        self.historyOrder_hbrq3_Data.setFont(bcrqfont)

        self.historyOrder_hbssl1 = QLabel(self.historyOrder3)
        self.historyOrder_hbssl1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbssl1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_hbssl1.setGeometry(57*self.width_scale, 190*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbssl1.setText('烘焙损失率:')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_hbssl1.setFont(bcrqfont)

        self.historyOrder_hbssl3_Data = QLabel(self.historyOrder_hbssl1)
        self.historyOrder_hbssl3_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbssl3_Data.setText('-')
        self.historyOrder_hbssl3_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbssl3_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_hbssl3_Data.setFont(bcrqfont)

        self.historyOrder_hbpf1 = QLabel(self.historyOrder3)
        self.historyOrder_hbpf1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbpf1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_hbpf1.setGeometry(57*self.width_scale, 238*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbpf1.setText('烘焙评分：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_hbpf1.setFont(bcrqfont)

        self.historyOrder_hbpf3_Data = QLabel(self.historyOrder_hbpf1)
        self.historyOrder_hbpf3_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbpf3_Data.setText('-')
        self.historyOrder_hbpf3_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbpf3_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_hbpf3_Data.setFont(bcrqfont)

        self.historyOrder_Agtron1 = QLabel(self.historyOrder3)
        self.historyOrder_Agtron1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_Agtron1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_Agtron1.setGeometry(57*self.width_scale, 286*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_Agtron1.setText('Agtron值：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_Agtron1.setFont(bcrqfont)

        self.historyOrder_Agtron3_Data = QLabel(self.historyOrder_Agtron1)
        self.historyOrder_Agtron3_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_Agtron3_Data.setText('-')
        self.historyOrder_Agtron3_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_Agtron3_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_Agtron3_Data.setFont(bcrqfont)

        self.historyOrder_bcpf1 = QLabel(self.historyOrder3)
        self.historyOrder_bcpf1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcpf1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_bcpf1.setGeometry(57*self.width_scale, 334*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcpf1.setText('杯测评分：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_bcpf1.setFont(bcrqfont)

        self.historyOrder_bcpf3_Data = QLabel(self.historyOrder_bcpf1)
        self.historyOrder_bcpf3_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcpf3_Data.setText('-')
        self.historyOrder_bcpf3_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcpf3_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_bcpf3_Data.setFont(bcrqfont)

        self.historyOrder_bcrq1 = QLabel(self.historyOrder3)
        self.historyOrder_bcrq1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcrq1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_bcrq1.setGeometry(57*self.width_scale, 385*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcrq1.setText('杯测日期：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_bcrq1.setFont(bcrqfont)

        self.historyOrder_bcrq3_Data = QLabel(self.historyOrder_bcrq1)
        self.historyOrder_bcrq3_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcrq3_Data.setText('-')
        self.historyOrder_bcrq3_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcrq3_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #A8A8A8;")
        self.historyOrder_bcrq3_Data.setFont(bcrqfont)

        self.historyOrder4 = QLabel(self.historyAnalyse)
        self.historyOrder4.setStyleSheet(
            f'border-radius: {25*self.height_scale}px;background-color: #FFFFFF; border: 1px solid #258B96;')
        self.historyOrder4.setGeometry(814*self.width_scale, 1962*self.height_scale, 724*self.width_scale, 495*self.height_scale)

        self.historyOrder1_Num = QLabel(self.historyOrder4)
        self.historyOrder1_Num.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.historyOrder1_Num.setText('No.4')
        self.historyOrder1_Num.setGeometry(52*self.width_scale, 55*self.height_scale, 70*self.width_scale, 35*self.height_scale)
        self.historyOrder1_Num.setStyleSheet("background-color: transparent; border:none;color: #C8402C;")
        historyOrder1_Numfont = QFont(self.font_family4, 24*self.width_scale)
        self.historyOrder1_Num.setFont(historyOrder1_Numfont)

        self.fengedian = QLabel(self.historyOrder4)
        self.fengedian.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.fengedian.setText('·')
        self.fengedian.setGeometry(126*self.width_scale, 55*self.height_scale, 5*self.width_scale, 35*self.height_scale)
        self.fengedian.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        fengedianfont = QFont(self.font_family4, 24*self.width_scale)
        self.fengedian.setFont(fengedianfont)

        self.historyOrder4_Title = QLabel(self.historyOrder4)
        self.historyOrder4_Title.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder4_Title.setText('-')
        self.historyOrder4_Title.setGeometry(140*self.width_scale, 55*self.height_scale, 450*self.width_scale, 35*self.height_scale)
        self.historyOrder4_Title.setStyleSheet("background-color: transparent; border:none;color: #090101;")
        historyOrder1_Titlefont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder4_Title.setFont(historyOrder1_Titlefont)

        self.historyOrder4_Time = QLabel(self.historyOrder4)
        self.historyOrder4_Time.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder4_Time.setText('16:20')
        self.historyOrder4_Time.setGeometry(574*self.width_scale, 55*self.height_scale, 100*self.width_scale, 35*self.height_scale)
        self.historyOrder4_Time.setStyleSheet("background-color: transparent; border:none;color: #222222;")
        historyOrder1_Timefont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder4_Time.setFont(historyOrder1_Timefont)

        self.historyOrder4_pl1 = QLabel(self.historyOrder4)
        self.historyOrder4_pl1.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder4_pl1.setText('-') # -玫瑰山谷| 蔓越莓·黑巧·玫瑰花
        self.historyOrder4_pl1.setGeometry(378*self.width_scale, 100*self.height_scale, 100*self.width_scale, 25*self.height_scale)
        self.historyOrder4_pl1.setStyleSheet("background-color: transparent; border:none;color: #090101;")
        historyOrder1_pl1font = QFont(self.font_family4, 14*self.width_scale)
        self.historyOrder4_pl1.setFont(historyOrder1_pl1font)

        self.historyOrder4_pl2 = QLabel(self.historyOrder4)
        self.historyOrder4_pl2.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder4_pl2.setText('')
        self.historyOrder4_pl2.setGeometry(485*self.width_scale, 100*self.height_scale, 180*self.width_scale, 25*self.height_scale)
        self.historyOrder4_pl2.setStyleSheet("background-color: transparent; border:none;color: #A8A8A8;")
        historyOrder1_pl2font = QFont(self.font_family4, 14*self.width_scale)
        self.historyOrder4_pl2.setFont(historyOrder1_pl2font)

        self.historyOrder_hbrq1 = QLabel(self.historyOrder4)
        self.historyOrder_hbrq1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbrq1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_hbrq1.setGeometry(57*self.width_scale, 142*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbrq1.setText('烘焙日期:')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_hbrq1.setFont(bcrqfont)

        self.historyOrder_hbrq4_Data = QLabel(self.historyOrder_hbrq1)
        self.historyOrder_hbrq4_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbrq4_Data.setText('-')
        self.historyOrder_hbrq4_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbrq4_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #A8A8A8;")
        self.historyOrder_hbrq4_Data.setFont(bcrqfont)

        self.historyOrder_hbssl1 = QLabel(self.historyOrder4)
        self.historyOrder_hbssl1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbssl1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_hbssl1.setGeometry(57*self.width_scale, 190*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbssl1.setText('烘焙损失率:')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_hbssl1.setFont(bcrqfont)

        self.historyOrder_hbssl4_Data = QLabel(self.historyOrder_hbssl1)
        self.historyOrder_hbssl4_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbssl4_Data.setText('-')
        self.historyOrder_hbssl4_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbssl4_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_hbssl4_Data.setFont(bcrqfont)

        self.historyOrder_hbpf1 = QLabel(self.historyOrder4)
        self.historyOrder_hbpf1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbpf1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_hbpf1.setGeometry(57*self.width_scale, 238*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbpf1.setText('烘焙评分：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_hbpf1.setFont(bcrqfont)

        self.historyOrder_hbpf4_Data = QLabel(self.historyOrder_hbpf1)
        self.historyOrder_hbpf4_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_hbpf4_Data.setText('-')
        self.historyOrder_hbpf4_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_hbpf4_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_hbpf4_Data.setFont(bcrqfont)

        self.historyOrder_Agtron1 = QLabel(self.historyOrder4)
        self.historyOrder_Agtron1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_Agtron1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_Agtron1.setGeometry(57*self.width_scale, 286*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_Agtron1.setText('Agtron值：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_Agtron1.setFont(bcrqfont)

        self.historyOrder_Agtron4_Data = QLabel(self.historyOrder_Agtron1)
        self.historyOrder_Agtron4_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_Agtron4_Data.setText('-')
        self.historyOrder_Agtron4_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_Agtron4_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_Agtron4_Data.setFont(bcrqfont)

        self.historyOrder_bcpf1 = QLabel(self.historyOrder4)
        self.historyOrder_bcpf1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcpf1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_bcpf1.setGeometry(57*self.width_scale, 334*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcpf1.setText('杯测评分：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_bcpf1.setFont(bcrqfont)

        self.historyOrder_bcpf4_Data = QLabel(self.historyOrder_bcpf1)
        self.historyOrder_bcpf4_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcpf4_Data.setText('-')
        self.historyOrder_bcpf4_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcpf4_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #393939;")
        self.historyOrder_bcpf4_Data.setFont(bcrqfont)

        self.historyOrder_bcrq1 = QLabel(self.historyOrder4)
        self.historyOrder_bcrq1.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcrq1.setStyleSheet(
            'background-color: transparent; border: none; color:#A8A8A8;')
        self.historyOrder_bcrq1.setGeometry(57*self.width_scale, 385*self.height_scale, 610*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcrq1.setText('杯测日期：')
        bcrqfont = QFont(self.font_family4, 18*self.width_scale)
        self.historyOrder_bcrq1.setFont(bcrqfont)

        self.historyOrder_bcrq4_Data = QLabel(self.historyOrder_bcrq1)
        self.historyOrder_bcrq4_Data.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.historyOrder_bcrq4_Data.setText('-')
        self.historyOrder_bcrq4_Data.setGeometry(300*self.width_scale, 0, 310*self.width_scale, 75*self.height_scale)
        self.historyOrder_bcrq4_Data.setStyleSheet(
            "background-color: transparent; border:none;color: #A8A8A8;")
        self.historyOrder_bcrq4_Data.setFont(bcrqfont)

        self.zhezhaoLabel2 = QLabel(self.historyAnalyse)
        self.zhezhaoLabel2.setGeometry(0, 0, 1600*self.width_scale, 2739*self.height_scale)
        self.zhezhaoLabel2.setStyleSheet(f"background-color: rgba(0, 0, 0, 0);border-radius: {25*self.height_scale}px;")
        self.zhezhao2 = QPixmap(self.normalized_path + '/includes/Icons/history/back_L2.png')
        self.zhezhaoLabel2.setPixmap(self.zhezhao2)
        self.zhezhaoLabel2.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.zhezhaoLabel2.setScaledContents(True)

        self.diologRect2Zhezhao = QPushButton(self)  # 出仓报错弹窗
        self.diologRect2Zhezhao.setStyleSheet('border: none;background-color: rgba(0, 0, 0, 128);')
        self.diologRect2Zhezhao.setGeometry(0,0 , 1920 * self.width_scale,
                                            1080 * self.width_scale)
        self.diologRect2Zhezhao.clicked.connect(self.closeDiolog)
        self.diologRect2Zhezhao.setVisible(False)

        self.diologRect2 = QLabel(self.diologRect2Zhezhao)  # 出仓报错弹窗
        self.diologRect2.setStyleSheet(f'border-radius: {25*self.height_scale}px;background-color: #ffffff;')
        self.diologRect2.setGeometry(775 * self.width_scale, 455 * self.height_scale, 370 * self.width_scale,
                                     170 * self.width_scale)
        # self.rdtcImg = QPixmap(self.normalized_path + '/includes/Icons/yrzb/diolog.png')
        # self.diologRect2.setPixmap(self.rdtcImg)


        self.jbLbel2 = QLabel(self.diologRect2)
        self.jbLbel2.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.jbLbel2.setGeometry(15 * self.width_scale, 15 * self.height_scale, 340 * self.width_scale, 36 * self.height_scale)
        self.jbLbel2.setText('警 报')
        self.jbLbel2.setStyleSheet(f"background-color: #DC630C;border-radius: {18*self.height_scale}px; border:none;color: #ffffff")
        jbLbelfont = QFont(self.font_family3, 16 * self.width_scale)
        self.jbLbel2.setFont(jbLbelfont)

        self.jbCentent2 = QLabel(self.diologRect2)
        self.jbCentent2.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.jbCentent2.setGeometry(0, 35 * self.height_scale, 370 * self.width_scale, 100 * self.height_scale)
        self.jbCentent2.setText('保存失败，烘焙批次号和烘焙曲线已存在')
        self.jbCentent2.setStyleSheet("background-color: transparent; border:none;color: #222222")
        jbCententfont = QFont(self.font_family3, 12 * self.width_scale)
        self.jbCentent2.setFont(jbCententfont)

        # AI 窗口
        self.ai_widget = QLabel(self)
        self.ai_widget.setGeometry(1624 * self.width_scale, 16 * self.height_scale, 280 * self.width_scale,
                                   1048 * self.height_scale)
        self.ai_pixmap = QPixmap(self.normalized_path + '/includes/Icons/general/Ai/back.png')  # 背景图
        self.ai_widget.setPixmap(self.ai_pixmap)
        self.ai_widget.setScaledContents(True)
        self.ai_widget.setVisible(False)

        self.hxb = QLabel(self.ai_widget)  # 第一行设备名称
        self.hxb.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.hxb.setGeometry(29 * self.width_scale, 33 * self.height_scale, 120 * self.width_scale,
                             38 * self.height_scale)
        self.hxb.setStyleSheet("""
                                            color: #222222;
                                            border: none;  /* 去掉按钮的边框 */
                                            background-color: transparent;  /* 设置背景为透明 */
                                        """)
        self.hxb.setText("烘 小 贝")
        hxbfont = QFont(self.font_family2, 20 * self.width_scale)
        # shebeifont.setBold(True)
        self.hxb.setFont(hxbfont)

        self.hxbBottom = QLabel(self.ai_widget)
        self.hxbBottom.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        self.hxbBottom.setGeometry(29 * self.width_scale, 71 * self.height_scale, 120 * self.width_scale,
                                   38 * self.height_scale)
        self.hxbBottom.setStyleSheet("""
                                                            color: #222222;
                                                            border: none;  /* 去掉按钮的边框 */
                                                            background-color: transparent;  /* 设置背景为透明 */
                                                        """)
        self.hxbBottom.setText("风味科学智能助理")
        hxbBottomfont = QFont(self.font_family6, 10 * self.width_scale)
        self.hxbBottom.setFont(hxbBottomfont)

        self.closeAi = QPushButton(self.ai_widget)
        self.closeAi.setGeometry(235 * self.width_scale, 39 * self.height_scale, 30 * self.width_scale,
                                 30 * self.height_scale)
        self.closeAi.setStyleSheet("""
                                                                          QPushButton {
                                                                              background-color: transparent;
                                                                              border: none;
                                                                          }
                                                                      """)
        self.closeAiPixmap = QIcon(self.normalized_path + '/includes/Icons/general/Ai/close.png')
        self.closeAi.setIcon(self.closeAiPixmap)
        self.closeAi.setIconSize(QSize(32 * self.width_scale, 32 * self.width_scale))
        self.closeAi.clicked.connect(self.closeAiWidget)

        self.sendAiInfo: QLineEdit = QLineEdit(self.ai_widget)
        self.sendAiInfo.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        # self.userContent.setText('185°')
        self.sendAiInfo.setStyleSheet(f"""
                                                    QLineEdit {{
                                                                background-color: #FFFFFF;  /* 设置背景颜色 */
                                                                color: #393939;             /* 设置文字颜色 */
                                                                padding-left: 20px;         /* 设置文字左边距 */
                                                                font-size: 12px;            /* 设置字体大小 */
                                                                border: none;               /* 移除边框 */
                                                                border-radius: {30 * self.height_scale}px;
                                                            }}
                                                """)
        sendAiInfofont = QFont(self.font_family4, 14 * self.width_scale)
        self.sendAiInfo.setFont(sendAiInfofont)
        self.sendAiInfo.setGeometry(15 * self.width_scale, 972 * self.height_scale, 252 * self.width_scale,
                                    60 * self.height_scale)  # 设置控件的固定大小为56x24px

        self.sendAi_button = QPushButton(self.sendAiInfo)
        self.sendAi_button.setGeometry(209 * self.width_scale, 15 * self.height_scale, 30 * self.width_scale,
                                       30 * self.width_scale)
        self.sendAi_button.setCheckable(True)
        self.sendAi_button.setIcon(
            QIcon(self.normalized_path + '/includes/Icons/general/Ai/send/send.png'))
        self.sendAi_button.setStyleSheet("border: none;background-color:transparent")
        self.sendAi_button.setIconSize(QSize(30 * self.width_scale, 30 * self.width_scale))
        self.sendAi_button.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        # self.sendAi_button.clicked.connect(self.toggle_password_visibility)


        # self.loginUI()  # 登录
        self.closeSystemUI()  # 关机


        # self.computedData = self.computedProfileInformation()
        # # if 'AUCbegin' in self.computedData:
        # sys.stdout = open("outputttttttttttt.log", "w")
        #
        # print('曲线数据',self.computedData)

        self.qmc.setAttribute(Qt.WidgetAttribute.WA_NoSystemBackground)

        # Arduino、Hottop和通用MODBUS设备的PID控制
        self.pidcontrol: PIDcontrol = PIDcontrol(self)

        #### 热顶控制
        self.HottopControlActive: bool = False

        #### 异步采样定时器
        self.AsyncSamplingTimer: Optional[QTimer] = None

        self.wheeldialog: Optional['WheelDlg'] = None

        self.simulator: Optional[Simulator] = None  # 将模拟器保持在模拟模式
        self.simulatorpath: str = ''  # 指向模拟器使用的最后一个概要文件

        self.comparator: Optional['roastCompareDlg'] = None  # 保持配置文件比较器对话框

        self.qmc.setContentsMargins(0, 0, 0, 0)
        # 事件配置
        self.eventsbuttonflag: int = 0
        self.minieventsflags: List[int] = [0, 0, 0]  # 每个状态的minieditor可见性关闭、打开、启动

        # 最后一个IO命令结果
        self.lastIOResult: Optional[float] = None
        # Last Artisan Command result
        self.lastArtisanResult: Optional[float] = None

        # 记录串行通信(帮助菜单)
        self.seriallogflag: bool = False
        self.seriallog: List[str] = []

        # 创建一个串行端口对象(主ET BT设备)
        self.ser: serialport = serialport(self)
        # 创建一个modbus端口对象(主modbus设备)
        self.modbus: modbusport = modbusport(self)
        # 传递值的临时存储。保存MODBUS通道T1和T2以及MODBUS连接设备的额外通道T3、T4、T5和T6值
        self.extraMODBUStemps: List[float] = [-1] * self.modbus.channels
        self.extraMODBUStx: float = 0.

        # 创建s7端口对象(主s7设备)
        self.s7: s7port = s7port(self)
        self.extraS7tx: float = 0.
        # 创建一个WebSocket端口对象(主设备，如Probat示例)
        self.ws: wsport = wsport(self)
        # 创建比例端口对象
        self.scale: scaleport = scaleport(self)
        # 创建颜色端口对象
        self.color: colorport = colorport(self)
        # 带有额外串行端口(额外设备)的列表
        self.extraser: List[serialport] = []
        # 额外的通信端口设置
        self.extracomport: List[str] = []
        self.extrabaudrate: List[int] = []
        self.extrabytesize: List[int] = []
        self.extraparity: List[str] = []
        self.extrastopbits: List[int] = []
        self.extratimeout: List[float] = []

        # WebLCDs
        self.weblcds_server: Optional['WebLCDs'] = None  # 保存WebLCD实例

        # Hottop
        self.hottop: Optional['Hottop'] = None  # 保存在连接时创建的Hottop实例；断开时重置为无

        # Santoker Network
        self.santokerHost: str = '10.10.100.254'
        self.santokerPort: int = 20001
        self.santokerSerial: bool = False  # 如果真正的连接是通过主串行端口
        self.santoker: Optional['Santoker'] = None  # 保存在connect上创建的Santoker实例；断开时重置为无

        # Kaleido Network
        self.kaleido_default_host: Final[str] = '127.0.0.1'
        self.kaleidoHost: str = self.kaleido_default_host
        self.kaleidoPort: int = 80
        self.kaleidoSerial: bool = False  # 如果真正的连接是通过主串行端口
        self.kaleidoPID: bool = True  # 如果为真，则运行外部Kaleido PID，否则内部Artisan PID处于活动状态
        self.kaleido: Optional['KaleidoPort'] = None  # 保存在connect上创建的Kaleido实例；断开时重置为无

        # Ikawa BLE
        self.ikawa: Optional['IKAWA_BLE'] = None

        # 创建一个ET控制对象
        self.fujipid: FujiPID = FujiPID(self)
        self.dtapid: DtaPID = DtaPID(self)

        self.soundflag: int = 0

        self.notificationsflag: bool = True  # 显示/隐藏和启用/禁用通知

        # 最近的烘焙，保存部分烘焙属性的字典的有序列表(先进先出)和到背景简介的链接(如果有的话)
        self.recentRoasts: List[RecentRoast] = []
        self.maxRecentRoasts = 25  # the maximum number of recent roasts held

        # lcd1 =时间，lcd2 = met，lcd3 = bt，lcd4 = roc et，lcd5 = roc bt，lcd6 = sv(额外设备lcd与sv设置相同)
        self.lcdpaletteB: Dict[str, str] = {
            'timer': '#F8F8F8',
            'et': '#cc0f50',
            'bt': '#0A5C90',
            'deltaet': '#EBEBEB',
            'deltabt': '#EBEBEB',
            'sv': '#F8F8F8',
            'rstimer': '#F8F8F8',
            'slowcoolingtimer': '#F8F8F8',
        }
        self.lcdpaletteF: Dict[str, str] = {
            'timer': '#262626',
            'et': '#ffffff',
            'bt': '#ffffff',
            'deltaet': '#cc0f50',
            'deltabt': '#0A5C90',
            'sv': '#4C4C4C',
            'rstimer': '#187AB3',
            'slowcoolingtimer': '#CC0D50',
        }

        # 用户定义的事件按钮
        self.extraeventsbuttonsflags: List[int] = [0, 1, 1]  # 额外的按钮可见性每个状态关闭，打开，开始
        #
        self.extraeventslabels: List[str] = []
        self.extraeventsdescriptions: List[str] = []
        self.extraeventstypes: List[int] = []
        self.extraeventsvalues: List[
            float] = []  # internal eventvalues (see canvas.py:self.qmc.eventsExternal2InternalValue()/eventsInternal2ExternalValue()
        # extraeventtypes:
        # 0-3:自定义事件类型(绝对值赋值)
        # 4:没有分配事件类型
        # 5-8:自定义事件类型(相对值分配；+/-步)
        self.extraeventbuttoncolor: List[str] = []
        self.extraeventbuttontextcolor: List[str] = []
        self.extraeventsactionstrings: List[str] = []
        self.extraeventsactions: List[int] = []
        self.extraeventsvisibility: List[int] = []

        # 指示按钮是否
        # 0:方形
        # 1:左圆角
        # 2:右圆角
        # 3:两边都是圆形的
        self.extraeventbuttonround: List[
            int] = []  # set by realignbuttons on rendering the button rows and read by setExtraEventButtonStyle to update the style

        # 如果lock _ quantization _ sampling _ ticks不为0，量化将被阻止
        # (例如，当机器通过按钮或滑块动作改变事件值后，像遗嘱检验一样可能需要几秒钟才能慢慢完成
        # 逐步调整机器滑块，直到达到设定的事件值。我们不想从这些中间步骤中产生更多的事件)
        self.block_quantification_sampling_ticks: List[int] = [0, 0, 0, 0]
        # 默认情况下，在以下时间后，我们会阻止sampling _ ticks _ to _ block _ quantifiction采样间隔的量化
        # 按钮/滑块事件
        self.sampling_seconds_to_block_quantifiction: Final[int] = 15
        self.sampling_ticks_to_block_quantifiction: int = self.blockTicks()

        self.extraeventsactionslastvalue: List[Optional[int]] = [None, None, None, None]  # 用作相对+-按钮动作基础的最后一个值
        self.org_extradevicesettings: Optional[ExtraDeviceSettings] = None

        # 事件滑块
        self.eventsliders: Final[int] = 4
        self.eventslidervalues: List[int] = [0] * self.eventsliders
        self.eventslidervisibilities: List[int] = [0] * self.eventsliders
        self.eventsliderKeyboardControl: bool = True  # 如果使用向上/向下键无法移动错误滑块
        self.eventsliderAlternativeLayout: bool = False  # 如果为True，则组合滑块1+4和2+3，而不是滑块1+2和3+4
        self.eventslideractions: List[int] = [
                                                 0] * self.eventsliders  # 0:无，1:串行命令，2: Modbus命令，3: DTA命令，4:调用程序，5:热顶加热器，6:热顶风扇
        self.eventslidercommands: List[str] = [''] * self.eventsliders
        self.eventslideroffsets: List[float] = [0] * self.eventsliders
        self.eventsliderfactors: List[float] = [1.0] * self.eventsliders
        self.eventslidermin: List[int] = [0] * self.eventsliders
        self.eventsMaxValue: Final[int] = 999
        self.eventslidermax: List[int] = [100] * self.eventsliders
        self.eventslidersflags: List[int] = [0, 1, 1]  # 每种状态的滑块可见性关闭、打开、启动
        self.eventsliderBernoulli: List[int] = [0] * self.eventsliders  # 如果为1，伯努利公式将应用于滑块值
        self.eventslidercoarse: List[int] = [0] * self.eventsliders  # 如果为1，滑块以10的倍数步进，如果为2，滑块以5步进，否则为1
        self.eventslidertemp: List[int] = [0] * self.eventsliders  # 如果为1，滑块值将被解释为温度，最小/最大限制将通过温度模式进行转换
        self.eventsliderunits: List[str] = [''] * self.eventsliders
        self.eventslidermoved: List[int] = [0] * self.eventsliders  # 只需在移动时设置并在释放时重置，以避免不精确的滑块移动
        self.SVslidermoved: int = 0

        # 事件量词
        self.eventquantifieractive: List[int] = [0] * self.eventsliders
        self.eventquantifiersource: List[int] = [0] * self.eventsliders
        self.eventquantifierSV: List[int] = [0] * self.eventsliders  # 1 (SV模式):量化从不阻塞；0 (PV模式):量化被阻止一段时间，因为信号可能仍在移动
        self.eventquantifiermin: List[int] = [0] * self.eventsliders
        self.eventquantifiermax: List[int] = [100] * self.eventsliders
        self.eventquantifiercoarse: List[int] = [0] * self.eventsliders  # 1:分10步量化，2:分5步量化，否则分1步量化
        self.eventquantifieraction: List[int] = [0] * self.eventsliders
        self.clusterEventsFlag: bool = False
        self.eventquantifierlinspaces: List['npt.NDArray[numpy.double]'] = [self.computeLinespace(0),
                                                                            self.computeLinespace(1),
                                                                            self.computeLinespace(2),
                                                                            self.computeLinespace(3)]
        self.eventquantifierthresholdfine: float = .5  # 原始:1.5，滑块步长1的遗嘱检验遗嘱检验#更改为0.5
        self.eventquantifierthresholdmed: float = .5
        self.eventquantifierthresholdcoarse: float = .5  # 对于滑块步长10
        self.lastdigitizedvalue: List[Optional[float]] = [None, None, None, None]  # 每个量词的最后数字化值
        self.lastdigitizedtemp: List[Optional[float]] = [None, None, None, None]  # 每个量词的最后数字化温度值

        self.readingslcdsflags: List[int] = [0, 1, 1]  # 关闭、开启、启动状态下的LCD可见度读数

        # 水印图像
        self.logoimgalpha: float = 2.0
        self.logoimgflag: bool = False  # display during OnMonitor?
        self.logofilename: str = ''

        self.redrawOnResize: bool = True  # if a logofilename is set and redrawOnResize is True a redraw is triggered; usually set to True!

        self.updateWindowTitle()

        # 填充最近的文件菜单
        for _ in range(self.MaxRecentFiles):
            action = QAction(self)
            action.triggered.connect(self.openRecentFile)
            self.recentFileActs.append(action)
        # 填充最近设置菜单
        for _ in range(self.MaxRecentFiles):
            action = QAction(self)
            action.triggered.connect(self.openRecentSetting)
            self.recentSettingActs.append(action)
        # 填充最近主题菜单
        for _ in range(self.MaxRecentFiles):
            action = QAction(self)
            action.triggered.connect(self.openRecentTheme)
            self.recentThemeActs.append(action)

        # 帮助菜单artisan设置中文本搜索的临时变量
        self.searchtextartisansettings = ''

        #######################    MENUS SECTION ##################################################
        ###############  create Top MENUS

        # 伪造条目以获得Mac应用程序菜单的翻译
        _mac_services = QApplication.translate('MAC_APPLICATION_MENU', 'Services')
        _mac_hide = QApplication.translate('MAC_APPLICATION_MENU', 'Hide {0}')
        _mac_hideothers = QApplication.translate('MAC_APPLICATION_MENU', 'Hide Others')
        _mac_showall = QApplication.translate('MAC_APPLICATION_MENU', 'Show All')
        _mac_preferences = QApplication.translate('MAC_APPLICATION_MENU', 'Preferences...')
        _mac_quit = QApplication.translate('MAC_APPLICATION_MENU', 'Quit {0}')
        _mac_about = QApplication.translate('MAC_APPLICATION_MENU', 'About {0}')

        menuBar = self.menuBar()
        self.fileMenu: Optional[QMenu] = None
        self.editMenu: Optional[QMenu] = None
        self.RoastMenu: Optional[QMenu] = None
        self.ConfMenu: Optional[QMenu] = None
        self.ToolkitMenu: Optional[QMenu] = None
        self.viewMenu: Optional[QMenu] = None
        self.helpMenu: Optional[QMenu] = None

        menuBar.setVisible(False) #隐藏导航栏
        self.setWindowFlag(Qt.WindowType.FramelessWindowHint)

        if menuBar is not None:
            self.fileMenu = menuBar.addMenu('&' + QApplication.translate('Menu', 'File'))
            self.editMenu = menuBar.addMenu('&' + QApplication.translate('Menu', 'Edit'))
            self.RoastMenu = menuBar.addMenu('&' + QApplication.translate('Menu', 'Roast'))
            self.ConfMenu = menuBar.addMenu('&' + QApplication.translate('Menu', 'Config'))
            self.ToolkitMenu = menuBar.addMenu('&' + QApplication.translate('Menu', 'Tools'))
            self.viewMenu = menuBar.addMenu('&' + QApplication.translate('Menu', 'View'))
            self.helpMenu = menuBar.addMenu('&' + QApplication.translate('Menu', 'Help'))

        # FILE menu
        if self.fileMenu is not None:
            self.newRoastMenu: Optional[QMenu] = self.fileMenu.addMenu(QApplication.translate('Menu', 'New'))

            self.fileLoadAction = QAction(QApplication.translate('Menu', 'Open...'), self)
            self.fileLoadAction.setShortcut(QKeySequence.StandardKey.Open)
            self.fileLoadAction.triggered.connect(self.fileLoad)
            self.fileMenu.addAction(self.fileLoadAction)

            self.openRecentMenu = self.fileMenu.addMenu(QApplication.translate('Menu', 'Open Recent'))
            if self.openRecentMenu is not None:
                for i in range(self.MaxRecentFiles):
                    self.openRecentMenu.addAction(self.recentFileActs[i])
                self.updateRecentFileActions()

            self.importMenu: Optional[QMenu] = self.fileMenu.addMenu(QApplication.translate('Menu', 'Import'))
            if self.importMenu is not None:
                urlImportAction = QAction('Artisan URL...', self)
                urlImportAction.triggered.connect(self.urlImport)
                self.importMenu.addAction(urlImportAction)

                fileImportCSVAction = QAction('Artisan CSV...', self)
                fileImportCSVAction.triggered.connect(self.fileImportCSV)
                self.importMenu.addAction(fileImportCSVAction)

                fileImportJSONAction = QAction('Artisan JSON...', self)
                fileImportJSONAction.triggered.connect(self.fileImportJSON)
                self.importMenu.addAction(fileImportJSONAction)

                self.importMenu.addSeparator()

                importBulletAction = QAction('Aillio RoasTime...', self)
                #                importBulletAction.triggered.connect(self.importBullet)
                self.importMenu.addAction(importBulletAction)
                importBulletAction.setEnabled(False)

                importBulletAction = QAction('Aillio Roast.World URL...', self)
                #                importBulletAction.triggered.connect(self.importBulletURL)
                self.importMenu.addAction(importBulletAction)
                importBulletAction.setEnabled(False)

                importCropsterAction = QAction('Cropster XLS...', self)
                importCropsterAction.triggered.connect(self.importCropster)
                self.importMenu.addAction(importCropsterAction)

                importGiesenAction = QAction('Giesen CSV...', self)
                importGiesenAction.triggered.connect(self.importGiesen)
                self.importMenu.addAction(importGiesenAction)

                importHH506RAAction = QAction('HH506RA...', self)
                importHH506RAAction.triggered.connect(self.importHH506RA)
                self.importMenu.addAction(importHH506RAAction)

                importIkawaURLAction = QAction('IKAWA URL...', self)
                importIkawaURLAction.triggered.connect(self.importIkawaURL)
                self.importMenu.addAction(importIkawaURLAction)

                importIkawaAction = QAction('IKAWA CSV...', self)
                importIkawaAction.triggered.connect(self.importIkawa)
                self.importMenu.addAction(importIkawaAction)

                importK202Action = QAction('K202...', self)
                importK202Action.triggered.connect(self.importK202)
                self.importMenu.addAction(importK202Action)

                importK204Action = QAction('K204...', self)
                importK204Action.triggered.connect(self.importK204)
                self.importMenu.addAction(importK204Action)

                importLoringAction = QAction('Loring CSV...', self)
                importLoringAction.triggered.connect(self.importLoring)
                self.importMenu.addAction(importLoringAction)

                importRubasseAction = QAction('Rubasse CSV...', self)
                importRubasseAction.triggered.connect(self.importRubasse)
                self.importMenu.addAction(importRubasseAction)

                importPetronciniAction = QAction('Petroncini CSV...', self)
                importPetronciniAction.triggered.connect(self.importPetroncini)
                self.importMenu.addAction(importPetronciniAction)

                importPilotAction = QAction('Probat Pilot...', self)
                importPilotAction.triggered.connect(self.importPilot)
                self.importMenu.addAction(importPilotAction)

                fileImportRoastLoggerAction = QAction('RoastLogger...', self)
                fileImportRoastLoggerAction.triggered.connect(self.fileImportRoastLogger)
                self.importMenu.addAction(fileImportRoastLoggerAction)

                importRoastLogAction = QAction('RoastLog URL...', self)
                importRoastLogAction.triggered.connect(self.importRoastLog)
                self.importMenu.addAction(importRoastLogAction)

                importRoastPathAction = QAction('RoastPATH URL...', self)
                importRoastPathAction.triggered.connect(self.importRoastPATH)
                self.importMenu.addAction(importRoastPathAction)

            self.fileMenu.addSeparator()

            self.fileSaveAction = QAction(QApplication.translate('Menu', 'Save'), self)
            self.fileSaveAction.setShortcut(QKeySequence.StandardKey.Save)
            self.fileSaveAction.triggered.connect(self.fileSave_current_action)
            self.fileMenu.addAction(self.fileSaveAction)

            self.fileSaveAsAction = QAction(QApplication.translate('Menu', 'Save As...'), self)
            self.fileSaveAsAction.setShortcut(QKeySequence.StandardKey.SaveAs)
            self.fileSaveAsAction.triggered.connect(self.fileSave_new_action)
            self.fileMenu.addAction(self.fileSaveAsAction)

            # same as SaveAs, just that the saved file gets a new roastUUID assigned
            self.fileSaveCopyAsAction = QAction(QApplication.translate('Menu', 'Save a Copy As...'), self)
            self.fileSaveCopyAsAction.triggered.connect(self.fileSave_copy_action)
            self.fileMenu.addAction(self.fileSaveCopyAsAction)

            self.fileMenu.addSeparator()

            self.exportMenu = self.fileMenu.addMenu(QApplication.translate('Menu', 'Export'))
            if self.exportMenu is not None:
                fileExportCSVAction = QAction(QApplication.translate('Menu', 'Artisan CSV...'), self)
                fileExportCSVAction.triggered.connect(self.fileExportCSV)
                self.exportMenu.addAction(fileExportCSVAction)

                fileExportJSONAction = QAction(QApplication.translate('Menu', 'Artisan JSON...'), self)
                fileExportJSONAction.triggered.connect(self.fileExportJSON)
                self.exportMenu.addAction(fileExportJSONAction)

                self.exportMenu.addSeparator()

                fileExportExcelAction = QAction(QApplication.translate('Menu', 'Excel...'), self)
                fileExportExcelAction.triggered.connect(self.fileExportExcel)
                self.exportMenu.addAction(fileExportExcelAction)

                self.exportMenu.addSeparator()

                fileExportPilotAction = QAction(QApplication.translate('Menu', 'Probat Pilot...'), self)
                fileExportPilotAction.triggered.connect(self.fileExportPilot)
                self.exportMenu.addAction(fileExportPilotAction)

                fileExportRoastLoggerAction = QAction(QApplication.translate('Menu', 'RoastLogger...'), self)
                fileExportRoastLoggerAction.triggered.connect(self.fileExportRoastLogger)
                self.exportMenu.addAction(fileExportRoastLoggerAction)

            self.convMenu: Optional[QMenu] = self.fileMenu.addMenu(QApplication.translate('Menu', 'Convert To'))
            if self.convMenu is not None:
                # fileConvertFahrenheitAction = QAction(QApplication.translate('Menu', 'Fahrenheit...'), self)
                # fileConvertFahrenheitAction.triggered.connect(self.fileConvertToFahrenheit)
                # self.convMenu.addAction(fileConvertFahrenheitAction)

                fileConvertCelsiusAction = QAction(QApplication.translate('Menu', 'Celsius...'), self)
                fileConvertCelsiusAction.triggered.connect(self.fileConvertToCelsius)
                self.convMenu.addAction(fileConvertCelsiusAction)

                self.convMenu.addSeparator()

                fileConvertExcelAction = QAction(QApplication.translate('Menu', 'Excel...'), self)
                fileConvertExcelAction.triggered.connect(self.fileConvertExcel)
                self.convMenu.addAction(fileConvertExcelAction)

                self.convMenu.addSeparator()

                fileConvertCSVAction = QAction(QApplication.translate('Menu', 'Artisan CSV...'), self)
                fileConvertCSVAction.triggered.connect(self.fileConvertCSV)
                self.convMenu.addAction(fileConvertCSVAction)

                fileConvertJSONAction = QAction(QApplication.translate('Menu', 'Artisan JSON...'), self)
                fileConvertJSONAction.triggered.connect(self.fileConvertJSON)
                self.convMenu.addAction(fileConvertJSONAction)

                self.convMenu.addSeparator()

                fileConvertProbatAction = QAction(QApplication.translate('Menu', 'Probat Pilot...'), self)
                fileConvertProbatAction.triggered.connect(self.fileConvertPilot)
                self.convMenu.addAction(fileConvertProbatAction)

                fileConvertRoastLoggerAction = QAction(QApplication.translate('Menu', 'RoastLogger...'), self)
                fileConvertRoastLoggerAction.triggered.connect(self.fileConvertRoastLogger)
                self.convMenu.addAction(fileConvertRoastLoggerAction)

                self.convMenu.addSeparator()

                fileConvertPNGAction = QAction(QApplication.translate('Menu', 'PNG...'), self)
                fileConvertPNGAction.triggered.connect(self.fileConvertPNG)
                self.convMenu.addAction(fileConvertPNGAction)

                fileConvertJPEGAction = QAction(QApplication.translate('Menu', 'JPEG...'), self)
                fileConvertJPEGAction.triggered.connect(self.fileConvertJPEG)
                self.convMenu.addAction(fileConvertJPEGAction)

                fileConvertBMPAction = QAction(QApplication.translate('Menu', 'BMP...'), self)
                fileConvertBMPAction.triggered.connect(self.fileConvertBMP)
                self.convMenu.addAction(fileConvertBMPAction)

                fileConvertSVGAction = QAction(QApplication.translate('Menu', 'SVG...'), self)
                fileConvertSVGAction.triggered.connect(self.fileConvertSVG)
                self.convMenu.addAction(fileConvertSVGAction)

                fileConvertPDFAction = QAction(QApplication.translate('Menu', 'PDF...'), self)
                fileConvertPDFAction.triggered.connect(self.fileConvertPDF)
                self.convMenu.addAction(fileConvertPDFAction)

                fileConvertReportPDFAction = QAction(QApplication.translate('Menu', 'Roast Report PDF...'), self)
                fileConvertReportPDFAction.triggered.connect(self.fileConvertReportPDF)
                self.convMenu.addAction(fileConvertReportPDFAction)
                if not self.QtWebEngineSupport:
                    fileConvertReportPDFAction.setEnabled(False)

            self.fileMenu.addSeparator()

            self.saveGraphMenu: Optional[QMenu] = self.fileMenu.addMenu(QApplication.translate('Menu', 'Save Graph'))
            if self.saveGraphMenu is not None:
                PDFAction = QAction('PDF...', self)
                PDFAction.triggered.connect(self.saveVectorGraph_PDF)
                self.saveGraphMenu.addAction(PDFAction)

                SVGAction = QAction('SVG...', self)
                SVGAction.triggered.connect(self.saveVectorGraph_SVG)
                self.saveGraphMenu.addAction(SVGAction)

                fullsizeAction = QAction(QApplication.translate('Menu', 'PNG...'), self)
                fullsizeAction.triggered.connect(self.resizeImg_0_1)
                self.saveGraphMenu.addAction(fullsizeAction)

                JPEGAction = QAction('JPEG...', self)
                JPEGAction.triggered.connect(self.resizeImg_0_1_JPEG)
                self.saveGraphMenu.addAction(JPEGAction)

                BMPAction = QAction('BMP...', self)
                BMPAction.triggered.connect(self.resizeImg_0_1_BMP)
                self.saveGraphMenu.addAction(BMPAction)

                self.saveGraphMenu.addSeparator()

                HomeBaristaAction = QAction('Home-Barista.com (1200x?)...', self)
                HomeBaristaAction.triggered.connect(self.resizeImg_1200_1)
                self.saveGraphMenu.addAction(HomeBaristaAction)

                KaffeeNetzAction = QAction('Kaffee-Netz.de (800x?)...', self)
                KaffeeNetzAction.triggered.connect(self.resizeImg_800_1)
                self.saveGraphMenu.addAction(KaffeeNetzAction)

                RiktigtKaffeAction = QAction('RiktigtKaffe.se (620x?)...', self)
                RiktigtKaffeAction.triggered.connect(self.resizeImg_620_1)
                self.saveGraphMenu.addAction(RiktigtKaffeAction)

                PlanetCafeAction = QAction('PlanetCafe.fr (600x?)...', self)
                PlanetCafeAction.triggered.connect(self.resizeImg_600_1)
                self.saveGraphMenu.addAction(PlanetCafeAction)

                CoffeeGeekAction = QAction('CoffeeGeek.com (500x?)...', self)
                CoffeeGeekAction.triggered.connect(self.resizeImg_500_1)
                self.saveGraphMenu.addAction(CoffeeGeekAction)

                self.saveGraphMenu.addSeparator()

                facebookSizeAction = QAction('Facebook (1200x628)...', self)
                facebookSizeAction.triggered.connect(self.resizeImgSize_1200_628)
                self.saveGraphMenu.addAction(facebookSizeAction)

                instagramSizeAction = QAction('Instagram (1080x608)...', self)
                instagramSizeAction.triggered.connect(self.resizeImgSize_1080_608)
                self.saveGraphMenu.addAction(instagramSizeAction)

            self.reportMenu: Optional[QMenu] = self.fileMenu.addMenu(QApplication.translate('Menu', 'Report'))
            if self.reportMenu is not None:

                self.roastReportMenu: Optional[QMenu] = self.reportMenu.addMenu(QApplication.translate('Menu', 'Roast'))
                if self.roastReportMenu is not None:
                    self.roastReportPDFAction = QAction(QApplication.translate('Menu', 'PDF...'), self)
                    self.roastReportPDFAction.triggered.connect(self.pdfReport)
                    self.roastReportMenu.addAction(self.roastReportPDFAction)
                    if not self.QtWebEngineSupport:
                        self.roastReportPDFAction.setEnabled(False)

                    self.htmlAction = QAction(QApplication.translate('Menu', 'Web...'), self)
                    self.htmlAction.triggered.connect(self.htmlReport)
                    self.htmlAction.setShortcut('Ctrl+R')
                    self.roastReportMenu.addAction(self.htmlAction)

                self.productionMenu: Optional[QMenu] = self.reportMenu.addMenu(
                    QApplication.translate('Menu', 'Batches'))
                if self.productionMenu is not None:
                    self.productionPDFAction = QAction(QApplication.translate('Menu', 'PDF...'), self)
                    self.productionPDFAction.triggered.connect(self.productionPDFReport)
                    self.productionMenu.addAction(self.productionPDFAction)
                    if not self.QtWebEngineSupport:
                        self.productionPDFAction.setEnabled(False)
                    self.productionWebAction = QAction(QApplication.translate('Menu', 'Web...'), self)
                    self.productionWebAction.triggered.connect(self.productionHTMLReport)
                    self.productionMenu.addAction(self.productionWebAction)
                    self.productionCsvAction = QAction(QApplication.translate('Menu', 'CSV...'), self)
                    self.productionCsvAction.triggered.connect(self.productionCSVReport)
                    self.productionMenu.addAction(self.productionCsvAction)
                    self.productionExcelAction = QAction(QApplication.translate('Menu', 'Excel...'), self)
                    self.productionExcelAction.triggered.connect(self.productionExcelReport)
                    self.productionMenu.addAction(self.productionExcelAction)

                self.rankingMenu: Optional[QMenu] = self.reportMenu.addMenu(QApplication.translate('Menu', 'Ranking'))
                if self.rankingMenu is not None:
                    self.rankingPDFAction = QAction(QApplication.translate('Menu', 'PDF...'), self)
                    self.rankingPDFAction.triggered.connect(self.rankingPDFReport)
                    self.rankingMenu.addAction(self.rankingPDFAction)
                    if not self.QtWebEngineSupport:
                        self.rankingPDFAction.setEnabled(False)
                    self.rankingWebAction = QAction(QApplication.translate('Menu', 'Web...'), self)
                    self.rankingWebAction.triggered.connect(self.rankingHTMLReport)
                    self.rankingMenu.addAction(self.rankingWebAction)
                    self.rankingCsvAction = QAction(QApplication.translate('Menu', 'CSV...'), self)
                    self.rankingCsvAction.triggered.connect(self.rankingCSVReport)
                    self.rankingMenu.addAction(self.rankingCsvAction)
                    self.rankingExcelAction = QAction(QApplication.translate('Menu', 'Excel...'), self)
                    self.rankingExcelAction.triggered.connect(self.rankingExcelReport)
                    self.rankingMenu.addAction(self.rankingExcelAction)

            self.savestatisticsAction: QAction = QAction(QApplication.translate('Menu', 'Save Statistics...'), self)
            self.savestatisticsAction.triggered.connect(self.saveStatistics)
            self.fileMenu.addAction(self.savestatisticsAction)

            self.fileMenu.addSeparator()

            self.printAction: QAction = QAction(QApplication.translate('Menu', 'Print...'), self)
            self.printAction.setShortcut(QKeySequence.StandardKey.Print)
            self.printAction.triggered.connect(self.filePrint)
            self.fileMenu.addAction(self.printAction)

            self.quitAction: QAction
            if platform.system() == 'Darwin':
                self.quitAction = QAction('Quit', self)  # automatically translated by Qt Translators
            else:
                self.quitAction = QAction(
                    QApplication.translate('MAC_APPLICATION_MENU', 'Quit {0}').format(application_name), self)
            self.quitAction.setMenuRole(QAction.MenuRole.QuitRole)
            self.quitAction.setShortcut(QKeySequence.StandardKey.Quit)
            self.quitAction.triggered.connect(self.fileQuit)
            self.fileMenu.addAction(self.quitAction)

        # EDIT menu
        if self.editMenu is not None:
            self.cutAction: QAction = QAction(QApplication.translate('Menu', 'Cut'), self)
            self.cutAction.setShortcut(QKeySequence.StandardKey.Cut)
            self.editMenu.addAction(self.cutAction)
            self.cutAction.triggered.connect(self.on_actionCut_triggered)
            self.copyAction: QAction = QAction(QApplication.translate('Menu', 'Copy'), self)
            self.copyAction.setShortcut(QKeySequence.StandardKey.Copy)
            self.editMenu.addAction(self.copyAction)
            self.copyAction.triggered.connect(self.on_actionCopy_triggered)
            self.pasteAction: QAction = QAction(QApplication.translate('Menu', 'Paste'), self)
            self.pasteAction.setShortcut(QKeySequence.StandardKey.Paste)
            self.editMenu.addAction(self.pasteAction)
            self.pasteAction.triggered.connect(self.on_actionPaste_triggered)

        # ROAST menu
        if self.RoastMenu is not None:
            self.editGraphAction: QAction = QAction(QApplication.translate('Menu', 'Properties...'), self)
            self.editGraphAction.setMenuRole(QAction.MenuRole.NoRole)  # without this, this item is not shown in he
            self.editGraphAction.triggered.connect(self.editgraph)
            self.RoastMenu.addAction(self.editGraphAction)
            self.editGraphAction.setShortcut('Ctrl+T')

            self.backgroundAction: QAction = QAction(QApplication.translate('Menu', 'Background...'), self)
            self.backgroundAction.triggered.connect(self.background)
            self.RoastMenu.addAction(self.backgroundAction)
            self.backgroundAction.setShortcut('Ctrl+B')

            self.flavorAction: QAction = QAction(QApplication.translate('Menu', 'Cup Profile...'), self)
            self.flavorAction.triggered.connect(self.flavorchart)
            self.RoastMenu.addAction(self.flavorAction)

            self.RoastMenu.addSeparator()

            self.switchAction: QAction = QAction(QApplication.translate('Menu', 'Switch Profiles'), self)
            self.switchAction.setShortcut(QKeySequence.StandardKey.Close)
            self.switchAction.triggered.connect(self.switch)
            self.RoastMenu.addAction(self.switchAction)

            self.switchETBTAction: QAction = QAction(QApplication.translate('Menu', 'Switch ET<->BT'), self)
            self.switchETBTAction.triggered.connect(self.switchETBT)
            self.RoastMenu.addAction(self.switchETBTAction)

        # CONFIGURATION menu
        if self.ConfMenu is not None:
            self.machineMenu: QMenu = QMenu(QApplication.translate('Menu', 'Machine'))
            # populated in populateMachineMenu/populateListMenu if not empty
            self.populateMachineMenu()

            self.deviceAction: QAction = QAction(QApplication.translate('Menu', 'Device...'), self)
            self.deviceAction.triggered.connect(self.deviceassigment)
            self.ConfMenu.addAction(self.deviceAction)
            self.deviceAction.setShortcut('Ctrl+D')

            self.commportAction: QAction = QAction(QApplication.translate('Menu', 'Port...'), self)
            self.commportAction.triggered.connect(self.setcommport)
            self.ConfMenu.addAction(self.commportAction)

            self.ConfMenu.addSeparator()

            self.calibrateDelayAction: QAction = QAction(QApplication.translate('Menu', 'Sampling...'), self)
            self.calibrateDelayAction.triggered.connect(self.calibratedelay)
            self.ConfMenu.addAction(self.calibrateDelayAction)

            self.ConfMenu.addSeparator()

            self.curvesAction: QAction = QAction(QApplication.translate('Menu', 'Curves...'), self)
            self.curvesAction.triggered.connect(self.setCurves)
            self.curvesAction.setShortcut('Ctrl+U')
            self.ConfMenu.addAction(self.curvesAction)

            self.ConfMenu.addSeparator()

            self.eventsAction: QAction = QAction(QApplication.translate('Menu', 'Events...'), self)
            self.eventsAction.triggered.connect(self.eventsconf)
            self.ConfMenu.addAction(self.eventsAction)
            self.eventsAction.setShortcut('Ctrl+E')

            self.alarmAction: QAction = QAction(QApplication.translate('Menu', 'Alarms...'), self)
            self.alarmAction.triggered.connect(self.alarmconfig)
            self.alarmAction.setShortcut('Ctrl+A')
            self.ConfMenu.addAction(self.alarmAction)

            self.ConfMenu.addSeparator()

            self.phasesGraphAction: QAction = QAction(QApplication.translate('Menu', 'Phases...'), self)
            self.phasesGraphAction.triggered.connect(self.editphases)
            self.ConfMenu.addAction(self.phasesGraphAction)

            self.StatisticsAction: QAction = QAction(QApplication.translate('Menu', 'Statistics...'), self)
            self.StatisticsAction.triggered.connect(self.showstatistics)
            self.ConfMenu.addAction(self.StatisticsAction)

            self.WindowconfigAction: QAction = QAction(QApplication.translate('Menu', 'Axes...'), self)
            self.WindowconfigAction.triggered.connect(self.Windowconfig)
            self.WindowconfigAction.setShortcut('Ctrl+Shift+A')
            self.ConfMenu.addAction(self.WindowconfigAction)

            self.ConfMenu.addSeparator()

            self.colorsAction: QAction = QAction(QApplication.translate('Menu', 'Colors...'), self)
            self.colorsAction.triggered.connect(self.qmc.changeGColor3)
            self.ConfMenu.addAction(self.colorsAction)

            self.themeMenu: QMenu = QMenu(QApplication.translate('Menu', 'Themes'))
            self.populateThemeMenu()
            self.ConfMenu.addMenu(self.themeMenu)
            self.updateRecentThemeActions()

            self.ConfMenu.addSeparator()

            self.autosaveAction: QAction = QAction(QApplication.translate('Menu', 'Autosave...'), self)
            self.autosaveAction.triggered.connect(self.autosaveconf)
            self.ConfMenu.addAction(self.autosaveAction)

            self.batchAction: QAction = QAction(QApplication.translate('Menu', 'Batch...'), self)
            self.batchAction.triggered.connect(self.batchconf)
            self.ConfMenu.addAction(self.batchAction)

            self.ConfMenu.addSeparator()

            self.temperatureConfMenu: Optional[QMenu] = self.ConfMenu.addMenu(
                QApplication.translate('Menu', 'Temperature'))
            # self.FahrenheitAction: QAction
            self.CelsiusAction: QAction
            if self.temperatureConfMenu is not None:
                # self.FahrenheitAction = QAction(QApplication.translate('Menu', 'Fahrenheit Mode'), self)
                # self.FahrenheitAction.triggered.connect(self.qmc.celsiusModeRedraw)
                # self.temperatureConfMenu.addAction(self.FahrenheitAction)
                self.CelsiusAction = QAction(QApplication.translate('Menu', 'Celsius Mode'), self)
                self.CelsiusAction.triggered.connect(self.qmc.celsiusModeRedraw)
                self.temperatureConfMenu.addAction(self.CelsiusAction)

            self.languageMenu: Optional[QMenu]
            if self.ConfMenu is not None:
                self.languageMenu = self.ConfMenu.addMenu(QApplication.translate('Menu', 'Language'))

        # language_menu_actions holds a dict associating iso2 locale strings to language menu actions
        self.language_menu_actions: Dict[str, QAction] = {}

        # use s.encode("ascii", 'backslashreplace').decode("utf-8") and remove the duplicate \\
        for iso, name in [
            ('ar', '\u0627\u0644\u0639\u0631\u0628\u064a\u0629'),
            ('da', 'Dansk'),
            ('de', 'Deutsch'),
            ('en', 'English'),
            ('es', 'Espa\u00f1ol'),
            ('fa', '\u0641\u0627\u0631\u0633\u06cc'),
            ('fi', 'Suomalainen'),
            ('fr', 'Fran\u00e7ais'),
            ('gd', 'G\u00e0idhlig na h-Alba'),
            ('el', '\u03b5\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac'),
            ('he', '\u05e2\u05d1\u05e8\u05d9\u05ea'),
            ('id', 'Indonesia'),
            ('it', 'Italiano'),
            ('ja', '\u65e5\u672c\u8a9e'),
            ('ko', '\ud55c\uad6d\uc758'),
            ('lv', 'Latviete'),
            ('hu', 'Magyar'),
            ('nl', 'Nederlands'),
            ('no', 'Norsk'),
            ('pl', 'Polski'),
            ('pt', 'Portugu\xeas'),
            ('pt_BR', 'Portugu\u00EAs do Brasil'),
            ('ru', '\u0420\u0443\u0441\u0441\u043a\u0438\u0439'),
            ('sk', 'Slov\u00e1k'),
            ('sv', 'Svenska'),
            ('uk', '\u0443\u043a\u0440\u0430\u0457\u043d\u0435\u0446\u044c'),
            # "\u0443\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0438\u0439"),
            ('th', 'Thai'),
            ('tr', 'T\xfcrk\u00e7e'),
            ('vi', 'Ti\u1EBFng Vi\u1EC7t'),
            ('zh_CN', '\u7b80\u4f53\u4e2d\u6587'),
            ('zh_TW', '\u7e41\u9ad4\u4e2d\u6587')]:
            self.addLanguage(iso, name)

        # TOOLKIT menu

        if self.ToolkitMenu is not None:
            self.analyzeMenu: Optional[QMenu] = self.ToolkitMenu.addMenu(QApplication.translate('Menu', 'Analyzer'))
            if self.analyzeMenu is not None:
                self.fitIdealautoAction = QAction(QApplication.translate('Menu', 'Auto All'), self)
                self.fitIdealautoAction.triggered.connect(self.analysisfitCurvesALL)
                self.fitIdealautoAction.setShortcut('Ctrl+K')
                self.analyzeMenu.addAction(self.fitIdealautoAction)
                self.analyzeMenu.addSeparator()
                self.fitIdealx2Action = QAction(QApplication.translate('Menu', 'Fit BT to') + ' x\xb2', self)
                self.fitIdealx2Action.triggered.connect(self.analysisfitCurvesX2)
                self.analyzeMenu.addAction(self.fitIdealx2Action)
                self.fitIdealx3Action = QAction(QApplication.translate('Menu', 'Fit BT to') + ' x\xb3', self)
                self.fitIdealx3Action.triggered.connect(self.analysisfitCurvesX3)
                self.analyzeMenu.addAction(self.fitIdealx3Action)
                self.fitIdealx0Action = QAction(QApplication.translate('Menu', 'Fit BT to') + ' ln()', self)
                self.fitIdealx0Action.triggered.connect(self.analysisfitCurvesLN)
                self.analyzeMenu.addAction(self.fitIdealx0Action)
                self.analyzeMenu.addSeparator()
                self.fitBkgndAction = QAction(QApplication.translate('Menu', 'Fit BT to Bkgnd'), self)
                self.fitBkgndAction.triggered.connect(self.analysisfitCurvesBkgnd)
                self.analyzeMenu.addAction(self.fitBkgndAction)
                self.analyzeMenu.addSeparator()
                self.clearresultsAction = QAction(QApplication.translate('Menu', 'Clear results'), self)
                self.clearresultsAction.triggered.connect(self.clearResults)
                self.clearresultsAction.setShortcut('Ctrl+Alt+K')  # COMMAND+OPTION on macOS
                self.analyzeMenu.addAction(self.clearresultsAction)

            self.roastCompareAction: QAction = QAction(QApplication.translate('Menu', 'Comparator'), self)
            self.roastCompareAction.triggered.connect(self.roastCompare)
            self.roastCompareAction.setCheckable(True)
            self.roastCompareAction.setChecked(bool(self.comparator))
            self.ToolkitMenu.addAction(self.roastCompareAction)

            self.designerAction: QAction = QAction(QApplication.translate('Menu', 'Designer'), self)
            self.designerAction.triggered.connect(self.designerTriggered)
            self.designerAction.setCheckable(True)
            self.designerAction.setChecked(self.qmc.designerflag)
            self.ToolkitMenu.addAction(self.designerAction)

            self.simulatorAction: QAction = QAction(QApplication.translate('Menu', 'Simulator'), self)
            self.simulatorAction.triggered.connect(self.simulate)
            self.simulatorAction.setCheckable(True)
            self.simulatorAction.setChecked(bool(self.simulator))
            self.ToolkitMenu.addAction(self.simulatorAction)

            self.wheeleditorAction: QAction = QAction(QApplication.translate('Menu', 'Wheel Graph'), self)
            self.wheeleditorAction.triggered.connect(self.graphwheel)
            self.wheeleditorAction.setCheckable(True)
            self.wheeleditorAction.setChecked(self.qmc.wheelflag)
            self.ToolkitMenu.addAction(self.wheeleditorAction)

            self.ToolkitMenu.addSeparator()

            self.transformAction: QAction = QAction(QApplication.translate('Menu', 'Transposer'), self)
            self.transformAction.triggered.connect(self.transform)
            self.ToolkitMenu.addAction(self.transformAction)

            self.temperatureMenu: Optional[QMenu] = self.ToolkitMenu.addMenu(
                QApplication.translate('Menu', 'Convert Profile Temperature'))

            # self.ConvertToFahrenheitAction: QAction
            self.ConvertToCelsiusAction: QAction
            if self.temperatureMenu is not None:
                # self.ConvertToFahrenheitAction = QAction(QApplication.translate('Menu', 'Convert to Fahrenheit'), self)
                # self.ConvertToFahrenheitAction.triggered.connect(self.qmc.convertTemperatureF)
                # self.temperatureMenu.addAction(self.ConvertToFahrenheitAction)

                self.ConvertToCelsiusAction = QAction(QApplication.translate('Menu', 'Convert to Celsius'), self)
                self.ConvertToCelsiusAction.triggered.connect(self.qmc.convertTemperatureC)
                self.temperatureMenu.addAction(self.ConvertToCelsiusAction)

                if self.qmc.mode == 'C':
                    # self.FahrenheitAction.setDisabled(True)
                    # self.ConvertToFahrenheitAction.setDisabled(True)
                    self.CelsiusAction.setDisabled(True)
                    self.ConvertToCelsiusAction.setDisabled(True)
                else:
                    self.CelsiusAction.setDisabled(True)
                    self.ConvertToCelsiusAction.setDisabled(True)

            self.ToolkitMenu.addSeparator()

            calculatorAction = QAction(QApplication.translate('Menu', 'Calculator'), self)
            calculatorAction.triggered.connect(self.calculator)
            self.ToolkitMenu.addAction(calculatorAction)

        # VIEW menu

        if self.viewMenu is not None:
            self.controlsAction = QAction(QApplication.translate('Menu', 'Controls'), self)
            self.controlsAction.triggered.connect(self.toggleControls)
            self.controlsAction.setCheckable(True)
            self.controlsAction.setChecked(True)
            self.viewMenu.addAction(self.controlsAction)

            self.readingsAction = QAction(QApplication.translate('Menu', 'Readings'), self)
            self.readingsAction.triggered.connect(self.toggleReadings)
            self.readingsAction.setCheckable(True)
            self.readingsAction.setChecked(False)
            self.viewMenu.addAction(self.readingsAction)

            self.eventsEditorAction = QAction(QApplication.translate('Menu', 'Events Editor'), self)
            self.eventsEditorAction.triggered.connect(self.toggle_minieventline)
            self.eventsEditorAction.setCheckable(True)
            self.eventsEditorAction.setChecked(False)
            self.viewMenu.addAction(self.eventsEditorAction)

            self.buttonsAction = QAction(QApplication.translate('Menu', 'Buttons'), self)
            self.buttonsAction.triggered.connect(self.toggleExtraButtons)
            self.buttonsAction.setCheckable(True)
            self.buttonsAction.setChecked(False)
            self.viewMenu.addAction(self.buttonsAction)

            self.slidersAction: QAction = QAction(QApplication.translate('Menu', 'Sliders'), self)
            self.slidersAction.triggered.connect(self.toggleSliders)
            self.slidersAction.setCheckable(True)
            self.slidersAction.setChecked(False)
            self.viewMenu.addAction(self.slidersAction)

            self.viewMenu.addSeparator()

            self.lcdsAction: QAction = QAction(QApplication.translate('Menu', 'Main LCDs'), self)
            self.lcdsAction.triggered.connect(self.largeLCDs)
            self.lcdsAction.setCheckable(True)
            self.lcdsAction.setChecked(False)
            self.lcdsAction.setShortcut('Ctrl+L')
            self.viewMenu.addAction(self.lcdsAction)

            self.deltalcdsAction: QAction = QAction(QApplication.translate('Menu', 'Delta LCDs'), self)
            self.deltalcdsAction.triggered.connect(self.largeDeltaLCDs)
            self.deltalcdsAction.setCheckable(True)
            self.deltalcdsAction.setChecked(False)
            self.viewMenu.addAction(self.deltalcdsAction)

            self.pidlcdsAction: QAction = QAction(QApplication.translate('Menu', 'PID LCDs'), self)
            self.pidlcdsAction.triggered.connect(self.largePIDLCDs)
            self.pidlcdsAction.setCheckable(True)
            self.pidlcdsAction.setChecked(False)
            self.viewMenu.addAction(self.pidlcdsAction)

            self.extralcdsAction: QAction = QAction(QApplication.translate('Menu', 'Extra LCDs'), self)
            self.extralcdsAction.triggered.connect(self.largeExtraLCDs)
            self.extralcdsAction.setCheckable(True)
            self.extralcdsAction.setChecked(False)
            self.viewMenu.addAction(self.extralcdsAction)

            self.phaseslcdsAction: QAction = QAction(QApplication.translate('Menu', 'Phases LCDs'), self)
            self.phaseslcdsAction.triggered.connect(self.largePhasesLCDs)
            self.phaseslcdsAction.setCheckable(True)
            self.phaseslcdsAction.setChecked(False)
            self.viewMenu.addAction(self.phaseslcdsAction)

            self.scalelcdsAction: QAction = QAction(QApplication.translate('Menu', 'Scale LCDs'), self)
            self.scalelcdsAction.triggered.connect(self.largeScaleLCDs)
            self.scalelcdsAction.setCheckable(True)
            self.scalelcdsAction.setChecked(False)
            self.viewMenu.addAction(self.scalelcdsAction)

            self.viewMenu.addSeparator()

            if not (
                    platform.system() == 'Darwin' and self.qmc.locale_str == 'en'):  # macOS automatically adds the fullscreen action to View menu
                self.fullscreenAction = QAction(QApplication.translate('Menu', 'Full Screen'), self)
                self.fullscreenAction.triggered.connect(self.toggleFullscreen)
                self.fullscreenAction.setCheckable(True)
                self.fullscreenAction.setChecked(False)
                self.fullscreenAction.setShortcut('Ctrl+F')
                self.fullscreenAction.setMenuRole(QAction.MenuRole.NoRole)
                self.viewMenu.addAction(self.fullscreenAction)

        # HELP menu
        if self.helpMenu is not None:
            if self.app.artisanviewerMode:
                helpAboutAction = QAction(
                    QApplication.translate('MAC_APPLICATION_MENU', 'About {0}').format(application_viewer_name), self)
            else:
                helpAboutAction = QAction(
                    QApplication.translate('MAC_APPLICATION_MENU', 'About {0}').format(application_name), self)
            helpAboutAction.setMenuRole(QAction.MenuRole.AboutRole)
            helpAboutAction.triggered.connect(self.helpAbout)
            self.helpMenu.addAction(helpAboutAction)

            aboutQtAction = QAction(QApplication.translate('Menu', 'About Qt'), self)
            aboutQtAction.setMenuRole(QAction.MenuRole.AboutQtRole)
            aboutQtAction.triggered.connect(self.showAboutQt)
            self.helpMenu.addAction(aboutQtAction)

            helpDocumentationAction = QAction(QApplication.translate('Menu', 'Documentation'), self)
            helpDocumentationAction.triggered.connect(self.helpHelp)
            helpDocumentationAction.setShortcut(QKeySequence.StandardKey.HelpContents)
            self.helpMenu.addAction(helpDocumentationAction)

            KshortCAction = QAction(QApplication.translate('Menu', 'Keyboard Shortcuts'), self)
            KshortCAction.triggered.connect(self.viewKshortcuts)
            self.helpMenu.addAction(KshortCAction)

            self.helpMenu.addSeparator()

            checkUpdateAction = QAction(QApplication.translate('Menu', 'Check for Updates'), self)
            checkUpdateAction.setMenuRole(QAction.MenuRole.NoRole)
            checkUpdateAction.triggered.connect(self.checkUpdate)
            self.helpMenu.addAction(checkUpdateAction)

            self.helpMenu.addSeparator()

            errorAction = QAction(QApplication.translate('Menu', 'Errors'), self)
            errorAction.triggered.connect(self.viewErrorLog)
            self.helpMenu.addAction(errorAction)

            messageAction = QAction(QApplication.translate('Menu', 'Messages'), self)
            messageAction.triggered.connect(self.viewMessageLog)
            self.helpMenu.addAction(messageAction)

            serialAction = QAction(QApplication.translate('Menu', 'Serial'), self)
            serialAction.triggered.connect(self.viewSerialLog)
            serialAction.setMenuRole(QAction.MenuRole.NoRole)
            self.helpMenu.addAction(serialAction)

            platformAction = QAction(QApplication.translate('Menu', 'Platform'), self)
            platformAction.triggered.connect(self.viewplatform)
            self.helpMenu.addAction(platformAction)

            # SETTINGS submenu
            self.helpMenu.addSeparator()

            self.loadSettingsAction = QAction(QApplication.translate('Menu', 'Load Settings...'), self)
            self.loadSettingsAction.triggered.connect(self.loadSettings_triggered)
            self.loadSettingsAction.setMenuRole(QAction.MenuRole.NoRole)  # avoid specific handling of settings menu
            self.helpMenu.addAction(self.loadSettingsAction)

            self.openRecentSettingMenu: Optional[QMenu] = self.helpMenu.addMenu(
                QApplication.translate('Menu', 'Load Recent Settings'))
            if self.openRecentSettingMenu is not None:
                for i in range(self.MaxRecentFiles):
                    self.openRecentSettingMenu.addAction(self.recentSettingActs[i])
                self.updateRecentSettingActions()

            self.saveAsSettingsAction = QAction(QApplication.translate('Menu', 'Save Settings...'), self)
            self.saveAsSettingsAction.triggered.connect(self.saveSettings)
            self.saveAsSettingsAction.setMenuRole(QAction.MenuRole.NoRole)  # avoid specific handling of settings menu

            self.helpMenu.addAction(self.saveAsSettingsAction)
            self.helpMenu.addSeparator()
            self.resetAction = QAction(QApplication.translate('Menu', 'Factory Reset'), self)
            self.resetAction.triggered.connect(self.resetApplication)
            self.helpMenu.addAction(self.resetAction)

        self.displayonlymenus()

        # 创建一个标签对象来显示程序状态信息
        self.messagelabel: QLabel = QLabel()
        f = self.messagelabel.font()
        f.setPointSize(self.messagelabel.font().pointSize() + 1)
        self.messagelabel.setFont(f)

        self.messagelabel.setIndent(6)
        # 设置几个宽泛的样式参数
        if platform.system() == 'Linux':
            self.button_font_size_pt = 11
        else:
            self.button_font_size_pt = 13

        # TODO: delete # pylint: disable=fixme
        if platform.system() == 'Windows':
            self.button_font_size = f'{self.button_font_size_pt - 2}pt'
        else:
            self.button_font_size = f'{self.button_font_size_pt}pt'
        self.button_font_size_small = f'{self.button_font_size_pt - 3}pt'
        self.button_font_size_small_selected = f'{self.button_font_size_pt - 2}pt'
        self.button_font_size_tiny = f'{self.button_font_size_pt - 4}pt'
        self.button_font_size_micro = f'{self.button_font_size_pt - 5}pt'

        # TODO: keep # pylint: disable=fixme
        button_font_size_small_pt = self.button_font_size_pt - 3
        button_font_size_small_selected_pt = self.button_font_size_pt - 2
        #        button_font_size_tiny_pt = self.button_font_size_pt - 4
        #        button_font_size_micro_pt = self.button_font_size_pt - 5
        if platform.system() == 'Windows':
            self.button_font_size_pt = self.button_font_size_pt - 2

        self.main_button_min_width_str: str
        self.small_button_min_width_str: str
        self.tiny_button_min_width_str: str
        self.standard_button_min_width_px: int

        # 以像素为单位的按钮宽度
        if platform.system() == 'Windows':
            # TODO: remove # pylint: disable=fixme
            self.main_button_min_width_str = '110px'
            self.small_button_min_width_str = '75px'
            self.tiny_button_min_width_str = '60px'
            # TODO: keep # pylint: disable=fixme
            #            self.main_button_min_width_px = 110
            self.standard_button_min_width_px = 90
        #            self.small_button_min_width_px = 75
        # self.tiny_button_min_width_px = 60
        else:
            # TODO: remove # pylint: disable=fixme
            self.main_button_min_width_str = '100px'
            self.small_button_min_width_str = '60px'
            self.tiny_button_min_width_str = '50px'
            # TODO: keep # pylint: disable=fixme
            #            self.main_button_min_width_px = 100
            self.standard_button_min_width_px = 75
        #            self.small_button_min_width_px = 60
        #            self.tiny_button_min_width_px = 50

        border_modern = f'border-style:solid; border-radius:{4*self.height_scale}px;border-color:grey; border-width:0;'  # modernize
        # 自定义按钮的样式
        self.pushbuttonstyles_simulator: dict[str, str] = {
            'OFF': """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: '#147bb3';
                    background-color: white;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: #E0E0E0;
                }
                QPushButton:pressed {
                    color: 116D98;
                    background-color: #EEEEEE;
                }
                QPushButton:hover:!pressed {
                    color: #1985ba;
                    background-color: #F5F5F5;
                }
            """,
            'ON': """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: #cc0f50;
                    background-color: white;

                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #c70d49;
                    background-color: #EEEEEE;
                }
                QPushButton:hover:!pressed {
                    color: #d4336a;
                    background-color: #F5F5F5;
                }
            """,
            'STOP': """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: #147bb3;
                    background-color: white;
                }
                QPushButton:!enabled {
                    color: #EFEFEF;
                    background-color: darkgrey;
                }
                QPushButton:pressed {
                    color: #116999;
                    background-color: #EEEEEE;
                }
                QPushButton:hover:!pressed {
                    color: #1985ba;
                    background-color: #F5F5F5;
                }
            """,
            'START': """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: yellow;
                    background-color: #ff3d00;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #116999;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: red;
                }
            """,
        }

        self.pushbuttonstyles: dict[str, str] = {
            'RESET': """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background-color: #2298c7;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: lightgrey;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #1985ba;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: #43a7cf;
                }
            """,
            'OFF': """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background-color: #147bb3;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #116D98;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: #1985ba;
                }
            """,
            'ON': """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background-color: #cc0f50;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #c70d49;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: #d4336a;
                }
            """,
            'STOP': """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background-color: #147bb3;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #116999;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: #1985ba;
                }
            """,
            'START': """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: yellow;
                    background-color: #ff3d00;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: #E0E0E0;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #116999;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: red;
                }
            """,
            'PID': """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background-color: #2298c7;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: lightgrey;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #1985ba;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: #43a7cf;
                }
            """,
            'PIDactive': """
                QPushButton {
                    min-width: """ + self.main_button_min_width_str + """;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size + """;
                    font-weight: bold;
                    color: white;
                    background-color: #cc0f50;
                }
                QPushButton:!enabled {
                    color: darkgrey;
                    background-color: lightgrey;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color: #c70d49;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color: #d4336a;
                }
            """,
            'SV +': """
                QPushButton {
                    min-width: """ + str(self.standard_button_min_width_px) + """px;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background-color:""" + createGradient('#db5785') + """ ;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color:""" + createGradient('#d4336a') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color:""" + createGradient('#e480a2') + """ ;
                                     }
            """,
            'SV -': """
                QPushButton {
                    min-width: """ + str(self.standard_button_min_width_px) + """px;
                    """ + border_modern + """
                    font-size: """ + self.button_font_size_small + """;
                    font-weight: bold;
                    color: white;
                    background-color:""" + createGradient('#64b7d8') + """ ;
                }
                QPushButton:pressed {
                    color: #EEEEEE;
                    background-color:""" + createGradient('#43a7cf') + """ ;
                }
                QPushButton:hover:!pressed {
                    color: white;
                    background-color:""" + createGradient('#85cae1') + """ ;
                }
            """
        }
        # 我们使用这个高度来动态调整按钮大小以适应不同的字体大小(这对Windows上的高dpi显示很重要)
        self.standard_button_tiny_height: int
        self.standard_button_small_height: int
        self.standard_button_height: int
        if platform.system() == 'Windows':
            default_button_height = QPushButton('Test').sizeHint().height()
            self.standard_button_tiny_height = int(round(default_button_height * 1.1))
            self.standard_button_small_height = int(round(default_button_height * 1.5))
            self.standard_button_height = int(round(default_button_height * 2))
        else:
            self.standard_button_small_height = QPushButton('Test').sizeHint().height()
            self.standard_button_tiny_height = int(round(self.standard_button_small_height * 0.8))
            self.standard_button_height = int(round(self.standard_button_small_height * 1.3))

        # create ON/OFF buttons

        self.buttonONOFF: QPushButton = QPushButton(QApplication.translate('Button', 'ON'))
        self.buttonONOFF.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonONOFF.setToolTip(QApplication.translate('Tooltip', 'Start monitoring'))
        self.buttonONOFF.setStyleSheet(self.pushbuttonstyles['OFF'])
        self.buttonONOFF.setGraphicsEffect(self.makeShadow())
        self.buttonONOFF.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.buttonONOFF.setMinimumHeight(self.standard_button_height)
        self.buttonONOFF.clicked.connect(self.qmc.ToggleMonitor)
        if self.app.artisanviewerMode:
            self.buttonONOFF.setVisible(False)

        # create START/STOP buttons
        self.buttonSTARTSTOP: QPushButton = QPushButton(QApplication.translate('Button', 'START'))
        self.buttonSTARTSTOP.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSTARTSTOP.setToolTip(QApplication.translate('Tooltip', 'Start recording'))
        self.buttonSTARTSTOP.setStyleSheet(self.pushbuttonstyles['STOP'])
        self.buttonSTARTSTOP.setGraphicsEffect(self.makeShadow())
        #        self.buttonSTARTSTOP.pressed.connect(self.mainButtonPressed)
        #        self.buttonSTARTSTOP.released.connect(self.mainButtonReleased)
        self.buttonSTARTSTOP.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        self.buttonSTARTSTOP.setMinimumHeight(self.standard_button_height)
        self.buttonSTARTSTOP.clicked.connect(self.qmc.ToggleRecorder)
        if self.app.artisanviewerMode:
            self.buttonSTARTSTOP.setVisible(False)

        # 创建1C开始、1C结束、2C开始和2C结束按钮 一爆二爆
        self.buttonFCs: MinorEventPushButton = MinorEventPushButton(QApplication.translate('Button', 'FC\nSTART'))
        self.buttonFCs.setToolTip(QApplication.translate('Tooltip', 'First Crack Start'))
        self.buttonFCs.clicked.connect(self.qmc.mark1Cstart)

        self.buttonFCe: MinorEventPushButton = MinorEventPushButton(QApplication.translate('Button', 'FC\nEND'))
        self.buttonFCe.setToolTip(QApplication.translate('Tooltip', 'First Crack End'))
        self.buttonFCe.clicked.connect(self.qmc.mark1Cend)

        self.buttonSCs: MinorEventPushButton = MinorEventPushButton(QApplication.translate('Button', 'SC\nSTART'))
        self.buttonSCs.setToolTip(QApplication.translate('Tooltip', 'Second Crack Start'))
        self.buttonSCs.clicked.connect(self.qmc.mark2Cstart)

        self.buttonSCe: MinorEventPushButton = MinorEventPushButton(QApplication.translate('Button', 'SC\nEND'))
        self.buttonSCe.setToolTip(QApplication.translate('Tooltip', 'Second Crack End'))
        self.buttonSCe.clicked.connect(self.qmc.mark2Cend)

        # create RESET button
        self.buttonRESET: QPushButton = QPushButton(QApplication.translate('Button', 'RESET'))
        self.buttonRESET.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonRESET.setStyleSheet(self.pushbuttonstyles['RESET'])
        self.buttonRESET.setGraphicsEffect(self.makeShadow())
        #        self.buttonRESET.pressed.connect(self.mainButtonPressed)
        #        self.buttonRESET.released.connect(self.mainButtonReleased)
        self.buttonRESET.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.buttonRESET.setMinimumHeight(self.standard_button_height)
        self.buttonRESET.setToolTip(QApplication.translate('Tooltip', 'Reset'))
        self.buttonRESET.clicked.connect(self.qmc.resetButtonAction)

        # create CHARGE button出仓
        self.buttonCHARGE: AnimatedMajorEventPushButton = AnimatedMajorEventPushButton(
            QApplication.translate('Button', 'CHARGE'))
        self.buttonCHARGE.setToolTip(QApplication.translate('Tooltip', 'Charge'))
        self.buttonCHARGE.clicked.connect(self.qmc.markCharge)

        # create DROP button 出库
        self.buttonDROP: MajorEventPushButton = MajorEventPushButton(QApplication.translate('Button', 'DROP'))
        self.buttonDROP.setToolTip(QApplication.translate('Tooltip', 'Drop'))
        self.buttonDROP.clicked.connect(self.qmc.markDrop)

        # create PID control button
        self.buttonCONTROL: QPushButton = QPushButton(QApplication.translate('Button', 'Control'))
        self.buttonCONTROL.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonCONTROL.setStyleSheet(self.pushbuttonstyles['PID'])
        self.buttonCONTROL.setGraphicsEffect(self.makeShadow())
        #        self.buttonCONTROL.pressed.connect(self.mainButtonPressed)
        #        self.buttonCONTROL.released.connect(self.mainButtonReleased)
        self.buttonCONTROL.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.buttonCONTROL.setMinimumHeight(self.standard_button_height)
        self.buttonCONTROL.clicked.connect(self.PIDcontrol)
        if self.app.artisanviewerMode:
            self.buttonCONTROL.setVisible(False)

        self.buttonOpen: QPushButton = QPushButton(QApplication.translate('Button', 'OPEN'))
        self.buttonOpen.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonOpen.setStyleSheet(self.pushbuttonstyles['OFF'])
        self.buttonOpen.setGraphicsEffect(self.makeShadow())
        self.buttonOpen.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.buttonOpen.setMinimumHeight(self.standard_button_height)
        self.buttonOpen.clicked.connect(self.fileLoad)
        if self.app.artisanviewerMode:
            self.buttonOpen.setVisible(False)

        # create EVENT record button
        self.buttonEVENT: AuxEventPushButton = AuxEventPushButton(QApplication.translate('Button', 'EVENT'))
        self.buttonEVENT.setToolTip(QApplication.translate('Tooltip', 'Event'))
        self.buttonEVENT.clicked.connect(self.qmc.EventRecord_action)

        # create PID+5 button
        self.buttonSVp5: QPushButton = QPushButton(QApplication.translate('Button', 'SV +5'))
        self.buttonSVp5.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSVp5.setStyleSheet(self.pushbuttonstyles['SV +'])
        self.buttonSVp5.setMinimumWidth(90)
        self.buttonSVp5.setMinimumHeight(self.standard_button_height)
        self.buttonSVp5.setToolTip(QApplication.translate('Tooltip', 'Increases the current SV value by 5'))
        self.buttonSVp5.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        # create PID+10 button
        self.buttonSVp10: QPushButton = QPushButton(QApplication.translate('Button', 'SV +10'))
        self.buttonSVp10.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSVp10.setStyleSheet(self.pushbuttonstyles['SV +'])
        self.buttonSVp10.setMinimumWidth(90)
        self.buttonSVp10.setMinimumHeight(self.standard_button_height)
        self.buttonSVp10.setToolTip(QApplication.translate('Tooltip', 'Increases the current SV value by 10'))
        self.buttonSVp10.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        # create PID+20 button
        self.buttonSVp20: QPushButton = QPushButton(QApplication.translate('Button', 'SV +20'))
        self.buttonSVp20.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSVp20.setStyleSheet(self.pushbuttonstyles['SV +'])
        self.buttonSVp20.setMinimumWidth(90)
        self.buttonSVp20.setMinimumHeight(self.standard_button_height)
        self.buttonSVp20.setToolTip(QApplication.translate('Tooltip', 'Increases the current SV value by 20'))
        self.buttonSVp20.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        # create PID-20 button
        self.buttonSVm20: QPushButton = QPushButton(QApplication.translate('Button', 'SV -20'))
        self.buttonSVm20.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSVm20.setStyleSheet(self.pushbuttonstyles['SV -'])
        self.buttonSVm20.setMinimumWidth(90)
        self.buttonSVm20.setMinimumHeight(self.standard_button_height)
        self.buttonSVm20.setToolTip(QApplication.translate('Tooltip', 'Decreases the current SV value by 20'))
        self.buttonSVm20.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        # create PID-10 button
        self.buttonSVm10: QPushButton = QPushButton(QApplication.translate('Button', 'SV -10'))
        self.buttonSVm10.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSVm10.setStyleSheet(self.pushbuttonstyles['SV -'])
        self.buttonSVm10.setMinimumWidth(90)
        self.buttonSVm10.setMinimumHeight(self.standard_button_height)
        self.buttonSVm10.setToolTip(QApplication.translate('Tooltip', 'Decreases the current SV value by 10'))
        self.buttonSVm10.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        # create PID-5 button
        self.buttonSVm5: QPushButton = QPushButton(QApplication.translate('Button', 'SV -5'))
        self.buttonSVm5.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.buttonSVm5.setStyleSheet(self.pushbuttonstyles['SV -'])
        self.buttonSVm5.setMinimumWidth(90)
        self.buttonSVm5.setMinimumHeight(self.standard_button_height)
        self.buttonSVm5.setToolTip(QApplication.translate('Tooltip', 'Decreases the current SV value by 5'))
        self.buttonSVm5.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        # HUD按钮(button_18已删除)

        # create DRY button 转黄点
        self.buttonDRY: MinorEventPushButton = MinorEventPushButton(QApplication.translate('Button', 'DRY\nEND'))
        self.buttonDRY.setToolTip(QApplication.translate('Tooltip', 'Dry End'))
        self.buttonDRY.clicked.connect(self.qmc.markDryEnd)

        # create COOLe button
        self.buttonCOOL: MinorEventPushButton = MinorEventPushButton(QApplication.translate('Button', 'COOL\nEND'))
        self.buttonCOOL.setToolTip(QApplication.translate('Tooltip', 'Cool End'))
        self.buttonCOOL.clicked.connect(self.qmc.markCoolEnd)

        # connect PID sv easy buttons
        self.buttonSVp5.clicked.connect(self.adjustPIDsv5)
        self.buttonSVp10.clicked.connect(self.adjustPIDsv10)
        self.buttonSVp20.clicked.connect(self.adjustPIDsv20)
        self.buttonSVm20.clicked.connect(self.adjustPIDsv20m)
        self.buttonSVm10.clicked.connect(self.adjustPIDsv10m)
        self.buttonSVm5.clicked.connect(self.adjustPIDsv5m)

        # NavigationToolbar VMToolbar
        # self.ntb: VMToolbar = VMToolbar(self.qmc, self.main_widget)
        # self.ntb.setMinimumHeight(50)

        # create LCD displays
        # RIGHT COLUMN
        self.lcd1: MyQLCDNumber = MyQLCDNumber()  # time
        self.lcd1.setSegmentStyle(QLCDNumber.SegmentStyle.Flat)
        self.lcd1.setMinimumHeight(40)
        self.lcd1.setMinimumWidth(100)
        self.lcd1.setFrameStyle(QFrame.Shadow.Plain)
        # switch superusermode action:
        self.lcd1.clicked.connect(self.superusermodeLeftClicked)
        self.lcd1.setVisible(False)

        self.lcd2: MyQLCDNumber = self.ArtisanLCD()  # Temperature ET
        self.lcd3: MyQLCDNumber = self.ArtisanLCD()  # Temperature BT
        self.lcd4: MyQLCDNumber = self.ArtisanLCD()  # rate of change ET
        self.lcd5: MyQLCDNumber = self.ArtisanLCD()  # rate of change BT
        self.lcd6: MyQLCDNumber = self.ArtisanLCD()  # pid sv
        self.lcd7: MyQLCDNumber = self.ArtisanLCD()  # pid power % duty cycle

        # self.lcd1.display('00:00')
        # zz = '-.-' if self.qmc.LCDdecimalplaces else '--'
        # self.lcd2.display(zz)
        # self.lcd3.display(zz)
        # self.lcd4.display(zz)
        # self.lcd5.display(zz)
        # self.lcd6.display(zz)
        # self.lcd7.display(zz)

        self.lcd1.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['timer']}; background-color: {self.lcdpaletteB['timer']};}}")
        self.lcd2.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['et']}; background-color: {self.lcdpaletteB['et']};}}")
        self.lcd3.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['bt']}; background-color: {self.lcdpaletteB['bt']};}}")
        self.lcd4.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['deltaet']}; background-color: {self.lcdpaletteB['deltaet']};}}")
        self.lcd5.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['deltabt']}; background-color: {self.lcdpaletteB['deltabt']};}}")
        self.lcd6.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['sv']}; background-color: {self.lcdpaletteB['sv']};}}")
        self.lcd7.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['sv']}; background-color: {self.lcdpaletteB['sv']};}}")

        self.lcd1.setToolTip(QApplication.translate('Tooltip', 'Timer'))
        self.lcd2.setToolTip(QApplication.translate('Tooltip', 'ET Temperature'))
        self.lcd3.setToolTip(QApplication.translate('Tooltip', 'BT Temperature'))
        self.lcd4.setToolTip(QApplication.translate('Tooltip', 'ET/time (degrees/min)'))
        self.lcd5.setToolTip(QApplication.translate('Tooltip', 'BT/time (degrees/min)'))
        self.lcd6.setToolTip(QApplication.translate('Tooltip', 'Value of SV in PID'))
        self.lcd7.setToolTip(QApplication.translate('Tooltip', 'PID power %'))

        # MET
        self.label2: QLabel = QLabel()
        self.label2.setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
        self.label2.setText('0')
        # self.processInfoLabel.setText(f"<big><b>{QApplication.translate('Label', 'ET')}</b></big>")
        self.setLabelColor(self.label2, QColor(self.qmc.palette['et']))

        # BT
        self.label3: QLabel = QLabel()
        self.label3.setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
        self.label3.setText(f"<big><b>{QApplication.translate('Label', 'BT')}</b></big>")
        self.setLabelColor(self.label3, QColor(self.qmc.palette['bt']))
        # DELTA MET
        self.label4: QLabel = QLabel()
        self.label4.setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
        self.label4.setText(f"{deltaLabelBigPrefix}{QApplication.translate('Label', 'ET')}</b></big>")
        self.setLabelColor(self.label4, QColor(self.qmc.palette['deltaet']))
        # DELTA BT
        self.label5: QLabel = QLabel()
        self.label5.setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
        self.label5.setText(f"{deltaLabelBigPrefix}{QApplication.translate('Label', 'BT')}</b></big>")
        self.setLabelColor(self.label5, QColor(self.qmc.palette['deltabt']))
        # pid sv
        self.label6: QLabel = QLabel()
        self.label6.setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
        self.label6.setText(f"<big><b>{QApplication.translate('Label', 'PID SV')}</b></big>")
        # pid power % duty cycle
        self.label7: QLabel = QLabel()
        self.label7.setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
        self.label7.setText(f"<big><b>{QApplication.translate('Label', 'PID %')}</b></big>")

        # extra LCDs
        self.extraLCD1: List[MyQLCDNumber] = []
        self.extraLCD2: List[MyQLCDNumber] = []
        self.extraLCDlabel1: List[QLabel] = []
        self.extraLCDlabel2: List[QLabel] = []
        self.extraLCDframe1: List[ClickableLCDFrame] = []
        self.extraLCDframe2: List[ClickableLCDFrame] = []
        self.extraLCDvisibility1: List[bool] = [False] * self.nLCDS
        self.extraLCDvisibility2: List[bool] = [False] * self.nLCDS
        self.extraCurveVisibility1: List[bool] = [True] * self.nLCDS
        self.extraCurveVisibility2: List[bool] = [True] * self.nLCDS
        self.extraDelta1: List[bool] = [False] * self.nLCDS
        self.extraDelta2: List[bool] = [False] * self.nLCDS
        self.extraFill1: List[int] = [0] * self.nLCDS  # alpha values 0-100 in % of fill between extra curve and x-axis
        self.extraFill2: List[int] = [0] * self.nLCDS  # alpha values 0-100 in % of fill between extra curve and x-axis
        for i in range(self.nLCDS):
            # configure LCDs
            self.extraLCDframe1.append(ClickableLCDFrame())
            self.extraLCD1.append(self.ArtisanLCD())
            self.extraLCDlabel1.append(QLabel())
            self.extraLCDframe2.append(ClickableLCDFrame())
            self.extraLCD2.append(self.ArtisanLCD())
            self.extraLCDlabel2.append(QLabel())
            self.extraLCDframe1[i].setVisible(False)
            if self.qmc.LCDdecimalplaces:
                if self.qmc.intChannel(i, 0):
                    self.extraLCD1[i].display('--')
                else:
                    self.extraLCD1[i].display('-.-')
                if self.qmc.intChannel(i, 1):
                    self.extraLCD2[i].display('--')
                else:
                    self.extraLCD2[i].display('-.-')
            else:
                self.extraLCD1[i].display('--')
                self.extraLCD2[i].display('--')
            self.extraLCDframe1[i].setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.extraLCDframe1[i].customContextMenuRequested.connect(self.setTare_slot)
            self.extraLCDframe1[i].left_clicked.connect(self.toggleExtraCurve1)
            self.extraLCDframe1[i].setVisible(False)
            self.extraLCDframe2[i].setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.extraLCDframe2[i].customContextMenuRequested.connect(self.setTare_slot)
            self.extraLCDframe2[i].left_clicked.connect(self.toggleExtraCurve2)
            self.extraLCDframe2[i].setVisible(False)
            self.extraLCD1[i].setStyleSheet(
                f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['sv']}; background-color: {self.lcdpaletteB['sv']};}}")
            self.extraLCD2[i].setStyleSheet(
                f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['sv']}; background-color: {self.lcdpaletteB['sv']};}}")
            # configure Labels
            self.extraLCDlabel1[i].setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
            self.extraLCDlabel2[i].setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
            self.extraLCDlabel1[i].setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)
            self.extraLCDlabel2[i].setAlignment(Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)

        # 通道皮重值(通过点击相应的LCD进行设置)
        # 用于ET/BT和每个额外通道(2x self.nLCDS)
        self.channel_tare_values: List[float] = [0.0] * (2 + self.nLCDS * 2)

        # 最多可存储500封邮件
        self.messagehist: List[str] = []

        # 仅当设备为富士PID时，才可操作控制按钮
        # 通过PID控制面板激活SV按钮
        self.buttonCONTROL.setVisible(False)

        self.buttonSVp5.setVisible(False)
        self.buttonSVp10.setVisible(False)
        self.buttonSVp20.setVisible(False)
        self.buttonSVm20.setVisible(False)
        self.buttonSVm10.setVisible(False)
        self.buttonSVm5.setVisible(False)

        #### 事件迷你编辑器:无需打开烘焙属性Dlg即可查看和编辑事件
        self.eventlabel: QLabel = QLabel(f'{QApplication.translate("Form Caption", "Event")} #<b>0 </b>')

        self.eventlabel.setIndent(5)

        self.eNumberSpinBox: QSpinBox = QSpinBox()
        self.eNumberSpinBox.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.eNumberSpinBox.setToolTip(QApplication.translate('Tooltip', 'Number of events found'))
        self.eNumberSpinBox.setRange(0, 99)
        self.eNumberSpinBox.valueChanged.connect(self.changeEventNumber)
        self.eNumberSpinBox.setMaximumWidth(40)

        self.minieventleft: QPushButton = QPushButton('<')
        self.minieventleft.clicked.connect(self.decrEventNumber)
        self.minieventright = QPushButton('>')
        self.minieventright.clicked.connect(self.incrEventNumber)

        self.lineEvent: QLineEdit = QLineEdit()
        self.lineEvent.setMinimumWidth(200)

        self.eventlabel.setStyleSheet("background-color:'#bdbdbd';")

        self.etypeComboBox: QComboBox = QComboBox()
        self.etypeComboBox.setToolTip(QApplication.translate('Tooltip', 'Type of event'))
        self.etypeComboBox.addItems(self.qmc.etypes)

        # regexvalue = QRegularExpression(r"^100|\d?\d?$") # allow event values 0-100 (%)
        regexvalue: QRegularExpression = QRegularExpression(r'^[1-9][0-9]{1,3}$|^\d$')  # allow event values 0-9999
        self.valueEdit: QLineEdit = QLineEdit()
        self.valueEdit.setValidator(QRegularExpressionValidator(regexvalue, self))
        self.valueEdit.setToolTip(QApplication.translate('Tooltip', 'Value of event'))
        self.valueEdit.setMaximumWidth(50)

        regextime = QRegularExpression(r'^-?[0-9]?[0-9]?[0-9]:[0-5][0-9]$')
        self.etimeline: QLineEdit = QLineEdit()
        self.etimeline.setValidator(QRegularExpressionValidator(regextime, self))
        self.etimeline.setMaximumWidth(50)

        # 创建事件迷你按钮
        self.buttonminiEvent: QPushButton = QPushButton(QApplication.translate('Button', 'Update'))
        self.buttonminiEvent.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.buttonminiEvent.clicked.connect(self.miniEventRecord)
        self.buttonminiEvent.setToolTip(QApplication.translate('Tooltip', 'Updates the event'))

        ####自定义事件按钮
        self.buttonlist: List[QPushButton] = []
        self.buttonStates: List[
            int] = []  # per custom event button it holds a 0 or 1 if indicating its state as managed by button actions
        self.lastbuttonpressed: int = -1
        self.buttonlistmaxlen: int = 11
        self.buttonpalette_default_label: Final[str] = ''
        self.buttonpalette_label: str = self.buttonpalette_default_label
        # 10个按钮调色板
        self.max_palettes: Final[int] = 10
        self.palette_entries: Final[int] = 28
        self.buttonpalette: List[
            Palette] = []  # a list of Palettes, either valid, paletteValid(p), or empty, generated by makePalette(empty=True)
        for _ in range(self.max_palettes):
            self.buttonpalette.append(self.makePalette())
        self.buttonpalettemaxlen: List[int] = [14] * 10  # keeps max number of buttons per row per palette
        self.buttonpalette_shortcuts: bool = True  # if True palettes can be changed via the number keys
        self.buttonsize: int = 1  # 0: tiny, 1: small (default), 2: large
        self.mark_last_button_pressed: bool = True
        self.show_extrabutton_tooltips: bool = False

        self.eventbuttontablecolumnwidths: List[int] = []  # custom event button table column widths

        # 创建下层按钮小部件布局QDialogButtonBox以堆叠所有下层按钮
        self.lowerbuttondialogLayout = QHBoxLayout()
        self.lowerbuttondialogLayout.setSpacing(5)
        self.lowerbuttondialogLayout.setContentsMargins(0, 0, 0, 10)

        self.lowerbuttondialog: QFrame = QFrame()
        self.lowerbuttondialog.setLayout(self.lowerbuttondialogLayout)
        self.lowerbuttondialog.setVisible(False)
        # 我们在此设置分配给self.lowerbuttondialog的事件按钮的样式
        # 其子元素的所有样式表(实际的事件按钮)都必须没有冲突。
        # 任何冲突都会关闭父样式的合并，而只依赖子样式表。
        self.lowerbuttondialog.setStyleSheet(
            artisan_event_button_style.format(
                min_width=self.standard_button_min_width_px - 6,
                min_height=self.standard_button_height - 7,
                padding=3,
                default_font_size=button_font_size_small_pt,
                selected_font_size=button_font_size_small_selected_pt))

        # initiate configuration
        self.lowerbuttondialogLayout.addStretch()
        self.lowerbuttondialogLayout.addWidget(self.buttonCHARGE)
        self.lowerbuttondialogLayout.addWidget(self.buttonDRY)
        self.lowerbuttondialogLayout.addWidget(self.buttonFCs)
        self.lowerbuttondialogLayout.addWidget(self.buttonFCe)
        self.lowerbuttondialogLayout.addWidget(self.buttonSCs)
        self.lowerbuttondialogLayout.addWidget(self.buttonSCe)
        self.lowerbuttondialogLayout.addWidget(self.buttonDROP)
        self.lowerbuttondialogLayout.addWidget(self.buttonCOOL)
        self.lowerbuttondialogLayout.addWidget(self.buttonEVENT)
        self.lowerbuttondialogLayout.addStretch()

        self.e1buttonbarLayout = QHBoxLayout()
        self.e1buttonbarLayout.setSpacing(1)
        self.e1buttonbarLayout.setContentsMargins(0, 0, 0, 0)
        self.e1buttondialog = QFrame()
        self.e1buttondialog.setContentsMargins(0, 0, 0, 0)
        self.e1buttondialog.setLayout(self.e1buttonbarLayout)

        self.e2buttonbarLayout = QHBoxLayout()
        self.e2buttonbarLayout.setSpacing(1)
        self.e2buttonbarLayout.setContentsMargins(0, 0, 0, 0)
        self.e2buttondialog = QFrame()
        self.e2buttondialog.setContentsMargins(0, 0, 0, 0)
        self.e2buttondialog.setLayout(self.e2buttonbarLayout)

        self.e3buttonbarLayout = QHBoxLayout()
        self.e3buttonbarLayout.setSpacing(1)
        self.e3buttonbarLayout.setContentsMargins(0, 0, 0, 0)
        self.e3buttondialog = QFrame()
        self.e3buttondialog.setContentsMargins(0, 0, 0, 0)
        self.e3buttondialog.setLayout(self.e3buttonbarLayout)

        self.e4buttonbarLayout = QHBoxLayout()
        self.e4buttonbarLayout.setSpacing(1)
        self.e4buttonbarLayout.setContentsMargins(0, 0, 0, 0)
        self.e4buttondialog = QFrame()
        self.e4buttondialog.setContentsMargins(0, 0, 0, 0)
        self.e4buttondialog.setLayout(self.e4buttonbarLayout)

        # 将焦点设置在主小部件上
        self.main_widget.setFocus()

        # 将MainWindow的中心小部件设置为main_widget
        self.setCentralWidget(self.main_widget)

        # 可供选择的功能列表(使用左右键盘箭头)
        # side cond:len(self . keyboardmove)= len(self . keyboard button list)#对于每个self.keyboardmoveindex，我们有一个keyboard move函数
        self.keyboardmove: List[Callable[..., None]] = [self.qmc.markCharge, self.qmc.markDryEnd, self.qmc.mark1Cstart,
                                                        self.qmc.mark1Cend,
                                                        self.qmc.mark2Cstart, self.qmc.mark2Cend, self.qmc.markDrop,
                                                        self.qmc.markCoolEnd, self.qmc.EventRecord]
        # 可通过键盘控制的按钮列表
        # 重置->开/关->..->事件(从不使用索引0处的重置)
        self.keyboardButtonList = [
            # this list corresponds to the self.qmc.buttonvisibility, but has additionally the entry for the EVENT button
            self.buttonCHARGE,  # 0 CHARGE
            self.buttonDRY,  # 1 DRY END
            self.buttonFCs,  # 2 FC START
            self.buttonFCe,  # 3 FC END
            self.buttonSCs,  # 4 SC START
            self.buttonSCe,  # 5 SC END
            self.buttonDROP,  # 6 DROP
            self.buttonCOOL,  # 7 COOL END
            self.buttonEVENT  # 8 EVENT
        ]
        # 0:CHARGE,1:DRY,2:FCs,3:FCe,4:SCs,5:SCe,6:DROP,7:COOL,8:EVENT
        self.keyboardButtonStyles = [
            'CHARGE',
            'DRY END',
            'FC START',
            'FC END',
            'SC START',
            'SC END',
            'DROP',
            'COOL END',
            'EVENT']

        # 上述当前功能
        self.keyboardmoveindex: int = 0  # points to the last activated button; we start with the CHARGE button (see keyboardButtonList)
        # 上面的州旗。它是通过按空格键或左右箭头来初始化的
        self.keyboardmoveflag: int = 0
        # 防止多次识别的最后一个键盘事件空间的时间戳
        self.lastkeyboardcmd: float = 0.

        self.error_dlg: Optional[
            errorDlg] = None  # bound to the error message window instance if open, update by updategraphics
        self.serial_dlg: Optional[
            serialLogDlg] = None  # bound to the serial message window if open, update by updategraphics
        self.message_dlg: Optional[
            messageDlg] = None  # bound to the serial message window if open, update by updategraphics

        self.ETname: str = QApplication.translate('Label', 'ET')
        self.BTname: str = QApplication.translate('Label', 'BT')

        ####################   应用程序窗口(AW)布局  ##############################################

        self.level1frame = QFrame()
        self.level1layout = QHBoxLayout()  # matplotlib toolbox + RESET button + LCD Timer
        self.level1frame.setLayout(self.level1layout)
        self.level1frame.setVisible(False)

        level3layout = QHBoxLayout()  # PID buttons, graph, temperature LCDs

        pidbuttonLayout = QVBoxLayout()

        EventsLayout = QHBoxLayout()
        EventsLayout.setContentsMargins(1, 1, 1, 1)
        EventsLayout.setSpacing(0)

        # 事件迷你编辑器布局
        EventsLayout.addWidget(self.eventlabel)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.etimeline)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.lineEvent)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.etypeComboBox)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.valueEdit)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.eNumberSpinBox)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.minieventleft)
        EventsLayout.addWidget(self.minieventright)
        EventsLayout.addSpacing(4)
        EventsLayout.addWidget(self.buttonminiEvent)
        self.EventsGroupLayout = QGroupBox()
        self.EventsGroupLayout.setLayout(EventsLayout)
        self.EventsGroupLayout.setVisible(False)

        LCDlayout = QVBoxLayout()
        LCDlayout.setSpacing(0)
        LCDlayout.setContentsMargins(0, 0, 5, 0)
        LCDlayout.setSizeConstraint(QLayout.SizeConstraint.SetMinimumSize)

        # 将控制按钮+LCD放在垂直按钮布局管理器中
        self.LCD2frame: ClickableLCDFrame = ClickableLCDFrame()
        self.LCD2frame.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.LCD2frame.customContextMenuRequested.connect(self.setTareET)
        self.LCD2frame.left_clicked.connect(self.toggleETlcdCurve)
        w = self.makeLCDbox(self.label2, self.lcd2, self.LCD2frame)
        LCDlayout.addWidget(w)
        LCDlayout.setAlignment(w, Qt.AlignmentFlag.AlignRight)

        self.LCD3frame: ClickableLCDFrame = ClickableLCDFrame()
        self.LCD3frame.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.LCD3frame.customContextMenuRequested.connect(self.setTareBT)
        self.LCD3frame.left_clicked.connect(self.toggleBTlcdCurve)
        w = self.makeLCDbox(self.label3, self.lcd3, self.LCD3frame)
        LCDlayout.addWidget(w)
        LCDlayout.setAlignment(w, Qt.AlignmentFlag.AlignRight)

        self.LCD4frame: ClickableLCDFrame = ClickableLCDFrame()
        self.LCD4frame.left_clicked.connect(self.toggleDeltaETlcdCurve)
        w = self.makeLCDbox(self.label4, self.lcd4, self.LCD4frame)
        LCDlayout.addWidget(w)
        LCDlayout.setAlignment(w, Qt.AlignmentFlag.AlignRight)
        self.LCD4frame.setVisible(False)  # by default this one is not visible

        self.LCD5frame: ClickableLCDFrame = ClickableLCDFrame()
        self.LCD5frame.left_clicked.connect(self.toggleDeltaBTlcdCurve)
        w = self.makeLCDbox(self.label5, self.lcd5, self.LCD5frame)
        LCDlayout.addWidget(w)
        LCDlayout.setAlignment(w, Qt.AlignmentFlag.AlignRight)

        self.LCD6frame: QFrame = QFrame()
        w = self.makeLCDbox(self.label6, self.lcd6, self.LCD6frame)
        LCDlayout.addWidget(w)
        LCDlayout.setAlignment(w, Qt.AlignmentFlag.AlignRight)
        self.LCD6frame.setVisible(False)

        self.LCD7frame: QFrame = QFrame()
        w = self.makeLCDbox(self.label7, self.lcd7, self.LCD7frame)
        LCDlayout.addWidget(w)
        LCDlayout.setAlignment(w, Qt.AlignmentFlag.AlignRight)
        self.LCD7frame.setVisible(False)

        # add extra LCDs
        for i in range(self.nLCDS):
            w = self.makeLCDbox(self.extraLCDlabel1[i], self.extraLCD1[i], self.extraLCDframe1[i])
            LCDlayout.addWidget(w)
            LCDlayout.setAlignment(w, Qt.AlignmentFlag.AlignRight)
            w = self.makeLCDbox(self.extraLCDlabel2[i], self.extraLCD2[i], self.extraLCDframe2[i])
            LCDlayout.addWidget(w)
            LCDlayout.setAlignment(w, Qt.AlignmentFlag.AlignRight)
        LCDlayout.addStretch()
        del w

        # PID Buttons
        pidbuttonLayout.addWidget(self.buttonSVp20)
        pidbuttonLayout.addWidget(self.buttonSVp10)
        pidbuttonLayout.addWidget(self.buttonSVp5)
        pidbuttonLayout.addWidget(self.buttonSVm5)
        pidbuttonLayout.addWidget(self.buttonSVm10)
        pidbuttonLayout.addWidget(self.buttonSVm20)

        # phases LCDs

        # TP
        self.TPlabel: QLabel = QLabel()
        self.TPlabel.setText('<small><b>' + QApplication.translate('Label', 'TP') + '&raquo;</b></small>')
        self.TPlcd = QLCDNumber()
        self.TPlcd.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.TPlcd.customContextMenuRequested.connect(self.PhaseslcdClicked)
        self.TPlcd.display('--:--')
        self.TPlcdFrame = self.makePhasesLCDbox(self.TPlabel, self.TPlcd)

        # TP2DRY
        self.TP2DRYlabel: QLabel = QLabel('')
        self.TP2DRYlabel.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignVCenter)
        TP2DRYlayout = QHBoxLayout()
        TP2DRYlayout.addWidget(self.TP2DRYlabel)
        TP2DRYlayout.setContentsMargins(3, 0, 3, 0)
        self.TP2DRYframe = QFrame()
        self.TP2DRYframe.setLayout(TP2DRYlayout)

        # DRY
        self.DRYlabel: QLabel = QLabel()
        self.DRYlabel.setText('<small><b>&raquo;' + QApplication.translate('Label', 'DRY') + '</b></small>')
        self.DRYlcd = QLCDNumber()
        self.DRYlcd.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.DRYlcd.customContextMenuRequested.connect(self.PhaseslcdClicked)
        self.DRYlcd.display('--:--')
        self.DRYlcdFrame = self.makePhasesLCDbox(self.DRYlabel, self.DRYlcd)

        # DRY2FCs
        self.DRY2FCslabel: QLabel = QLabel('')
        self.DRY2FCslabel.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignVCenter)
        DRY2FCslayout = QHBoxLayout()
        DRY2FCslayout.addWidget(self.DRY2FCslabel)
        DRY2FCslayout.setContentsMargins(3, 0, 3, 0)
        self.DRY2FCsframe = QFrame()
        self.DRY2FCsframe.setLayout(DRY2FCslayout)

        # FCs
        self.FCslabel: QLabel = QLabel()
        self.FCslabel.setText('<small><b>&raquo;' + QApplication.translate('Label', 'FCs') + '</b></small>')
        self.FCslcd = QLCDNumber()
        self.FCslcd.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.FCslcd.customContextMenuRequested.connect(self.PhaseslcdClicked)
        self.FCslcd.display('--:--')
        self.FCslcdFrame = self.makePhasesLCDbox(self.FCslabel, self.FCslcd)

        # AUC LCD
        self.AUClabel: QLabel = QLabel()
        self.AUClabel.setText('<small><b>' + QApplication.translate('Label', 'AUC') + '</b></small>')
        self.AUClcd: QLCDNumber = QLCDNumber()
        self.AUClcd.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.AUClcd.customContextMenuRequested.connect(self.AUClcdClicked)
        self.AUClcd.display('--')
        self.AUClcdFrame: QFrame = self.makePhasesLCDbox(self.AUClabel, self.AUClcd)
        #        self.AUClcdFrame.setFrameStyle(QFrame.Shadow.Plain)
        self.AUClcd.setNumDigits(3)
        self.AUClcd.setMinimumWidth(65)
        self.AUClcdFrame.setStyleSheet(
            'QLCDNumber{border-radius:4; border-width: 0; border-color: black; border-style:solid; color: black; background-color: #e6e6e6;}')

        AUCLayout = QHBoxLayout()
        AUCLayout.addSpacing(20)
        AUCLayout.addWidget(self.AUClcdFrame)
        AUCLayout.setContentsMargins(0, 0, 0, 0)
        AUCLayout.setSpacing(0)

        self.AUCLCD: QFrame = QFrame()
        self.AUCLCD.setContentsMargins(0, 0, 0, 0)
        self.AUCLCD.setLayout(AUCLayout)
        self.AUCLCD.hide()

        #
        # self.phasesLCDs: QFrame = QFrame()
        # self.phasesLCDs.setContentsMargins(0, 0, 0, 0)
        # phasesLCDlayout = QHBoxLayout()
        # phasesLCDlayout.addWidget(self.TPlcdFrame)
        # phasesLCDlayout.addWidget(self.TP2DRYframe)
        # phasesLCDlayout.addWidget(self.DRYlcdFrame)
        # phasesLCDlayout.addWidget(self.DRY2FCsframe)
        # phasesLCDlayout.addWidget(self.FCslcdFrame)
        # phasesLCDlayout.setContentsMargins(0, 0, 0, 0)
        # phasesLCDlayout.setSpacing(0)
        # self.phasesLCDs.setLayout(phasesLCDlayout)
        # self.phasesLCDs.hide()
        # self.phasesLCDs.setToolTip(QApplication.translate('Tooltip','Phase LCDs: right-click to cycle through TIME, PERCENTAGE and TEMP MODE'))
        #
        # #level 1
        # self.level1layout.addStretch()
        # self.level1layout.addWidget(self.phasesLCDs)
        # self.level1layout.addWidget(self.AUCLCD)
        # self.level1layout.addSpacing(20)
        # self.level1layout.addWidget(self.buttonRESET)
        # self.level1layout.addSpacing(10)
        # self.level1layout.addWidget(self.buttonONOFF)
        # self.level1layout.addSpacing(1)
        # self.level1layout.addWidget(self.buttonOpen)
        # self.level1layout.addSpacing(10)
        # self.level1layout.addWidget(self.buttonSTARTSTOP)
        # self.level1layout.addSpacing(10)
        # self.level1layout.addWidget(self.buttonCONTROL)
        # self.level1layout.addSpacing(10)
        # self.level1layout.addWidget(self.lcd1)
        # self.level1layout.setSpacing(0)
        # self.level1layout.setContentsMargins(0,7,7,12) # left, top, right, bottom
        #
        # # level 3
        # level3layout.addLayout(pidbuttonLayout,0)
        #
        # self.qpc: tphasescanvas = tphasescanvas(self.dpi, self)
        # self.qpc.mpl_connect('scroll_event', self.scrollingPhases)
        #
        # self.scroller: QScrollArea = QScrollArea()
        # self.scroller.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        # self.scroller.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        # self.scroller.setWidget(self.qpc)
        # self.scroller.setWidgetResizable(True)
        # self.scroller.setFrameShape(QFrame.Shape.NoFrame)
        # self.scroller.setVisible(False)
        #
        # self.splitter: QSplitter = QSplitter(Qt.Orientation.Vertical)
        # self.splitter.addWidget(self.qmc)
        # self.splitter.addWidget(self.scroller)
        # self.splitter.setSizes([100,0])
        # self.splitter.setFrameShape(QFrame.Shape.NoFrame)
        # settings = QSettings()
        # if settings.contains('MainSplitter') and QApplication.queryKeyboardModifiers() != Qt.KeyboardModifier.AltModifier:
        #     self.splitter.restoreState(settings.value('MainSplitter'))
        #
        # self.splitter.setHandleWidth(7)
        #
        # self.splitter.setSizePolicy(QSizePolicy.Policy.Expanding,QSizePolicy.Policy.Expanding)
        # # self.qpc.setSizePolicy(QSizePolicy.Policy.Expanding,QSizePolicy.Policy.Fixed)图表位置
        # level3layout.addWidget(self.splitter)#添加图表
        #
        # level3layout.setSpacing(0)
        # level3layout.setContentsMargins(0,0,0,0)#

        self.extrabuttonsLayout = QVBoxLayout()
        self.extrabuttonsLayout.setContentsMargins(0, 0, 0, 10)
        self.extrabuttonsLayout.setSpacing(5)
        self.extrabuttonsLayout.addWidget(self.e1buttondialog)
        self.extrabuttonsLayout.addWidget(self.e2buttondialog)
        self.extrabuttonsLayout.addWidget(self.e3buttondialog)
        self.extrabuttonsLayout.addWidget(self.e4buttondialog)

        self.e1buttondialog.setVisible(False)
        self.e2buttondialog.setVisible(False)
        self.e3buttondialog.setVisible(False)
        self.e4buttondialog.setVisible(False)

        self.extrabuttondialogs = QFrame()
        self.extrabuttondialogs.setLayout(self.extrabuttonsLayout)
        self.extrabuttondialogs.setVisible(False)

        midleftlayout = QVBoxLayout()
        midleftlayout.setSpacing(0)
        midleftlayout.setContentsMargins(0, 0, 0, 0)
        midleftlayout.addWidget(self.messagelabel)
        midleftlayout.addLayout(level3layout)
        midleftlayout.addWidget(self.lowerbuttondialog)
        midleftlayout.addWidget(self.extrabuttondialogs)

        midleftlayout.addWidget(self.EventsGroupLayout)

        self.slider1: QSlider = self.slider()
        self.sliderLCD1: QLCDNumber = self.sliderLCD()
        self.sliderLCD1.setStyleSheet(f'font-weight: bold; color: {self.qmc.EvalueColor[0]};')
        self.sliderLCD1.display(self.slider1.value())
        sliderGrp1 = QVBoxLayout()
        sliderGrp1.addWidget(self.sliderLCD1)
        sliderGrp1.addWidget(self.slider1)
        sliderGrp1.setAlignment(Qt.AlignmentFlag.AlignCenter)
        sliderGrp1.setContentsMargins(0, 7, 0, 0)
        sliderGrp1.setSpacing(0)
        self.sliderGrpBox1 = QGroupBox()
        self.sliderGrpBox1.setLayout(sliderGrp1)
        self.sliderGrpBox1.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.sliderGrpBox1.setMinimumWidth(55)
        self.sliderGrpBox1.setMaximumWidth(55)
        self.sliderGrpBox1.setVisible(False)
        self.sliderGrpBox1.setFlat(True)
        self.sliderGrpBox1x = QVBoxLayout()  # we had to add this extra layer of QVBoxLayout for alignment issues
        self.sliderGrpBox1x.addWidget(self.sliderGrpBox1)
        # simulate tracking via sliderMoved events to work around an issue of certain PyQt5 variants on macOS; this breaks on PyQt6.2.2 on macOS
        # self.slider1.setTracking(False)
        # self.slider1.sliderMoved.connect(self.slider1Moved)
        # self.slider1.valueChanged.connect(self.slider1valueChanged)
        # tracking on version that works on PyQt6.2.2 on macOS and on PyQt 5.15.6
        # tracking by default on (drives the LCD)
        self.slider1.valueChanged.connect(self.updateSlider1LCD)
        self.slider1.sliderReleased.connect(self.slider1released)
        # needed for both tracking variants:
        self.slider1.actionTriggered.connect(self.slider1actionTriggered)
        self.slider1.setFocusPolicy(Qt.FocusPolicy.StrongFocus)  # ClickFocus TabFocus StrongFocus NoFocus

        self.slider2: QSlider = self.slider()
        self.sliderLCD2: QLCDNumber = self.sliderLCD()
        self.sliderLCD2.setStyleSheet(f'font-weight: bold; color: {self.qmc.EvalueColor[1]};')
        self.sliderLCD2.display(self.slider2.value())
        sliderGrp2 = QVBoxLayout()
        sliderGrp2.addWidget(self.sliderLCD2)
        sliderGrp2.addWidget(self.slider2)
        sliderGrp2.setAlignment(Qt.AlignmentFlag.AlignCenter)
        sliderGrp2.setContentsMargins(0, 7, 0, 0)
        sliderGrp2.setSpacing(0)
        self.sliderGrpBox2 = QGroupBox()
        self.sliderGrpBox2.setLayout(sliderGrp2)
        self.sliderGrpBox2.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.sliderGrpBox2.setMinimumWidth(55)
        self.sliderGrpBox2.setMaximumWidth(55)
        self.sliderGrpBox2.setVisible(False)
        self.sliderGrpBox2.setFlat(True)
        self.sliderGrpBox2x = QVBoxLayout()  # we had to add this extra layer of QVBoxLayout for alignment issues
        self.sliderGrpBox2x.addWidget(self.sliderGrpBox2)
        # tracking by default on (drives the LCD)
        self.slider2.valueChanged.connect(self.updateSlider2LCD)
        self.slider2.sliderReleased.connect(self.slider2released)
        # needed for both tracking variants:
        self.slider2.actionTriggered.connect(self.slider2actionTriggered)
        self.slider2.setFocusPolicy(Qt.FocusPolicy.StrongFocus)  # ClickFocus TabFocus StrongFocus

        self.slider3: QSlider = self.slider()
        self.sliderLCD3: QLCDNumber = self.sliderLCD()
        self.sliderLCD3.setStyleSheet(f'font-weight: bold; color: {self.qmc.EvalueColor[2]};')
        self.sliderLCD3.display(self.slider3.value())
        sliderGrp3 = QVBoxLayout()
        sliderGrp3.addWidget(self.sliderLCD3)
        sliderGrp3.addWidget(self.slider3)
        sliderGrp3.setAlignment(Qt.AlignmentFlag.AlignCenter)
        sliderGrp3.setContentsMargins(0, 7, 0, 0)
        sliderGrp3.setSpacing(0)
        self.sliderGrpBox3 = QGroupBox()
        self.sliderGrpBox3.setLayout(sliderGrp3)
        self.sliderGrpBox3.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.sliderGrpBox3.setMinimumWidth(55)
        self.sliderGrpBox3.setMaximumWidth(55)
        self.sliderGrpBox3.setVisible(False)
        self.sliderGrpBox3.setFlat(True)
        self.sliderGrpBox3x = QVBoxLayout()  # we had to add this extra layer of QVBoxLayout for alignment issues
        self.sliderGrpBox3x.addWidget(self.sliderGrpBox3)
        # simulate tracking via sliderMoved events to work around an issue of certain PyQt5 variants on macOS; this breaks on PyQt6.2.2 on macOS
        #        self.slider3.setTracking(False)
        #        self.slider3.sliderMoved.connect(self.slider3Moved)
        #        self.slider3.valueChanged.connect(self.slider3valueChanged)
        # tracking on version that works on PyQt6.2.2 on macOS and on PyQt 5.15.6
        # tracking by default on (drives the LCD)
        self.slider3.valueChanged.connect(self.updateSlider3LCD)
        self.slider3.sliderReleased.connect(self.slider3released)
        # needed for both tracking variants:
        self.slider3.actionTriggered.connect(self.slider3actionTriggered)
        self.slider3.setFocusPolicy(Qt.FocusPolicy.StrongFocus)  # ClickFocus TabFocus StrongFocus

        self.slider4: QSlider = self.slider()
        self.sliderLCD4: QLCDNumber = self.sliderLCD()
        self.sliderLCD4.setStyleSheet(f'font-weight: bold; color: {self.qmc.EvalueColor[3]};')
        self.sliderLCD4.display(self.slider4.value())
        sliderGrp4 = QVBoxLayout()
        sliderGrp4.addWidget(self.sliderLCD4)
        sliderGrp4.addWidget(self.slider4)
        sliderGrp4.setAlignment(Qt.AlignmentFlag.AlignCenter)
        sliderGrp4.setContentsMargins(0, 7, 0, 0)
        sliderGrp4.setSpacing(0)
        self.sliderGrpBox4 = QGroupBox()
        self.sliderGrpBox4.setLayout(sliderGrp4)
        self.sliderGrpBox4.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.sliderGrpBox4.setMinimumWidth(55)
        self.sliderGrpBox4.setMaximumWidth(55)
        self.sliderGrpBox4.setVisible(False)
        self.sliderGrpBox4.setFlat(True)
        self.sliderGrpBox4x = QVBoxLayout()  # we had to add this extra layer of QVBoxLayout for alignment issues
        self.sliderGrpBox4x.addWidget(self.sliderGrpBox4)
        # simulate tracking via sliderMoved events to work around an issue of certain PyQt5 variants on macOS; this breaks on PyQt6.2.2 on macOS
        #        self.slider4.setTracking(False)
        #        self.slider4.sliderMoved.connect(self.slider4Moved)
        #        self.slider4.valueChanged.connect(self.slider4valueChanged)
        # tracking on version that works on PyQt6.2.2 on macOS and on PyQt 5.15.6
        # 默认跟踪开启(驱动LCD)
        self.slider4.valueChanged.connect(self.updateSlider4LCD)
        self.slider4.sliderReleased.connect(self.slider4released)
        # 两种跟踪变量都需要:
        self.slider4.actionTriggered.connect(self.slider4actionTriggered)
        self.slider4.setFocusPolicy(Qt.FocusPolicy.StrongFocus)  # ClickFocus TabFocus StrongFocus

        self.sliderSV: QSlider = self.slider()
        self.sliderLCDSV: QLCDNumber = self.sliderLCD()
        #        self.sliderLCDSV.setStyleSheet("font-weight: bold; color: %s;"%self.qmc.palette["text"])
        self.sliderLCDSV.setNumDigits(3)
        self.sliderLCDSV.setStyleSheet('font-weight: bold;')
        sv = max(min(self.pidcontrol.svValue, self.pidcontrol.svSliderMax), self.pidcontrol.svSliderMin)
        self.sliderLCDSV.display(sv)
        sliderGrpSV = QVBoxLayout()
        sliderGrpSV.addWidget(self.sliderLCDSV)
        sliderGrpSV.addWidget(self.sliderSV)
        sliderGrpSV.setAlignment(Qt.AlignmentFlag.AlignCenter)
        sliderGrpSV.setContentsMargins(0, 7, 0, 0)
        sliderGrpSV.setSpacing(0)
        self.sliderGrpBoxSV: QGroupBox = QGroupBox()
        self.sliderGrpBoxSV.setLayout(sliderGrpSV)
        self.sliderGrpBoxSV.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.sliderGrpBoxSV.setMinimumWidth(55)
        self.sliderGrpBoxSV.setMaximumWidth(55)
        self.sliderGrpBoxSV.setVisible(False)
        self.sliderGrpBoxSV.setTitle(QApplication.translate('Label', 'SV'))
        self.sliderGrpBoxSV.setFlat(True)
        self.sliderSV.valueChanged.connect(self.updateSVSliderLCD)
        self.sliderSV.sliderReleased.connect(self.sliderSVreleased)
        self.sliderSV.actionTriggered.connect(self.sliderSVactionTriggered)
        self.sliderSV.setFocusPolicy(Qt.FocusPolicy.StrongFocus)  # ClickFocus TabFocus StrongFocus

        self.sliderGrp12 = QVBoxLayout()
        self.sliderGrp12.setSpacing(0)
        self.sliderGrp12.setContentsMargins(0, 0, 0, 0)
        self.sliderGrp12.addLayout(self.sliderGrpBox1x)
        self.sliderGrp12.addLayout(self.sliderGrpBox2x)
        self.sliderGrp34 = QVBoxLayout()
        self.sliderGrp34.setSpacing(0)
        self.sliderGrp34.setContentsMargins(0, 0, 0, 0)
        self.sliderGrp34.addLayout(self.sliderGrpBox3x)
        self.sliderGrp34.addLayout(self.sliderGrpBox4x)
        sliderGrpSV = QVBoxLayout()
        sliderGrpSV.setSpacing(0)
        sliderGrpSV.setContentsMargins(0, 0, 0, 0)
        sliderGrpSV.addWidget(self.sliderGrpBoxSV)

        self.leftlayout: QHBoxLayout = QHBoxLayout()
        self.leftlayout.setSpacing(0)
        self.leftlayout.setContentsMargins(0, 0, 0, 0)
        self.leftlayout.addLayout(self.sliderGrp12)
        self.leftlayout.addLayout(self.sliderGrp34)
        self.leftlayout.addLayout(sliderGrpSV)

        self.sliderFrame: QFrame = QFrame()
        self.sliderFrame.setLayout(self.leftlayout)
        self.sliderFrame.setVisible(False)
        self.sliderFrame.setContentsMargins(0, 0, 0, 0)

        self.lcdFrame: QFrame = QFrame()
        self.lcdFrame.setLayout(LCDlayout)
        self.lcdFrame.setVisible(False)
        self.lcdFrame.setContentsMargins(0, 0, 0, 0)
        self.lcdFrame.setSizePolicy(QSizePolicy.Policy.Maximum,
                                    QSizePolicy.Policy.Expanding)  # prevent horizontal expansion (graph might not maximize otherwise)

        self.midlayout: QHBoxLayout = QHBoxLayout()
        self.midlayout.addWidget(self.sliderFrame)
        self.midlayout.addLayout(midleftlayout)
        self.midlayout.addWidget(self.lcdFrame)
        self.midlayout.setSpacing(0)
        self.midlayout.setContentsMargins(0, 0, 0, 0)

        mainlayout: QVBoxLayout = QVBoxLayout(self.main_widget)
        mainlayout.addWidget(self.level1frame)
        mainlayout.addLayout(self.midlayout)
        mainlayout.setContentsMargins(0, 0, 0, 0)
        mainlayout.setSpacing(0)

        if self.qmc.mode == 'C':
            # self.qmc.mode = 'F'
            self.qmc.celsiusMode()
            self.qmc.phases = self.qmc.phases_celsius_defaults

        #        if self.qmc.toolbar is not None:
        #            self.qmc.toolbar.hide() # we need to hide the default navigation toolbar that we don't use
        #            self.qmc.toolbar.destroy()

        # 如果烘焙属性对话框打开，该变量将绑定到该对话框，设置为False将阻止打开该对话框，否则设置为None

        self.editgraphdialog: Optional[Union[editGraphDlg, bool]] = None

        #        # 在启动时向用户提供有关共享设置的信息消息
        if settingsRelocated:
            string = QApplication.translate('Message', 'Welcome to version {0} of Artisan!').format(
                __version__) + '\n\n'
            string += QApplication.translate('Message',
                                             'This is a one time message to inform you about a change in Artisan.') + '\n\n'
            string += QApplication.translate('Message',
                                             'If you never run older versions of Artisan you can skip this message, the change does not affect you.') + '  '
            string += QApplication.translate('Message',
                                             'Artisan preserves all your configuration settings when you exit so they will automatically be available the next time you start Artisan.') + '  '
            string += QApplication.translate('Message',
                                             'Beginning with release v2.0, settings will no longer be automatically shared at start-up with versions before v2.0.') + '\n\n'
            string += QApplication.translate('Message',
                                             'Do not worry. Since this is the first time you opened this new version Artisan has already loaded your last used settings.') + '\n\n'
            string += QApplication.translate('Message',
                                             "To share settings between this version and Artisan versions before v2.0 use 'Help>Save Settings' and 'Help>Load Settings'.") + '\n\n'
            string += QApplication.translate('Message', 'Enjoy using Artisan, The Artisan Team')
            QMessageBox.information(self, QApplication.translate('Message',
                                                                 'One time message about loading settings at start-up'),
                                    string)

        # provide information message to user about ArtisanViewer the first time it is started
        if self.artisanviewerFirstStart:
            string = QApplication.translate('Message', 'Welcome to the ArtisanViewer!').format(__version__) + '\n\n'
            string += QApplication.translate('Message',
                                             'This is a one time message to introduce you to the ArtisanViewer.') + '\n\n'
            string += QApplication.translate('Message',
                                             'The ArtisanViewer opens whenever a copy of Artisan is already running.') + '\n\n'
            string += QApplication.translate('Message',
                                             'ArtisanViewer will preserve all your configuration settings when you exit so they will automatically be available the next time you start ArtisanViewer.') + '\n\n'
            string += QApplication.translate('Message',
                                             "Caution, the only way to share settings between Artisan and ArtisanViewer is to explicitly save and load them using 'Help>Save Settings' and 'Help>Load Settings'.") + '\n\n'
            string += QApplication.translate('Message', 'Enjoy using ArtisanViewer,') + '\n'
            string += QApplication.translate('Message', 'The Artisan Team')
            QMessageBox.information(self, QApplication.translate('Message', 'One time message about ArtisanViewer'),
                                    string)
            settings.setValue('Mode',
                              self.qmc.mode)  # prevent this popup in case a second instance is started before this first one is closed.

        self.recording_version: str = str(
            __version__)  # saved to and loaded from profiles, indicating the Artisan version that created this profile, will be set to __version__ on RESET
        self.recording_revision: str = str(
            __revision__)  # saved to and loaded from profiles, indicating the Artisan revision that created this profile, will be set to __revision__ on RESET
        self.recording_build: str = str(
            __build__)  # saved to and loaded from profiles, indicating the Artisan build that created this profile, will be set to __build__ on RESET

        # we connect the signals
        self.singleShotPhidgetsPulseOFF.connect(self.processSingleShotPhidgetsPulse)
        self.singleShotPhidgetsPulseOFFSerial.connect(self.processSingleShotPhidgetsPulse)
        self.setTitleSignal.connect(self.qmc.setProfileTitle)
        self.sendmessageSignal.connect(self.sendmessage)
        self.openPropertiesSignal.connect(self.editgraph)
        self.soundpopSignal.connect(self.soundpop)
        self.setCanvasColorSignal.connect(self.setCanvasColor)
        self.resetCanvasColorSignal.connect(self.resetCanvasColor)
        self.setbuttonsfromSignal.connect(self.setbuttonsfromAction)
        self.setExtraEventButtonStyleSignal.connect(self.setExtraEventButtonStyle)
        self.loadBackgroundSignal.connect(self.loadbackgroundRedraw)
        self.clearBackgroundSignal.connect(self.clearbackgroundRedraw)
        self.setTareSignal.connect(self.setTare)
        self.adjustSVSignal.connect(self.adjustPIDsv)
        self.setSVSignal.connect(self.setPIDsv)
        self.fireslideractionSignal.connect(self.fireslideraction)
        self.moveButtonSignal.connect(self.moveKbutton)
        self.sendnotificationMessageSignal.connect(self.sendNotificationMessage)
        self.updateSubscriptionSignal.connect(self.updateSubscription)
        self.updateLimitsSignal.connect(self.updateLimits)
        self.updatePlaybackIndicatorSignal.connect(self.updatePlaybackIndicator)
        self.pidOnSignal.connect(self.pidOn)
        self.pidOffSignal.connect(self.pidOff)
        self.pidToggleSignal.connect(self.pidToggle)
        self.notificationsSetEnabledSignal.connect(self.notificationsSetEnabled)
        self.santokerSendMessageSignal.connect(self.santokerSendMessage)
        self.kaleidoSendMessageSignal.connect(self.kaleidoSendMessage)
        self.kaleidoSendMessageAwaitSignal.connect(self.kaleidoSendMessageAwait)
        self.addEventSignal.connect(self.addEventSlot, type=Qt.ConnectionType.QueuedConnection)  # type: ignore
        # by default the connection type is AutoConnection (If the emitter & receiver are in the same thread, a DirectConnection is used. Otherwise, a QueuedConnection is used.)
        # if the signal is send/receveid in the same thread a direct connection equals to a direct function call, the event is NOT put on the event loop and this not potentially processed delays
        # explicitly specifying QueuedConnection puts the message on the event loop and delays the processing potentially also if running in the same thread as the sender
        self.updateMessageLogSignal.connect(self.updateMessageLog)
        self.updateSerialLogSignal.connect(self.updateSerialLog)
        self.updateErrorLogSignal.connect(self.updateErrorLog)
        self.establishQuantifiedEventSignal.connect(self.establishQuantifiedEventSlot)
        self.updateExtraEventButtonsVisibilitySignal.connect(self.update_extraeventbuttons_visibility)
        self.realignButtonsSignal.connect(self.realignbuttons)
        self.loadAlarmsSignal.connect(self.loadAlarms, type=Qt.ConnectionType.QueuedConnection)  # type: ignore
        self.loadFileSignal.connect(self.loadFileSlot, type=Qt.ConnectionType.QueuedConnection)  # type: ignore
        self.loadPalettesSignal.connect(self.loadPalettesSlot, type=Qt.ConnectionType.QueuedConnection)  # type: ignore
        self.importArtisanURLSignal.connect(self.importArtisanURLSlot,
                                            type=Qt.ConnectionType.QueuedConnection)  # type: ignore
        self.comparatorAddProfileURLSignal.connect(self.comparatorAddProfileURLSlot,
                                                   type=Qt.ConnectionType.QueuedConnection)  # type: ignore
        self.comparatorAddProfileSignal.connect(self.comparatorAddProfileSlot,
                                                type=Qt.ConnectionType.QueuedConnection)  # type: ignore

        self.notificationManager: Optional[NotificationManager] = None
        if not self.app.artisanviewerMode:
            self.notificationManager = NotificationManager()

        if sys.platform.startswith('darwin') and QVersionNumber.fromString(qVersion())[0] < QVersionNumber(6, 5, 0):
            # only on macOS we install the eventFilter to catch the signal on switching between light and dark modes
            self.installEventFilter(self)

        # PLUS
        self.updatePlusStatusSignal.connect(self.updatePlusStatusSlot)

        QTimer.singleShot(2000, self.donate)

        QTimer.singleShot(0, self.logStartupTime)

        self.zoomInShortcut = QShortcut(QKeySequence.StandardKey.ZoomIn, self)
        self.zoomInShortcut.activated.connect(self.zoomIn)
        self.zoomOutShortcut = QShortcut(QKeySequence.StandardKey.ZoomOut, self)
        self.zoomOutShortcut.activated.connect(self.zoomOut)

        self.network_manager = QNetworkAccessManager(self)

        self.coffeeTitleVisible = True  # 设置文字闪烁显隐
        # self.show_message()
        # 阶段倒计时
        self.time_left = 30
        # self.label1111 = QLabel(f'Time left: {self.time_left} seconds', self)
        # self.label1111.setGeometry(20, 20, 76, 40)
        self.jieduanTimer = QTimer()
        self.jieduanTimer.timeout.connect(self.update_countdown)

    def resource_path(relative_path):
        """ Get the absolute path to a resource, works for both development and PyInstaller builds """
        if hasattr(sys, '_MEIPASS'):
            return os.path.join(sys._MEIPASS, relative_path)
        return os.path.join(os.path.abspath("."), relative_path)

    def loginUI(self):

        self.loginBack = QWidget(self)  # 登录
        self.loginBack.setStyleSheet('background-color: #ffffff;')
        self.loginBack.setGeometry(0, 0, 1920*self.width_scale, 1080*self.height_scale)
        # self.loginBack.setVisible(False)

        self.loginImg = QLabel(self.loginBack)
        self.loginImg.setGeometry(673*self.width_scale, 0, 1247*self.width_scale, 1080*self.height_scale)
        # self.loginImgpixmap = QPixmap(self.normalized_path + '/includes/Icons/login/back.png')  # 背景图
        # self.loginImg.setPixmap(self.loginImgpixmap)
        # self.loginImg.setScaledContents(True)

        self.loginImages = [
            self.normalized_path + '/includes/Icons/login/back.png',
            self.normalized_path + '/includes/Icons/login/back2.jpg',
            self.normalized_path + '/includes/Icons/login/back3.jpg',
            self.normalized_path + '/includes/Icons/login/back4.jpg',
            self.normalized_path + '/includes/Icons/login/back5.jpg',
            self.normalized_path + '/includes/Icons/login/back6.jpg'
        ]
        self.loginImages_index = random.randint(0, 5)
        self.update_image()
        # 设置定时器，每 20 秒切换一次图片
        self.imgtimer = QTimer(self)
        self.imgtimer.timeout.connect(self.next_image)
        self.imgtimer.start(20000)  # 20 秒 (20,000 毫秒)

        self.loginLogo = QLabel(self.loginBack)
        self.loginLogo.setGeometry(313*self.width_scale, 170*self.height_scale, 46*self.width_scale, 60*self.width_scale)
        self.loginLogopixmap = QPixmap(self.normalized_path + '/includes/Icons/login/LOGO.png')  # 背景图
        self.loginLogo.setPixmap(self.loginLogopixmap)
        self.loginLogo.setScaledContents(True)

        douyinSansBold = QFontDatabase.addApplicationFont(self.normalized_path + '/includes/Fonts/DouyinSansBold.otf')
        douyinSansBoldFamily = QFontDatabase.applicationFontFamilies(douyinSansBold)[0]

        self.logoTXT = QLabel(self.loginBack)
        self.logoTXT.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.logoTXT.setText('风味科学')
        self.logoTXT.setGeometry(272*self.width_scale, 267*self.height_scale, 128*self.width_scale, 30*self.height_scale)
        self.logoTXT.setStyleSheet("background-color: transparent; border:none;color: #252525; font-weight: bold;")
        logoTXTfont = QFont(douyinSansBoldFamily, 22*self.width_scale)
        self.logoTXT.setFont(logoTXTfont)

        self.userText = QLabel(self.loginBack)
        self.userText.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        self.userText.setText('用户名')
        self.userText.setGeometry(132*self.width_scale, 380*self.height_scale, 170*self.width_scale, 22*self.height_scale)
        self.userText.setStyleSheet("background-color: transparent; border:none;color: #959595; ")
        userTextfont = QFont(self.font_family6, 14*self.width_scale)
        self.userText.setFont(userTextfont)
        padding_left = int(38 * self.width_scale)
        self.userContent = QLineEdit(self.loginBack)
        self.userContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        # self.userContent.setText('185°')
        self.userContent.setStyleSheet(f"""
                                    QLineEdit {{
                                        background-color: #252525;  /* 设置背景颜色 */
                                        color: #FBFBFB;             /* 设置文字颜色 */
                                        padding-left: {padding_left}px;         /* 设置文字左边距 */
                                        font-size: 16px;            /* 设置字体大小 */
                                        border: none;               /* 移除边框 */
                                        border-radius: {30*self.height_scale}px;
                                    }}
                                """)
        userContentfont = QFont(self.font_family4, 14*self.width_scale)
        self.userContent.setFont(userContentfont)
        self.userContent.setGeometry(111*self.width_scale, 413*self.height_scale, 451*self.width_scale, 60*self.height_scale)  # 设置控件的固定大小为56x24px

        self.passwordText = QLabel(self.loginBack)
        self.passwordText.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        self.passwordText.setText('密码')
        self.passwordText.setGeometry(132*self.width_scale, 501*self.height_scale, 40*self.width_scale, 22*self.height_scale)
        self.passwordText.setStyleSheet("background-color: transparent; border:none;color: #959595; ")
        passwordTextfont = QFont(self.font_family6, 14*self.width_scale)
        self.passwordText.setFont(passwordTextfont)

        self.wjmm = QPushButton(self.loginBack)
        # self.wjmm.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        self.wjmm.setText('忘记密码？')
        self.wjmm.setGeometry(453*self.width_scale, 501*self.height_scale, 98*self.width_scale, 22*self.height_scale)
        self.wjmm.setStyleSheet("""
                                            QPushButton {
                                                background-color: transparent; border:none;color: #525252; 
                                            }
                                            QPushButton:hover {
                                                background-color: transparent; border:none;color: #252525; text-decoration: underline;
                                            }
                                        """)
        wjmmfont = QFont(self.font_family6, 14*self.width_scale)
        self.wjmm.setFont(wjmmfont)
        self.wjmm.setCursor(Qt.CursorShape.PointingHandCursor)

        self.passwordContent: QLineEdit = QLineEdit(self.loginBack)
        self.passwordContent.setEchoMode(QLineEdit.EchoMode.Password)  # 设置为密码模式
        self.passwordContent.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignLeft)
        # self.userContent.setText('185°')
        self.passwordContent.setStyleSheet(f"""
                                    QLineEdit {{
                                                background-color: #252525;  /* 设置背景颜色 */
                                                color: #FBFBFB;             /* 设置文字颜色 */
                                                padding-left: {padding_left}px;         /* 设置文字左边距 */
                                                font-size: 16px;            /* 设置字体大小 */
                                                border: none;               /* 移除边框 */
                                                border-radius: {30*self.height_scale}px;
                                            }}
                                """)
        passwordContentfont = QFont(self.font_family4, 14*self.width_scale)
        self.passwordContent.setFont(passwordContentfont)
        self.passwordContent.setGeometry(111*self.width_scale, 534*self.height_scale, 451*self.width_scale, 60*self.height_scale)  # 设置控件的固定大小为56x24px

        self.toggle_button = QPushButton(self.passwordContent)
        self.toggle_button.setGeometry(391*self.width_scale, 20*self.height_scale, 20*self.width_scale, 20*self.width_scale)
        self.toggle_button.setCheckable(True)
        self.toggle_button.setIcon(
            QIcon(self.normalized_path + '/includes/Icons/login/eyeFalse.png'))  # 使用图标作为按钮，需替换为实际路径
        self.toggle_button.setStyleSheet("border: none;background-color:transparent")  # 移除按钮边框
        self.toggle_button.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.toggle_button.clicked.connect(self.toggle_password_visibility)

        self.loginBtn = QPushButton(self.loginBack)
        # self.rdBtn.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.loginBtn.setText('登录')
        self.loginBtn.setGeometry(111*self.width_scale, 656*self.height_scale, 451*self.width_scale, 60*self.height_scale)
        self.loginBtn.setStyleSheet(
            f"QPushButton{{color: #121212;background-color: transparent;border-radius: {30*self.height_scale}px;border: 1px solid #8C6348}}"
            f"QPushButton:hover{{color: #ffffff;background-color: #8C6348;border-radius: {30*self.height_scale}px;}}"
        )
        loginBtnfont = QFont(self.font_family4, 14*self.width_scale)
        self.loginBtn.setFont(loginBtnfont)
        # self.loginBtn.clicked.connect(self.loginClicked)

        # self.myzhzc = QLabel(self.loginBack)
        # self.myzhzc.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        # self.myzhzc.setText('没有账号？ 注册')
        # self.myzhzc.setGeometry(263, 738, 140, 21)
        # self.myzhzc.setStyleSheet("background-color: transparent; border:none;color: #959595; ")
        # myzhzcfont = QFont(self.font_family6, 14)
        # self.myzhzc.setFont(myzhzcfont)

    # def add_data(self, data):
    #     if not hasattr(self, "id_value"):
    #         self.id_value = []  # 确保 id_value 已初始化
    #     self.id_value.append(data)

    # sys.stdout = open("outputttttttttttt.log", "w")
    # print(self.id_value)

    def updatetodayTime(self):
        # 获取当前时间
        current_time = QDateTime.currentDateTime()
        # 格式化时间为 'yyyy年M月d日 dddd HH:mm:ss'
        formatted_time = current_time.toString("yyyy年M月d日 dddd HH:mm:ss")
        # 更新标签显示
        self.todayTime.setText(formatted_time)

    def update_image(self):
        """更新当前显示的图片"""
        loginImgPixmap = QPixmap(self.loginImages[self.loginImages_index])
        self.loginImg.setPixmap(loginImgPixmap)
        self.loginImg.setScaledContents(True)  # 保证图片自动缩放适应标签

    def next_image(self):
        """切换到下一张图片"""
        self.loginImages_index = random.randint(0, 5)
        self.update_image()

    def closeSystemUI(self):
        self.closeBack = QLabel(self)  # 关机
        self.closeBack.setStyleSheet('background-color: #ffffff')
        self.closeBack.setGeometry(0, 0, 1920*self.width_scale, 1080*self.height_scale)
        self.closeBack.setVisible(False)

        self.movie = QMovie(self.normalized_path + '/includes/Icons/close/SceneEdit.gif')  # 替换为你的 GIF 文件路径
        self.movie.setScaledSize(QSize(1920 * self.width_scale, 1080 * self.height_scale))  # 缩放 GIF 尺寸
        self.closeBack.setMovie(self.movie)
        # 开始播放 GIF
        self.movie.start()

        self.closeTask = QLabel(self.closeBack)
        self.closeTask.setGeometry(428*self.width_scale, 201*self.height_scale, 1064*self.width_scale, 702*self.height_scale)
        self.closeTaskpixmap = QPixmap(self.normalized_path + '/includes/Icons/close/closeBack.png')  # 背景图
        self.closeTask.setStyleSheet('background-color: transparent')
        self.closeTask.setPixmap(self.closeTaskpixmap)
        self.closeTask.setScaledContents(True)

        self.closeTitle = QLabel(self.closeTask)
        self.closeTitle.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.closeTitle.setText('关 机 前 请 确 认 以 下 任 务 是 否 完 成')
        self.closeTitle.setGeometry(200*self.width_scale, 90*self.height_scale, 676*self.width_scale, 36*self.height_scale)
        self.closeTitle.setStyleSheet("background-color: transparent; border:none;color: #313030; ")
        closeTitlefont = QFont(self.font_family3, 28*self.width_scale)
        self.closeTitle.setFont(closeTitlefont)

        self.xingxing = QLabel(self.closeTask)
        self.xingxing.setGeometry(334*self.width_scale, 247*self.height_scale, 19*self.width_scale, 22*self.width_scale)
        self.xingxing.setStyleSheet("background-color: transparent; border:none; ")
        self.xingxingpixmap = QPixmap(self.normalized_path + '/includes/Icons/close/tag.png')
        self.xingxing.setPixmap(self.xingxingpixmap)
        self.xingxing.setScaledContents(True)

        self.xingxing = QLabel(self.closeTask)
        self.xingxing.setGeometry(334*self.width_scale, 313*self.height_scale, 19*self.width_scale, 22*self.width_scale)
        self.xingxing.setStyleSheet("background-color: transparent; border:none; ")
        self.xingxingpixmap = QPixmap(self.normalized_path + '/includes/Icons/close/tag.png')
        self.xingxing.setPixmap(self.xingxingpixmap)
        self.xingxing.setScaledContents(True)

        self.xingxing = QLabel(self.closeTask)
        self.xingxing.setGeometry(334*self.width_scale, 379*self.height_scale, 19*self.width_scale, 22*self.width_scale)
        self.xingxing.setStyleSheet("background-color: transparent; border:none; ")
        self.xingxingpixmap = QPixmap(self.normalized_path + '/includes/Icons/close/tag.png')
        self.xingxing.setPixmap(self.xingxingpixmap)
        self.xingxing.setScaledContents(True)

        self.xingxing = QLabel(self.closeTask)
        self.xingxing.setGeometry(334*self.width_scale, 445*self.height_scale, 19*self.width_scale, 22*self.width_scale)
        self.xingxing.setStyleSheet("background-color: transparent; border:none; ")
        self.xingxingpixmap = QPixmap(self.normalized_path + '/includes/Icons/close/tag.png')
        self.xingxing.setPixmap(self.xingxingpixmap)
        self.xingxing.setScaledContents(True)

        self.xingxingText = QLabel(self.closeTask)
        self.xingxingText.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        self.xingxingText.setText('设 备 是 否 异 常')
        self.xingxingText.setGeometry(374*self.width_scale, 244*self.height_scale, 180*self.width_scale, 24*self.height_scale)
        self.xingxingText.setStyleSheet("background-color: transparent; border:none;color: #313030; ")
        xingxingTextfont = QFont(self.font_family3, 16*self.width_scale)
        self.xingxingText.setFont(xingxingTextfont)

        self.xingxingText = QLabel(self.closeTask)
        self.xingxingText.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        self.xingxingText.setText('炉 温 100℃ 以 下')
        self.xingxingText.setGeometry(374*self.width_scale, 310*self.height_scale, 180*self.width_scale, 24*self.height_scale)
        self.xingxingText.setStyleSheet("background-color: transparent; border:none;color: #313030; ")
        xingxingTextfont = QFont(self.font_family3, 16*self.width_scale)
        self.xingxingText.setFont(xingxingTextfont)

        self.xingxingText = QLabel(self.closeTask)
        self.xingxingText.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        self.xingxingText.setText('检 查 所 有 电 源')
        self.xingxingText.setGeometry(374*self.width_scale, 376*self.height_scale, 180*self.width_scale, 24*self.height_scale)
        self.xingxingText.setStyleSheet("background-color: transparent; border:none;color: #313030; ")
        xingxingTextfont = QFont(self.font_family3, 16*self.width_scale)
        self.xingxingText.setFont(xingxingTextfont)

        self.xingxingText = QLabel(self.closeTask)
        self.xingxingText.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        self.xingxingText.setText('清 理 银 皮 桶')
        self.xingxingText.setGeometry(374*self.width_scale, 442*self.height_scale, 180*self.width_scale, 24*self.height_scale)
        self.xingxingText.setStyleSheet("background-color: transparent; border:none;color: #313030; ")
        xingxingTextfont = QFont(self.font_family3, 16*self.width_scale)
        self.xingxingText.setFont(xingxingTextfont)

        self.sbsfycBtn = QPushButton(self.closeTask)
        self.sbsfycBtn.setStyleSheet(f"background-color: #313030; color: #ffffff; border: none;border-radius:{10*self.height_scale}px;")
        self.sbsfycBtn.setGeometry(664*self.width_scale, 243*self.height_scale, 80*self.width_scale, 30*self.height_scale)
        self.sbsfycBtn.setCheckable(True)  # 设置为可选中
        self.sbsfycBtn.setChecked(False)  # 默认选中“否”
        self.sbsfycBtn.clicked.connect(self.device_issueClick)  # 连接点击事件

        self.huakuaiRect = QLabel(self.sbsfycBtn)
        self.huakuaiRect.setGeometry(39*self.width_scale, 4*self.height_scale, 37*self.width_scale, 22*self.height_scale)
        self.huakuaiRect.setStyleSheet(f"background-color: #ffffff; border:none;border-radius:{6*self.height_scale}px;")

        self.shiTxt = QLabel(self.sbsfycBtn)
        self.shiTxt.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        self.shiTxt.setText('是')
        self.shiTxt.setGeometry(15*self.width_scale, 5*self.height_scale, 20*self.width_scale, 20*self.height_scale)
        self.shiTxt.setStyleSheet("background-color: transparent; border:none;color: #FFFFFF; ")
        shiTxtfont = QFont(self.font_family4, 12*self.width_scale)
        self.shiTxt.setFont(shiTxtfont)

        self.fouTxt = QLabel(self.sbsfycBtn)
        self.fouTxt.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        self.fouTxt.setText('否')
        self.fouTxt.setGeometry(50*self.width_scale, 5*self.height_scale, 20*self.width_scale, 20*self.height_scale)
        self.fouTxt.setStyleSheet("background-color: transparent; border:none;color: #393939; ")
        self.fouTxt.setFont(shiTxtfont)





        self.checkbox_second = QCheckBox(self.closeTask)
        self.checkbox_second.setGeometry(664*self.width_scale, 307*self.height_scale, 34*self.width_scale, 33*self.width_scale)
        # self.checkbox_second.stateChanged.connect(self.update_label)
        self.checkbox_second.setStyleSheet("background-color: transparent; border:none;")
        self.checkbox_second.setStyleSheet(f"""
            QCheckBox::indicator {{
                width: {34 * self.width_scale}px;  /* 根据缩放比例调整宽度 */
                height: {34 * self.width_scale}px; /* 根据缩放比例调整高度 */
            }}
            QCheckBox::indicator:checked {{
                image: url({self.normalized_path}/includes/Icons/close/backTrue.png);
            }}
            QCheckBox::indicator:unchecked {{
                image: url({self.normalized_path}/includes/Icons/close/back.png);  /* 替换为你自己的图标路径 */
            }}
            QCheckBox {{
                color: #4a90e2;  /* 文字颜色 */
            }}
        """)

        self.checkbox_second = QCheckBox(self.closeTask)
        self.checkbox_second.setGeometry(664*self.width_scale, 373*self.height_scale, 34*self.width_scale, 33*self.width_scale)
        # self.checkbox_second.stateChanged.connect(self.update_label)
        self.checkbox_second.setStyleSheet("background-color: transparent; border:none;")
        self.checkbox_second.setStyleSheet(f"""
            QCheckBox::indicator {{
                width: {34 * self.width_scale}px;  /* 根据缩放比例调整宽度 */
                height: {34 * self.width_scale}px; /* 根据缩放比例调整高度 */
            }}
            QCheckBox::indicator:checked {{
                image: url({self.normalized_path}/includes/Icons/close/backTrue.png);
            }}
            QCheckBox::indicator:unchecked {{
                image: url({self.normalized_path}/includes/Icons/close/back.png);  /* 替换为你自己的图标路径 */
            }}
            QCheckBox {{
                color: #4a90e2;  /* 文字颜色 */
            }}
        """)

        self.checkbox_second = QCheckBox(self.closeTask)
        self.checkbox_second.setGeometry(664*self.width_scale, 439*self.height_scale, 34*self.width_scale, 33*self.width_scale)
        # self.checkbox_second.stateChanged.connect(self.update_label)
        self.checkbox_second.setStyleSheet("background-color: transparent; border:none;")
        self.checkbox_second.setStyleSheet(f"""
            QCheckBox::indicator {{
                width: {34 * self.width_scale}px;  /* 根据缩放比例调整宽度 */
                height: {34 * self.width_scale}px; /* 根据缩放比例调整高度 */
            }}
            QCheckBox::indicator:checked {{
                image: url({self.normalized_path}/includes/Icons/close/backTrue.png);
            }}
            QCheckBox::indicator:unchecked {{
                image: url({self.normalized_path}/includes/Icons/close/back.png);  /* 替换为你自己的图标路径 */
            }}
            QCheckBox {{
                color: #4a90e2;  /* 文字颜色 */
            }}
        """)

        self.closeBtn = QPushButton(self.closeTask)
        # self.rdBtn.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.closeBtn.setText('关机')
        self.closeBtn.setGeometry(335*self.width_scale, 577*self.height_scale, 112*self.width_scale, 42*self.height_scale)
        self.closeBtn.setStyleSheet(
            f"QPushButton{{color: #ffffff;background-color: #313030;border-radius: {20*self.height_scale}px;}}"
            f"QPushButton:hover{{color: #ffffff;background-color: #313030;border-radius: {20*self.height_scale}px;}}"
        )
        closeBtnfont = QFont(self.font_family4, 14*self.width_scale)
        self.closeBtn.setFont(closeBtnfont)
        self.closeBtn.clicked.connect(self.closeEXE)

        self.quxiaoBtn = QPushButton(self.closeTask)
        # self.rdBtn.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        self.quxiaoBtn.setText('取消')
        self.quxiaoBtn.setGeometry(460*self.width_scale, 577*self.height_scale, 110*self.width_scale, 40*self.height_scale)
        self.quxiaoBtn.setStyleSheet(
            f"QPushButton{{color: #313030;background-color: #ffffff;border-radius: {19*self.height_scale}px;border: 1px solid #313030}}"
            f"QPushButton:hover{{color: #ffffff;background-color: #313030;border-radius: {19*self.height_scale}px;}}"
        )
        quxiaoBtnfont = QFont(self.font_family4, 14*self.width_scale)
        self.quxiaoBtn.setFont(quxiaoBtnfont)
        self.quxiaoBtn.clicked.connect(self.controlClose)

    def resizeEvent(self, event):
        # 获取新的窗口大小
        new_width = self.width()
        new_height = self.height()

        # 根据新的窗口大小调整 QLabel 和 GIF 图像
        self.closeBack.setGeometry(0, 0, new_width, new_height)

        # 设置 GIF 图像的大小，使其适应新的窗口大小，保持宽高比
        movie_size = self.movie.currentImage().scaled(new_width, new_height, Qt.AspectRatioMode.KeepAspectRatio)
        self.closeBack.setPixmap(movie_size)

        # 调用基类的 resizeEvent（如果需要其他处理）
        super().resizeEvent(event)

    # def workbenchUI(self):
    def getShebeiList(self):
        self.sblb.show()

        # 获取 localJson/Machines 目录路径
        machines_path = os.path.join('localJson', 'Machines')

        # 确保目录存在
        if not os.path.exists(machines_path):
            print(f"Error: {machines_path} does not exist.")
            return

        # 清空当前设备列表
        self.sblbList.clear()

        # 设置每一项的间距
        self.sblbList.setSpacing(10)  # 设置项之间的间距为 10

        # 遍历 Machines 目录，获取文件名
        for root, dirs, files in os.walk(machines_path):
            # 只处理文件（不包括子目录）
            for file in files:
                # 去掉文件后缀名
                device_name = os.path.splitext(file)[0]

                # 创建列表项并设置设备名称
                list_item = QListWidgetItem(device_name)
                list_item.setData(Qt.ItemDataRole.UserRole, os.path.join(root, file))  # 将完整路径存储在 UserRole 中

                # 设置项的样式
                # list_item.setFont()  # 例如设置字体（需要先定义一个 QFont）
                list_item.setTextAlignment(Qt.AlignmentFlag.AlignLeft)  # 设置左对齐

                # 设置下划线样式
                label = QLabel(f"{device_name}")  # 添加下划线
                label.setAlignment(Qt.AlignmentFlag.AlignLeft)  # 设置左对齐
                label.setStyleSheet("""
                                QLabel {
                                    color: #393939;
                                    padding-left: 10px;
                                    text-decoration: underline;
                                    border: 1px solid #222222;
                                }
                            """)

                # 将列表项添加到 QListWidget
                self.sblbList.addItem(list_item)

    def on_item_clicked(self, item):
        # 隐藏 QListWidget
        self.sblb.hide()

        # 将点击的项目内容显示到 QLabel
        self.shebeiLabel.setText(item.text())
        # 获取点击的项的文件路径
        file_path = item.data(Qt.ItemDataRole.UserRole)

        print('file_path', file_path)

        # 创建一个 QAction，并设置相应的属性
        action = QAction(self)
        action.setText(item.text())  # 设定文本
        action.setData(file_path)  # 设定文件路径为数据

        # 连接动作到相应的槽函数
        action.triggered.connect(lambda: self.openMachineSettings(file_path))
        # action.triggered.connect(self.openMachineSettings)

        # 模拟触发动作（这里可以传递 action 给 openMachineSettings）
        action.trigger()  # 触发 action，这样就会进入 openMachineSettings 函数

    # def startProgress(self):
    #     # 重置状态并启动定时器
    #     self.current_progress = 0
    #     self.current_bar_index = 0
    #     for bar in self.progress_bars:
    #         bar.setValue(0)  # 重置所有进度条
    #
    #     # 启动定时器
    #     self.fourTimer.start(self.fourInterval)

    def update_progress(self):
        """
        更新当前进度条的进度，达到 100% 后切换到下一个
        """
        self.intoTime2 = self.intoTime2.addSecs(1)
        # 更新标签显示的时间
        self.jdqkLabelTime.setText(self.intoTime2.toString("mm:ss"))

        # 检查当前进度条索引是否超出范围
        if self.current_bar_index >= len(self.progress_bars):
            self.fourTimer.stop()
            return

        # 获取当前进度条
        current_bar = self.progress_bars[self.current_bar_index]

        if self.current_progress < self.total_steps:
            self.current_progress += 1
            current_bar.setValue(self.current_progress)
        else:
            # 当前进度条已完成，移动到下一个进度条
            self.current_progress = 0
            self.current_bar_index += 1

            # 如果还有下一个进度条，则开始更新
            if self.current_bar_index < len(self.progress_bars):
                # 这里可以添加对下一个进度条的初始化或重置逻辑
                self.progress_bars[self.current_bar_index].setValue(0)  # 重置下一个进度条为 0

        # 检查是否在 15 分钟内有用户点击操作
        if self.current_bar_index == len(self.progress_bars) and not self.user_interacted:
            self.colorChangeTimer.stop()  # 停止颜色更改定时器
            self.change_last_bar_color()  # 确保在最后一个进度条上调用颜色改变

    def change_last_bar_color(self):
        # 改变最后一个进度条的颜色为红色
        if not self.user_interacted:  # 仅在没有点击的情况下改变颜色
            last_bar = self.progress_bars[-1]
            last_bar.setStyleSheet(
                f"QProgressBar {{border-radius: {3*self.height_scale}px; background-color: #cccccc; text-align: center; font-size: 0px; color: transparent}}"
                f"QProgressBar::chunk {{ background-color: red; }}"
            )


    def blink_text(self):
        # 切换标签的可见状态
        # print(self.coffeeTitleVisible)
        self.coffeeTitleVisible = not self.coffeeTitleVisible
        if self.coffeeTitleVisible:
            self.shebeiLabel.setStyleSheet("color: #000000; ")  # 设置文本为黑色
        else:
            self.shebeiLabel.setStyleSheet("color: white; ")  # 设置文本为白色（与背景色相同，达到隐藏效果）

    def stop_blinking(self):
        # 停止定时器，停止闪烁
        self.blink_timer.stop()
        # 确保文字在停止时显示为黑色
        self.shebeiLabel.setStyleSheet("color: #000000;")

    def update_time(self):
        # 每次更新时间增加 1 秒
        self.intoTime = self.intoTime.addSecs(1)
        # 更新标签显示的时间
        self.ksyrBtn.setText(self.intoTime.toString("hh:mm:ss"))
        self.yrqkLabelTime.setText(self.intoTime.toString("mm:ss"))

    def gjxy_update_time(self):
        # 每次调用方法时，将时间增加 1 秒
        self.intoTime3 = self.intoTime3.addSecs(1)
        # 更新标签显示的时间
        self.gjxyTimeTxt.setText(self.intoTime3.toString("mm:ss"))

    def orderMoreClicked(self):
        self.ordersRect_More.setVisible(True)
        
    def orderShouqiClicked(self):
        self.ordersRect_More.setVisible(False)

    def ksyrBtnState(self):
        self.ksyrBtn.setText("00:00:00")
        self.ksyrtimer.start(1000)  # 每隔 1 秒触发一次
        # self.statusLabel.setText("烘焙中...")
        self.qmc.ToggleRecorder()
        self.ksyrBtn.setEnabled(False)

        if self.jdtTimer.isActive():
            self.jdtTimer.stop()
        else:
            self.jdtTimer.start(100, self)



    def jieduanInfo(self, first_Value):
        # self.processInfoLabel.setText('171.3')
        sys.stdout = open("lj.log", "w")
        print(self.qmc.tpChangeBool)
        if self.qmc.tpChangeBool == False:
            self.jieduanNum.setText('1')
            self.mbwdNum.setText(str(first_Value[5][0]))
            self.ckzNumR.setText('0')
            self.hlNumR.setText(str(first_Value[5][1]))
            self.fmNumR.setText(str(first_Value[5][2]))
            self.zsNumR.setText(str(first_Value[5][3]))
            print('0')  # self.setmuwdNum
            self.setHl.setText(str(first_Value[5][1]))
            self.slider4.setValue(first_Value[5][1])
            self.slider4released()
            self.setFm.setText(str(first_Value[5][2]))
            self.slider1.setValue(first_Value[5][2])
            self.slider1released()
            self.setZs.setText(str(first_Value[5][3]))
            self.slider2.setValue(first_Value[5][3])
            self.slider2released()
        else:
            if float(self.processInfoLabel.text()) < first_Value[5][0]:
                self.jieduanNum.setText('1')
                self.mbwdNum.setText(str(first_Value[5][0]))
                self.ckzNumR.setText('0')
                self.hlNumR.setText(str(first_Value[5][1]))
                self.fmNumR.setText(str(first_Value[5][2]))
                self.zsNumR.setText(str(first_Value[5][3]))
                print('1')  # self.setmuwdNum
                self.setHl.setText(str(first_Value[5][1]))
                self.slider4.setValue(first_Value[5][1])
                self.slider4released()
                self.setFm.setText(str(first_Value[5][2]))
                self.slider1.setValue(first_Value[5][2])
                self.slider1released()
                self.setZs.setText(str(first_Value[5][3]))
                self.slider2.setValue(first_Value[5][3])
                self.slider2released()

            elif float(self.processInfoLabel.text()) >= first_Value[5][0] and float(self.processInfoLabel.text()) < \
                    first_Value[6][0]:
                self.jieduanNum.setText('2')
                self.mbwdNum.setText(str(first_Value[6][0]))
                self.ckzNumR.setText('0')
                self.hlNumR.setText(str(first_Value[6][1]))
                self.fmNumR.setText(str(first_Value[6][2]))
                self.zsNumR.setText(str(first_Value[6][3]))
                print('2')
                self.setHl.setText(str(first_Value[6][1]))
                self.slider4.setValue(first_Value[6][1])
                self.slider4released()
                self.setFm.setText(str(first_Value[6][2]))
                self.slider1.setValue(first_Value[6][2])
                self.slider1released()
                self.setZs.setText(str(first_Value[6][3]))
                self.slider2.setValue(first_Value[6][3])
                self.slider2released()

            elif float(self.processInfoLabel.text()) >= first_Value[6][0] and float(self.processInfoLabel.text()) < \
                    first_Value[7][0]:
                self.jieduanNum.setText('3')
                self.mbwdNum.setText(str(first_Value[7][0]))
                self.ckzNumR.setText('2')
                self.hlNumR.setText(str(first_Value[7][1]))
                self.fmNumR.setText(str(first_Value[7][2]))
                self.zsNumR.setText(str(first_Value[7][3]))
                print('3')
                self.setHl.setText(str(first_Value[7][1]))
                self.slider4.setValue(first_Value[7][1])
                self.slider4released()
                self.setFm.setText(str(first_Value[7][2]))
                self.slider1.setValue(first_Value[7][2])
                self.slider1released()
                self.setZs.setText(str(first_Value[7][3]))
                self.slider2.setValue(first_Value[7][3])
                self.slider2released()

            elif float(self.processInfoLabel.text()) >= first_Value[7][0] and float(self.processInfoLabel.text()) < \
                    first_Value[8][0]:
                self.jieduanNum.setText('4')
                self.mbwdNum.setText(str(first_Value[8][0]))
                self.ckzNumR.setText('3')
                self.hlNumR.setText(str(first_Value[8][1]))
                self.fmNumR.setText(str(first_Value[8][2]))
                self.zsNumR.setText(str(first_Value[8][3]))
                print('4')
                self.setHl.setText(str(first_Value[8][1]))
                self.slider4.setValue(first_Value[8][1])
                self.slider4released()
                self.setFm.setText(str(first_Value[8][2]))
                self.slider1.setValue(first_Value[8][2])
                self.slider1released()
                self.setZs.setText(str(first_Value[8][3]))
                self.slider2.setValue(first_Value[8][3])
                self.slider2released()

            elif float(self.processInfoLabel.text()) >= first_Value[8][0] and float(self.processInfoLabel.text()) < \
                    first_Value[9][0]:
                self.jieduanNum.setText('5')
                self.mbwdNum.setText(str(first_Value[9][0]))
                self.ckzNumR.setText('4')
                self.hlNumR.setText(str(first_Value[9][1]))
                self.fmNumR.setText(str(first_Value[9][2]))
                self.zsNumR.setText(str(first_Value[9][3]))
                print('5')
                self.setHl.setText(str(first_Value[9][1]))
                self.slider4.setValue(first_Value[9][1])
                self.slider4released()
                self.setFm.setText(str(first_Value[9][2]))
                self.slider1.setValue(first_Value[9][2])
                self.slider1released()
                self.setZs.setText(str(first_Value[9][3]))
                self.slider2.setValue(first_Value[9][3])
                self.slider2released()

            elif float(self.processInfoLabel.text()) >= first_Value[9][0] and float(self.processInfoLabel.text()) < \
                    first_Value[10][0]:
                self.jieduanNum.setText('6')
                self.mbwdNum.setText(str(first_Value[10][0]))
                self.ckzNumR.setText('5')
                self.hlNumR.setText(str(first_Value[10][1]))
                self.fmNumR.setText(str(first_Value[10][2]))
                self.zsNumR.setText(str(first_Value[10][3]))
                print('6')
                self.setHl.setText(str(first_Value[10][1]))
                self.slider4.setValue(first_Value[10][1])
                self.slider4released()
                self.setFm.setText(str(first_Value[10][2]))
                self.slider1.setValue(first_Value[10][2])
                self.slider1released()
                self.setZs.setText(str(first_Value[10][3]))
                self.slider2.setValue(first_Value[10][3])
                self.slider2released()



    def huoli_jia_clicked(self):
        if self.setHuoli < 100:
            self.setHuoli += 5
        else:
            self.setHuoli = 100  # 设置最大值为 100，防止超出

        print(self.setHuoli)

        # 更新界面元素
        self.setHl.setText(str(self.setHuoli))
        self.setHl.setStyleSheet(
            f"QLabel{{color: #FFFFFF;background-color: #393939;border-radius: {7 * self.height_scale}px;border: 1px solid #222222;}}")

        # 更新滑块的值
        self.slider4.setValue(self.setHuoli)

        # 调用 released 方法（假设这个方法做其他处理）
        self.slider4released()

    def huoli_jian_clicked(self):
        self.setHuoli -= 5
        print(self.setHuoli)
        self.setHl.setText(str(self.setHuoli))
        self.setHl.setStyleSheet(
            f"QLabel{{color: #FFFFFF;background-color: #393939;border-radius: {7*self.height_scale}px;border: 1px solid #222222;}}")
        self.slider4.setValue(self.setHuoli)
        self.slider4released()

    def fengmen_jia_clicked(self):
        self.setFengmen += 1
        print(self.setFengmen)
        self.setFm.setText(str(self.setFengmen))
        self.setFm.setStyleSheet(
            f"QLabel{{color: #FFFFFF;background-color: #393939;border-radius: {7*self.height_scale}px;border: 1px solid #222222;}}")
        self.slider1.setValue(self.setFengmen)
        self.slider1released()

    def fengmen_jian_clicked(self):
        self.setFengmen -= 1
        print(self.setFengmen)
        self.setFm.setText(str(self.setFengmen))
        self.setFm.setStyleSheet(
            f"QLabel{{color: #FFFFFF;background-color: #393939;border-radius: {7*self.height_scale}px;border: 1px solid #222222;}}")
        self.slider1.setValue(self.setFengmen)
        self.slider1released()

    def zhuansu_jia_clicked(self):
        self.setZhuansu += 1
        print(self.setZhuansu)
        self.setZs.setText(str(self.setZhuansu))
        self.setZs.setStyleSheet(
            f"QLabel{{color: #FFFFFF;background-color: #393939;border-radius: {7*self.height_scale}px;border: 1px solid #222222;}}")
        self.slider2.setValue(self.setZhuansu)
        self.slider2released()

    def zhuansu_jian_clicked(self):
        self.setZhuansu -= 1
        print(self.setZhuansu)
        self.setZs.setText(str(self.setZhuansu))
        self.setZs.setStyleSheet(
            f"QLabel{{color: #FFFFFF;background-color: #393939;border-radius: {7*self.height_scale}px;border: 1px solid #222222;}}")
        self.slider2.setValue(self.setZhuansu)
        self.slider2released()



    def timerEvent(self, event):
        # 判断触发事件的是哪个计时器
        if event.timerId() == self.rudouTimer.timerId():
            # 更新第一个进度条
            if self.rudouStep >= 100:
                self.rudouTimer.stop()
                return

            self.rudouStep += 0.03
            self.rudouBar.setValue(self.rudouStep)

        elif event.timerId() == self.jdtTimer.timerId():
            # 更新第二个进度条
            if self.jdtStep >= 100:
                self.jdtTimer.stop()
                return

            self.jdtStep += 0.0075
            self.jdt.setValue(self.jdtStep)

        elif event.timerId() == self.jdtGJXYTimer.timerId():
            # 更新第三个进度条
            if self.jdtGJXYStep >= 100:
                self.jdtGJXYTimer.stop()
                return

            self.jdtGJXYStep += 0.0075
            self.jdtGJXY.setValue(self.jdtGJXYStep)

    def updateRudouBar(self):
        # 更新第一个进度条
        if self.rudouStep >= 100:
            self.rudouTimer.stop()
            return

        self.rudouStep += 0.03
        self.rudouBar.setValue(self.rudouStep)

    def updateJdtBar(self):
        # 更新第二个进度条
        if self.jdtStep >= 100:
            self.jdtTimer.stop()
            return

        self.jdtStep += 0.0075
        self.jdt.setValue(self.jdtStep)

    def updategjxyBar(self):
        # 检查进度条是否达到 100%
        if self.jdtGJXYStep >= 100:
            # 停止计时器
            self.jdtGJXYTimer.stop()
            # 重置进度条的值
            self.jdtGJXYStep = 0
            self.jdtGJXY.setValue(self.jdtGJXYStep)
            # 重新启动计时器
            # self.jdtGJXYTimer.start(self.jdtGJXYInterval)
            self.gjxy.setVisible(False)
            self.jdqk.setVisible(True)
            return

        # 增加步骤并更新进度条
        self.jdtGJXYStep += 0.01042
        self.jdtGJXY.setValue(self.jdtGJXYStep)

    def closeAiWidget(self):
        self.ai_widget.setVisible(False)

    def openAiWidget(self):
        self.ai_widget.setVisible(True)


    # def markChargeClick(self):
    # print(self.time_left)
    # self.qmc.markCharge()
    # self.statusLabel.setText("烘焙中...")
    # self.start_countdown()
    #
    # self.ordering.setVisible(True)
    #
    # self.yrqk.setVisible(False)
    # self.jdqk.setVisible(True)
    # self.gjxy.setVisible(False)
    #
    # # self.ordersRect2.setGeometry(231, 591, 290, 185)
    # self.statusCard.setVisible(False)
    #
    # self.diologRect.setVisible(False)
    #
    # # self.rudouPixmap2 = QPixmap(self.normalized_path + '/includes/Icons/yrzb/rd-hover.png')
    # self.rudouImg.setPixmap(QPixmap(self.normalized_path + '/includes/Icons/yrzb/rd-hover.png'))
    #
    # # first_order_item = self.orderList.item(0)
    # # if first_order_item:
    # #     # 将第一个订单移除，并在标签中显示它
    # #     removed_order = first_order_item.text()
    # #     self.orderList.takeItem(0)  # 从列表中移除
    # #     # self.moved_order_label.setText(f"订单已移出:\n{removed_order}")
    # first_Value = self.id_value[0]
    # global token
    # url = "http://inner4.mjytech.com:22104/admin/task/startBakingTaskStatus"  # 开始烘焙
    # payload = json.dumps({'id': first_Value[0]})
    # headers = {
    #     'token': f'{token}',
    #     'Content-Type': 'application/json'
    # }
    # if token:
    #     response = requests.post(url, payload, headers=headers)
    #     if response.status_code == 200:
    #         data = response.json()
    #         textCode = data['code']
    #         if textCode == 0 or textCode == 200:
    #             print('连接成功')
    #             self.task_name_label2.setText(first_Value[1])
    #             new_text = f"任务订单: {first_Value[2]}"
    #             self.task_no_label2.original_text = new_text  # 更新原始文本
    #             self.task_no_label2.setText(new_text)  # 更新标签的显示文本
    #             # self.task_no_label2.update_text_dimensions()  # 更新宽度
    #             if self.task_no_label2.text_width > self.task_no_label2.label_width:
    #                 self.task_no_label2.timer.start(100)  # 如果文本宽度大于标签宽度，开始滚动
    #             self.deadline_label2.setText(f"截止日期: {first_Value[3]}")
    #         else:
    #             print('连接失败')
    #     else:
    #         print('连接失败')
    #
    # if self.rudouTimer.isActive():
    #     self.rudouTimer.stop()
    # else:
    #     self.rudouTimer.start(100, self)
    #
    # # 重置状态并启动定时器
    # self.current_progress = 0
    # self.current_bar_index = 0
    # for bar in self.progress_bars:
    #     bar.setValue(0)  # 重置所有进度条
    #
    # # 启动定时器
    # self.fourTimer.start(self.fourInterval)

    # def markDropClick(self):
    #     self.zhezhaoWidget.setVisible(True)
    #     self.ccjlWidget.setVisible(True)
    #     self.yrqk.setVisible(False)
    #     self.jdqk.setVisible(False)
    #     self.gjxy.setVisible(True)
    #     self.status_label2.setText('已完成')
    #     self.statusLabel.setText("锅间协议")
    #     self.chukuImg.setStyleSheet("""
    #                                                         QPushButton {
    #                                                             border-image: url('src/includes/Icons/yrzb/rd-hover.png');
    #                                                         }
    #                                                     """)
    #     self.qmc.markDrop()
    #
    #     self.user_interacted = True  # 用户进行了交互
    #
    #     self.gjxytimer.start(1000)  # 每隔 1 秒触发一次
    #
    #     if self.jdtGJXYTimer.isActive():
    #         self.jdtGJXYTimer.stop()
    #     else:
    #         self.jdtGJXYTimer.start(100, self)

    # def submitCCJL(self):
    #     self.zhezhaoWidget.setVisible(False)
    #     self.ccjlWidget.setVisible(False)
    #     # baking_batch_1, task_id_1 = self.chucangValue[0]
    #     self.toggle_updateCloud()
    #     if self.id_value:
    #         # 删除第一组数据
    #         self.id_value.pop(0)
    #     # sys.stdout = open("outputttttttttttt.log", "w")
    #     print(self.id_value)
    # self.getHonbeiList()
    # global token
    # url = "http://inner4.mjytech.com:22104/admin/storeroom/saveInventoryMiddle"  # 熟豆入仓
    # payload = json.dumps({
    #     "bakingBatch": self.chucangValue[0],
    #     "cacheTime": self.hcsjContent.text(),
    #     "defectiveRate": self.xclContent.text(),#
    #     "dehydrationRate": self.tslContent.text(),#
    #     "num": self.slContent.text(),#
    #     "taskId": self.chucangValue[1],
    #     "type": 3
    # })
    # headers = {
    #     'token': f'{token}',
    #     'Content-Type': 'application/json'
    # }
    # if token:
    #     response = requests.post(url, payload, headers=headers)
    #     if response.status_code == 200:
    #         # dataJson = response.json()
    #         print('连接成功')
    #         self.toggle_updateCloud()
    #     else:
    #         print('连接失败')



    def markDryEndClick(self):
        # self.qmc.markDryEnd()
        self.zhdImg.setStyleSheet(f"""
                                    QPushButton {{
                                        border-image: url('{self.normalized_path}/includes/Icons/yrzb/rd-hover.png');
                                    }}
                                """)

    def markyibaoClick(self):
        # self.qmc.mark1Cstart()
        self.yibaoImg.setStyleSheet(f"""
                                            QPushButton {{
                                                border-image: url('{self.normalized_path}/includes/Icons/yrzb/rd-hover.png');
                                            }}
                                        """)

    def start_countdown(self):
        # 设置定时器间隔为1000毫秒（1秒）
        self.jieduanTimer.start(1000)

    def update_countdown(self):
        # 更新倒计时时间
        if self.time_left > 0:
            self.time_left -= 1
            # self.label1111.setText(f'Time left: {self.time_left} seconds')
            print(self.time_left)
        else:
            # self.jieduanTimer.stop()
            # self.label1111.setText('Time is up!')
            print('Time is up!')
            # self.jieduanInfo()

    def todayClick(self):
        today = QDate.currentDate()
        self.date_edit.setDate(today)

    def update_display_with_weekday(self, date):
        # 获取日期对应的星期几（中文）
        day_of_week = date.toString("dddd")  # "dddd" 会返回系统语言的完整星期名称（中文）
        # 构建新的文本框内容，包括日期和星期几
        new_display_text = f"{date.toString('yyyy-MM-dd')} {day_of_week}"
        self.date_edit.setDisplayFormat(" ")  # 清空默认显示格式
        self.date_edit.setDate(date)  # 更新日期
        self.date_edit.lineEdit().setText(new_display_text)  # 更新文本框内容

    def comBoxLabelClick(self):
        self.selectList.setVisible(True)

    def selectItem1Changed(self):
        self.selectList.setVisible(False)
        self.comBoxLabel.setText('任务名称')

    def selectItem2Changed(self):
        self.selectList.setVisible(False)
        self.comBoxLabel.setText('任务时长')

    def selectItem3Changed(self):
        self.selectList.setVisible(False)
        self.comBoxLabel.setText('Agtron值')

    def selectItem4Changed(self):
        self.selectList.setVisible(False)
        self.comBoxLabel.setText('反馈情况')


    # def analyseClick(self):
    #     order_ids_str = ','.join(self.orderID)
    #     url = "http://inner4.mjytech.com:22104/admin/device/lookFormulaCurve"
    #     params = {'bakingBatchList': order_ids_str}
    #     response = requests.get(url, params)
    #     if response.status_code == 200:
    #         data = response.json()
    #         textCode = data['code']
    #         if textCode == 0 or textCode == 200:
    #             self.historyAnalyse.setVisible(True)
    #             self.scroll_area.setVisible(True)
    #             self.scroll_area.setWidget(self.historyAnalyse)
    #             dataJson = response.json()
    #             data = dataJson['data']
    #             # bakingBatchList1 = data[0].get('bakingBatch')
    #             historyOrder_count = len(self.orderDetail)
    #             dataJson2 = self.orderDetail
    #             # 历史分析数据
    #             if historyOrder_count == 1:
    #                 self.history_sheibei.setText(str(dataJson2[0].get('bakingBatch')))
    #                 self.historyOrder1_Title.setText(str(dataJson2[0].get('bakingBatch')))
    #                 self.historyOrder1_Time.setText(str(int(dataJson2[0].get('taskTime')) // 60) + ':' + str(
    #                     int(dataJson2[0].get('taskTime')) % 60))
    #                 self.historyOrder_hbrq1_Data.setText(str(dataJson2[0].get('createTime')))
    #                 self.historyOrder_hbssl1_Data.setText(str(dataJson2[0].get('dehydrationRate')))
    #                 self.historyOrder_hbpf1_Data.setText(str(dataJson2[0].get('bakingScore')))
    #                 self.historyOrder_Agtron1_Data.setText(str(dataJson2[0].get('agtronValue')))
    #                 if dataJson2[0]['cuppingDetail'] not in dataJson2:
    #                     self.historyOrder_bcpf1_Data.setText("-")
    #                     self.historyOrder_bcrq1_Data.setText("-")
    #                 else:
    #                     self.historyOrder_bcpf1_Data.setText(str(dataJson2[0]['cuppingDetail']['score']))
    #                     self.historyOrder_bcrq1_Data.setText(str(dataJson2[0]['cuppingDetail']['createTime']))
    #
    #             elif historyOrder_count == 2:
    #                 self.history_sheibei.setText(str(dataJson2[0].get('bakingBatch')))
    #                 self.historyOrder1_Title.setText(str(dataJson2[0].get('bakingBatch')))
    #                 self.historyOrder1_Time.setText(str(int(dataJson2[0].get('taskTime')) // 60) + ':' + str(
    #                     int(dataJson2[0].get('taskTime')) % 60))
    #                 self.historyOrder_hbrq1_Data.setText(str(dataJson2[0].get('createTime')))
    #                 self.historyOrder_hbssl1_Data.setText(str(dataJson2[0].get('dehydrationRate')))
    #                 self.historyOrder_hbpf1_Data.setText(str(dataJson2[0].get('bakingScore')))
    #                 self.historyOrder_Agtron1_Data.setText(str(dataJson2[0].get('agtronValue')))
    #                 if dataJson2[0]['cuppingDetail'] not in dataJson2:
    #                     self.historyOrder_bcpf1_Data.setText("-")
    #                     self.historyOrder_bcrq1_Data.setText("-")
    #                 else:
    #                     self.historyOrder_bcpf1_Data.setText(str(dataJson2[0]['cuppingDetail']['score']))
    #                     self.historyOrder_bcrq1_Data.setText(str(dataJson2[0]['cuppingDetail']['createTime']))
    #
    #                 self.history_sheibei2.setText(str(dataJson2[1].get('bakingBatch')))
    #                 self.historyOrder2_Title.setText(str(dataJson2[1].get('bakingBatch')))
    #                 self.historyOrder2_Time.setText(str(int(dataJson2[1].get('taskTime')) // 60) + ':' + str(
    #                     int(dataJson2[1].get('taskTime')) % 60))
    #                 self.historyOrder_hbrq2_Data.setText(str(dataJson2[1].get('createTime')))
    #                 self.historyOrder_hbssl2_Data.setText(str(dataJson2[1].get('dehydrationRate')))
    #                 self.historyOrder_hbpf2_Data.setText(str(dataJson2[1].get('bakingScore')))
    #                 self.historyOrder_Agtron2_Data.setText(str(dataJson2[1].get('agtronValue')))
    #                 if dataJson2[1]['cuppingDetail'] not in dataJson2:
    #                     self.historyOrder_bcpf2_Data.setText("-")
    #                     self.historyOrder_bcrq2_Data.setText("-")
    #                 else:
    #                     self.historyOrder_bcpf2_Data.setText(str(dataJson2[1]['cuppingDetail']['score']))
    #                     self.historyOrder_bcrq2_Data.setText(str(dataJson2[1]['cuppingDetail']['createTime']))
    #             elif historyOrder_count == 3:
    #                 self.history_sheibei.setText(str(dataJson2[0].get('bakingBatch')))
    #                 self.historyOrder1_Title.setText(str(dataJson2[0].get('bakingBatch')))
    #                 self.historyOrder1_Time.setText(str(int(dataJson2[0].get('taskTime')) // 60) + ':' + str(
    #                     int(dataJson2[0].get('taskTime')) % 60))
    #                 self.historyOrder_hbrq1_Data.setText(str(dataJson2[0].get('createTime')))
    #                 self.historyOrder_hbssl1_Data.setText(str(dataJson2[0].get('dehydrationRate')))
    #                 self.historyOrder_hbpf1_Data.setText(str(dataJson2[0].get('bakingScore')))
    #                 self.historyOrder_Agtron1_Data.setText(str(dataJson2[0].get('agtronValue')))
    #                 if dataJson2[0]['cuppingDetail'] not in dataJson2:
    #                     self.historyOrder_bcpf1_Data.setText("-")
    #                     self.historyOrder_bcrq1_Data.setText("-")
    #                 else:
    #                     self.historyOrder_bcpf1_Data.setText(str(dataJson2[0]['cuppingDetail']['score']))
    #                     self.historyOrder_bcrq1_Data.setText(str(dataJson2[0]['cuppingDetail']['createTime']))
    #
    #                 self.history_sheibei2.setText(str(dataJson2[1].get('bakingBatch')))
    #                 self.historyOrder2_Title.setText(str(dataJson2[1].get('bakingBatch')))
    #                 self.historyOrder2_Time.setText(str(int(dataJson2[1].get('taskTime')) // 60) + ':' + str(
    #                     int(dataJson2[1].get('taskTime')) % 60))
    #                 self.historyOrder_hbrq2_Data.setText(str(dataJson2[1].get('createTime')))
    #                 self.historyOrder_hbssl2_Data.setText(str(dataJson2[1].get('dehydrationRate')))
    #                 self.historyOrder_hbpf2_Data.setText(str(dataJson2[1].get('bakingScore')))
    #                 self.historyOrder_Agtron2_Data.setText(str(dataJson2[1].get('agtronValue')))
    #                 if dataJson2[1]['cuppingDetail'] not in dataJson2:
    #                     self.historyOrder_bcpf2_Data.setText("-")
    #                     self.historyOrder_bcrq2_Data.setText("-")
    #                 else:
    #                     self.historyOrder_bcpf2_Data.setText(str(dataJson2[1]['cuppingDetail']['score']))
    #                     self.historyOrder_bcrq2_Data.setText(str(dataJson2[1]['cuppingDetail']['createTime']))
    #
    #                 self.history_sheibei3.setText(str(dataJson2[2].get('bakingBatch')))
    #                 self.historyOrder3_Title.setText(str(dataJson2[2].get('bakingBatch')))
    #                 self.historyOrder3_Time.setText(str(int(dataJson2[2].get('taskTime')) // 60) + ':' + str(
    #                     int(dataJson2[2].get('taskTime')) % 60))
    #                 self.historyOrder_hbrq3_Data.setText(str(dataJson2[2].get('createTime')))
    #                 self.historyOrder_hbssl3_Data.setText(str(dataJson2[2].get('dehydrationRate')))
    #                 self.historyOrder_hbpf3_Data.setText(str(dataJson2[2].get('bakingScore')))
    #                 self.historyOrder_Agtron3_Data.setText(str(dataJson2[2].get('agtronValue')))
    #                 if dataJson2[2]['cuppingDetail'] not in dataJson2:
    #                     self.historyOrder_bcpf3_Data.setText("-")
    #                     self.historyOrder_bcrq3_Data.setText("-")
    #                 else:
    #                     self.historyOrder_bcpf3_Data.setText(str(dataJson2[2]['cuppingDetail']['score']))
    #                     self.historyOrder_bcrq3_Data.setText(str(dataJson2[2]['cuppingDetail']['createTime']))
    #             elif historyOrder_count == 4:
    #                 self.history_sheibei.setText(str(dataJson2[0].get('bakingBatch')))
    #                 self.historyOrder1_Title.setText(str(dataJson2[0].get('bakingBatch')))
    #                 self.historyOrder1_Time.setText(str(int(dataJson2[0].get('taskTime')) // 60) + ':' + str(
    #                     int(dataJson2[0].get('taskTime')) % 60))
    #                 self.historyOrder_hbrq1_Data.setText(str(dataJson2[0].get('createTime')))
    #                 self.historyOrder_hbssl1_Data.setText(str(dataJson2[0].get('dehydrationRate')))
    #                 self.historyOrder_hbpf1_Data.setText(str(dataJson2[0].get('bakingScore')))
    #                 self.historyOrder_Agtron1_Data.setText(str(dataJson2[0].get('agtronValue')))
    #                 if dataJson2[0]['cuppingDetail'] not in dataJson2:
    #                     self.historyOrder_bcpf1_Data.setText("-")
    #                     self.historyOrder_bcrq1_Data.setText("-")
    #                 else:
    #                     self.historyOrder_bcpf1_Data.setText(str(dataJson2[1]['cuppingDetail']['score']))
    #                     self.historyOrder_bcrq1_Data.setText(str(dataJson2[1]['cuppingDetail']['createTime']))
    #
    #                 self.history_sheibei2.setText(str(dataJson2[1].get('bakingBatch')))
    #                 self.historyOrder2_Title.setText(str(dataJson2[1].get('bakingBatch')))
    #                 self.historyOrder2_Time.setText(str(int(dataJson2[1].get('taskTime')) // 60) + ':' + str(
    #                     int(dataJson2[1].get('taskTime')) % 60))
    #                 self.historyOrder_hbrq2_Data.setText(str(dataJson2[1].get('createTime')))
    #                 self.historyOrder_hbssl2_Data.setText(str(dataJson2[1].get('dehydrationRate')))
    #                 self.historyOrder_hbpf2_Data.setText(str(dataJson2[1].get('bakingScore')))
    #                 self.historyOrder_Agtron2_Data.setText(str(dataJson2[1].get('agtronValue')))
    #                 if dataJson2[1]['cuppingDetail'] not in dataJson2:
    #                     self.historyOrder_bcpf2_Data.setText("-")
    #                     self.historyOrder_bcrq2_Data.setText("-")
    #                 else:
    #                     self.historyOrder_bcpf2_Data.setText(str(dataJson2[1]['cuppingDetail']['score']))
    #                     self.historyOrder_bcrq2_Data.setText(str(dataJson2[1]['cuppingDetail']['createTime']))
    #
    #                 self.history_sheibei3.setText(str(dataJson2[2].get('bakingBatch')))
    #                 self.historyOrder3_Title.setText(str(dataJson2[2].get('bakingBatch')))
    #                 self.historyOrder3_Time.setText(str(int(dataJson2[2].get('taskTime')) // 60) + ':' + str(
    #                     int(dataJson2[2].get('taskTime')) % 60))
    #                 self.historyOrder_hbrq3_Data.setText(str(dataJson2[2].get('createTime')))
    #                 self.historyOrder_hbssl3_Data.setText(str(dataJson2[2].get('dehydrationRate')))
    #                 self.historyOrder_hbpf3_Data.setText(str(dataJson2[2].get('bakingScore')))
    #                 self.historyOrder_Agtron3_Data.setText(str(dataJson2[2].get('agtronValue')))
    #                 if dataJson2[2]['cuppingDetail'] not in dataJson2:
    #                     self.historyOrder_bcpf3_Data.setText("-")
    #                     self.historyOrder_bcrq3_Data.setText("-")
    #                 else:
    #                     self.historyOrder_bcpf3_Data.setText(str(dataJson2[2]['cuppingDetail']['score']))
    #                     self.historyOrder_bcrq3_Data.setText(str(dataJson2[2]['cuppingDetail']['createTime']))
    #
    #                 self.history_sheibei4.setText(str(dataJson2[3].get('bakingBatch')))
    #                 self.historyOrder4_Title.setText(str(dataJson2[3].get('bakingBatch')))
    #                 self.historyOrder4_Time.setText(str(int(dataJson2[3].get('taskTime')) // 60) + ':' + str(
    #                     int(dataJson2[3].get('taskTime')) % 60))
    #                 self.historyOrder_hbrq4_Data.setText(str(dataJson2[3].get('createTime')))
    #                 self.historyOrder_hbssl4_Data.setText(str(dataJson2[3].get('dehydrationRate')))
    #                 self.historyOrder_hbpf4_Data.setText(str(dataJson2[3].get('bakingScore')))
    #                 self.historyOrder_Agtron4_Data.setText(str(dataJson2[3].get('agtronValue')))
    #                 if dataJson2[3]['cuppingDetail'] not in dataJson2:
    #                     self.historyOrder_bcpf4_Data.setText("-")
    #                     self.historyOrder_bcrq4_Data.setText("-")
    #                 else:
    #                     self.historyOrder_bcpf4_Data.setText(str(dataJson2[3]['cuppingDetail']['score']))
    #                     self.historyOrder_bcrq4_Data.setText(str(dataJson2[3]['cuppingDetail']['createTime']))
    #
    #             order_count = len(data)
    #             totaltimeList = []
    #             for i in range(order_count):
    #                 totaltimeList.append(data[i]['jsonMessage']['totaltime'])
    #
    #             max_time_in_seconds = max(totaltimeList)
    #             max_time_in_minutes = int(max_time_in_seconds) // 60
    #
    #             # 创建时间数量小部件
    #             timeNumWidget = QWidget(self.historyAnalyse)
    #             timeNumWidget.setStyleSheet("background-color: transparent; border:none; color: #222222;")
    #
    #             # 创建横向布局并添加到小部件
    #             timeNumLayout = QHBoxLayout(timeNumWidget)
    #
    #             # 初始化并设置时间标签
    #             # self.analyseTimeNum = QLabel(f"{max_time_in_minutes:.2f}", self.historyAnalyse)
    #             # self.analyseTimeNum.setStyleSheet("color: white;")  # 设置字体颜色为白色
    #             for minute in range(max_time_in_minutes):  # +1 包含最大分钟数
    #                 self.analyseTimeNum = QLabel(f"{minute}", self.historyAnalyse)
    #                 self.analyseTimeNum.setFixedHeight(30)
    #                 self.analyseTimeNum.setStyleSheet("background-color: transparent; border:none;color: #292827;")
    #                 analyseTimeNumfont = QFont(self.font_family4, 18 * self.width_scale)
    #                 self.analyseTimeNum.setFont(analyseTimeNumfont)
    #
    #                 timeNumLayout.addWidget(self.analyseTimeNum)
    #
    #             timeNumLayout.addWidget(self.analyseTimeNum)
    #
    #             # 将小部件添加到布局中（确保设置大小）
    #             timeNumWidget.setFixedHeight(34 * self.height_scale)  # 设置高度
    #             timeNumWidget.setGeometry(148 * self.width_scale, 1290 * self.height_scale, 1384 * self.width_scale,
    #                                       34 * self.height_scale)  # 如果必要，可以设置几何形状
    #             timeNumWidget.show()  # 确保小部件可见
    #
    #             # 获取不同的 timex 数组
    #             try:
    #                 timex1 = data[0]['jsonMessage']['alogJson']['timex']
    #             except (IndexError, KeyError, TypeError):
    #                 timex1 = []
    #
    #             try:
    #                 timex2 = data[1]['jsonMessage']['alogJson']['timex']
    #             except (IndexError, KeyError, TypeError):
    #                 timex2 = []
    #
    #             try:
    #                 timex3 = data[2]['jsonMessage']['alogJson']['timex']
    #             except (IndexError, KeyError, TypeError):
    #                 timex3 = []
    #
    #             try:
    #                 timex4 = data[3]['jsonMessage']['alogJson']['timex']
    #             except (IndexError, KeyError, TypeError):
    #                 timex4 = []
    #
    #             # 找到最长的 timex
    #             timex_lengths = [len(timex1), len(timex2), len(timex3), len(timex4)]
    #             max_len_index = timex_lengths.index(max(timex_lengths))  # 获取最长 timex 的索引
    #
    #             # 使用最长的 timex
    #             timex = [timex1, timex2, timex3, timex4][max_len_index]
    #
    #             # 获取四个温度数据
    #             try:
    #                 temp1 = data[0]['jsonMessage']['alogJson']['temp1']
    #             except (IndexError, KeyError, TypeError):
    #                 temp1 = []
    #
    #             try:
    #                 temp2 = data[1]['jsonMessage']['alogJson']['temp1']
    #             except (IndexError, KeyError, TypeError):
    #                 temp2 = []
    #
    #             try:
    #                 temp3 = data[2]['jsonMessage']['alogJson']['temp1']
    #             except (IndexError, KeyError, TypeError):
    #                 temp3 = []
    #
    #             try:
    #                 temp4 = data[3]['jsonMessage']['alogJson']['temp1']
    #             except (IndexError, KeyError, TypeError):
    #                 temp4 = []
    #
    #             # 更新图表
    #             self.matplotlib_widget.update_plot(timex, temp1, temp2, temp3, temp4)
    #
    #             msgdata = data[0].get('jsonMessage')
    #             self.onekstTxt1.setText(
    #                 f"入豆温度: {msgdata['CHARGE_BT']}℃   回温点: {msgdata['TP_BT']}℃/{msgdata['TP_time']}")
    #             self.onekstTxt1.setGeometry(16 * self.width_scale, 3 * self.height_scale, (((int(
    #                 msgdata['totaltime']) - int(msgdata['Maillard_time']) - int(msgdata['FCs_time'])) / int(
    #                 msgdata['totaltime'])) * 1385 * (int(msgdata['totaltime']) / int(
    #                 max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #             self.onekstTxt2.setText(f"转黄点: {msgdata['Maillard']}℃/{msgdata['Maillard_time']}")
    #             self.onekstTxt2.setGeometry((int(self.onekstTxt1.geometry().width() + 17)) * self.width_scale,
    #                                         3 * self.height_scale, ((int(msgdata['Maillard_time']) / int(
    #                     msgdata['totaltime'])) * 1385 * (int(msgdata['totaltime']) / int(
    #                     max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #             self.onekstTxt3.setText(f"一爆: {msgdata['FCs_BT']}℃/{msgdata['FCs_time']}")
    #             self.onekstTxt3.setGeometry((
    #                                             int(self.onekstTxt1.geometry().width() + 18 + self.onekstTxt2.geometry().width())) * self.width_scale,
    #                                         3 * self.height_scale, ((int(msgdata['FCs_time']) / int(
    #                     msgdata['totaltime'])) * 1385 * (int(msgdata['totaltime']) / int(
    #                     max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #             if(len(data) == 2):
    #                 msgdata2 = data[1].get('jsonMessage')
    #                 self.twokstTxt1.setText(
    #                     f"入豆温度: {msgdata2['CHARGE_BT']}℃   回温点: {msgdata2['TP_BT']}℃/{msgdata2['TP_time']}")
    #                 self.twokstTxt1.setGeometry(16 * self.width_scale, 3 * self.height_scale, (((int(
    #                     msgdata2['totaltime']) - int(msgdata2['Maillard_time']) - int(msgdata2['FCs_time'])) / int(
    #                     msgdata2['totaltime'])) * 1385 * (int(msgdata2['totaltime']) / int(
    #                     max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.twokstTxt2.setText(f"转黄点: {msgdata2['Maillard']}℃/{msgdata2['Maillard_time']}")
    #                 self.twokstTxt2.setGeometry((int(self.onekstTxt1.geometry().width() + 17)) * self.width_scale,
    #                                             3 * self.height_scale, ((int(msgdata2['Maillard_time']) / int(
    #                         msgdata2['totaltime'])) * 1385 * (int(msgdata2['totaltime']) / int(
    #                         max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.twokstTxt3.setText(f"一爆: {msgdata2['FCs_BT']}℃/{msgdata2['FCs_time']}")
    #                 self.twokstTxt3.setGeometry((
    #                                                 int(self.onekstTxt1.geometry().width() + 18 + self.onekstTxt2.geometry().width())) * self.width_scale,
    #                                             3 * self.height_scale, ((int(msgdata2['FCs_time']) / int(
    #                         msgdata2['totaltime'])) * 1385 * (int(msgdata2['totaltime']) / int(
    #                         max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #             elif(len(data) == 3):
    #                 msgdata2 = data[1].get('jsonMessage')
    #                 msgdata3 = data[2].get('jsonMessage')
    #                 self.twokstTxt1.setText(
    #                     f"入豆温度: {msgdata2['CHARGE_BT']}℃   回温点: {msgdata2['TP_BT']}℃/{msgdata2['TP_time']}")
    #                 self.twokstTxt1.setGeometry(16 * self.width_scale, 3 * self.height_scale, (((int(
    #                     msgdata2['totaltime']) - int(msgdata2['Maillard_time']) - int(msgdata2['FCs_time'])) / int(
    #                     msgdata2['totaltime'])) * 1385 * (int(msgdata2['totaltime']) / int(
    #                     max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.twokstTxt2.setText(f"转黄点: {msgdata2['Maillard']}℃/{msgdata2['Maillard_time']}")
    #                 self.twokstTxt2.setGeometry((int(self.onekstTxt1.geometry().width() + 17)) * self.width_scale,
    #                                             3 * self.height_scale, ((int(msgdata2['Maillard_time']) / int(
    #                         msgdata2['totaltime'])) * 1385 * (int(msgdata2['totaltime']) / int(
    #                         max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.twokstTxt3.setText(f"一爆: {msgdata2['FCs_BT']}℃/{msgdata2['FCs_time']}")
    #                 self.twokstTxt3.setGeometry((
    #                                                 int(self.onekstTxt1.geometry().width() + 18 + self.onekstTxt2.geometry().width())) * self.width_scale,
    #                                             3 * self.height_scale, ((int(msgdata2['FCs_time']) / int(
    #                         msgdata2['totaltime'])) * 1385 * (int(msgdata2['totaltime']) / int(
    #                         max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.threekstTxt1.setText(
    #                 f"入豆温度: {msgdata3['CHARGE_BT']}℃   回温点: {msgdata3['TP_BT']}℃/{msgdata3['TP_time']}")
    #                 self.threekstTxt1.setGeometry(16 * self.width_scale, 3 * self.height_scale, (((int(
    #                 msgdata3['totaltime']) - int(msgdata3['Maillard_time']) - int(msgdata3['FCs_time'])) / int(
    #                 msgdata3['totaltime'])) * 1385 * (int(msgdata3['totaltime']) / int(
    #                 max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.threekstTxt2.setText(f"转黄点: {msgdata3['Maillard']}℃/{msgdata3['Maillard_time']}")
    #                 self.threekstTxt2.setGeometry((int(self.onekstTxt1.geometry().width() + 17)) * self.width_scale,
    #                                           3 * self.height_scale, ((int(msgdata3['Maillard_time']) / int(
    #                     msgdata3['totaltime'])) * 1385 * (int(msgdata3['totaltime']) / int(
    #                     max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.threekstTxt3.setText(f"一爆: {msgdata3['FCs_BT']}℃/{msgdata3['FCs_time']}")
    #                 self.threekstTxt3.setGeometry((
    #                                               int(self.onekstTxt1.geometry().width() + 18 + self.onekstTxt2.geometry().width())) * self.width_scale,
    #                                           3 * self.height_scale, ((int(msgdata3['FCs_time']) / int(
    #                     msgdata3['totaltime'])) * 1385 * (int(msgdata3['totaltime']) / int(
    #                     max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #             elif(len(data) == 4):
    #                 msgdata2 = data[1].get('jsonMessage')
    #                 msgdata3 = data[2].get('jsonMessage')
    #                 msgdata4 = data[3].get('jsonMessage')
    #                 self.twokstTxt1.setText(
    #                     f"入豆温度: {msgdata2['CHARGE_BT']}℃   回温点: {msgdata2['TP_BT']}℃/{msgdata2['TP_time']}")
    #                 self.twokstTxt1.setGeometry(16 * self.width_scale, 3 * self.height_scale, (((int(
    #                     msgdata2['totaltime']) - int(msgdata2['Maillard_time']) - int(msgdata2['FCs_time'])) / int(
    #                     msgdata2['totaltime'])) * 1385 * (int(msgdata2['totaltime']) / int(
    #                     max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.twokstTxt2.setText(f"转黄点: {msgdata2['Maillard']}℃/{msgdata2['Maillard_time']}")
    #                 self.twokstTxt2.setGeometry((int(self.onekstTxt1.geometry().width() + 17)) * self.width_scale,
    #                                             3 * self.height_scale, ((int(msgdata2['Maillard_time']) / int(
    #                         msgdata2['totaltime'])) * 1385 * (int(msgdata2['totaltime']) / int(
    #                         max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.twokstTxt3.setText(f"一爆: {msgdata2['FCs_BT']}℃/{msgdata2['FCs_time']}")
    #                 self.twokstTxt3.setGeometry((
    #                                                 int(self.onekstTxt1.geometry().width() + 18 + self.onekstTxt2.geometry().width())) * self.width_scale,
    #                                             3 * self.height_scale, ((int(msgdata2['FCs_time']) / int(
    #                         msgdata2['totaltime'])) * 1385 * (int(msgdata2['totaltime']) / int(
    #                         max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.threekstTxt1.setText(
    #                     f"入豆温度: {msgdata3['CHARGE_BT']}℃   回温点: {msgdata3['TP_BT']}℃/{msgdata3['TP_time']}")
    #                 self.threekstTxt1.setGeometry(16 * self.width_scale, 3 * self.height_scale, (((int(
    #                     msgdata3['totaltime']) - int(msgdata3['Maillard_time']) - int(msgdata3['FCs_time'])) / int(
    #                     msgdata3['totaltime'])) * 1385 * (int(msgdata3['totaltime']) / int(
    #                     max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.threekstTxt2.setText(f"转黄点: {msgdata3['Maillard']}℃/{msgdata3['Maillard_time']}")
    #                 self.threekstTxt2.setGeometry((int(self.onekstTxt1.geometry().width() + 17)) * self.width_scale,
    #                                               3 * self.height_scale, ((int(msgdata3['Maillard_time']) / int(
    #                         msgdata3['totaltime'])) * 1385 * (int(msgdata3['totaltime']) / int(
    #                         max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.threekstTxt3.setText(f"一爆: {msgdata3['FCs_BT']}℃/{msgdata3['FCs_time']}")
    #                 self.threekstTxt3.setGeometry((
    #                                                   int(self.onekstTxt1.geometry().width() + 18 + self.onekstTxt2.geometry().width())) * self.width_scale,
    #                                               3 * self.height_scale, ((int(msgdata3['FCs_time']) / int(
    #                         msgdata3['totaltime'])) * 1385 * (int(msgdata3['totaltime']) / int(
    #                         max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.fourkstTxt1.setText(
    #                     f"入豆温度: {msgdata4['CHARGE_BT']}℃   回温点: {msgdata4['TP_BT']}℃/{msgdata4['TP_time']}")
    #                 self.fourkstTxt1.setGeometry(16 * self.width_scale, 3 * self.height_scale, (((int(
    #                     msgdata4['totaltime']) - int(msgdata4['Maillard_time']) - int(msgdata4['FCs_time'])) / int(
    #                     msgdata4['totaltime'])) * 1385 * (int(msgdata4['totaltime']) / int(
    #                     max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.fourkstTxt2.setText(f"转黄点: {msgdata4['Maillard']}℃/{msgdata4['Maillard_time']}")
    #                 self.fourkstTxt2.setGeometry((int(self.onekstTxt1.geometry().width() + 17)) * self.width_scale,
    #                                              3 * self.height_scale, ((int(msgdata4['Maillard_time']) / int(
    #                         msgdata4['totaltime'])) * 1385 * (int(msgdata4['totaltime']) / int(
    #                         max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #
    #                 self.fourkstTxt3.setText(f"一爆: {msgdata4['FCs_BT']}℃/{msgdata4['FCs_time']}")
    #                 self.fourkstTxt3.setGeometry((
    #                                                  int(self.onekstTxt1.geometry().width() + 18 + self.onekstTxt2.geometry().width())) * self.width_scale,
    #                                              3 * self.height_scale, ((int(msgdata4['FCs_time']) / int(
    #                         msgdata4['totaltime'])) * 1385 * (int(msgdata4['totaltime']) / int(
    #                         max_time_in_seconds))) * self.width_scale, 60 * self.height_scale)
    #         else:
    #             print('连接失败')
    #
    # def toggle_analyse_dw(self):
    #
    #     order_ids_str = ','.join(self.orderID)
    #     url = "http://inner4.mjytech.com:22104/admin/device/lookFormulaCurve"
    #     params = {'bakingBatchList': order_ids_str}
    #     response = requests.get(url, params)
    #     if response.status_code == 200:
    #         data = response.json()
    #         textCode = data['code']
    #         if textCode == 0 or textCode == 200:
    #             self.historyAnalyse.setVisible(True)
    #             self.scroll_area.setVisible(True)
    #             self.scroll_area.setWidget(self.historyAnalyse)
    #             dataJson = response.json()
    #             data = dataJson['data']
    #
    #             # 获取不同的 timex 数组
    #             try:
    #                 timex1 = data[0]['jsonMessage']['alogJson']['timex']
    #             except (IndexError, KeyError, TypeError):
    #                 timex1 = []
    #
    #             try:
    #                 timex2 = data[1]['jsonMessage']['alogJson']['timex']
    #             except (IndexError, KeyError, TypeError):
    #                 timex2 = []
    #
    #             try:
    #                 timex3 = data[2]['jsonMessage']['alogJson']['timex']
    #             except (IndexError, KeyError, TypeError):
    #                 timex3 = []
    #
    #             try:
    #                 timex4 = data[3]['jsonMessage']['alogJson']['timex']
    #             except (IndexError, KeyError, TypeError):
    #                 timex4 = []
    #
    #             # 找到最长的 timex
    #             timex_lengths = [len(timex1), len(timex2), len(timex3), len(timex4)]
    #             max_len_index = timex_lengths.index(max(timex_lengths))  # 获取最长 timex 的索引
    #
    #             # 使用最长的 timex
    #             timex = [timex1, timex2, timex3, timex4][max_len_index]
    #
    #             # 获取四个温度数据
    #             try:
    #                 temp1 = data[0]['jsonMessage']['alogJson']['temp1']
    #             except (IndexError, KeyError, TypeError):
    #                 temp1 = []
    #
    #             try:
    #                 temp2 = data[1]['jsonMessage']['alogJson']['temp1']
    #             except (IndexError, KeyError, TypeError):
    #                 temp2 = []
    #
    #             try:
    #                 temp3 = data[2]['jsonMessage']['alogJson']['temp1']
    #             except (IndexError, KeyError, TypeError):
    #                 temp3 = []
    #
    #             try:
    #                 temp4 = data[3]['jsonMessage']['alogJson']['temp1']
    #             except (IndexError, KeyError, TypeError):
    #                 temp4 = []
    #
    #             # 更新图表
    #             self.matplotlib_widget.update_plot(timex, temp1, temp2, temp3, temp4)
    #
    #             self.analyse_dw.setStyleSheet('border-radius: 16px;background-color: #FBF8F5;border: 2px solid #D18F65')
    #             self.analyse_fw.setStyleSheet('border-radius: 16px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
    #             self.analyse_ROR.setStyleSheet('border-radius: 16px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
    #             self.analyse_Agtron.setStyleSheet('border-radius: 16px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
    #             self.analyse_pqsd.setStyleSheet('border-radius: 16px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
    #             self.analyse_pqwd.setStyleSheet('border-radius: 16px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
    #
    # def toggle_analyse_fw(self):
    #     order_ids_str = ','.join(self.orderID)
    #     url = "http://inner4.mjytech.com:22104/admin/device/lookFormulaCurve"
    #     params = {'bakingBatchList': order_ids_str}
    #     response = requests.get(url, params)
    #     if response.status_code == 200:
    #         data = response.json()
    #         textCode = data['code']
    #         if textCode == 0 or textCode == 200:
    #             self.historyAnalyse.setVisible(True)
    #             self.scroll_area.setVisible(True)
    #             self.scroll_area.setWidget(self.historyAnalyse)
    #             dataJson = response.json()
    #             data = dataJson['data']
    #
    #             # 获取不同的 timex 数组
    #             try:
    #                 timex1 = data[0]['jsonMessage']['alogJson']['timex']
    #             except (IndexError, KeyError, TypeError):
    #                 timex1 = []
    #
    #             try:
    #                 timex2 = data[1]['jsonMessage']['alogJson']['timex']
    #             except (IndexError, KeyError, TypeError):
    #                 timex2 = []
    #
    #             try:
    #                 timex3 = data[2]['jsonMessage']['alogJson']['timex']
    #             except (IndexError, KeyError, TypeError):
    #                 timex3 = []
    #
    #             try:
    #                 timex4 = data[3]['jsonMessage']['alogJson']['timex']
    #             except (IndexError, KeyError, TypeError):
    #                 timex4 = []
    #
    #             # 找到最长的 timex
    #             timex_lengths = [len(timex1), len(timex2), len(timex3), len(timex4)]
    #             max_len_index = timex_lengths.index(max(timex_lengths))  # 获取最长 timex 的索引
    #
    #             # 使用最长的 timex
    #             timex = [timex1, timex2, timex3, timex4][max_len_index]
    #
    #             # 获取四个温度数据
    #             try:
    #                 temp1 = data[0]['jsonMessage']['alogJson']['temp2']
    #             except (IndexError, KeyError, TypeError):
    #                 temp1 = []
    #
    #             try:
    #                 temp2 = data[1]['jsonMessage']['alogJson']['temp2']
    #             except (IndexError, KeyError, TypeError):
    #                 temp2 = []
    #
    #             try:
    #                 temp3 = data[2]['jsonMessage']['alogJson']['temp2']
    #             except (IndexError, KeyError, TypeError):
    #                 temp3 = []
    #
    #             try:
    #                 temp4 = data[3]['jsonMessage']['alogJson']['temp2']
    #             except (IndexError, KeyError, TypeError):
    #                 temp4 = []
    #
    #             # 更新图表
    #             self.matplotlib_widget.update_plot(timex, temp1, temp2, temp3, temp4)
    #
    #             self.analyse_dw.setStyleSheet('border-radius: 16px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
    #             self.analyse_fw.setStyleSheet('border-radius: 16px;background-color: #FBF8F5;border: 2px solid #AC3230')
    #             self.analyse_ROR.setStyleSheet(
    #                 'border-radius: 16px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
    #             self.analyse_Agtron.setStyleSheet(
    #                 'border-radius: 16px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
    #             self.analyse_pqsd.setStyleSheet(
    #                 'border-radius: 16px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
    #             self.analyse_pqwd.setStyleSheet(
    #                 'border-radius: 16px;background-color: #FBF8F5;border: 2px solid #CAC6C2')


    def submitInfo(self):
        print('000')

    # def date_changed(self, date):
    #
    #     midnight2 = QDateTime(date, QTime(0, 0))
    #     end_of_day2 = QDateTime(date, QTime(23, 59))
    #
    #     global token
    #     url = 'http://inner4.mjytech.com:22104/admin/device/getPadBakinglist'  # 获取历史任务列表
    #     params = {'bakingDeviceId': "2", 'startTime': midnight2.toString('yyyy-MM-dd HH:mm'),
    #               'endTime': end_of_day2.toString('yyyy-MM-dd HH:mm')}
    #     headers = {
    #         'token': f'{token}',
    #         'Content-Type': 'application/json'
    #     }
    #     if token:
    #         response = requests.get(url, params, headers=headers)
    #         if response.status_code == 200:
    #             dataJson = response.json()
    #             dataJson2 = dataJson['bakingTaskList']
    #
    #             textCode = dataJson['code']
    #             if textCode == 0 or textCode == 200:
    #                 # list_widget 历史列表
    #                 self.list_widget.clear()
    #                 for data in dataJson2:
    #                     historyListBack = QWidget()
    #                     historyListBack.setStyleSheet(
    #                         'border-radius: 12px; background-color: transparent; border: 1px solid #378AF6;')
    #
    #                     # 使用布局管理器
    #                     item_layout \
    #                         = QHBoxLayout(historyListBack)
    #                     item_layout.setContentsMargins(0 * self.width_scale, 5 * self.height_scale,
    #                                                    10 * self.width_scale, 5 * self.height_scale)  # 设置边距
    #                     item_layout.setSpacing(0 * self.height_scale)  # 设置控件之间的间距
    #
    #                     # 创建标签并添加到布局
    #                     checkbox = QCheckBox(historyListBack)
    #                     checkbox.setStyleSheet("color: #222222; border:none; padding: 2px;background-color: #ffffff")
    #                     # item_layout.addWidget(checkbox)
    #                     checkbox.setGeometry(45 * self.width_scale, 9 * self.height_scale, 18 * self.height_scale,
    #                                          18 * self.height_scale)
    #                     checkbox.setFixedWidth(18 * self.width_scale)
    #                     checkbox.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
    #                     # checkbox.bakingBatch = data['bakingBatch']
    #                     checkbox.setProperty("bakingBatch", data.get("bakingBatch"))
    #                     checkbox.setProperty("orderDetailJson", data)
    #                     checkbox.stateChanged.connect(self.handle_checkbox)
    #
    #                     fkqkImg = QLabel(historyListBack)
    #                     fkqkImg.setGeometry(140 * self.width_scale, 8 * self.height_scale, 20 * self.width_scale,
    #                                         20 * self.height_scale)
    #                     # fkqkImg.setFixedSize(20, 20)
    #                     fkqkImg.setStyleSheet("color: #222222; border:none; padding: 2px;background-color: transparent")
    #                     if data['desncription'] != '':
    #                         fkqkImgPixmap = QPixmap(self.normalized_path + '/includes/Icons/history/pingfen2.png')
    #                     else:
    #                         fkqkImgPixmap = QPixmap(self.normalized_path + '/includes/Icons/history/pingfen.png')
    #                     fkqkImg.setPixmap(fkqkImgPixmap)
    #                     fkqkImg.setScaledContents(True)
    #                     # item_layout.addWidget(fkqkImg)
    #                     # fkqkImg.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
    #
    #                     bakingBatch_label = QLabel(historyListBack)
    #                     bakingBatch_label.setStyleSheet(
    #                         "color: #222222; border:none; padding: 2px;background-color: transparent")
    #                     bakingBatch_label.setText(data['bakingBatch'])
    #                     bakingBatch_label.setGeometry(261 * self.width_scale, 0, 250 * self.width_scale,
    #                                                   36 * self.height_scale)
    #                     # bakingBatch_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
    #                     # item_layout.addWidget(bakingBatch_label)
    #                     # bakingBatch_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
    #
    #                     taskName_label = QLabel(historyListBack)
    #                     taskName_label.setStyleSheet(
    #                         "color: #222222; border:none; padding: 2px;background-color: transparent")
    #                     taskName_label.setText(data['taskName'])
    #                     taskName_label.setGeometry(507 * self.width_scale, 0, 120 * self.width_scale,
    #                                                36 * self.height_scale)
    #                     taskName_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
    #                     # item_layout.addWidget(taskName_label)
    #                     taskName_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
    #
    #                     taskTime_label = QLabel(historyListBack)  # 将时间换算为分钟
    #                     taskTime_label.setStyleSheet(
    #                         "color: #222222; border:none; padding: 2px;background-color: transparent")
    #                     taskTime_label.setText(str(data['taskTime'] / 60))
    #                     taskTime_label.setGeometry(787 * self.width_scale, 0, 120 * self.width_scale,
    #                                                36 * self.height_scale)
    #                     taskTime_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
    #                     taskTime_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
    #
    #                     create_time = data.get('createTime')
    #                     baking_finish_time = data.get('bakingFinishTime')
    #                     createTime_label = QLabel(historyListBack)
    #                     if create_time is None or baking_finish_time is None:
    #                         createTime_label.setText('-')  # 显示时间段
    #                     else:
    #                         createTime_label.setText(
    #                             str(create_time[11:16]) + '-' + str(baking_finish_time[11:16]))  # 显示时间段
    #                     createTime_label.setStyleSheet("color: #222222; border:none; padding: 2px;")
    #                     createTime_label.setGeometry(1045 * self.width_scale, 0, 120 * self.width_scale,
    #                                                  36 * self.height_scale)
    #                     createTime_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
    #                     # item_layout.addWidget(createTime_label)
    #                     createTime_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
    #
    #                     agtronValue_label = QLabel(historyListBack)
    #                     agtronValue_label.setStyleSheet("color: #222222; border:none; padding: 2px;")
    #                     # item_layout.addWidget(agtronValue_label)
    #                     agtronValue_label.setText(str(data['agtronValue']))
    #                     agtronValue_label.setGeometry(1265 * self.width_scale, 0, 120 * self.width_scale,
    #                                                   36 * self.height_scale)
    #                     agtronValue_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
    #                     agtronValue_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
    #
    #                     # 添加间距项
    #                     spacer = QSpacerItem(0, 40 * self.height_scale)
    #                     item_layout.addItem(spacer)
    #
    #                     # 设置 QWidget 的大小
    #                     historyListBack.setFixedHeight(36 * self.height_scale)
    #
    #
    #                     # 创建 QListWidgetItem
    #                     list_item = QListWidgetItem(self.list_widget)
    #                     list_item.setSizeHint(historyListBack.sizeHint())  # 设置项的大小提示
    #                     list_item.setData(12, data['numberOfBeans'])  # 含水量
    #                     list_item.setData(11, data['number'])  # 生豆重量
    #                     list_item.setData(22, data['bakingBatch'])  # 任务编号
    #                     list_item.setData(3, data['numberOfBeans'])  # 熟豆重量
    #                     list_item.setData(4, data['dehydrationRate'])  # 烘焙损失率
    #                     list_item.setData(5, data['bakingFinishTime'])  # 烘焙日期
    #                     list_item.setData(7, data['bakingScore'])  # 烘焙评分
    #
    #                     if data['cuppingDetail'] not in dataJson2:
    #                         list_item.setData(6, '-')  # 杯测评分
    #                         list_item.setData(8, '-')  # 杯测日期
    #                         list_item.setData(9, '-')  # 品控反馈
    #                     else:
    #                         list_item.setData(6, data['cuppingDetail']['score'])  # 杯测评分
    #                         list_item.setData(8, data['cuppingDetail']['createTime'])  # 杯测日期
    #                         list_item.setData(9, data['cuppingDetail']['descn'])  # 品控反馈
    #
    #                     self.list_widget.addItem(list_item)  # 添加项到 QListWidget
    #                     self.list_widget.setItemWidget(list_item, historyListBack)
    #             else:
    #                 print('连接失败', response.text)
    #         else:
    #             print('连接失败', response.text)

    # def handle_checkbox(self, state):
    #     checkbox = self.sender()  # 获取信号发送者（即复选框）
    #
    #     # 获取自定义属性 bakingBatch
    #     bakingBatch = checkbox.property("bakingBatch")
    #     orderDetailJson = checkbox.property("orderDetailJson")
    #
    #     # 如果 bakingBatch 是 None，跳过操作
    #     if bakingBatch is None:
    #         with open("outputttttttttttt.log", "a") as f:
    #             print("Warning: bakingBatch is None", file=f)
    #         return
    #
    #     if state == 2:  # 如果复选框被选中
    #         if bakingBatch not in self.orderID:
    #             self.orderID.append(bakingBatch)  # 将ID添加到数组
    #             self.orderDetail.append(orderDetailJson)
    #             with open("outputttttttttttt.log", "a") as f:  # 使用 'a' 模式追加而非覆盖
    #                 print('orderId=' + str(self.orderDetail), file=f)
    #     elif state == 0:
    #         if bakingBatch in self.orderID:
    #             self.orderID.remove(bakingBatch)  # 从数组中移除ID
    #             self.orderDetail.remove(orderDetailJson)
    #             with open("outputttttttttttt.log", "a") as f:
    #                 print('orderId=' + str(self.orderDetail), file=f)
    def handle_checkbox(self, state):
        checkbox = self.sender()  # 获取信号发送者（即复选框）

        # 获取自定义属性 bakingBatch 和 orderDetailJson
        bakingBatch = checkbox.property("bakingBatch")
        orderDetailJson = checkbox.property("orderDetailJson")

        # 如果 bakingBatch 是 None，跳过操作
        if bakingBatch is None:
            with open("outputttttttttttt.log", "a") as f:
                print("Warning: bakingBatch is None", file=f)
            return

        if state == 2:  # 如果复选框被选中
            # 检查是否已经存在于数组中且是否超过限制
            if bakingBatch not in self.orderID:
                if len(self.orderID) < 4:
                    self.orderID.append(bakingBatch)  # 将ID添加到数组
                    self.orderDetail.append(orderDetailJson)
                    with open("outputttttttttttt.log", "a") as f:
                        print('orderId=' + str(self.orderDetail), file=f)
                else:
                    # 超过限制，取消复选框状态并终止操作
                    checkbox.blockSignals(True)  # 暂时禁用信号
                    checkbox.setChecked(False)  # 取消选中状态
                    checkbox.blockSignals(False)  # 恢复信号
                    self.diologRect2Zhezhao.setVisible(True)
                    self.jbCentent2.setText("最多勾选四项哦！超过四项的不起作用。")
                    with open("outputttttttttttt.log", "a") as f:
                        print("Warning: Cannot add more items. Maximum limit reached.", file=f)

        elif state == 0:  # 如果复选框取消选中
            if bakingBatch in self.orderID:
                self.orderID.remove(bakingBatch)  # 从数组中移除ID
                self.orderDetail.remove(orderDetailJson)
                with open("outputttttttttttt.log", "a") as f:
                    print('orderId=' + str(self.orderDetail), file=f)

    # def showHistorydetail(self, item):
    #     item_id = item.data(22)
    #
    #     self.qmc: tgraphcanvas = tgraphcanvas(self.historyInfo, self.dpi, self.locale_str, self)
    #     self.qmc.setGeometry(65*self.width_scale, 104*self.height_scale, 1481*self.width_scale, 600*self.height_scale)
    #     self.qmc.setVisible(True)
    #     self.qmc.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)#鼠标穿透
    #
    #     self.sdzl.setText(str(item.data(12))+'kg')
    #     self.hslTxt.setText(str(item.data(11))+'kg')
    #     self.hbrqNum.setText(str(item.data(5)))
    #     self.bcpfNum.setText(str(item.data(6))+'分')
    #     self.hbpfNum.setText(str(item.data(7))+'分')
    #     self.bcrqNum.setText(str(item.data(8)))
    #     self.pkfkTxt.setText(str(item.data(9)))
    #
    #     # order_id = "ORDER-2202409111052390111_2-0,ORDER-2202409111052390111_2-1"
    #     url = "http://inner4.mjytech.com:22104/admin/device/lookFormulaCurve" # 查看烘焙详情
    #     params = {'bakingBatchList': item_id}
    #     response = requests.get(url, params)
    #     if response.status_code == 200:
    #         self.historyInfo.setVisible(True)
    #         self.scroll_area.setVisible(True)
    #         self.scroll_area.setWidget(self.historyInfo)
    #         dataJson = response.json()
    #         data = dataJson['data']
    #         textCode = dataJson['code']
    #         if textCode == 0 or textCode == 200:
    #             self.historyDetail_sheibei.setText(item_id)
    #
    #             # self.fileLoad()
    #             obj = data[0]['jsonMessage']['alogJson']
    #             res = self.setProfile(obj) # 打开烘焙曲线
    #             if res:
    #                 # update etypes combo box
    #                 self.etypeComboBox.clear()
    #                 self.etypeComboBox.addItems(self.qmc.etypes)
    #                 self.qmc.fileDirtySignal.emit()
    #                 self.autoAdjustAxis()
    #                 self.qmc.redraw()
    #
    #             self.hbscContent = str(int(data[0]['jsonMessage']['totaltime']) // 60) + ':' + str(
    #                 int(data[0]['jsonMessage']['totaltime']) % 60)
    #             self.hongbeishichang.setText('烘焙时长：' + str(self.hbscContent))
    #
    #             self.rdwdContent = data[0]['jsonMessage']['CHARGE_BT']
    #             self.rudouwendu.setText('入豆温度：' + str(self.rdwdContent) + '℃')
    #
    #             self.hwdContent = str(data[0]['jsonMessage']['TP_BT']) + '/' + str(
    #                 int(data[0]['jsonMessage']['TP_time']) // 60) + ':' + str(
    #                 int(data[0]['jsonMessage']['TP_time']) % 60)
    #             self.huiwendian.setText('回温点：' + str(self.hwdContent))
    #
    #             self.zhdContent = str(data[0]['jsonMessage']['Maillard']) + '/' + str(
    #                 int(data[0]['jsonMessage']['Maillard_time']) // 60) + ':' + str(
    #                 int(data[0]['jsonMessage']['Maillard_time']) % 60)
    #             self.zhuanhuangdian.setText('转黄点：' + self.zhdContent)
    #
    #             self.ybContent = str(data[0]['jsonMessage']['FCs_BT']) + '/' + str(
    #                 int(data[0]['jsonMessage']['FCs_time']) // 60) + ':' + str(
    #                 int(data[0]['jsonMessage']['FCs_time']) % 60)
    #             self.yibao.setText('一爆：' + self.ybContent)
    #
    #             self.fzscContent = str(int(data[0]['jsonMessage']['finishphasetime']) // 60) + ':' + str(
    #                 int(data[0]['jsonMessage']['finishphasetime']) % 60)
    #             self.fazhanshichang.setText('发展时长：' + self.fzscContent)
    #
    #             self.dtrContent = data[0]['jsonMessage']['DTR']
    #             self.dtrTxt.setText('DTR：' + str(self.dtrContent) + '%')
    #
    #             self.wendu1Txt.setText(str(data[0]['jsonMessage']['target_temperature'][0]) + '℃')
    #             self.ckz1Txt.setText(str(data[0]['jsonMessage']['target_values'][0]) + 'RH%')
    #
    #             self.wendu2Txt.setText(str(data[0]['jsonMessage']['target_temperature'][1]) + '℃')
    #             self.ckz2Txt.setText(str(data[0]['jsonMessage']['target_values'][1]) + 'RH%')
    #
    #             self.wendu3Txt.setText(str(data[0]['jsonMessage']['target_temperature'][2]) + '℃')
    #             self.ckz3Txt.setText(str(data[0]['jsonMessage']['target_values'][2]) + 'RH%')
    #
    #             self.wendu4Txt.setText(str(data[0]['jsonMessage']['target_temperature'][3]) + '℃')
    #             self.ckz4Txt.setText(str(data[0]['jsonMessage']['target_values'][3]) + '%')
    #
    #             self.wendu5Txt.setText(str(data[0]['jsonMessage']['target_temperature'][4]) + '℃')
    #             self.ckz5Txt.setText(str(data[0]['jsonMessage']['target_values'][4]) + '%')
    #
    #             self.wendu6Txt.setText(str(data[0]['jsonMessage']['target_temperature'][5]) + '℃')
    #             self.ckz6Txt.setText(str(data[0]['jsonMessage']['target_values'][5]) + '%')
    #
    #             self.sjwendu1Txt.setText(str(data[0]['jsonMessage']['actual_temperature'][0]) + '℃')
    #             self.sjckz1Txt.setText(str(data[0]['jsonMessage']['actual_values'][0]) + 'RH%')
    #
    #             self.sjwendu2Txt.setText(str(data[0]['jsonMessage']['actual_temperature'][1]) + '℃')
    #             self.sjckz2Txt.setText(str(data[0]['jsonMessage']['actual_values'][1]) + 'RH%')
    #
    #             self.sjwendu3Txt.setText(str(data[0]['jsonMessage']['actual_temperature'][2]) + '℃')
    #             self.sjckz3Txt.setText(str(data[0]['jsonMessage']['actual_values'][2]) + 'RH%')
    #
    #             self.sjwendu4Txt.setText(str(data[0]['jsonMessage']['actual_temperature'][3]) + '℃')
    #             self.sjckz4Txt.setText(str(data[0]['jsonMessage']['actual_values'][3]) + '%')
    #
    #             self.sjwendu5Txt.setText(str(data[0]['jsonMessage']['actual_temperature'][4]) + '℃')
    #             self.sjckz5Txt.setText(str(data[0]['jsonMessage']['actual_values'][4]) + '%')
    #
    #             self.sjwendu6Txt.setText(str(data[0]['jsonMessage']['actual_temperature'][5]) + '℃')
    #             self.sjckz6Txt.setText(str(data[0]['jsonMessage']['actual_values'][5]) + '%')
    #
    #             self.sjpc1Txt.setText(str(round(
    #                 (data[0]['jsonMessage']['actual_values'][0] - data[0]['jsonMessage']['target_values'][0]) /
    #                 data[0]['jsonMessage']['actual_values'][0] * 100)) + '%')
    #             self.sjpc2Txt.setText(str(round(
    #                 (data[0]['jsonMessage']['actual_values'][1] - data[0]['jsonMessage']['target_values'][1]) /
    #                 data[0]['jsonMessage']['actual_values'][1] * 100)) + '%')
    #             self.sjpc3Txt.setText(str(round(
    #                 (data[0]['jsonMessage']['actual_values'][2] - data[0]['jsonMessage']['target_values'][2]) /
    #                 data[0]['jsonMessage']['actual_values'][2] * 100)) + '%')
    #             self.sjpc4Txt.setText(str(round(
    #                 (data[0]['jsonMessage']['actual_values'][3] - data[0]['jsonMessage']['target_values'][3]) /
    #                 data[0]['jsonMessage']['actual_values'][3] * 100)) + '%')
    #             self.sjpc5Txt.setText(str(round(
    #                 (data[0]['jsonMessage']['actual_values'][4] - data[0]['jsonMessage']['target_values'][4]) /
    #                 data[0]['jsonMessage']['actual_values'][4] * 100)) + '%')
    #             self.sjpc6Txt.setText(str(round(
    #                 (data[0]['jsonMessage']['actual_values'][5] - data[0]['jsonMessage']['target_values'][5]) /
    #                 data[0]['jsonMessage']['actual_values'][5] * 100)) + '%')
    #
    #             self.qkfkContent.setText(data[0].get('desncription'))
    #             self.agtronzhiNum.setText('#' + str(data[0].get('agtronValue')))
    #
    #         else:
    #             print('连接失败')
    #     else:
    #         print('连接失败')

    def syncScrollBar(self, value):
        # 同步两个 QListWidget 的滚动条
        sender = self.sender()
        if sender == self.list_widget.verticalScrollBar():
            self.list_widget2.verticalScrollBar().setValue(value)
        elif sender == self.list_widget2.verticalScrollBar():
            self.list_widget.verticalScrollBar().setValue(value)


    def toggle_password_visibility(self):
        if self.toggle_button.isChecked():
            self.passwordContent.setEchoMode(QLineEdit.EchoMode.Normal)  # 显示密码
            self.toggle_button.setIcon(QIcon(self.normalized_path + '/includes/Icons/login/eyeTrue.png'))
        else:
            self.passwordContent.setEchoMode(QLineEdit.EchoMode.Password)  # 隐藏密码
            self.toggle_button.setIcon(QIcon(self.normalized_path + '/includes/Icons/login/eyeFalse.png'))

    # def loginClicked(self):
    #     self.blink_timer.start(200)  # 启动定时器，间隔 500 毫秒（0.5 秒）
    #     # 创建计时器，用于停止闪烁
    #     self.stop_timer = QTimer(self)
    #     self.stop_timer.timeout.connect(self.stop_blinking)  # 当计时器超时时，停止闪烁
    #     self.stop_timer.setSingleShot(True)  # 设置为单次触发
    #     self.stop_timer.start(3000)  # 启动计时器，5秒后触发
    #     # self.loginBack.setVisible(False)passwordContent userContent
    #     url = 'http://inner4.mjytech.com:22104/sys/login'  # 示例 URL
    #     list_url = "http://inner4.mjytech.com:22104/admin/device/selectBakingDeviceList"
    #     self.getHonbeiList()
    #     global token
    #     payload = {
    #         "username": self.userContent.text(),
    #         "password": self.passwordContent.text()
    #     }
    #     try:
    #         response = requests.post(url, json=payload)
    #         if response.status_code == 200:
    #             try:
    #                 data = response.json()
    #                 token = data.get('token')
    #                 textCode = data['code']
    #                 if textCode == 0 or textCode == 200:
    #                     if token:
    #                         self.loginBack.setVisible(False)
    #                         headers = {
    #                             'token': f'{token}',
    #                             'Content-Type': 'application/json'
    #                         }
    #                         # 获取设备列表
    #                         list_response = requests.get(list_url, headers=headers)
    #                         if list_response.status_code == 200:
    #                             data2 = list_response.json()  # 解析返回的 JSON 数据
    #                             dataJson = data2['deviceList']
    #                             textCode = data2['code']
    #                             if textCode == 0 or textCode == 200:
    #                                 # bakingBatchList = data[0].get('bakingBatch')
    #
    #                                 self.sblbList.clear()
    #                                 for item_text in dataJson:
    #                                     list_item = QListWidgetItem(item_text['deviceModel'])
    #                                     list_item.setData(Qt.ItemDataRole.UserRole, item_text['id'])
    #                                     self.sblbList.addItem(list_item)
    #
    #                                 self.getHonbeiList()  # 获取烘焙订单列表
    #
    #                         else:
    #                             print(f"获取列表失败，状态码")
    #                             print("服务器响应:")
    #
    #                     else:
    #                         print("Login successful, but token not found in response.", flush=True)
    #             except ValueError:
    #                 print("Login successful, but response is not JSON:", flush=True)
    #                 print(response.text, flush=True)
    #         else:
    #             print(f"Login failed with status", flush=True)
    #
    #     except requests.RequestException as e:
    #         print(f"Request failed: {e}", flush=True)

    # def getHonbeiList(self):
    #     global token
    #     listurl = "http://inner4.mjytech.com:22104//admin/task/getBakingTask"  # 获取进行中列表
    #     # params = {'bakingDeviceId': "2"}
    #     headers = {
    #         'token': f'{token}',
    #         'Content-Type': 'application/json'
    #     }
    #
    #     if token:
    #         params = {'bakingDeviceId': "2"}
    #         list_response2 = requests.get(listurl, params, headers=headers)
    #         if list_response2.status_code == 200:
    #             data3 = list_response2.json()
    #             textCode = data3['code']
    #             if textCode == 0 or textCode == 200:
    #                 self.orderList_data = data3['data']
    #                 if data3['data']:
    #                     # 清除布局中的旧部件
    #                     for i in reversed(range(self.orderLayout.count())):
    #                         widget = self.orderLayout.itemAt(i).widget()
    #                         if widget is not None:
    #                             widget.deleteLater()
    #                             self.orderLayout.removeItem(self.orderLayout.itemAt(i))
    #                     for order in self.orderList_data:
    #                         ordersRect2 = QLabel()
    #                         ordersRect2.setStyleSheet(
    #                             'border-radius: 25px; background-color: #f5f8fb; border: 1px solid #e1f0fe;'
    #                         )
    #                         ordersRect2.setFixedSize(288 * self.width_scale, 185 * self.height_scale)
    #                         # self.id_value.append(order['id'])
    #                         # self.id_value.append(order['taskName'])
    #                         # self.id_value.append(order['bakingBatch'])
    #                         # self.id_value.append(order['bakingFinishTime'])
    #                         self.add_data(
    #                             [order['id'], order['taskName'], order['bakingBatch'], order['bakingFinishTime'], order['taskId']])
    #                         self.chucangValue.append(self.orderList_data[0]['bakingBatch'])
    #                         self.chucangValue.append(self.orderList_data[0]['taskId'])
    #
    #                         task_name_label = QLabel(ordersRect2)
    #                         task_name_label.setStyleSheet("color: #222222;border:none;background-color:transparent")
    #                         task_name_label.setGeometry(26 * self.width_scale, 26 * self.height_scale,
    #                                                     183 * self.width_scale, 24 * self.height_scale)
    #                         font = QFont(self.font_family3, 14 * self.width_scale)
    #                         task_name_label.setFont(font)
    #                         task_name_label.setText(order['taskName'])
    #
    #                         taskTxt_label = QLabel(ordersRect2)
    #                         taskTxt_label.setStyleSheet("color: #222222;border:none;")
    #                         taskTxt_label.setGeometry(26 * self.width_scale, 68 * self.height_scale,
    #                                                    60 * self.width_scale, 24 * self.height_scale)
    #                         font2 = QFont(self.font_family4, 10 * self.width_scale)
    #                         taskTxt_label.setFont(font2)
    #                         taskTxt_label.setText(f"任务订单:")
    #
    #                         self.task_no_label = ScrollingLabel(f"{order['bakingBatch']}", ordersRect2)
    #                         self.task_no_label.setGeometry(86 * self.width_scale, 68 * self.height_scale,
    #                                                        170 * self.width_scale, 24 * self.height_scale)
    #
    #                         self.task_no_label.setFont(font2)
    #
    #                         deadline_label = QLabel(ordersRect2)
    #                         deadline_label.setStyleSheet("color: #222222;border:none;")
    #                         deadline_label.setGeometry(26 * self.width_scale, 103 * self.height_scale,
    #                                                    210 * self.width_scale, 24 * self.height_scale)
    #                         deadline_label.setFont(font2)
    #                         deadline_label.setText(f"截止日期: {order['bakingFinishTime']}")
    #
    #                         order_id_label = QLabel(ordersRect2)
    #                         order_id_label.setStyleSheet("color: #222222;border:none;")
    #                         order_id_label.setGeometry(26 * self.width_scale, 138 * self.height_scale,
    #                                                    210 * self.width_scale, 24 * self.height_scale)
    #                         order_id_label.setFont(font2)
    #                         order_id_label.setText(f"订单数量: {order['id']}")
    #                         # self.order_id_label2.setText(f"订单数量: {self.orderList_data[0]['id']}")
    #
    #                         spacer_widget = QWidget()
    #                         spacer_widget.setFixedHeight(24)  # 设置为 36 像素高
    #
    #                         self.orderLayout.addWidget(ordersRect2)
    #                         self.orderLayout.setAlignment(ordersRect2, Qt.AlignmentFlag.AlignTop)
    #
    #                         self.orderLayout.addWidget(spacer_widget)
    #                         # self.orderLayout.setAlignment(spacer_widget, Qt.AlignmentFlag.AlignTop)
    #             else:
    #                 print("连接失败")



    def zuoyeClicked(self):
        # 工作台显示
        self.zuoyePixmap = QIcon(self.normalized_path + '/includes/Icons/general/zuoyeHover.png')
        self.zuoyeLabel.setIcon(self.zuoyePixmap)
        self.shebeiLabel.setVisible(True)
        self.xinghaoLabel.setVisible(True)
        self.statusLabel.setVisible(True)
        self.shuxian.setGeometry(2*self.width_scale, 363*self.height_scale, 3*self.width_scale, 60*self.height_scale)
        self.ai_widget.setVisible(False)

        # 流转显示
        # self.lzPixmap = QIcon(self.normalized_path + '/includes/Icons/general/zuoye.png')
        # self.lzLabel.setIcon(self.lzPixmap)
        self.shebeiLabel2.setVisible(False)
        self.todayTime.setVisible(False)
        self.lzTabel.setVisible(False)
        self.lzScroll.setVisible(False)

        # 历史显示-烘焙记录
        self.historyLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/history.png')
        self.historyLabel.setIcon(self.historyLabelPixmap)
        self.historyTabel.setVisible(False)

        # 监控情况
        self.monitorPixmap = QIcon(self.normalized_path + '/includes/Icons/general/monitor.png')
        self.monitorLabel.setIcon(self.monitorPixmap)
        self.jiankongTabel.setVisible(False)

        # 设备管理
        self.setLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/set.png')
        self.setLabel.setIcon(self.setLabelPixmap)
        self.deviceScroll.setVisible(False)
        self.deviceDetail.setVisible(False)

        # self.getHonbeiList()

    def lzDetailClick(self):
        # 工作台显示
        self.zuoyePixmap = QIcon(self.normalized_path + '/includes/Icons/general/zuoye.png')
        self.zuoyeLabel.setIcon(self.zuoyePixmap)
        self.shebeiLabel.setVisible(False)
        self.xinghaoLabel.setVisible(False)
        self.statusLabel.setVisible(False)
        self.ai_widget.setVisible(False)

        # 流转显示
        # self.lzPixmap = QIcon(self.normalized_path + '/includes/Icons/general/zuoyeHover.png')
        # self.lzLabel.setIcon(self.lzPixmap)
        self.shebeiLabel2.setVisible(True)
        self.shebeiLabel2.setText("任务流转")
        self.todayTime.setVisible(True)
        self.lzTabel.setVisible(True)
        self.lzScroll.setVisible(True)
        # self.shuxian.setGeometry(2, 403, 3, 60)

        # 历史显示-烘焙记录
        self.historyLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/history.png')
        self.historyLabel.setIcon(self.historyLabelPixmap)
        self.historyTabel.setVisible(False)

        # 监控情况
        self.monitorPixmap = QIcon(self.normalized_path + '/includes/Icons/general/monitor.png')
        self.monitorLabel.setIcon(self.monitorPixmap)


        # 设备管理
        self.setLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/set.png')
        self.setLabel.setIcon(self.setLabelPixmap)
        self.deviceScroll.setVisible(False)
        self.deviceDetail.setVisible(False)

        # global token
        # url = 'http://inner4.mjytech.com:22104/admin/task/getUserTask'  # 获取进行中列表
        # payload = {'taskStatus': 2,'taskFlow': 5}
        # headers = {
        #     'token': f'{token}',
        #     'Content-Type': 'application/json'
        # }
        # if token:
        #     response = requests.get(url, payload, headers=headers)
        #     if response.status_code == 200:
        #         data = response.json()
        #         dataJson = data['taskList']
        #         print(dataJson)
        #         textCode = data['code']
        #         if textCode == 0 or textCode == 200:
        #             # 确定行数：每行最多显示 4 个任务，向上取整计算需要多少行
        #             num_items = len(dataJson)
        #             num_columns = 4  # 每行 4 列
        #             num_rows = (num_items + num_columns - 1) // num_columns  # 向上取整计算行数
        #
        #             # 遍历 dataJson 中的任务并添加到网格布局中
        #             for index, task in enumerate(dataJson):
        #                 # 计算当前项的行和列
        #                 row = index // num_columns  # 当前项所在的行数
        #                 col = index % num_columns  # 当前项所在的列数
        #
        #                 backlabel = QLabel()
        #                 backlabel.setAlignment(Qt.AlignmentFlag.AlignCenter)  # 文字居中
        #
        #                 # 设置 QLabel 的固定大小为 373x380
        #                 backlabel.setFixedSize(373, 200 * self.height_scale)
        #
        #                 # 设置边框，方便观察组件边界
        #                 backlabel.setStyleSheet("border: 1px solid black;")
        #
        #                 self.rwlzBtn = QPushButton(backlabel)
        #                 # self.rdBtn.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignCenter)
        #                 self.rwlzBtn.setText('任务流转')
        #                 self.rwlzBtn.setGeometry(246 * self.width_scale, 15 * self.height_scale, 90 * self.width_scale,
        #                                          30 * self.height_scale)
        #                 self.rwlzBtn.setStyleSheet(
        #                     "QPushButton{color: #ffffff;background-color: #393939;border-radius: 20px;border: none}"
        #                     "QPushButton:hover{color: #ffffff;background-color: #8C6348;border-radius: 20px;border: none;}"
        #                 )
        #                 # self.rwlzBtn.clicked.connect(self.rwlzClick)
        #                 # 使用 lambda 函数传递 taskID
        #                 task_id = task.get('id', None)  # 获取当前任务的 taskID
        #                 # self.rwlzBtn.clicked.connect(lambda checked, task_id=task_id: self.rwlzClick(task_id))
        #
        #                 # 创建任务名称 QLabel
        #                 self.rwmcTitle = QLabel(backlabel)
        #                 self.rwmcTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        #                 self.rwmcTitle.setText(f"任务名称: {task.get('taskName', '未知')}")
        #                 self.rwmcTitle.setGeometry(32 * self.width_scale, 70 * self.height_scale,
        #                                            300 * self.width_scale, 34 * self.height_scale)
        #                 self.rwmcTitle.setStyleSheet(
        #                     "color: #222222;background-color: transparent; border: none; font-size: 16px"
        #                 )
        #
        #                 self.cgjzTitle = QLabel(backlabel)
        #                 self.cgjzTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        #                 self.cgjzTitle.setText(f"采购截止时间: {task.get('taskEndTime', '未知')}")
        #                 self.cgjzTitle.setGeometry(32 * self.width_scale, 114 * self.height_scale,
        #                                            300 * self.width_scale, 34 * self.height_scale)
        #                 self.cgjzTitle.setStyleSheet(
        #                     "color: #222222;background-color: transparent; border: none; font-size: 16px"
        #                 )
        #
        #                 self.yxjTitle = QLabel(backlabel)
        #                 self.yxjTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        #                 priority = task.get('priority', '未知')
        #                 # 根据 priority 值设置不同的文本和颜色
        #                 if priority == 0:
        #                     self.yxjTitle.setText("优先级: 紧急")
        #                     self.yxjTitle.setStyleSheet(
        #                         "color: red;background-color: transparent; border: none; font-size: 16px")
        #                 elif priority == 1:
        #                     self.yxjTitle.setText("优先级: 中")
        #                     self.yxjTitle.setStyleSheet(
        #                         "color: blue;background-color: transparent; border: none; font-size: 16px")
        #                 elif priority == 2:
        #                     self.yxjTitle.setText("优先级: 低")
        #                     self.yxjTitle.setStyleSheet(
        #                         "color: green;background-color: transparent; border: none; font-size: 16px")
        #                 else:
        #                     self.yxjTitle.setText(f"优先级: {priority}")
        #                     self.yxjTitle.setStyleSheet(
        #                         "color: black;background-color: transparent; border: none; font-size: 16px")
        #                 self.yxjTitle.setGeometry(32 * self.width_scale, 158 * self.height_scale,
        #                                           300 * self.width_scale, 34 * self.height_scale)
        #                 # self.yxjTitle.setStyleSheet(
        #                 #     "color: #222222;background-color: transparent; border: none; font-size: 16px"
        #                 # )
        #
        #                 # 将任务 backlabel 添加到布局中
        #                 self.lzGridLayout.addWidget(backlabel, row, col)
        #                 self.lzGridLayout.setAlignment(backlabel, Qt.AlignmentFlag.AlignTop)
        #         else:
        #             print('连接失败')

    def rwlzClick(self, task_id):
        # # self.selectPopup(task_id)
        print('000')
        # global token
        # url = 'http://inner4.mjytech.com:22104/admin/storeroom/getInventoryMiddle'  # 确认是否可以流转
        # params = {'taskId': task_id, 'taskFlow': 5}
        # headers = {
        #     'token': f'{token}',
        #     'Content-Type': 'application/json'
        # }
        # if token:
        #     response = requests.get(url, params, headers=headers)
        #     if response.status_code == 200:
        #         data = response.json()
        #         dataJson = data['ifFlow']
        #         if dataJson == True:
        #             self.selectPopup(task_id)
        #         else:
        #             print('任务不可流转')
        #
        #         print('000')
        #     else:
        #         print(f"请求失败，状态码: {response.status_code}")

    def selectPopup(self, task_id):
        # 创建弹窗
        popup = QDialog(self)
        popup.setWindowTitle("选择窗口")
        popup.setGeometry(100*self.width_scale, 100*self.height_scale, 400*self.width_scale, 300*self.height_scale)  # 设置弹窗大小

        layout = QVBoxLayout()

        # 人物下拉选择器
        label1 = QLabel("选择人物:")
        layout.addWidget(label1)

        self.person_combobox = QComboBox()
        people = self.get_people_list()

        # 添加 realName 作为下拉选项
        self.person_combobox.addItems([person['realName'] for person in people])
        layout.addWidget(self.person_combobox)

        # 日历选择器
        label2 = QLabel("选择日期:")
        layout.addWidget(label2)

        self.calendar = QCalendarWidget()
        layout.addWidget(self.calendar)

        # 确认按钮
        confirm_button = QPushButton("确认")
        confirm_button.clicked.connect(lambda: self.confirm_selection(task_id, people))
        layout.addWidget(confirm_button)

        popup.setLayout(layout)
        popup.exec()  # 显示弹窗

    # def get_people_list(self):
    #     global token
    #     url = "http://inner4.mjytech.com:22104/sys/user/list"  # 人物列表
    #     headers = {
    #         'token': token,
    #         'Content-Type': 'application/json'
    #     }
    #     people = []
    #
    #     if token:
    #         response = requests.get(url, headers=headers)
    #         if response.status_code == 200:
    #             data = response.json()
    #             dataJson = data['userList']
    #             textCode = data['code']
    #             if textCode == 0 or textCode == 200:
    #                 # 返回包含realName和userId的字典列表
    #                 people = [{'realName': person['realName'], 'userId': person['userId']} for person in dataJson]
    #             else:
    #                 print("连接失败")
    #         else:
    #             print(f"请求失败，状态码: {response.status_code}")
    #
    #     return people

    def confirm_selection(self, task_id, people):
        print('000')
        # selected_person_name = self.person_combobox.currentText()  # 获取选择的人名
        # selected_date = self.calendar.selectedDate().toString("yyyy-MM-dd")  # 获取选择的日期
        #
        # # 根据选中的 realName 查找对应的 userId
        # selected_user = next((person for person in people if person['realName'] == selected_person_name), None)
        #
        # # 检查是否找到对应的 userId
        # if selected_user:
        #     selected_user_id = selected_user['userId']  # 获取选择的用户ID
        # else:
        #     selected_user_id = None  # 未找到匹配的用户ID
        #
        # global token
        # url = "http://inner4.mjytech.com:22104/admin/task/taskFlow"  # 熟豆入仓
        # payload = json.dumps({
        #     "id": task_id,
        #     "managerId": selected_user_id,
        #     "taskEndTime": selected_date
        # })
        # headers = {
        #     'token': f'{token}',
        #     'Content-Type': 'application/json'
        # }
        # if token:
        #     response = requests.post(url, payload, headers=headers)
        #     if response.status_code == 200:
        #         dataJson = response.json()
        #         textCode = dataJson['code']
        #         if textCode == 0 or textCode == 200:
        #             print('连接成功')
        #             self.addWordLog(task_id)
        #         else:
        #             print('连接失败')
        #     else:
        #         print('连接失败')

        # popup.accept()  # 关闭弹窗

    def addWordLog(self, task_id):
        print('000')
        # global token
        # url = "http://inner4.mjytech.com:22104/admin/task/addWordLog"  # 添加工作日志
        # payload = json.dumps({
        #     "id": task_id,
        #     "workLog": "这批烘焙任务已完成"
        # })
        # headers = {
        #     'token': f'{token}',
        #     'Content-Type': 'application/json'
        # }
        # if token:
        #     response = requests.post(url, payload, headers=headers)
        #     if response.status_code == 200:
        #         dataJson = response.json()
        #         textCode = dataJson['code']
        #         if textCode == 0 or textCode == 200:
        #             print('连接成功')
        #         else:
        #             print('连接失败')
        #     else:
        #         print('连接失败')



    def historyClicked(self):
        global token
        # 工作台显示
        self.zuoyePixmap = QIcon(self.normalized_path + '/includes/Icons/general/zuoye.png')
        self.zuoyeLabel.setIcon(self.zuoyePixmap)
        self.shebeiLabel.setVisible(False)
        self.xinghaoLabel.setVisible(False)
        self.statusLabel.setVisible(False)
        self.ai_widget.setVisible(False)

        # 流转显示
        # self.lzPixmap = QIcon(self.normalized_path + '/includes/Icons/general/zuoye.png')
        # self.lzLabel.setIcon(self.lzPixmap)
        self.lzTabel.setVisible(False)
        self.lzScroll.setVisible(False)

        # 历史显示-烘焙记录
        self.historyLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/historyHover.png')
        self.historyLabel.setIcon(self.historyLabelPixmap)
        self.shebeiLabel2.setVisible(True)
        self.shebeiLabel2.setText("烘焙记录")
        self.todayTime.setVisible(True)
        self.historyTabel.setVisible(True)
        self.shuxian.setGeometry(2*self.width_scale, 463*self.height_scale, 3*self.width_scale, 60*self.height_scale)

        self.historyList_Json()

        # 监控情况
        self.monitorPixmap = QIcon(self.normalized_path + '/includes/Icons/general/monitor.png')
        self.monitorLabel.setIcon(self.monitorPixmap)
        self.jiankongTabel.setVisible(False)

        # 设备管理
        self.setLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/set.png')
        self.setLabel.setIcon(self.setLabelPixmap)
        self.deviceScroll.setVisible(False)
        self.deviceDetail.setVisible(False)



    def monitorClicked(self):
        # 工作台显示
        self.zuoyePixmap = QIcon(self.normalized_path + '/includes/Icons/general/zuoye.png')
        self.zuoyeLabel.setIcon(self.zuoyePixmap)
        self.shebeiLabel.setVisible(False)
        self.xinghaoLabel.setVisible(False)
        self.statusLabel.setVisible(False)
        self.ai_widget.setVisible(False)

        # 流转显示
        # self.lzPixmap = QIcon(self.normalized_path + '/includes/Icons/general/zuoye.png')
        # self.lzLabel.setIcon(self.lzPixmap)
        self.lzTabel.setVisible(False)
        self.lzScroll.setVisible(False)

        # 历史显示-烘焙记录
        self.historyLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/history.png')
        self.historyLabel.setIcon(self.historyLabelPixmap)
        self.historyTabel.setVisible(False)

        # 监控情况
        self.monitorPixmap = QIcon(self.normalized_path + '/includes/Icons/general/monitorHover.png')
        self.monitorLabel.setIcon(self.monitorPixmap)
        self.shebeiLabel2.setVisible(True)
        self.shebeiLabel2.setText("监控情况")
        self.todayTime.setVisible(True)
        self.shuxian.setGeometry(2*self.width_scale, 562*self.height_scale, 3*self.width_scale, 60*self.height_scale)
        self.jiankongTabel.setVisible(True)

        # 设备管理
        self.setLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/set.png')
        self.setLabel.setIcon(self.setLabelPixmap)
        self.deviceScroll.setVisible(False)
        self.deviceDetail.setVisible(False)

    def setLabelClicked(self):
        # 工作台显示
        self.zuoyePixmap = QIcon(self.normalized_path + '/includes/Icons/general/zuoye.png')
        self.zuoyeLabel.setIcon(self.zuoyePixmap)
        self.shebeiLabel.setVisible(False)
        self.xinghaoLabel.setVisible(False)
        self.statusLabel.setVisible(False)
        self.ai_widget.setVisible(False)

        # 流转显示
        # self.lzPixmap = QIcon(self.normalized_path + '/includes/Icons/general/zuoye.png')
        # self.lzLabel.setIcon(self.lzPixmap)
        self.lzTabel.setVisible(False)
        self.lzScroll.setVisible(False)

        # 历史显示-烘焙记录
        self.historyLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/history.png')
        self.historyLabel.setIcon(self.historyLabelPixmap)
        self.historyTabel.setVisible(False)

        # 监控情况
        self.monitorPixmap = QIcon(self.normalized_path + '/includes/Icons/general/monitor.png')
        self.monitorLabel.setIcon(self.monitorPixmap)
        self.jiankongTabel.setVisible(False)

        # 设备管理
        self.setLabelPixmap = QIcon(self.normalized_path + '/includes/Icons/general/setHover.png')
        self.setLabel.setIcon(self.setLabelPixmap)
        self.shebeiLabel2.setVisible(True)
        self.shebeiLabel2.setText("设备管理")
        self.todayTime.setVisible(True)
        self.deviceScroll.setVisible(True)
        self.shuxian.setGeometry(2*self.width_scale, 674*self.height_scale, 3*self.width_scale, 60*self.height_scale)
        self.deviceDetail.setVisible(False)

        self.setMachinesList()

    def setMachinesList(self):
        """读取 localJson/Machines 下所有文件夹中的 .aset 文件，并显示到界面上"""
        # 清空网格布局
        while self.deviceGridLayout.count():
            child = self.deviceGridLayout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        # 本地文件夹路径
        local_folder = "localJson/Machines"
        if not os.path.exists(local_folder):
            print(f"文件夹 {local_folder} 不存在")
            return

        # 获取所有文件夹
        subfolders = [f.path for f in os.scandir(local_folder) if f.is_dir()]

        # 初始化文件列表
        aset_files = []

        # 遍历每个文件夹，收集其中的 .aset 文件
        for folder in subfolders:
            files = [os.path.join(folder, f) for f in os.listdir(folder) if f.endswith('.aset')]
            aset_files.extend(files)

        num_columns = 4  # 每行最多 4 个元素
        spacing = 34 * self.height_scale  # 左右间距

        # 遍历 .aset 文件并添加到网格布局中
        for index, filepath in enumerate(aset_files):
            # 去掉路径和 .aset 后缀
            file_title = os.path.splitext(os.path.basename(filepath))[0]

            # 计算行列
            row = index // num_columns
            col = index % num_columns

            # 创建设备按钮
            backlabel = QPushButton()
            backlabel.setStyleSheet(
                f'border: 1px solid #DEEEFE; border-radius: {25*self.height_scale}px; background-color: #f5f8fc;'
            )
            backlabel.setFixedSize(372* self.width_scale, 380* self.height_scale)

            # 解析配置文件
            config = configparser.ConfigParser()
            config.read(filepath, encoding="utf-8")

            # 提取所需参数
            roastertype_setup = config.get("General", "roastertype_setup", fallback="N/A")
            roastersize_setup_default = config.get("General", "roastersize_setup_default", fallback="N/A")
            host = config.get("Modbus", "host", fallback="N/A")
            set_host = config.get("OtherSettings", "setHost", fallback=host)  # 优先显示 setHost
            # img_path = config.get("OtherSettings", "setImg", fallback=None)  # 获取图片路径
            setJX = config.get("OtherSettings", "setJX", fallback=None)  # 获取机型信息

            # backlabel.setText(file_title)
            backlabel.clicked.connect(lambda _, fname=filepath, jx=setJX: self.showMachinesDetails(fname, jx))

            # 设备图片 QLabel
            shebeiImg = QLabel(backlabel)
            shebeiImg.setGeometry(142 * self.width_scale, 59 * self.height_scale,
                                  90 * self.width_scale, 90 * self.height_scale)
            shebeiImg.setStyleSheet(
                f"border: 1px solid #DEEEFE; border-radius: {15*self.height_scale}px; background-color: #f5f8fc;"
            )
            shebeiImg.setScaledContents(True)
            img_path = self.normalized_path + '/includes/Icons/general/sbtx.png'
            if img_path and os.path.exists(img_path):  # 如果图片路径有效
                original_pixmap = QPixmap(img_path)
                rounded_radius = 15* self.width_scale  # 圆角半径
                rounded_pixmap = self.setRoundedPixmap(original_pixmap, rounded_radius)
                shebeiImg.setPixmap(rounded_pixmap)
            else:  # 如果图片无效，显示默认文本
                shebeiImg.setText("Image not found")
                shebeiImg.setAlignment(Qt.AlignmentFlag.AlignCenter)

            # 设备名称
            self.rwmcTitle = QLabel(backlabel)
            self.rwmcTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
            self.rwmcTitle.setText(file_title)
            self.rwmcTitle.setGeometry(32 * self.width_scale, 214 * self.height_scale,
                                       300 * self.width_scale, 34 * self.height_scale)
            self.rwmcTitle.setStyleSheet(
                "color: #222222;background-color: transparent; border: none; font-size: 16px"
            )
            rwmcTitlefont = QFont(self.font_family3, 18 * self.width_scale)
            self.rwmcTitle.setFont(rwmcTitlefont)

            # 设备机型
            self.yxjTitle = QLabel(backlabel)
            self.yxjTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
            self.yxjTitle.setText(
                f"<span style='color: #B2B1B1;'>机型: </span>{setJX}")
            self.yxjTitle.setGeometry(32 * self.width_scale, 269 * self.height_scale,
                                      300 * self.width_scale, 34 * self.height_scale)
            self.yxjTitle.setStyleSheet(
                "color: #222222;background-color: transparent; border: none; font-size: 16px"
            )
            cgjzTitlefont = QFont(self.font_family4, 14 * self.width_scale)
            self.yxjTitle.setFont(cgjzTitlefont)

            # 设备地址
            self.yxjTitle = QLabel(backlabel)
            self.yxjTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
            self.yxjTitle.setText(
                f"<span style='color: #B2B1B1;'>设备地址: </span>{set_host}")
            self.yxjTitle.setGeometry(32 * self.width_scale, 306 * self.height_scale,
                                      300 * self.width_scale, 34 * self.height_scale)
            self.yxjTitle.setStyleSheet(
                "color: #222222;background-color: transparent; border: none; font-size: 16px"
            )
            self.yxjTitle.setFont(cgjzTitlefont)

            # 添加到布局并设置间距
            self.deviceGridLayout.addWidget(backlabel, row, col,
                                            alignment=Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)

        # 计算 "添加" 按钮位置
        add_index = len(aset_files)
        add_row = add_index // num_columns
        add_col = add_index % num_columns

        # 创建 "添加" 按钮
        add_button = QPushButton()
        add_button.setFixedSize(373 * self.width_scale, 380 * self.height_scale)
        add_button.setStyleSheet(f'''
            QPushButton {{
                border: 1px solid #DEEEFE; 
                border-radius: {25 * self.height_scale}px; 
                background-color: #f5f8fc;
            }}
        ''')

        # 设置图标和图标大小
        icon = QIcon(f"{self.normalized_path}/includes/Icons/general/addProject.png")
        add_button.setIcon(icon)
        add_button.setIconSize(QSize(100 * self.height_scale, 100 * self.height_scale))

        # 连接点击事件
        add_button.clicked.connect(self.addNewMachines)
        # add_button.setIcon(QIcon(self.normalized_path + '/includes/Icons/general/addProject.png'))  # 设置图标

        # 添加 "添加" 按钮到布局
        self.deviceGridLayout.addWidget(add_button, add_row, add_col,
                                        alignment=Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)

        # 设置布局的水平和垂直间距
        self.deviceGridLayout.setHorizontalSpacing(spacing)
        self.deviceGridLayout.setVerticalSpacing(spacing)

        self.deviceTabel.setVisible(True)

        # global token
        # url = 'http://inner4.mjytech.com:22104/admin/device/selectBakingDeviceList'  # 获取设备列表
        # headers = {
        #     'token': f'{token}',
        #     'Content-Type': 'application/json'
        # }
        # if token:
        #     response = requests.get(url, headers=headers)
        #     if response.status_code == 200:
        #         data2 = response.json()  # 解析返回的 JSON 数据
        #         dataJson = data2['deviceList']
        #         textCode = data2['code']
        #         if textCode == 0 or textCode == 200:
        #             # 确定行数：每行最多显示 4 个任务，向上取整计算需要多少行
        #             num_items = len(dataJson)
        #             num_columns = 4  # 每行 4 列
        #             num_rows = (num_items + num_columns - 1) // num_columns  # 向上取整计算行数
        #
        #             # 遍历 dataJson 中的任务并添加到网格布局中
        #             for index, task in enumerate(dataJson):
        #                 # 计算当前项的行和列
        #                 row = index // num_columns  # 当前项所在的行数
        #                 col = index % num_columns  # 当前项所在的列数
        #
        #                 backlabel = QPushButton()
        #                 # backlabel.setAlignment(Qt.AlignmentFlag.AlignCenter)  # 文字居中
        #                 backlabel.setStyleSheet(
        #                     'border: 1px solid #70D0A3; border-radius: 25px; background-color: #DEEEFE; ')
        #
        #                 # 设置 QLabel 的固定大小为 373x380
        #                 backlabel.setFixedSize(373, 380)
        #
        #                 # 创建任务名称 QLabel
        #                 self.shebeiImg = QLabel(backlabel)
        #                 self.shebeiImg.setGeometry(142 * self.width_scale, 59 * self.height_scale,
        #                                            90 * self.width_scale, 90 * self.height_scale)
        #                 # self.shebeiImgPixmap = QPixmap(task.get('deviceImg'))
        #                 # self.shebeiImg.setPixmap(self.shebeiImgPixmap)
        #                 self.shebeiImg.setScaledContents(True)
        #                 device_img_url = task.get('deviceImg')
        #                 if device_img_url:
        #                     # Make the network request
        #                     request = QNetworkRequest(QUrl(device_img_url))
        #                     reply = self.network_manager.get(request)
        #                     reply.finished.connect(
        #                         lambda r=reply, img_label=self.shebeiImg: self.process_reply(r, img_label))
        #                 else:
        #                     self.shebeiImg.setText("Image URL not found")
        #
        #                 self.rwmcTitle = QLabel(backlabel)
        #                 self.rwmcTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        #                 self.rwmcTitle.setText(task.get('deviceTypeName'))
        #                 self.rwmcTitle.setGeometry(32 * self.width_scale, 214 * self.height_scale,
        #                                            300 * self.width_scale, 34 * self.height_scale)
        #                 self.rwmcTitle.setStyleSheet(
        #                     "color: #222222;background-color: transparent; border: none; font-size: 16px"
        #                 )
        #                 rwmcTitlefont = QFont(self.font_family3, 16 * self.width_scale)
        #                 self.rwmcTitle.setFont(rwmcTitlefont)
        #
        #                 self.cgjzTitle = QLabel(backlabel)
        #                 self.cgjzTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        #                 self.cgjzTitle.setText(
        #                     f"<span style='color: #B2B1B1;'>设备序列号</span>: {task.get('deviceModel', '未知')}")
        #                 self.cgjzTitle.setGeometry(32 * self.width_scale, 259 * self.height_scale,
        #                                            300 * self.width_scale, 34 * self.height_scale)
        #                 self.cgjzTitle.setStyleSheet(
        #                     "color: #222222;background-color: transparent; border: none; font-size: 16px"
        #                 )
        #                 cgjzTitlefont = QFont(self.font_family4, 14 * self.width_scale)
        #                 self.cgjzTitle.setFont(cgjzTitlefont)
        #
        #                 self.yxjTitle = QLabel(backlabel)
        #                 self.yxjTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        #                 self.yxjTitle.setText(
        #                     f"<span style='color: #B2B1B1;'>机型</span>: {task.get('gasType', '未知')}")
        #                 self.yxjTitle.setGeometry(32 * self.width_scale, 296 * self.height_scale,
        #                                           300 * self.width_scale, 34 * self.height_scale)
        #                 self.yxjTitle.setStyleSheet(
        #                     "color: #222222;background-color: transparent; border: none; font-size: 16px"
        #                 )
        #                 self.yxjTitle.setFont(cgjzTitlefont)
        #
        #                 self.yxjTitle = QLabel(backlabel)
        #                 self.yxjTitle.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignLeft)
        #                 self.yxjTitle.setText(
        #                     f"<span style='color: #B2B1B1;'>设备地址</span>: {task.get('usePosition', '未知')}")
        #                 self.yxjTitle.setGeometry(32 * self.width_scale, 331 * self.height_scale,
        #                                           300 * self.width_scale, 34 * self.height_scale)
        #                 self.yxjTitle.setStyleSheet(
        #                     "color: #222222;background-color: transparent; border: none; font-size: 16px"
        #                 )
        #                 self.yxjTitle.setFont(cgjzTitlefont)
        #
        #                 # 将任务 backlabel 添加到布局中
        #                 self.deviceGridLayout.addWidget(backlabel, row, col)
        #                 self.deviceGridLayout.setAlignment(backlabel, Qt.AlignmentFlag.AlignTop)
        #         else:
        #             print("连接失败")

    def setRoundedPixmap(self, pixmap: QPixmap, radius: int) -> QPixmap:
        """为 QPixmap 添加圆角效果"""
        # 创建与 pixmap 尺寸相同的 QPixmap
        rounded = QPixmap(pixmap.size())
        rounded.fill(Qt.GlobalColor.transparent)  # 设置为透明背景

        # 使用 QPainter 绘制圆角
        painter = QPainter(rounded)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)
        brush = QBrush(pixmap)
        painter.setBrush(brush)
        painter.setPen(Qt.PenStyle.NoPen)

        rect = QRectF(0, 0, pixmap.width(), pixmap.height())
        painter.drawRoundedRect(rect, radius, radius)
        painter.end()

        return rounded

    def load_files(self, folder_path):
        if os.path.exists(folder_path):
            dir = QDir(folder_path)
            dir.setFilter(QDir.Filter.Dirs | QDir.Filter.NoDotAndDotDot)  # 只获取子文件夹，排除 . 和 ..
            subfolders = dir.entryList()  # 获取所有子文件夹

            # 将所有文件夹添加到 QComboBox 中
            self.deviceNameEdit.addItems(subfolders)
        else:
            print(f"文件夹 {folder_path} 不存在！")

    def load_files_from_folder(self):
        """当选择文件夹时，加载该文件夹中的文件到 deviceModelEdit 下拉框，去掉文件后缀"""
        folder_path = self.deviceNameEdit.currentText()
        if folder_path:  # 如果选择了文件夹
            folder_full_path = os.path.join("Machines", folder_path)
            self.deviceModelEdit.clear()  # 清空现有项

            # 获取文件夹中的文件
            if os.path.exists(folder_full_path):
                files = [f for f in os.listdir(folder_full_path) if os.path.isfile(os.path.join(folder_full_path, f))]

                # 去掉文件的后缀，并将文件名添加到下拉框
                file_names_without_extension = [os.path.splitext(f)[0] for f in files]
                self.deviceModelEdit.addItems(file_names_without_extension)  # 只显示文件名部分，不显示后缀

                self.load_modbus_host()  # 加载 Modbus host 配置
        else:
            self.deviceModelEdit.clear()

    def load_modbus_host(self):
        """从选择的文件中提取 Modbus 配置中的 host 字段"""
        selected_file = self.deviceModelEdit.currentText()
        folder_path = self.deviceNameEdit.currentText()

        if selected_file and folder_path:
            file_path = os.path.join("Machines", folder_path, selected_file+'.aset')

            # 检查文件是否存在
            if not os.path.exists(file_path):
                print(f"文件 {file_path} 不存在！")
                self.deviceAddressEdit.setText("未找到文件")
                return

            # 读取文件内容并提取 Modbus 配置中的 host 字段
            with open(file_path, "r") as file:
                content = file.read()

            # 使用正则表达式提取 host 字段
            match = re.search(r"host\s*=\s*([\d\.]+)", content)
            if match:
                host = match.group(1)  # 获取 host 地址
                self.deviceAddressEdit.setText(host)  # 更新 deviceAddressEdit
            else:
                self.deviceAddressEdit.setText("未找到 host 配置")

    def addNewMachines(self):
        """打开文件选择器并复制 .aset 文件到目标路径"""
        # 打开文件选择器
        self.deviceDetail.setVisible(True)
        self.deviceNameEdit.setVisible(True)
        self.deviceModelEdit.setVisible(True)
        self.deviceNameLineEdit.setVisible(False)
        self.deviceModelLineEdit.setVisible(False)

        folder_path = "localJson/Machines"  # 假设这个是你需要查看的路径

        # 获取文件夹中的文件数量
        # if os.path.exists(folder_path):
        #     # 使用 QDir 获取文件数量
        #     dir = QDir(folder_path)
        #     dir.setFilter(QDir.Filter.Files)  # 获取文件而不是文件夹
        #     files = dir.entryList()  # 获取所有文件列表
        #
        #     # 更新 QLineEdit 显示文件数量 + 1
        #     file_count = len(files) + 1  # 加 1
        #     self.deviceXLHEdit.setText(str(file_count))
        # else:
        #     print(f"文件夹 {folder_path} 不存在！")
        #     self.deviceXLHEdit.setText("文件夹不存在")


        # self.default_path = "../includes/Machines"  # 默认路径
        # self.target_path = "localJson/Machines"  # 目标路径
        #
        # file_dialog = QFileDialog()
        # file_dialog.setWindowTitle("选择机器文件")
        # file_dialog.setNameFilter("ASET files (*.aset)")  # 仅显示 .aset 文件
        # file_dialog.setDirectory(self.default_path)  # 设置默认路径
        #
        # if file_dialog.exec():  # 检查用户是否选择了文件
        #     selected_files = file_dialog.selectedFiles()
        #     if selected_files:
        #         src_file = selected_files[0]  # 获取选择的文件路径
        #
        #         # 检查目标路径是否存在，不存在则创建
        #         os.makedirs(self.target_path, exist_ok=True)
        #
        #         # 目标文件路径
        #         target_file = os.path.join(self.target_path, os.path.basename(src_file))
        #
        #         try:
        #             # 复制文件到目标路径
        #             shutil.copy2(src_file, target_file)
        #             self.setMachinesList()
        #             QMessageBox.information(None, "成功", f"文件已成功复制到: {self.target_path}")
        #         except Exception as e:
        #             QMessageBox.critical(None, "错误", f"文件复制失败: {str(e)}")
        #     else:
        #         QMessageBox.warning(None, "未选择文件", "请先选择一个 .aset 文件。")
        # else:
        #     QMessageBox.information(None, "操作取消", "您未选择任何文件。")

    def showMachinesDetails(self, filename, setJX):
        """
        显示设备详情，并根据设备文件的内容填充表单。
        """
        self.deviceDetail.setVisible(True)

        config = configparser.ConfigParser()
        config.read(filename, encoding="utf-8")

        file_with_extension = os.path.basename(filename)

        # 去掉后缀，得到纯文件名
        file_name = os.path.splitext(file_with_extension)[0]

        # 提取所需参数
        file_title = os.path.splitext(os.path.basename(filename))[0]
        roastertype_setup = config.get("General", "roastertype_setup", fallback="N/A")
        idNum = config.get("Device", "id", fallback="N/A")
        roastersize_setup_default = config.get("General", "roastersize_setup_default", fallback="N/A")
        host = config.get("Modbus", "host", fallback="N/A")
        set_host = config.get("OtherSettings", "setHost", fallback=host)  # 优先显示 setHost
        heating = config.get("OtherSettings", "setHeating", fallback=None)
        img_path = config.get("OtherSettings", "setImg",
                              fallback=self.normalized_path + '/includes/Icons/general/sbtx.png')
        sbxl = config.get("OtherSettings", "setSBXL", fallback=None)
        sbdz = config.get("OtherSettings", "setDZ", fallback=None)

        # 更新 UI 元素
        self.deviceNameLineEdit.setVisible(True)
        self.deviceModelLineEdit.setVisible(True)

        self.deviceNameEdit.setVisible(False)
        self.deviceNameLineEdit.setText(setJX)
        self.deviceModelEdit.setVisible(False)
        self.deviceModelLineEdit.setText(file_name)
        self.deviceHeating.setCurrentText(heating)

        self.deviceXLHEdit.setText(sbxl)
        self.deviceDZEdit.setText(sbdz)
        # self.deviceXLHEdit.setReadOnly(True)
        self.deviceAddressEdit.setText(set_host)

        # 设置图片
        if img_path and os.path.exists(img_path):  # 检查图片路径是否有效
            pixmap = QPixmap(img_path)
            scaled_pixmap = pixmap.scaled(self.deviceDetailTouxiang.size(), Qt.AspectRatioMode.KeepAspectRatio)
            self.deviceDetailTouxiang.setPixmap(scaled_pixmap)
            self.deviceDetailTouxiang.setStyleSheet(
                f"border-radius: {25 * self.height_scale}px; border: 1px solid #DEE0E3;"
            )
        else:
            # 设置默认图片
            self.deviceDetailTouxiang.setPixmap(QPixmap())
            self.deviceDetailTouxiang.setStyleSheet(
                f'border-radius: {25 * self.height_scale}px;background-color: #DEEEFE; border: 1px solid #DEE0E3;'
            )

        # 绑定删除设备按钮
        self.d_deviceBtn.clicked.connect(lambda _, fname=filename: self.onDelectMachinesClick(fname))

    def openFileDialog(self, event):
        """ 打开文件对话框选择图片 """
        # 使用文件对话框打开文件，并设置文件过滤器
        filePath, _ = QFileDialog.getOpenFileName(self, "选择头像", "",
                                                  "图片文件 (*.png *.jpg *.bmp);;所有文件 (*)",
                                                  options=QFileDialog.Option.DontUseNativeDialog)

        if filePath:
            # 处理选择的图片
            self.selected_image_path = filePath
            # 调用 updateProfilePicture 函数来处理图片复制和显示
            self.updateProfilePicture(filePath)

    def updateProfilePicture(self, file_path):
        """ 更新头像显示并将图片路径保存到设备配置中 """
        # 将图片复制到 localJson\MachinesImg 路径下
        target_dir = "localJson/MachinesImg"
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)

        # 复制图片到目标路径
        file_name = os.path.basename(file_path)
        target_path = os.path.join(target_dir, file_name)
        shutil.copy(file_path, target_path)

        # 更新显示图片
        pixmap = QPixmap(target_path)
        self.deviceDetailTouxiang.setPixmap(
            pixmap.scaled(self.deviceDetailTouxiang.size(), Qt.AspectRatioMode.KeepAspectRatio))

        # 保存图片路径，等待用户点击确定时写入文件
        self.selected_image_path = target_path

    def updateAsetFile(self):
        """
        点击按钮时，根据是否存在同名文件决定更新或新建 .aset 文件，并在源文件基础上添加新字段。
        """
        if self.deviceNameEdit.isVisible():
            folder_name = self.deviceNameEdit.currentText()
            file_name = self.deviceModelEdit.currentText()
        else:
            folder_name = self.deviceNameLineEdit.text()
            file_name = self.deviceModelLineEdit.text()

        if not folder_name:
            QMessageBox.warning(self, "提示", "未选择文件夹！")
            return

        # 拼接目标文件夹路径和 .aset 文件路径
        target_folder_path = os.path.join("localJson/Machines", folder_name)
        aset_file_path = os.path.join(target_folder_path, f"{file_name}.aset")

        # 配置读取对象
        config = configparser.ConfigParser()

        # 确保目标文件夹存在
        if not os.path.exists(target_folder_path):
            os.makedirs(target_folder_path)  # 创建文件夹

        # 获取源文件路径
        source_file_path = os.path.join("Machines", folder_name, f"{file_name}.aset")

        # 检查是否为查看详情还是新建文件
        if os.path.exists(aset_file_path):
            # 查看详情：直接更新现有文件
            config.read(aset_file_path, encoding="utf-8")
            print(f"更新文件：{aset_file_path}")
        else:
            # 新建文件：复制源文件内容（如果存在），否则创建新文件
            if os.path.exists(source_file_path):
                # 复制源文件到目标位置
                shutil.copy(source_file_path, aset_file_path)
                print(f"文件 {source_file_path} 成功复制到 {aset_file_path}！")
                config.read(aset_file_path, encoding="utf-8")
            else:
                print(f"源文件 {source_file_path} 不存在，将创建新的 .aset 文件。")
                config.add_section("OtherSettings")

        # 确保 "OtherSettings" 部分存在
        if not config.has_section("OtherSettings"):
            config.add_section("OtherSettings")

        # 更新 setImg 字段（假设图片路径为 selected_image_path）
        if hasattr(self, 'selected_image_path'):
            config.set('OtherSettings', 'setImg', self.selected_image_path)

        # 更新 setHost 字段（假设设备地址来自 deviceAddressEdit）
        host = self.deviceAddressEdit.text()  # 获取设备地址
        config.set('OtherSettings', 'setHost', host)

        # 更新 setjx 字段（设为文件夹名称）
        config.set('OtherSettings', 'setjx', folder_name)

        # 更新加热类型字段
        config.set('OtherSettings', 'setHeating', self.deviceHeating.currentText())
        config.set('OtherSettings', 'setHeatingType', str(self.deviceHeating.currentIndex()))
        config.set('OtherSettings', 'setSBXL', self.deviceXLHEdit.text())
        config.set('OtherSettings', 'setDZ', self.deviceDZEdit.text())

        # 保存配置文件
        with open(aset_file_path, 'w', encoding="utf-8") as configfile:
            config.write(configfile)

        print(f"配置文件更新成功：{aset_file_path}")

        # 隐藏设备详情，并刷新设备列表
        self.deviceDetail.setVisible(False)
        self.setMachinesList()
        # self.deviceHeating.clear()
        # self.deviceNameEdit.clear()
        # self.deviceModelEdit.clear()

    def onConfirmClick(self):
        """ 点击确定按钮时，执行写入操作 """
        self.updateAsetFile()  # 更新 .aset 文件

    def onDelectMachinesClick(self,fname):
        # 获取当前设备的名称
        # device_name = self.deviceNameEdit.text()
        # file_name = self.deviceModelEdit.currentText()
        # folder = self.deviceNameLineEdit.text()
        #
        # # 构造 .aset 文件路径
        # aset_file_path = f"localJson/Machines/{folder}/{file_name}.aset"
        #
        # # 打印文件路径（可选，调试用）
        # print(f"Deleting file: {aset_file_path}")

        # 检查文件是否存在
        if os.path.exists(fname):
            # 删除文件
            os.remove(fname)
            self.deviceDetail.setVisible(False)
            self.setMachinesList()
            # self.deviceHeating.clear()
            # self.deviceNameEdit.clear()
            # self.deviceModelEdit.clear()
            print(f"File {fname} deleted successfully.")
        else:
            print(f"File {fname} not found.")

    def fhMachinesClick(self):
        self.deviceDetail.setVisible(False)
        self.setMachinesList()
        # self.deviceHeating.clear()
        # self.deviceNameEdit.clear()
        # self.deviceModelEdit.clear()


    def process_reply(self, reply, img_label):
        # 检查是否有错误
        if reply.error() != QNetworkReply.NetworkError.NoError:  # 改为使用 NetworkError.NoError
            img_label.setText("Failed to load image.")
            print(f"Error: {reply.errorString()}")
        else:
            pixmap = QPixmap()
            image_data = reply.readAll()
            if pixmap.loadFromData(image_data):
                img_label.setPixmap(pixmap)
            else:
                img_label.setText("Failed to load image data.")

        reply.deleteLater()

    def closeClicked(self):
        self.closeBack.setVisible(True)

    def closeHistoryClick(self):
        self.historyInfo.setVisible(False)
        self.scroll_area.setVisible(False)

    def closeAnalyseClick(self):
        self.historyAnalyse.setVisible(False)
        self.scroll_area.setVisible(False)

    def closeEXE(self):
        self.destroy()  # 窗口关闭销毁
        sys.exit(0)  # 系统结束推出

    def controlClose(self):
        self.closeBack.setVisible(False)

    def device_issueClick(self):
        if self.sbsfycBtn.isChecked():
            self.huakuaiRect.setGeometry(4*self.width_scale, 4*self.height_scale, 37*self.width_scale, 22*self.height_scale)
            self.shiTxt.setStyleSheet("background-color: transparent; border:none;color: #393939; ")  # 是
            self.fouTxt.setStyleSheet("background-color: transparent; border:none;color: #ffffff; ")
        else:
            self.huakuaiRect.setGeometry(39*self.width_scale, 4*self.height_scale, 37*self.width_scale, 22*self.height_scale)
            self.shiTxt.setStyleSheet("background-color: transparent; border:none;color: #ffffff; ")
            self.fouTxt.setStyleSheet("background-color: transparent; border:none;color: #393939; ")  # 否


    def toggle_updateCloud(self):
        print('000')
        # first_Value = self.id_value[0]
        # task_id = first_Value[4]
        # url = 'http://inner4.mjytech.com:22104/tablet/interaction/saveBakingCurveMsg'  # 保存烘焙曲线
        # # baking_batch_1, task_id_1 = self.chucangValue[0]
        # payload = json.dumps({
        #     "agtronValue": self.agtronNum.text(),
        #     "bakingBatch": first_Value[2],
        #     "bakingScore": 3,
        #     "desncription": self.qkfhContent.toPlainText(),
        #     "defectiveRate": self.xclContent.text(),  #瑕疵率
        #     "dehydrationRate": self.tslContent.text(),  #烘焙损失率
        #     "numberOfBeans": self.slContent.text(),  #熟豆数量
        #     "jsonMessage": {"totaltime": "930",
        #                     "CHARGE_BT": "167.5",
        #                     "TP_BT": "80",
        #                     "TP_time": "90",
        #                     "Maillard": "135",
        #                     "Maillard_time": "320",
        #                     "FCs_BT": "162",
        #                     "FCs_time": "345",
        #                     "SCs_BT": "185",
        #                     "SCs_time": "555",
        #                     "DROP_BT": "122",
        #                     "finishphasetime": self.computedData['AUCbegin'], #self.computedData['AUCbegin'],
        #                     "DTR": "22",
        #                     "target_temperature": [135, 165, 182, 192, 198, 205],
        #                     "target_values": [30, 35, 40, 90, 80, 65],
        #                     "actual_temperature": [135, 166, 182, 195, 200, 205],
        #                     "actual_values": [35, 40, 40, 90, 50, 65],
        #                     # "alogJson": self.getProfile()
        #                     "alogJson": {'recording_version': '1', 'recording_revision': 'unknown', 'recording_build': 'unknown', 'version': '2.10.4', 'revision': '', 'build': '0', 'artisan_os': 'Windows', 'artisan_os_version': '10', 'artisan_os_arch': 'AMD64', 'mode': 'F', 'viewerMode': False, 'timeindex': [29, 204, 390, 0, 0, 0, 492, 0], 'flavors': [5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 'flavorlabels': ['Acidity', 'Aftertaste', 'Clean Cup', 'Head', 'Fragrance', 'Sweetness', 'Aroma', 'Balance', 'Body'], 'flavorstartangle': 90, 'flavoraspect': 1.0, 'title': 'Roaster Scope', 'locale': 'zh_CN', 'beans': 'brazil natural espresso', 'weight': [0.0, 0.0, 'g'], 'volume': [0.0, 0.0, 'l'], 'density': [0.0, 'g', 1.0, 'l'], 'density_roasted': [0.0, 'g', 1.0, 'l'], 'roastertype': '', 'roastersize': 0.0, 'roasterheating': 0, 'machinesetup': 'WxA', 'operator': '', 'organization': '', 'drumspeed': '', 'heavyFC': False, 'lowFC': False, 'lightCut': False, 'darkCut': False, 'drops': False, 'oily': False, 'uneven': False, 'tipping': False, 'scorching': False, 'divots': False, 'whole_color': 0, 'ground_color': 90, 'color_system': '', 'volumeCalcWeightIn': '', 'volumeCalcWeightOut': '', 'roastdate': 'Mon Nov 7 2022', 'roastisodate': '2022-11-07', 'roasttime': '01:51:25', 'roastepoch': 1667757085, 'roasttzoffset': -28800, 'roastbatchnr': 0, 'roastbatchprefix': '', 'roastbatchpos': 10, 'roastUUID': 'b8e455502f2d4e2e91d5d001f65c814c', 'beansize_min': '0', 'beansize_max': '0', 'specialevents': [5, 10, 28, 31, 31, 31, 33, 231, 279, 318, 373, 426, 454, 470, 480, 491], 'specialeventstype': [3, 3, 3, 0, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], 'specialeventsvalue': [1.8, 1.7, 4.0, 5.5, 5.5, 4.0, 4.1, 3.8, 3.5, 3.2, 3.1, 2.8, 2.5, 2.2, 1.9, 1.0], 'specialeventsStrings': ['400%', '350%', '1500%', '', '', '', '1550%', '1400%', '1250%', '1100%', '1050%', '900%', '750%', '600%', '450%', '0%'], 'default_etypes': [True, True, True, True, True], 'etypes': ['Air', 'Drum', 'Damper', 'Burner', '--'], 'roastingnotes': '', 'cuppingnotes': '', 'timex': [0.3926663, 1.8887697, 3.3887442, 4.8887447, 6.3891795, 7.8887662, 9.3888249, 10.8887476, 12.3891401, 13.888761, 15.3887637, 16.8887517, 18.3890881, 19.8887577, 21.3887538, 22.8887627, 24.3887526, 25.8887742, 27.3887567, 28.888747, 30.3887896, 31.8887719, 33.3887541, 34.8887462, 36.3887423, 37.8887819, 39.3887543, 40.8887601, 42.3891647, 43.8887336, 45.3887548, 46.8887473, 48.3887592, 49.8887549, 51.3887618, 52.888756, 54.3887506, 55.8887167, 57.3888134, 58.8888078, 60.3888126, 61.8887667, 63.3887715, 64.8887685, 66.3887901, 67.8887735, 69.3887726, 70.8887708, 72.3887716, 73.8887681, 75.3887906, 76.8887661, 78.3887705, 79.8887695, 81.3887799, 82.8887827, 84.3887683, 85.8887699, 87.3887656, 88.8887969, 90.3887666, 91.8887694, 93.388801, 94.8887557, 96.3887555, 97.8887598, 99.3887843, 100.8887644, 102.3887585, 103.8887575, 105.3887696, 106.8887602, 108.3887936, 109.8887578, 111.3887632, 112.8887705, 114.3887589, 115.8887595, 117.3887681, 118.888759, 120.3887622, 121.8887589, 123.3887567, 124.8887626, 126.388748, 127.8887581, 129.3887592, 130.8887578, 132.3887584, 133.8887576, 135.3887636, 136.888766, 138.3887586, 139.8887592, 141.3887781, 142.8887679, 144.3887605, 145.8887814, 147.3887608, 148.8887589, 150.3887561, 151.8887584, 153.3887588, 154.8887571, 156.3887735, 157.8887594, 159.3887559, 160.8887738, 162.3887579, 163.8887528, 165.3887271, 166.8887797, 168.3887585, 169.8887572, 171.3887528, 172.8887593, 174.3887606, 175.8887627, 177.3887627, 178.8887547, 180.3887569, 181.8887487, 183.3887638, 184.8887755, 186.3887706, 187.8887605, 189.3887588, 190.8887605, 192.3887599, 193.8887616, 195.3887596, 196.8887637, 198.3887606, 199.8887608, 201.3887673, 202.8887676, 204.3887634, 205.888749, 207.3887572, 208.8887584, 210.3887571, 211.8887576, 213.3887523, 214.8887707, 216.3887563, 217.8887689, 219.3887587, 220.8887495, 222.3887595, 223.8887596, 225.3887563, 226.8887695, 228.388742, 229.8887754, 231.388756, 232.8887543, 234.3887708, 235.8887571, 237.3887548, 238.8887575, 240.3887568, 241.888768, 243.3887653, 244.888786, 246.3888042, 247.8887568, 249.3887513, 250.8887592, 252.3887591, 253.8887596, 255.3887563, 256.8887572, 258.3887668, 259.8887582, 261.3887595, 262.8887582, 264.3887657, 265.8887587, 267.3887549, 268.8887567, 270.3887576, 271.8887924, 273.3887562, 274.8887583, 276.3887692, 277.88877, 279.388756, 280.8887589, 282.3887561, 283.8887592, 285.3887554, 286.8887572, 288.3887593, 289.8887643, 291.3887607, 292.8887601, 294.3887517, 295.8887673, 297.3887586, 298.8887587, 300.388758, 301.8887748, 303.3887582, 304.8887646, 306.3887643, 307.8887556, 309.3887622, 310.888756, 312.3887565, 313.8887581, 315.3887691, 316.8887703, 318.3887588, 319.8887572, 321.3887675, 322.8887598, 324.3887558, 325.8887752, 327.3887587, 328.8887593, 330.3887569, 331.8887734, 333.3887559, 334.8887637, 336.3887813, 337.8887577, 339.3887807, 340.8887664, 342.3887592, 343.8887593, 345.3887564, 346.8887563, 348.3887754, 349.8887575, 351.3887783, 352.8888306, 354.388827, 355.888788, 357.3887703, 358.8889671, 360.3887743, 361.8888032, 363.3887716, 364.8887661, 366.3887716, 367.8887678, 369.3887913, 370.8887698, 372.3887719, 373.8887728, 375.3888077, 376.8887968, 378.3887914, 379.888792, 381.3887818, 382.8887742, 384.3887967, 385.8887749, 387.3888113, 388.8887736, 390.3887723, 391.8887669, 393.3887595, 394.8887617, 396.3887613, 397.8888028, 399.388768, 400.8887597, 402.3887716, 403.8887556, 405.3887767, 406.8887601, 408.3887664, 409.8887629, 411.3887752, 412.8887705, 414.3887616, 415.8887594, 417.3887571, 418.8887573, 420.3887651, 421.8887625, 423.388759, 424.8887582, 426.3887573, 427.8887577, 429.388759, 430.88876, 432.3887642, 433.8887589, 435.3887611, 436.8887632, 438.3887785, 439.8887729, 441.3887618, 442.8887487, 444.3887603, 445.8887619, 447.3887604, 448.8887745, 450.388758, 451.8887688, 453.3887625, 454.8887595, 456.3887602, 457.8887583, 459.3887595, 460.8887611, 462.388757, 463.8887576, 465.3887596, 466.8887587, 468.3887637, 469.8887598, 471.3887571, 472.8887578, 474.3887576, 475.8887537, 477.3887536, 478.8887737, 480.3887953, 481.8887558, 483.3887607, 484.8887593, 486.3887608, 487.888771, 489.388773, 490.8887618, 492.3887542, 493.8887553, 495.3887301, 496.888767, 498.3887578, 499.8887649, 501.3887655, 502.888759, 504.3887608, 505.8887617, 507.3887625, 508.8887568, 510.3887599, 511.8887576, 513.388773, 514.888761, 516.3887563, 517.8887607, 519.3887567, 520.8887708, 522.3887546, 523.8887623, 525.3887567, 526.8887577, 528.3887578, 529.8887548, 531.38876, 532.8887608, 534.3887606, 535.8887713, 537.388756, 538.8887707, 540.3887583, 541.8887572, 543.388767, 544.8887559, 546.3887571, 547.8887696, 549.3887581, 550.8887655, 552.388757, 553.8887718, 555.3887589, 556.888766, 558.3887566, 559.8887753, 561.3887624, 562.8887616, 564.388765, 565.8887595, 567.3887594, 568.8887699, 570.3887576, 571.8887529, 573.3887599, 574.88876, 576.3887682, 577.888762, 579.3887586, 580.8887577, 582.3887637, 583.8887636, 585.3887669, 586.8887664, 588.3887583, 589.8887635, 591.3887561, 592.8887544, 594.3887466, 595.8887615, 597.3887613, 598.888759, 600.3887597, 601.888764, 603.3887601, 604.8887604, 606.3887496, 607.9188199, 609.3887631, 610.8888108, 612.3887592, 613.8887561, 615.3887554, 616.8887555, 618.3887701, 619.8887683, 621.3887595, 622.8887795, 624.388732, 625.8887608, 627.3887581, 628.8887595, 630.3887659, 631.8887564, 633.3887704, 634.8887738, 636.3887585, 637.8887666, 639.3887667, 640.8887648, 642.3887587, 643.8887633, 645.3887565, 646.8888168, 648.3888247, 649.8888247, 651.3887907, 652.8887879, 654.3887749, 655.8887654, 657.3887692, 658.88877, 660.3887747, 661.888775, 663.3887721, 664.8887683, 666.3887711, 667.8887722, 669.3887659, 670.8887698, 672.3887981, 673.8887706, 675.3887688, 676.888769, 678.38877, 679.8887709, 681.3887687, 682.8887654, 684.3887942, 685.8887631, 687.3887765, 688.8887691, 690.3887965, 691.8887602, 693.3887517, 694.8887636, 696.3887711, 697.8887591, 699.3887563, 700.888772, 702.3887738, 703.8887596, 705.3887733, 706.8887796, 708.3887597, 709.8887607, 711.3887705, 712.8887729, 714.3887635, 715.8888, 717.3887593, 718.8887597, 720.3887883, 721.8887631, 723.3887576, 724.8887625, 726.3887596, 727.8887611, 729.3887566, 730.88876, 732.3887569, 733.888758, 735.3887589, 736.8887689, 738.388773, 739.8887588, 741.3887577, 742.8887726, 744.388758, 745.888778, 747.3887587, 748.8887609, 750.3887916, 751.8888055, 753.3887601, 754.8887576, 756.3887583, 757.8887588, 759.3887609, 760.8887596, 762.3887628, 763.8887725, 765.388761, 766.8887575, 768.3887185, 769.8887907, 771.3887834, 772.888756, 774.3888115, 775.8887614, 777.3887587, 778.88876, 780.3887578, 781.8887567, 783.3887579, 784.8887619, 786.3887617, 787.88876, 789.3887597, 790.8887618, 792.3887584, 793.8887573, 795.3887605, 796.8887566, 798.3887601, 799.8887575, 801.3887595, 802.8887712, 804.3887878, 805.8887699, 807.3887593, 808.8887581, 810.3887574, 811.8887593, 813.3887586, 814.8887619], 'temp1': [399.38, 399.38, 399.38, 399.38, 399.56, 399.56, 399.56, 399.56, 399.56, 400.1, 400.64, 401.36, 402.08, 402.8, 403.16, 403.34, 403.34, 403.34, 403.34, 403.16, 402.98, 402.62, 402.44, 402.26, 402.08, 401.72, 401.54, 401.18, 401.18, 401.0, 398.84, 391.46, 382.28, 373.64, 364.64, 355.28, 350.42, 347.36, 345.02, 343.22, 341.78, 340.88, 340.16, 339.62, 339.26, 339.08, 339.08, 339.26, 339.44, 339.8, 340.16, 340.52, 341.06, 341.42, 342.14, 342.5, 343.22, 343.94, 344.66, 345.2, 345.92, 346.64, 347.36, 348.26, 348.98, 349.88, 350.6, 351.5, 352.58, 353.3, 354.2, 355.1, 355.82, 356.36, 357.08, 357.8, 358.34, 358.88, 359.6, 360.14, 360.86, 361.58, 361.94, 362.48, 363.02, 363.74, 364.28, 364.82, 365.36, 365.9, 366.62, 367.16, 367.88, 368.24, 368.96, 369.5, 370.04, 370.58, 371.3, 371.84, 372.38, 372.92, 373.64, 374.36, 374.9, 375.62, 376.34, 377.24, 377.96, 378.68, 379.4, 379.94, 380.48, 381.02, 381.56, 382.1, 382.82, 383.36, 383.9, 384.44, 385.16, 385.7, 386.24, 386.78, 387.14, 387.5, 388.04, 388.58, 388.94, 389.3, 389.66, 390.2, 390.74, 391.1, 391.64, 392.18, 392.54, 392.9, 393.26, 393.62, 393.98, 394.34, 394.52, 394.88, 395.24, 395.42, 395.78, 396.32, 396.68, 397.22, 397.58, 397.76, 398.12, 398.48, 399.02, 399.38, 399.92, 400.28, 400.64, 401.18, 401.36, 401.54, 401.72, 402.08, 402.62, 403.16, 403.52, 403.88, 404.06, 404.42, 404.78, 405.14, 405.5, 405.68, 405.86, 406.22, 406.58, 406.94, 407.3, 407.66, 408.02, 408.38, 408.74, 409.1, 409.28, 409.64, 410.0, 410.36, 410.9, 411.26, 411.8, 412.34, 412.7, 413.42, 413.96, 414.32, 414.68, 415.04, 415.4, 415.76, 416.12, 416.48, 416.84, 417.2, 417.56, 418.1, 418.64, 419.0, 419.36, 419.9, 420.26, 420.62, 420.8, 421.34, 421.88, 422.24, 422.6, 422.78, 423.14, 423.5, 423.86, 424.22, 424.58, 424.94, 425.48, 425.84, 426.2, 426.56, 427.1, 427.64, 428.0, 428.36, 428.72, 428.9, 429.08, 429.08, 429.08, 429.08, 429.26, 429.62, 429.8, 429.98, 430.16, 430.16, 430.34, 430.34, 430.52, 430.7, 430.88, 431.06, 431.42, 431.6, 431.96, 432.14, 432.32, 432.5, 432.68, 432.86, 432.86, 433.04, 433.22, 433.4, 433.4, 433.58, 433.94, 434.12, 434.3, 434.66, 435.02, 435.2, 435.56, 435.74, 436.1, 436.46, 436.82, 437.0, 437.54, 437.9, 438.26, 438.62, 438.98, 439.16, 439.34, 439.34, 439.52, 439.52, 439.7, 439.7, 439.7, 439.7, 439.88, 440.06, 440.06, 440.24, 440.42, 440.6, 440.6, 440.6, 440.6, 440.78, 440.78, 440.96, 441.14, 441.32, 441.5, 441.5, 441.5, 441.68, 441.68, 441.86, 442.04, 442.4, 442.58, 442.76, 442.94, 443.3, 443.48, 443.66, 443.84, 444.02, 444.38, 444.56, 444.56, 444.56, 444.38, 444.38, 444.2, 444.2, 444.2, 444.2, 444.2, 444.2, 444.2, 444.2, 444.02, 444.02, 444.02, 444.02, 444.02, 444.2, 444.2, 444.2, 444.38, 444.38, 444.56, 444.74, 444.92, 444.92, 445.28, 445.28, 445.46, 445.64, 445.82, 446.0, 446.36, 446.54, 446.72, 447.08, 447.26, 447.44, 447.62, 447.8, 447.98, 448.16, 448.34, 448.52, 448.88, 449.24, 449.24, 449.42, 449.6, 449.78, 450.14, 450.32, 450.5, 450.68, 450.68, 451.04, 451.04, 451.22, 451.22, 451.22, 451.22, 451.4, 451.4, 451.58, 451.58, 451.58, 451.76, 451.94, 452.12, 452.3, 452.48, 452.66, 452.84, 453.02, 453.02, 453.2, 453.38, 453.56, 453.74, 453.74, 453.92, 454.1, 454.28, 454.46, 454.46, 454.64, 454.82, 454.82, 455.0, 455.18, 455.18, 455.18, 455.36, 455.36, 455.54, 455.72, 455.9, 455.9, 456.08, 456.26, 456.62, 456.8, 456.98, 457.34, 457.52, 457.7, 457.88, 458.06, 458.06, 457.88, 457.88, 457.7, 457.52, 457.52, 457.52, 457.34, 457.34, 457.34, 457.34, 457.34, 457.34, 457.34, 457.34, 457.34, 457.34, 457.34, 457.52, 457.52, 457.52, 457.52, 457.52, 457.52, 457.7, 457.7, 457.7, 457.88, 457.7, 457.52, 457.16, 457.16, 456.98, 456.8, 456.8, 456.62, 456.44, 456.44, 456.44, 456.44, 456.26, 456.26, 456.26, 456.08, 455.72, 455.36, 455.0, 454.82, 454.46, 454.1, 453.74, 453.56, 453.2, 452.84, 452.3, 451.76, 451.22, 450.5, 449.96, 449.42, 448.88, 448.52, 448.34, 447.44, 444.92, 440.78, 434.66, 425.48, 415.22, 405.68, 396.86, 388.76, 381.56, 375.62, 369.68, 363.74, 357.62, 351.32, 345.74, 340.52, 335.48, 331.16, 327.38, 323.6, 320.0, 316.76, 313.88, 311.18, 308.84, 306.5, 304.52, 302.54, 301.28, 306.68, 315.32, 323.24, 330.62, 336.92, 342.14, 346.46, 350.06, 352.76, 355.1, 356.9, 358.34, 359.6, 360.32, 361.04, 361.58, 361.76, 361.94, 361.94, 361.94, 361.94], 'temp2': [385.52, 385.52, 385.7, 385.7, 385.7, 386.06, 386.06, 386.24, 386.42, 386.6, 387.14, 387.68, 388.04, 388.58, 388.76, 389.12, 389.3, 389.3, 389.48, 389.48, 389.48, 389.3, 389.3, 389.3, 388.94, 388.94, 388.94, 388.76, 388.58, 388.4, 387.14, 378.14, 365.72, 351.5, 336.74, 323.06, 309.56, 298.76, 287.42, 276.98, 267.08, 257.9, 249.44, 241.52, 234.32, 229.1, 222.98, 217.58, 212.36, 207.32, 203.18, 199.04, 195.26, 192.38, 189.32, 186.8, 184.28, 182.48, 180.68, 178.88, 177.44, 176.18, 175.28, 174.38, 174.02, 173.48, 173.3, 173.12, 173.12, 173.12, 173.3, 173.66, 174.02, 174.56, 175.1, 175.82, 176.72, 177.44, 178.34, 179.06, 179.96, 181.04, 182.12, 183.2, 184.28, 185.54, 186.62, 187.7, 188.96, 190.4, 191.48, 192.74, 194.0, 195.26, 196.52, 197.78, 199.04, 200.3, 201.74, 203.18, 204.26, 205.7, 206.96, 208.4, 209.66, 210.92, 212.36, 213.62, 214.88, 216.32, 217.58, 218.84, 220.1, 221.54, 222.8, 224.06, 225.32, 226.4, 227.66, 229.1, 230.18, 231.44, 232.7, 233.96, 235.22, 236.3, 237.38, 238.64, 239.72, 240.98, 242.06, 243.14, 244.22, 245.3, 246.38, 247.64, 248.72, 249.8, 250.88, 251.96, 253.04, 254.3, 255.38, 256.46, 257.36, 258.44, 259.52, 260.42, 261.5, 262.58, 263.48, 264.38, 265.46, 266.36, 267.44, 268.34, 269.24, 270.14, 271.04, 271.94, 272.84, 273.74, 274.64, 275.54, 276.44, 277.16, 278.06, 278.96, 279.86, 280.58, 281.48, 282.38, 283.1, 283.82, 284.72, 285.44, 286.16, 287.06, 287.78, 288.5, 289.4, 290.12, 290.84, 291.56, 292.46, 293.0, 293.72, 294.62, 295.16, 295.88, 296.6, 297.14, 297.86, 298.58, 299.12, 299.84, 300.56, 301.1, 301.82, 302.36, 303.08, 303.62, 304.34, 305.06, 305.6, 306.32, 306.86, 307.58, 308.12, 308.66, 309.38, 309.92, 310.64, 311.18, 311.72, 312.08, 312.8, 313.34, 313.88, 314.6, 315.14, 315.68, 316.22, 316.76, 317.3, 318.02, 318.56, 319.1, 319.46, 320.18, 320.72, 321.26, 321.8, 322.34, 322.88, 323.6, 324.14, 324.68, 325.22, 325.76, 326.3, 326.84, 327.38, 327.92, 328.46, 329.0, 329.36, 329.9, 330.44, 330.98, 331.52, 332.06, 332.42, 332.96, 333.5, 334.22, 334.76, 335.3, 335.66, 336.02, 336.56, 337.1, 337.64, 338.18, 338.72, 339.08, 339.62, 340.16, 340.7, 341.24, 341.6, 342.14, 342.68, 343.22, 343.58, 343.94, 344.48, 345.02, 345.38, 345.92, 346.28, 346.82, 347.36, 347.72, 348.26, 348.62, 349.16, 349.52, 350.06, 350.42, 350.96, 351.32, 351.86, 352.22, 352.76, 353.12, 353.48, 354.02, 354.38, 354.74, 355.28, 355.64, 356.0, 356.54, 356.9, 357.44, 357.8, 358.34, 358.7, 359.24, 359.6, 359.96, 360.5, 360.86, 361.4, 361.76, 362.12, 362.48, 363.02, 363.38, 363.74, 364.28, 364.64, 365.0, 365.36, 365.72, 366.08, 366.44, 366.98, 367.34, 367.7, 368.06, 368.42, 368.96, 369.32, 369.68, 370.04, 370.4, 370.76, 371.12, 371.48, 372.02, 372.38, 372.74, 373.1, 373.46, 373.82, 374.18, 374.54, 375.08, 375.44, 375.62, 375.98, 376.52, 376.88, 377.24, 377.6, 377.96, 378.32, 378.86, 379.22, 379.58, 379.94, 380.3, 380.84, 381.2, 381.56, 381.92, 382.46, 382.82, 383.18, 383.54, 383.9, 384.26, 384.8, 385.16, 385.52, 385.88, 386.24, 386.78, 387.14, 387.32, 387.86, 388.04, 388.4, 388.94, 389.12, 389.66, 390.02, 390.38, 390.74, 391.1, 391.46, 391.82, 392.18, 392.54, 392.9, 393.08, 393.62, 393.98, 394.34, 394.7, 395.06, 395.42, 395.6, 396.14, 396.32, 396.68, 397.04, 397.4, 397.76, 398.12, 398.48, 398.84, 399.02, 399.38, 399.56, 399.92, 400.28, 400.64, 401.0, 401.36, 401.72, 402.08, 402.26, 402.62, 402.98, 403.16, 403.52, 403.88, 404.06, 404.6, 404.78, 404.96, 405.32, 405.68, 405.86, 406.22, 406.58, 406.76, 407.12, 407.48, 407.66, 408.02, 408.38, 408.74, 408.92, 409.28, 409.64, 409.82, 410.18, 410.54, 410.72, 411.08, 411.44, 411.8, 411.98, 412.34, 412.7, 413.06, 413.42, 413.6, 413.96, 414.32, 414.5, 414.86, 415.22, 415.58, 415.76, 416.3, 416.48, 416.84, 417.02, 417.38, 417.56, 417.92, 418.28, 418.46, 418.82, 419.18, 419.36, 419.54, 419.9, 420.08, 420.44, 420.62, 420.98, 421.16, 421.34, 421.7, 421.88, 422.06, 422.42, 418.28, 409.64, 400.1, 387.68, 373.82, 358.88, 346.46, 332.6, 319.28, 306.5, 293.72, 282.92, 273.38, 262.94, 253.22, 244.22, 235.58, 227.3, 219.38, 211.82, 204.8, 198.5, 192.74, 187.16, 181.94, 176.72, 172.04, 167.36, 163.4, 163.76, 172.4, 181.04, 190.04, 198.68, 206.6, 214.7, 221.9, 228.74, 235.58, 240.98, 246.92, 252.5, 257.72, 262.4, 266.9, 271.4, 275.54, 279.32, 282.92, 286.16, 289.4], 'phases': [300, 306, 391, 450], 'zmax': 45, 'zmin': 0, 'ymax': 527, 'ymin': 100, 'xmin': 0.48248113750000243, 'xmax': 763.95004334, 'ambientTemp': 0.0, 'ambient_humidity': 0.0, 'ambient_pressure': 0.0, 'moisture_greens': 0.0, 'greens_temp': 0.0, 'moisture_roasted': 0.0, 'extradevices': [], 'extraname1': [], 'extraname2': [], 'extratimex': [], 'extratemp1': [], 'extratemp2': [], 'extramathexpression1': [], 'extramathexpression2': [], 'extradevicecolor1': [], 'extradevicecolor2': [], 'extraLCDvisibility1': [False, False, False, False, False, False, False, False, False, False], 'extraLCDvisibility2': [False, False, False, False, False, False, False, False, False, False], 'extraCurveVisibility1': [True, True, True, True, True, True, True, True, True, True], 'extraCurveVisibility2': [True, True, True, True, True, True, True, True, True, True], 'extraDelta1': [False, False, False, False, False, False, False, False, False, False], 'extraDelta2': [False, False, False, False, False, False, False, False, False, False], 'extraFill1': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 'extraFill2': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 'extramarkersizes1': [], 'extramarkersizes2': [], 'extramarkers1': [], 'extramarkers2': [], 'extralinewidths1': [], 'extralinewidths2': [], 'extralinestyles1': [], 'extralinestyles2': [], 'extradrawstyles1': [], 'extradrawstyles2': [], 'externalprogram': 'test.py', 'externaloutprogram': 'out.py', 'extraNoneTempHint1': [], 'extraNoneTempHint2': [], 'alarmsetlabel': '', 'alarmflag': [], 'alarmguard': [], 'alarmnegguard': [], 'alarmtime': [], 'alarmoffset': [], 'alarmcond': [], 'alarmsource': [], 'alarmtemperature': [], 'alarmaction': [], 'alarmbeep': [], 'alarmstrings': [], 'backgroundpath': 'C:/Users/Oskar/Desktop/FoCP project/Brazylia California 6kg 93 #9.alog', 'samplinginterval': 1.5, 'svLabel': '', 'svValues': [0, 0, 0, 0, 0, 0, 0, 0], 'svRamps': [0, 0, 0, 0, 0, 0, 0, 0], 'svSoaks': [0, 0, 0, 0, 0, 0, 0, 0], 'svActions': [-1, -1, -1, -1, -1, -1, -1, -1], 'svBeeps': [False, False, False, False, False, False, False, False], 'svDescriptions': ['', '', '', '', '', '', '', ''], 'devices': ['S7'], 'elevation': 0, 'computed': {'CHARGE_ET': 401.0, 'CHARGE_BT': 388.4, 'TP_idx': 69, 'TP_time': 60.0, 'TP_ET': 353.3, 'TP_BT': 173.1, 'MET': 458.1, 'DRY_time': 262.5, 'DRY_ET': 417.6, 'DRY_BT': 305.6, 'FCs_time': 541.5, 'FCs_ET': 452.1, 'FCs_BT': 390.7, 'DROP_time': 694.5, 'DROP_ET': 448.3, 'DROP_BT': 422.4, 'totaltime': 694.5, 'dryphasetime': 262.5, 'midphasetime': 279.0, 'finishphasetime': 153.0, 'dry_phase_ror': 39.3, 'mid_phase_ror': 0.0, 'finish_phase_ror': 0.0, 'total_ror': 23.6, 'dry_phase_delta_temp': 132.5, 'total_ts': 628, 'total_ts_ET': 1339, 'total_ts_BT': 731, 'AUC': 708, 'AUCbegin': 'TP', 'AUCbase': 212, 'AUCfromeventflag': 0, 'dry_phase_AUC': 94, 'mid_phase_AUC': 360, 'finish_phase_AUC': 276, 'volumein': 0.0, 'volumeout': 0.0, 'weightin': 0.0, 'weightout': 0.0, 'BTU_preheat': 0.0, 'CO2_preheat': 0.0, 'BTU_bbp': 0.0, 'CO2_bbp': 0.0, 'BTU_cooling': 0.0, 'CO2_cooling': 0.0, 'BTU_LPG': 0.0, 'BTU_NG': 0.0, 'BTU_ELEC': 0.0, 'BTU_batch': 0.0, 'BTU_batch_per_green_kg': 0.0, 'BTU_roast': 0.0, 'BTU_roast_per_green_kg': 0.0, 'CO2_batch': 0.0, 'CO2_batch_per_green_kg': 0.0, 'CO2_roast': 0.0, 'CO2_roast_per_green_kg': 0.0, 'KWH_batch_per_green_kg': 0.0, 'KWH_roast_per_green_kg': 0.0}, 'anno_positions': [], 'flag_positions': [], 'loadlabels': ['', '', '', ''], 'loadratings': [0.0, 0.0, 0.0, 0.0], 'ratingunits': [0, 0, 0, 0], 'sourcetypes': [0, 0, 0, 0], 'load_etypes': [0, 0, 0, 0], 'presssure_percents': [False, False, False, False], 'loadevent_zeropcts': [0, 0, 0, 0], 'loadevent_hundpcts': [100, 100, 100, 100], 'preheatDuration': 0, 'preheatenergies': [0.0, 0.0, 0.0, 0.0], 'betweenbatchDuration': 0, 'betweenbatchenergies': [0.0, 0.0, 0.0, 0.0], 'coolingDuration': 0, 'coolingenergies': [0.0, 0.0, 0.0, 0.0], 'betweenbatch_after_preheat': True, 'electricEnergyMix': 0}
        #                     },
        #     "taskTime": 987
        # })
        # global token
        # headers = {
        #     'token': f'{token}',
        #     'Content-Type': 'application/json'
        # }
        # if token:
        #     response = requests.post(url, payload, headers=headers)
        #     if response.status_code == 200:
        #         dataJson = response.json()
        #         textCode = dataJson['code']
        #         if textCode == 0 or textCode == 200:
        #             print('连接成功')
        #             self.rwlzClick(task_id)
        #         else:
        #             print('连接失败')
        #             self.diologRect2Zhezhao.setVisible(True)
        #             self.jbCentent2.setText('保存失败，烘焙批次号和烘焙曲线已存在')
        #     else:
        #         print('连接失败')

    def closeDiolog(self):
        self.diologRect2Zhezhao.setVisible(False)



    # -------------------------------------------------------------------------------------------------------------------------单机版
    def add_orderDiolog(self):
        self.zhezhaoWidget_addOrder.setVisible(True)
        self.addOrderWidget.setVisible(True)

    # def getBakingBatchStr(self):
    #     current_time = datetime.datetime.now()
    #     timestamp = current_time.strftime("%Y%m%d%H%M%S")
    #     baking_batch = f"Task-{222}-{timestamp}"  # 假设 bakingDeviceId 固定为 2
    #     return baking_batch

    def on_stage_combobox_changed(self, selected_stage):
        """保存当前阶段的输入值到对应数组"""
        try:
            previous_stage = self.current_stage
            self.current_stage = selected_stage

            if previous_stage in self.stage_data:
                # 保存上一阶段的输入值
                self.stage_data[previous_stage] = [
                    int(self.stage_one_bContent.text()) if self.stage_one_bContent.text().isdigit() else 0,
                    int(self.stage_two_bContent.text()) if self.stage_two_bContent.text().isdigit() else 0,
                    int(self.stage_three_bContent.text()) if self.stage_three_bContent.text().isdigit() else 0,
                    int(self.stage_four_bContent.text()) if self.stage_four_bContent.text().isdigit() else 0,
                ]

            # 更新输入框为新的阶段
            if selected_stage in self.stage_data:
                new_stage_values = self.stage_data[selected_stage]
                self.stage_one_bContent.setText(str(new_stage_values[0]))
                self.stage_two_bContent.setText(str(new_stage_values[1]))
                self.stage_three_bContent.setText(str(new_stage_values[2]))
                self.stage_four_bContent.setText(str(new_stage_values[3]))

            print(f"Saved stage: {previous_stage}, Data: {self.stage_data[previous_stage]}")
            print(f"Current stage: {selected_stage}, Data: {self.stage_data[selected_stage]}")

        except Exception as e:
            import traceback
            print(traceback.format_exc())

    def addOrder_Json(self):
        try:
            # 确保当前阶段的输入值已保存
            self.on_stage_combobox_changed(self.stage_combo_box.currentText())

            # 确保目录存在
            os.makedirs("localJson", exist_ok=True)

            # 读取现有 JSON 文件
            try:
                with open("localJson/order.json", "r", encoding="utf-8") as file:
                    existing_data = json.load(file)
            except (FileNotFoundError, json.JSONDecodeError):
                existing_data = []

            # 获取最后一条记录的 ID
            last_id = existing_data[-1].get("id", 0) if existing_data else 0
            new_id = last_id + 1

            # 获取当前时间
            current_time = datetime.datetime.now()
            create_time = current_time.strftime("%Y-%m-%d %H:%M:%S")
            task_id = ''.join(random.choices("0123456789", k=18))
            baking_batch = f"task-{2}-{current_time.strftime('%Y%m%d%H%M%S')}"

            # 创建新记录
            data = {
                "id": new_id,
                "taskName": self.taskNameContent.text(),
                "bakingBatch": baking_batch,
                "createTime": create_time,
                "finishTime": self.finishContent.text(),
                "number": self.numberContent.text(),
                "numberOfBeans": self.nobContent.text(),
                "bakingStatue": 1,
                "bakingDeviceId": 2,
                "taskId": task_id,
                "stage1": self.stage_data["stage1"],
                "stage2": self.stage_data["stage2"],
                "stage3": self.stage_data["stage3"],
                "stage4": self.stage_data["stage4"],
                "stage5": self.stage_data["stage5"],
                "stage6": self.stage_data["stage6"]
            }

            # 添加新记录并写入文件
            existing_data.append(data)
            with open("localJson/order.json", "w", encoding="utf-8") as file:
                json.dump(existing_data, file, ensure_ascii=False, indent=4)

            print("Data saved successfully:", data)

            # 清空输入框
            self.taskNameContent.clear()
            self.finishContent.clear()
            self.numberContent.clear()
            self.nobContent.clear()
            self.stage_one_bContent.clear()
            self.stage_two_bContent.clear()
            self.stage_three_bContent.clear()
            self.stage_four_bContent.clear()

            # 隐藏窗口并刷新
            self.zhezhaoWidget_addOrder.setVisible(False)
            self.addOrderWidget.setVisible(False)
            self.load_order_json()

        except Exception as e:
            import traceback
            error_message = traceback.format_exc()
            print("Error saving data:", error_message)
            QMessageBox.critical(self, "错误", f"保存失败: {error_message}")

    def load_order_json(self):
        """从 JSON 文件加载数据到表单"""
        try:
            with open("localJson/order.json", "r", encoding="utf-8") as file:
                data = json.load(file)
                self.orderList_data = data

                # 清除布局中的旧部件
                for i in reversed(range(self.orderLayout.count())):
                    widget = self.orderLayout.itemAt(i).widget()
                    if widget is not None:
                        widget.deleteLater()
                        self.orderLayout.removeItem(self.orderLayout.itemAt(i))

                # 遍历订单数据并生成控件
                for order in self.orderList_data:
                    if order.get("bakingDeviceId") == 2 and order.get("bakingStatue") == 1:
                        ordersRect2 = QLabel()
                        ordersRect2.setStyleSheet(
                            f'border-radius: {25*self.height_scale}px; background-color: #f5f8fb; border: 1px solid #e1f0fe;'
                        )
                        ordersRect2.setFixedSize(288 * self.width_scale, 185 * self.height_scale)

                        # self.add_data([order['id'], order['taskName'], order['bakingBatch'], order['finishTime'],
                        #                order['taskId']])

                        task_name_label = QLabel(ordersRect2)
                        task_name_label.setStyleSheet("color: #222222;border:none;background-color:transparent")
                        task_name_label.setGeometry(26 * self.width_scale, 26 * self.height_scale,
                                                    183 * self.width_scale, 24 * self.height_scale)
                        font = QFont(self.font_family3, 14 * self.width_scale)
                        task_name_label.setFont(font)
                        task_name_label.setText(order['taskName'])

                        taskTxt_label = QLabel(ordersRect2)
                        taskTxt_label.setStyleSheet("color: #222222;border:none;")
                        taskTxt_label.setGeometry(26 * self.width_scale, 68 * self.height_scale,
                                                  60 * self.width_scale, 24 * self.height_scale)
                        font2 = QFont(self.font_family4, 10 * self.width_scale)
                        taskTxt_label.setFont(font2)
                        taskTxt_label.setText(f"任务订单:")

                        self.task_no_label = ScrollingLabel(f"{order['bakingBatch']}", ordersRect2)
                        self.task_no_label.setGeometry(86 * self.width_scale, 68 * self.height_scale,
                                                       170 * self.width_scale, 24 * self.height_scale)
                        self.task_no_label.setFont(font2)

                        deadline_label = QLabel(ordersRect2)
                        deadline_label.setStyleSheet("color: #222222;border:none;")
                        deadline_label.setGeometry(26 * self.width_scale, 103 * self.height_scale,
                                                   210 * self.width_scale, 24 * self.height_scale)
                        deadline_label.setFont(font2)
                        deadline_label.setText(f"截止日期: {order['finishTime']}")

                        order_id_label = QLabel(ordersRect2)
                        order_id_label.setStyleSheet("color: #222222;border:none;")
                        order_id_label.setGeometry(26 * self.width_scale, 138 * self.height_scale,
                                                   210 * self.width_scale, 24 * self.height_scale)
                        order_id_label.setFont(font2)
                        order_id_label.setText(f"订单编号: {order['id']}")

                        spacer_widget = QWidget()
                        spacer_widget.setFixedHeight(15* self.height_scale)  # 设置为 36 像素高

                        self.orderLayout.addWidget(ordersRect2)
                        self.orderLayout.setAlignment(ordersRect2, Qt.AlignmentFlag.AlignTop)

                        self.orderLayout.addWidget(spacer_widget)

                # 添加按钮
            self.addButton = QPushButton(self.orderWidget)
            self.addButton.setStyleSheet(f'''
                QPushButton {{
                    border-radius: {25 * self.height_scale}px;
                    background-color: #f5f8fb;
                    border: 1px solid #e1f0fe;
                }}
                QPushButton:hover {{
                    background-color: #DEEEFE;
                    border: 1px solid #b5d5fd; /* 改变边框颜色 */
                }}
                QPushButton:pressed {{
                    background-color: #e1f0fe;
                    border: 1px solid #91c6fc; /* 按下时的边框颜色 */
                }}
            ''')

            # 设置图标和图标大小
            icon_path = f"{self.normalized_path}/includes/Icons/general/addProject.png"
            self.addButton.setIcon(QIcon(icon_path))
            self.addButton.setIconSize(QSize(100 * self.height_scale, 100 * self.height_scale))

            # 设置按钮大小
            self.addButton.setFixedSize(290 * self.width_scale, 185 * self.height_scale)

            # 绑定点击事件
            self.addButton.clicked.connect(self.add_orderDiolog)

            # 打印路径以调试
            print(f"Icon path: {icon_path}")

            # 将按钮添加到布局中
            self.orderLayout.addWidget(self.addButton, alignment=Qt.AlignmentFlag.AlignBottom)


        except FileNotFoundError:
            print(self, "警告", "JSON 文件不存在")

        except Exception as e:
            print(self, "错误", f"加载失败: {e}")

    def markChargeClick(self):
        # print(self.time_left)
        # self.qmc.markCharge()
        self.statusLabel.setText("烘焙中...")
        self.start_countdown()


        self.ordering.setVisible(True)

        self.yrqk.setVisible(False)
        self.jdqk.setVisible(True)
        self.gjxy.setVisible(False)

        # self.ordersRect2.setGeometry(231, 591, 290, 185)
        self.statusCard.setVisible(False)

        # self.rudouPixmap2 = QPixmap(self.normalized_path + '/includes/Icons/yrzb/rd-hover.png')
        self.rudouImg.setPixmap(QPixmap(self.normalized_path + '/includes/Icons/yrzb/rd-hover.png'))

        self.hbList = []
        try:
            with open("localJson/order.json", "r", encoding="utf-8") as file:
                data = json.load(file)
                self.orderList_data = data

                # 遍历订单数据并生成控件
                for order in self.orderList_data:
                    if order.get("bakingDeviceId") == 2 and order.get("bakingStatue") == 1:
                        # 使用 .get() 取值，若不存在某字段则提供默认值 [0, 0, 0, 0]
                        stage1 = order.get("stage1", [0, 0, 0, 0])
                        stage2 = order.get("stage2", [0, 0, 0, 0])
                        stage3 = order.get("stage3", [0, 0, 0, 0])
                        stage4 = order.get("stage4", [0, 0, 0, 0])
                        stage5 = order.get("stage5", [0, 0, 0, 0])
                        stage6 = order.get("stage6", [0, 0, 0, 0])

                        # 将数据追加到 hbList
                        self.hbList.append([
                            order.get('id'),
                            order.get('taskName'),
                            order.get('bakingBatch'),
                            order.get('finishTime'),
                            order.get('taskId'),
                            stage1,
                            stage2,
                            stage3,
                            stage4,
                            stage5,
                            stage6
                        ])

        except FileNotFoundError:
            QMessageBox.warning(self, "警告", "JSON 文件不存在")

        first_Value = self.hbList[0]
        self.getTPMark = first_Value
        if len(self.getTPMark) > 0:
            self.jieduanInfo(self.getTPMark)
        self.task_name_label2.setText(first_Value[1])
        new_text = f"任务订单: {first_Value[2]}"
        self.task_no_label2.original_text = new_text  # 更新原始文本
        self.task_no_label2.setText(new_text)  # 更新标签的显示文本
        # self.task_no_label2.update_text_dimensions()  # 更新宽度
        if self.task_no_label2.text_width > self.task_no_label2.label_width:
            self.task_no_label2.timer.start(100)  # 如果文本宽度大于标签宽度，开始滚动
        self.deadline_label2.setText(f"截止日期: {first_Value[3]}")

        try:
            # 找到 "bakingDeviceId"=2 的第一条数据并修改 "bakingStatue" 为 2
            for order in self.orderList_data:
                if order.get("bakingDeviceId") == 2 and order.get("bakingStatue") == 1:
                    order["bakingStatue"] = 2
                    break  # 修改第一条数据后退出循环

            # 将修改后的数据写回 JSON 文件
            with open("localJson/order.json", "w", encoding="utf-8") as file:
                json.dump(self.orderList_data, file, ensure_ascii=False, indent=4)

        except Exception as e:
            QMessageBox.warning(self, "错误", f"修改 JSON 文件时发生错误: {e}")


        if self.rudouTimer.isActive():
            self.rudouTimer.stop()
        else:
            self.rudouTimer.start(100, self)

        # 重置状态并启动定时器
        self.current_progress = 0
        self.current_bar_index = 0
        for bar in self.progress_bars:
            bar.setValue(0)  # 重置所有进度条

        # 启动定时器
        self.fourTimer.start(self.fourInterval)

    def markDropClick(self):
        self.zhezhaoWidget.setVisible(True)
        self.ccjlWidget.setVisible(True)
        self.yrqk.setVisible(False)
        self.jdqk.setVisible(False)
        self.gjxy.setVisible(True)
        self.status_label2.setText('已完成')
        self.statusLabel.setText("锅间协议")
        self.chukuImg.setStyleSheet(f"""
                                                            QPushButton {{
                                                                border-image: url('{self.normalized_path}/includes/Icons/yrzb/rd-hover.png');
                                                            }}
                                                        """)
        # self.qmc.markDrop()

        self.user_interacted = True  # 用户进行了交互

        self.gjxytimer.start(1000)  # 每隔 1 秒触发一次

        if self.jdtGJXYTimer.isActive():
            self.jdtGJXYTimer.stop()
        else:
            self.jdtGJXYTimer.start(100, self)

    def submitCCJL(self):
        self.zhezhaoWidget.setVisible(False)
        self.ccjlWidget.setVisible(False)
        self.computedData = self.getProfile()

        try:
            with open("localJson/order.json", "r", encoding="utf-8") as file:
                data = json.load(file)
                self.orderList_data = data

            # 遍历订单数据并生成控件
            for i, order in enumerate(self.orderList_data):
                if order.get("bakingDeviceId") == 2 and order.get("bakingStatue") == 2:
                    # 修改 bakingStatue 为 3
                    order["bakingStatue"] = 3

                    # 获取当天的日期，用作文件夹名称
                    today_str = datetime.datetime.now().strftime("%Y%m%d")
                    history_path = f"localJson/History/{today_str}"

                    # 创建当天日期的文件夹（如果不存在）
                    os.makedirs(history_path, exist_ok=True)

                    # 创建以 bakingBatch 为文件名的 JSON 文件
                    file_name = f"{order['bakingBatch']}.json"
                    file_path = os.path.join(history_path, file_name)

                    current_time = datetime.datetime.now()
                    create_time = current_time.strftime("%Y-%m-%d %H:%M:%S")


                    # 添加额外的字段到数据中
                    enriched_order = order.copy()
                    enriched_order.update({
                        "dehydrationRate": self.tslContent.text(),
                        "defectRate": self.xclContent.text(),
                        "numberOfRipe": self.slContent.text(),
                        "bakingFinishTime": create_time,
                        "description": self.qkfhContent.toPlainText(),
                        "agtronValue": self.agtronNum.text(),
                        "taskTime": self.computedData['computed']['totaltime'],
                        "jsonMessage": {"totaltime": self.computedData['computed']['totaltime'],
                                        "CHARGE_BT": self.computedData['computed']['CHARGE_BT'],
                                        "TP_BT": self.computedData['computed']['TP_BT'],
                                        "TP_time": self.computedData['computed']['TP_time'],
                                        "Maillard": self.computedData['computed']['DRY_BT'],
                                        "Maillard_time": self.computedData['computed']['DRY_time'],
                                        "FCs_BT": self.computedData['computed']['FCs_BT'],
                                        "FCs_time": self.computedData['computed']['FCs_time'],
                                        "SCs_BT": self.computedData['computed']['SCs_BT'],
                                        "SCs_time": self.computedData['computed']['SCs_time'],
                                        "DROP_BT": self.computedData['computed']['DROP_BT'],
                                        "finishphasetime": self.computedData['computed']['finishphasetime'],
                                        # self.computedData['AUCbegin'],
                                        "DTR": self.computedData['computed']['DTR'],
                                        "target_temperature": [135, 165, 182, 192, 198, 205],
                                        "target_values": [30, 35, 40, 90, 80, 65],
                                        "actual_temperature": [135, 166, 182, 195, 200, 205],
                                        "actual_values": [35, 40, 40, 90, 50, 65],
                                        "alogJson": self.getProfile()
                                        },
                    })

                    # 将 enriched_order 写入 JSON 文件
                    with open(file_path, "w", encoding="utf-8") as history_file:
                        json.dump(enriched_order, history_file, ensure_ascii=False, indent=4)

                    # 从 orderList_data 移除该条记录
                    self.orderList_data.pop(i)

                    # 将修改后的 orderList_data 写回 order.json
                    with open("localJson/order.json", "w", encoding="utf-8") as file:
                        json.dump(self.orderList_data, file, ensure_ascii=False, indent=4)

                    print(f"订单已成功移至 {file_path}")
                    self.load_order_json()
                    self.tslContent.clear()
                    self.xclContent.clear()
                    self.slContent.clear()
                    self.qkfhContent.clear()
                    break  # 处理完第一条符合条件的订单后退出循环

        except FileNotFoundError:
            QMessageBox.warning(self, "警告", "JSON 文件不存在")
        except Exception as e:
            QMessageBox.warning(self, "错误", f"处理订单时发生错误: {e}")

    def historyList_Json(self):
        self.list_widget.clear()

        # 获取今天日期
        today_str = datetime.datetime.now().strftime("%Y%m%d")

        # 获取文件夹路径
        date_folder = f"localJson/History/{today_str}"

        # 如果文件夹存在，则列出其中的所有文件
        if os.path.exists(date_folder):
            files = os.listdir(date_folder)  # 获取文件夹中的文件列表
        else:
            files = []  # 如果文件夹不存在，返回空列表

        self.list_widget.clear()

        for file_name in files:
            # 假设文件是 JSON 格式，首先构建文件路径
            file_path = os.path.join(date_folder, file_name)

            # 读取 JSON 文件内容
            with open(file_path, 'r', encoding='utf-8') as file:
                try:
                    data = json.load(file)
                except json.JSONDecodeError:
                    print(f"无法解析文件: {file_name}")
                    continue  # 如果文件内容无法解析为JSON，跳过该文件

            historyListBack = QWidget()
            historyListBack.setStyleSheet(
                f'border-radius: {12*self.height_scale}px; background-color: transparent; border: 1px solid #378AF6;')

            # 使用布局管理器
            item_layout = QHBoxLayout(historyListBack)
            item_layout.setContentsMargins(10 * self.width_scale, 5 * self.height_scale,
                                           10 * self.width_scale, 5 * self.height_scale)  # 设置边距
            item_layout.setSpacing(15 * self.height_scale)  # 设置控件之间的间距

            # 创建复选框
            checkbox = QCheckBox(historyListBack)
            checkbox.setStyleSheet("color: #222222; border:none; padding: 2px;background-color: #ffffff")
            checkbox.setGeometry(45 * self.width_scale, 9 * self.height_scale, 18 * self.height_scale,
                                 18 * self.height_scale)
            checkbox.setFixedWidth(18 * self.width_scale)
            checkbox.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
            checkbox.setProperty("bakingBatch", data.get("bakingBatch"))
            checkbox.setProperty("orderDetailJson", data)
            checkbox.stateChanged.connect(self.handle_checkbox)

            # 创建评分图标标签
            fkqkImg = QLabel(historyListBack)
            fkqkImg.setGeometry(140 * self.width_scale, 8 * self.height_scale, 20 * self.width_scale,
                                20 * self.height_scale)
            fkqkImg.setStyleSheet("color: #222222; border:none; padding: 2px;background-color: transparent")
            if data.get('description', '') != '':  # 确保 'description' 字段存在
                fkqkImgPixmap = QPixmap(self.normalized_path + '/includes/Icons/history/pingfen2.png')
            else:
                fkqkImgPixmap = QPixmap(self.normalized_path + '/includes/Icons/history/pingfen.png')
            fkqkImg.setPixmap(fkqkImgPixmap)
            fkqkImg.setScaledContents(True)

            # 烘焙批次标签
            bakingBatch_label = QLabel(historyListBack)
            bakingBatch_label.setStyleSheet(
                "color: #222222; border:none; padding: 2px;background-color: transparent")
            bakingBatch_label.setText(data.get('bakingBatch', ''))   # 显示文件名，假设文件名是批次号
            bakingBatch_label.setGeometry(261 * self.width_scale, 0, 250 * self.width_scale,
                                          36 * self.height_scale)

            # 任务名称标签
            taskName_label = QLabel(historyListBack)
            taskName_label.setStyleSheet(
                "color: #222222; border:none; padding: 2px;background-color: transparent")
            taskName_label.setText(data.get('taskName', ''))  # 假设 JSON 中有 'taskName' 字段
            taskName_label.setGeometry(507 * self.width_scale, 0, 120 * self.width_scale,
                                       36 * self.height_scale)
            taskName_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)

            # 任务时间标签
            taskTime_label = QLabel(historyListBack)
            taskTime_label.setStyleSheet(
                "color: #222222; border:none; padding: 2px;background-color: transparent")
            taskTime_label.setText(str(data.get('taskTime', 0) / 60))  # 将秒转换为分钟
            taskTime_label.setGeometry(787 * self.width_scale, 0, 120 * self.width_scale,
                                       36 * self.height_scale)
            taskTime_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)

            # 创建时间标签
            create_time = data.get('createTime')
            baking_finish_time = data.get('bakingFinishTime')
            createTime_label = QLabel(historyListBack)
            if create_time is None or baking_finish_time is None:
                createTime_label.setText('-')  # 显示时间段
            else:
                createTime_label.setText(
                    str(create_time[11:16]) + '-' + str(baking_finish_time[11:16]))  # 显示时间段
            createTime_label.setStyleSheet("color: #222222; border:none; padding: 2px;")
            createTime_label.setGeometry(1045 * self.width_scale, 0, 120 * self.width_scale,
                                         36 * self.height_scale)
            createTime_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)

            agtronValue_label = QLabel(historyListBack)
            agtronValue_label.setStyleSheet("color: #222222; border:none; padding: 2px;")
            # item_layout.addWidget(agtronValue_label)
            agtronValue_label.setText(data.get('agtronValue', ''))
            agtronValue_label.setGeometry(1265 * self.width_scale, 0, 120 * self.width_scale,
                                          36 * self.height_scale)
            agtronValue_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
            agtronValue_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)

            # 添加空白项以便布局
            spacer = QSpacerItem(0, 40 * self.height_scale)
            item_layout.addItem(spacer)

            # 设置 QWidget 的大小
            historyListBack.setFixedHeight(36 * self.height_scale)

            # 创建 QListWidgetItem
            list_item = QListWidgetItem(self.list_widget)
            list_item.setSizeHint(historyListBack.sizeHint())  # 设置项的大小提示

            list_item.setData(22, data.get('bakingBatch', ''))  # 任务编号
            list_item.setData(23, today_str)  # 任务编号

            # 添加项到 QListWidget
            self.list_widget.addItem(list_item)
            self.list_widget.setItemWidget(list_item, historyListBack)

    def date_changed(self, date):
        self.list_widget.clear()

        # 获取今天日期
        today_str = date.toString("yyyyMMdd")

        # 获取文件夹路径
        date_folder = f"localJson/History/{today_str}"

        # 如果文件夹存在，则列出其中的所有文件
        if os.path.exists(date_folder):
            files = os.listdir(date_folder)  # 获取文件夹中的文件列表
        else:
            files = []  # 如果文件夹不存在，返回空列表

        self.list_widget.clear()

        for file_name in files:
            # 假设文件是 JSON 格式，首先构建文件路径
            file_path = os.path.join(date_folder, file_name)

            # 读取 JSON 文件内容
            with open(file_path, 'r', encoding='utf-8') as file:
                try:
                    data = json.load(file)
                except json.JSONDecodeError:
                    print(f"无法解析文件: {file_name}")
                    continue  # 如果文件内容无法解析为JSON，跳过该文件

            historyListBack = QWidget()
            historyListBack.setStyleSheet(
                f'border-radius: {12*self.height_scale}px; background-color: transparent; border: 1px solid #378AF6;')

            # 使用布局管理器
            item_layout = QHBoxLayout(historyListBack)
            item_layout.setContentsMargins(10 * self.width_scale, 5 * self.height_scale,
                                           10 * self.width_scale, 5 * self.height_scale)  # 设置边距
            item_layout.setSpacing(15 * self.height_scale)  # 设置控件之间的间距

            # 创建复选框
            checkbox = QCheckBox(historyListBack)
            checkbox.setStyleSheet("color: #222222; border:none; padding: 2px;background-color: #ffffff")
            checkbox.setGeometry(45 * self.width_scale, 9 * self.height_scale, 18 * self.height_scale,
                                 18 * self.height_scale)
            checkbox.setFixedWidth(18 * self.width_scale)
            checkbox.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
            checkbox.setProperty("bakingBatch", data.get("bakingBatch"))
            checkbox.setProperty("orderDetailJson", data)
            checkbox.stateChanged.connect(self.handle_checkbox)

            # 创建评分图标标签
            fkqkImg = QLabel(historyListBack)
            fkqkImg.setGeometry(140 * self.width_scale, 8 * self.height_scale, 20 * self.width_scale,
                                20 * self.height_scale)
            fkqkImg.setStyleSheet("color: #222222; border:none; padding: 2px;background-color: transparent")
            if data.get('description', '') != '':  # 确保 'description' 字段存在
                fkqkImgPixmap = QPixmap(self.normalized_path + '/includes/Icons/history/pingfen2.png')
            else:
                fkqkImgPixmap = QPixmap(self.normalized_path + '/includes/Icons/history/pingfen.png')
            fkqkImg.setPixmap(fkqkImgPixmap)
            fkqkImg.setScaledContents(True)

            # 烘焙批次标签
            bakingBatch_label = QLabel(historyListBack)
            bakingBatch_label.setStyleSheet(
                "color: #222222; border:none; padding: 2px;background-color: transparent")
            bakingBatch_label.setText(data.get('bakingBatch', ''))  # 显示文件名，假设文件名是批次号
            bakingBatch_label.setGeometry(261 * self.width_scale, 0, 250 * self.width_scale,
                                          36 * self.height_scale)

            # 任务名称标签
            taskName_label = QLabel(historyListBack)
            taskName_label.setStyleSheet(
                "color: #222222; border:none; padding: 2px;background-color: transparent")
            taskName_label.setText(data.get('taskName', ''))  # 假设 JSON 中有 'taskName' 字段
            taskName_label.setGeometry(507 * self.width_scale, 0, 120 * self.width_scale,
                                       36 * self.height_scale)
            taskName_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)

            # 任务时间标签
            taskTime_label = QLabel(historyListBack)
            taskTime_label.setStyleSheet(
                "color: #222222; border:none; padding: 2px;background-color: transparent")
            taskTime_label.setText(str(data.get('taskTime', 0) / 60))  # 将秒转换为分钟
            taskTime_label.setGeometry(787 * self.width_scale, 0, 120 * self.width_scale,
                                       36 * self.height_scale)
            taskTime_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)

            # 创建时间标签
            create_time = data.get('createTime')
            baking_finish_time = data.get('bakingFinishTime')
            createTime_label = QLabel(historyListBack)
            if create_time is None or baking_finish_time is None:
                createTime_label.setText('-')  # 显示时间段
            else:
                createTime_label.setText(
                    str(create_time[11:16]) + '-' + str(baking_finish_time[11:16]))  # 显示时间段
            createTime_label.setStyleSheet("color: #222222; border:none; padding: 2px;")
            createTime_label.setGeometry(1045 * self.width_scale, 0, 120 * self.width_scale,
                                         36 * self.height_scale)
            createTime_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)

            agtronValue_label = QLabel(historyListBack)
            agtronValue_label.setStyleSheet("color: #222222; border:none; padding: 2px;")
            # item_layout.addWidget(agtronValue_label)
            agtronValue_label.setText(data.get('agtronValue', ''))
            agtronValue_label.setGeometry(1265 * self.width_scale, 0, 120 * self.width_scale,
                                          36 * self.height_scale)
            agtronValue_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignCenter)
            agtronValue_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)

            # 添加空白项以便布局
            spacer = QSpacerItem(0, 40 * self.height_scale)
            item_layout.addItem(spacer)

            # 设置 QWidget 的大小
            historyListBack.setFixedHeight(36 * self.height_scale)

            # 创建 QListWidgetItem
            list_item = QListWidgetItem(self.list_widget)
            list_item.setSizeHint(historyListBack.sizeHint())
            list_item.setData(22, data.get('bakingBatch', ''))  # 任务编号
            list_item.setData(23, today_str)  # 任务编号

            # 添加项到 QListWidget
            self.list_widget.addItem(list_item)
            self.list_widget.setItemWidget(list_item, historyListBack)

    def showHistorydetail(self, item):
        item_id = item.data(22)  # 获取选中的项目的 ID 或文件路径
        dateStr = item.data(23)

        # 根据 item_id 构建文件路径
        file_path = f"localJson/History/{dateStr}/{item_id}.json"  # 假设 ID 对应的文件名
        self.scroll_area.setVisible(True)
        self.historyInfo.setVisible(True)

        self.scroll_area.setWidget(self.historyInfo)
        self.qmc: tgraphcanvas = tgraphcanvas(self.historyInfo, self.dpi, self.locale_str, self)
        self.qmc.setGeometry(65 * self.width_scale, 104 * self.height_scale, 1481 * self.width_scale,
                             600 * self.height_scale)
        self.qmc.setVisible(True)
        self.qmc.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)  # 鼠标穿透

        try:
            # 读取 JSON 文件
            with open(file_path, 'r', encoding='utf-8') as file:
                data_json = json.load(file)

            # 提取顶层数据
            self.historyDetail_sheibei.setText(item_id)

            task_name = data_json.get("taskName", "未知任务")
            baking_batch = data_json.get("bakingBatch", "未知批次")
            number = data_json.get("number", 0)
            number_of_beans = data_json.get("numberOfBeans", 0)
            dehydration_rate = data_json.get("dehydrationRate", "未知")
            defect_rate = data_json.get("defectRate", "未知")
            description = data_json.get("description", "")
            agtron_value = data_json.get("agtronValue", "未知")
            numberOfRipe = data_json.get("numberOfRipe", "未知")
            bakingFinishTime = data_json.get("bakingFinishTime", "未知")

            # 提取 jsonMessage 数据
            json_message = data_json.get("jsonMessage", {})
            total_time = json_message.get("totaltime", "0")
            charge_bt = json_message.get("CHARGE_BT", "0")
            tp_bt = json_message.get("TP_BT", "0")
            tp_time = json_message.get("TP_time", "0")
            maillard = json_message.get("Maillard", "0")
            maillard_time = json_message.get("Maillard_time", "0")
            dtr = json_message.get("DTR", "0")
            fCs_BT = json_message.get("FCs_BT", "0")
            fCs_time = json_message.get("FCs_time", "0")
            finishphasetime = json_message.get("finishphasetime", "0")
            dtr = json_message.get("DTR", "0")

            obj = json_message.get("alogJson", "0")
            res = self.setProfile(obj)  # 打开烘焙曲线
            if res:
                # update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                self.qmc.fileDirtySignal.emit()
                self.autoAdjustAxis()
                self.qmc.redraw()

            # 更新界面组件
            # self.historyDetail_sheibei.setText(f"批次号: {baking_batch}")
            self.hongbeishichang.setText(f"烘焙时长: {int(total_time) // 60}:{int(total_time) % 60} ")
            self.rudouwendu.setText(f"入豆温度: {charge_bt}℃")
            self.huiwendian.setText(f"回温点: {tp_bt}℃ / {int(tp_time) // 60}:{int(tp_time) % 60} ")
            self.zhuanhuangdian.setText(
                f"转黄点: {maillard}℃ / {int(maillard_time) // 60}:{int(maillard_time) % 60} ")
            self.dtrTxt.setText(f"DTR: {dtr}%")
            self.yibao.setText(f"一爆: {fCs_BT}℃ / {int(fCs_time) // 60}:{int(fCs_time) % 60} ")
            self.fazhanshichang.setText(f"发展时长: {int(finishphasetime) // 60}:{int(finishphasetime) % 60} ")
            self.dtrTxt.setText('DTR：' + str(dtr) + '%')

            self.pfTitle.setText('-')
            self.sdzl.setText(f"{number}g")
            self.hslTxt.setText(f"{number_of_beans}g")

            self.agtronzhiNum.setText(f"#{agtron_value}")
            self.qkfkContent.setText(f"{description}")
            self.shoudouNum.setText(f"{numberOfRipe}g")
            self.hbsslNum.setText(f"{dehydration_rate}%")
            self.hbrqNum.setText(f"{bakingFinishTime}")

            self.bcpfNum.setText('-')
            self.hbpfNum.setText('-')
            self.bcrqNum.setText('-')
            self.pkfkTxt.setText('-')

            # 更新目标和实际温湿度数据
            target_temperatures = json_message.get("target_temperature", [])
            target_values = json_message.get("target_values", [])
            actual_temperatures = json_message.get("actual_temperature", [])
            actual_values = json_message.get("actual_values", [])

            for i in range(6):
                getattr(self, f"wendu{i + 1}Txt").setText(
                    f"{target_temperatures[i]}℃" if i < len(target_temperatures) else "N/A")
                getattr(self, f"ckz{i + 1}Txt").setText(f"{target_values[i]}%" if i < len(target_values) else "N/A")
                getattr(self, f"sjwendu{i + 1}Txt").setText(
                    f"{actual_temperatures[i]}℃" if i < len(actual_temperatures) else "N/A")
                getattr(self, f"sjckz{i + 1}Txt").setText(f"{actual_values[i]}%" if i < len(actual_values) else "N/A")

            # 计算实际偏差百分比并显示
            for i in range(6):
                if i < len(actual_temperatures) and i < len(target_temperatures):
                    deviation = round((actual_temperatures[i] - target_temperatures[i]) / target_temperatures[i] * 100,
                                      2) if \
                        target_temperatures[i] != 0 else "N/A"
                    getattr(self, f"sjpc{i + 1}Txt").setText(f"{deviation}%")
                else:
                    getattr(self, f"sjpc{i + 1}Txt").setText("N/A")

            print("JSON 数据加载完成")
        except Exception as e:
            print(f"加载 JSON 文件时出错: {e}")

    def analyseClick(self):
        """
        Analyse click handler to populate the history analysis view.
        """
        # 使历史分析界面和滚动区域可见
        self.historyAnalyse.setVisible(True)
        self.scroll_area.setVisible(True)
        self.scroll_area.setWidget(self.historyAnalyse)

        # 从 orderDetail 获取数据列表
        data_list = self.orderDetail
        historyOrder_count = len(data_list)


        # 遍历数据列表并动态填充数据
        for i, order in enumerate(data_list):
            # 动态设置设备和订单标题
            getattr(self, f'history_sheibei{i + 1}').setText(str(order.get('bakingBatch', '-')))
            getattr(self, f'historyOrder{i + 1}_Title').setText(str(order.get('bakingBatch', '-')))

            # 动态设置任务时间
            task_time_minutes = int(order.get('taskTime', 0)) // 60
            task_time_seconds = int(order.get('taskTime', 0)) % 60
            getattr(self, f'historyOrder{i + 1}_Time').setText(f"{task_time_minutes}:{task_time_seconds}")

            # 动态设置创建时间、脱水率、烘焙评分、Agtron值 historyOrder_hbrq1_Data
            getattr(self, f'historyOrder_hbrq{i + 1}_Data').setText(str(order.get('bakingFinishTime', '-')))
            getattr(self, f'historyOrder_hbssl{i + 1}_Data').setText(str(order.get('dehydrationRate', '-')))
            getattr(self, f'historyOrder_Agtron{i + 1}_Data').setText(str(order.get('agtronValue', '-')))

            # 设置烘焙阶段信息
            msgdata = order.get('jsonMessage', {})
            if msgdata:
                # 获取 alogJson 数据
                alogJson = msgdata.get('alogJson', {})

                # 获取不同的 timex 数组
                timex_list = []
                temp_list = []
                for index in range(4):  # 假设我们有 4 个可能的条目（下标 0 到 3）
                    try:
                        # 获取 timex 数据，如果为空字符串或不存在，使用空列表
                        timex_data = data_list[index]['jsonMessage']['alogJson'].get('timex', "")
                        if timex_data == "":  # 判断为空字符串的情况
                            timex_list.append([])
                        else:
                            timex_list.append(timex_data)
                    except (IndexError, KeyError, TypeError):
                        timex_list.append([])

                    try:
                        # 获取 temp1 数据，如果为空字符串或不存在，使用空列表
                        temp_data = data_list[index]['jsonMessage']['alogJson'].get('temp1', "")
                        if temp_data == "":  # 判断为空字符串的情况
                            temp_list.append([])
                        else:
                            temp_list.append(temp_data)
                    except (IndexError, KeyError, TypeError):
                        temp_list.append([])

                # 找到最长的 timex
                timex_lengths = [len(timex) for timex in timex_list]
                max_len_index = timex_lengths.index(max(timex_lengths))  # 获取最长 timex 的索引

                # 使用最长的 timex
                timex = timex_list[max_len_index]

                # 获取四个温度数据
                temp1, temp2, temp3, temp4 = temp_list[0], temp_list[1], temp_list[2], temp_list[3]

                # 更新图表
                self.matplotlib_widget.update_plot(timex, temp1, temp2, temp3, temp4)

                # 显示阶段点文本和几何
                stages = ['onekst', 'twokst', 'threekst', 'fourkst']
                stage_labels = ['CHARGE_BT', 'TP_BT', 'TP_time', 'Maillard', 'Maillard_time', 'FCs_BT', 'FCs_time']
                stage_positions = ['Txt1', 'Txt2', 'Txt3']
                total_time = int(msgdata.get('totaltime', 1))
                max_time_in_seconds = max(total_time, 930)  # Default max time

                order_count = historyOrder_count
                totaltimeList = []
                for i in range(order_count):
                    totaltimeList.append(total_time)

                max_time_in_seconds = max(totaltimeList)
                max_time_in_minutes = int(max_time_in_seconds) // 60

                # 创建时间数量小部件
                timeNumWidget = QWidget(self.historyAnalyse)
                timeNumWidget.setStyleSheet("background-color: transparent; border:none; color: #222222;")

                # 创建横向布局并添加到小部件
                timeNumLayout = QHBoxLayout(timeNumWidget)

                # 初始化并设置时间标签
                for minute in range(max_time_in_minutes):  # +1 包含最大分钟数
                    self.analyseTimeNum = QLabel(f"{minute}", self.historyAnalyse)
                    self.analyseTimeNum.setFixedHeight(30)
                    self.analyseTimeNum.setStyleSheet("background-color: transparent; border:none;color: #292827;")
                    analyseTimeNumfont = QFont(self.font_family4, 18 * self.width_scale)
                    self.analyseTimeNum.setFont(analyseTimeNumfont)

                    timeNumLayout.addWidget(self.analyseTimeNum)

                timeNumLayout.addWidget(self.analyseTimeNum)

                # 将小部件添加到布局中（确保设置大小）
                timeNumWidget.setFixedHeight(34 * self.height_scale)  # 设置高度
                timeNumWidget.setGeometry(148 * self.width_scale, 1290 * self.height_scale, 1384 * self.width_scale,
                                          34 * self.height_scale)  # 如果必要，可以设置几何形状
                timeNumWidget.show()  # 确保小部件可见

                for idx, stage in enumerate(stages):
                    if idx >= len(data_list):
                        break
                    stage_data = data_list[idx].get('jsonMessage', {})
                    if not stage_data:
                        continue

                    phase_data = [
                        f"入豆温度: {stage_data['CHARGE_BT']}℃   回温点: {stage_data['TP_BT']}℃/{stage_data['TP_time']}",
                        f"转黄点: {stage_data['Maillard']}℃/{stage_data['Maillard_time']}",
                        f"一爆: {stage_data['FCs_BT']}℃/{stage_data['FCs_time']}"
                    ]

                    phase_lengths = [
                        (total_time - int(stage_data['Maillard_time']) - int(stage_data['FCs_time'])) / total_time,
                        int(stage_data['Maillard_time']) / total_time,
                        int(stage_data['FCs_time']) / total_time
                    ]

                    position_offset = 16  # Initial offset
                    for txt_idx, txt in enumerate(stage_positions):
                        text_control = getattr(self, f"{stage}{txt}")
                        geometry_width = phase_lengths[txt_idx] * 1385 * (
                                total_time / max_time_in_seconds) * self.width_scale
                        text_control.setText(phase_data[txt_idx])
                        text_control.setGeometry(
                            position_offset * self.width_scale,
                            3 * self.height_scale,
                            geometry_width,
                            60 * self.height_scale
                        )
                        position_offset += geometry_width + 1  # Increment position for next stage

    def toggle_analyse_dw(self):
        """切换豆温曲线的显示状态"""
        is_visible = self.analyse_dw.styleSheet() == f'border-radius: {16*self.height_scale}px;background-color: #FBF8F5;border: 2px solid #D18F65'

        data_list = self.orderDetail

        if is_visible:
            # 隐藏豆温曲线
            self.analyse_dw.setStyleSheet(f'border-radius: {16*self.height_scale}px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
            self.matplotlib_widget.update_plot([], [], [], [], [])  # 清空图表
        else:
            # 显示豆温曲线
            self.analyse_dw.setStyleSheet(f'border-radius: {16*self.height_scale}px;background-color: #FBF8F5;border: 2px solid #D18F65')

            # 获取不同的 timex 数组
            timex_list = []
            temp_list = []
            for index in range(4):  # 假设我们有 4 个可能的条目（下标 0 到 3）
                try:
                    # 获取 timex 数据，如果为空字符串或不存在，使用空列表
                    timex_data = data_list[index]['jsonMessage']['alogJson'].get('timex', "")
                    if timex_data == "":  # 判断为空字符串的情况
                        timex_list.append([])
                    else:
                        timex_list.append(timex_data)
                except (IndexError, KeyError, TypeError):
                    timex_list.append([])

                try:
                    # 获取 temp1 数据，如果为空字符串或不存在，使用空列表
                    temp_data = data_list[index]['jsonMessage']['alogJson'].get('temp1', "")
                    if temp_data == "":  # 判断为空字符串的情况
                        temp_list.append([])
                    else:
                        temp_list.append(temp_data)
                except (IndexError, KeyError, TypeError):
                    temp_list.append([])

            # 找到最长的 timex
            timex_lengths = [len(timex) for timex in timex_list]
            max_len_index = timex_lengths.index(max(timex_lengths))  # 获取最长 timex 的索引

            # 使用最长的 timex
            timex = timex_list[max_len_index]

            # 获取四个温度数据
            temp1, temp2, temp3, temp4 = temp_list[0], temp_list[1], temp_list[2], temp_list[3]

            # 更新图表
            self.matplotlib_widget.update_plot(timex, temp1, temp2, temp3, temp4)
    def toggle_analyse_fw(self):
        """切换风温曲线的显示状态"""
        is_visible = self.analyse_fw.styleSheet() == f'border-radius: {16*self.height_scale}px;background-color: #FBF8F5;border: 2px solid #AC3230'
        data_list = self.orderDetail

        if is_visible:
            # 隐藏风温曲线
            self.analyse_fw.setStyleSheet(f'border-radius: {16*self.height_scale}px;background-color: #FBF8F5;border: 2px solid #CAC6C2')
            self.matplotlib_widget.update_plot([], [], [], [], [])  # 清空图表
        else:
            # 显示风温曲线
            self.analyse_fw.setStyleSheet(f'border-radius: {16*self.height_scale}px;background-color: #FBF8F5;border: 2px solid #AC3230')

            # 获取不同的 timex 数组
            timex_list = []
            temp_list = []
            for index in range(4):  # 假设我们有 4 个可能的条目（下标 0 到 3）
                try:
                    # 获取 timex 数据，如果为空字符串或不存在，使用空列表
                    timex_data = data_list[index]['jsonMessage']['alogJson'].get('timex', "")
                    if timex_data == "":  # 判断为空字符串的情况
                        timex_list.append([])
                    else:
                        timex_list.append(timex_data)
                except (IndexError, KeyError, TypeError):
                    timex_list.append([])

                try:
                    # 获取 temp1 数据，如果为空字符串或不存在，使用空列表
                    temp_data = data_list[index]['jsonMessage']['alogJson'].get('temp2', "")
                    if temp_data == "":  # 判断为空字符串的情况
                        temp_list.append([])
                    else:
                        temp_list.append(temp_data)
                except (IndexError, KeyError, TypeError):
                    temp_list.append([])

            # 找到最长的 timex
            timex_lengths = [len(timex) for timex in timex_list]
            max_len_index = timex_lengths.index(max(timex_lengths))  # 获取最长 timex 的索引

            # 使用最长的 timex
            timex = timex_list[max_len_index]

            # 获取四个温度数据
            temp1, temp2, temp3, temp4 = temp_list[0], temp_list[1], temp_list[2], temp_list[3]

            # 更新图表
            self.matplotlib_widget.update_plot(timex, temp1, temp2, temp3, temp4)

    def blockTicks(self) -> int:
        return max(1, int(round(self.sampling_seconds_to_block_quantifiction / (self.qmc.delay / 1000))) + 1)

    def setSamplingRate(self, rate: int) -> None:
        self.qmc.delay = max(self.qmc.min_delay, rate)
        self.sampling_ticks_to_block_quantifiction = self.blockTicks()  # we update the quantification block ticks

    @pyqtSlot()
    def updateMessageLog(self) -> None:
        if self.message_dlg:
            self.message_dlg.update_log()

    @pyqtSlot()
    def updateSerialLog(self) -> None:
        if self.serial_dlg:
            self.serial_dlg.update_log()

    @pyqtSlot()
    def updateErrorLog(self) -> None:
        if self.error_dlg:
            self.error_dlg.update_log()

    @pyqtSlot()
    def pidOn(self) -> None:
        self.pidcontrol.pidOn()

    @pyqtSlot()
    def pidOff(self) -> None:
        self.pidcontrol.pidOff()

    @pyqtSlot()
    def pidToggle(self) -> None:
        self.pidcontrol.togglePID()

    def zoomIn(self) -> None:
        self.setdpi(self.dpi + 10)

    def zoomOut(self) -> None:
        self.setdpi(self.dpi - 10)

    def scrollingPhases(self, event: 'MplEvent') -> Any:
        verticalScroller: Optional['QScrollBar'] = self.scroller.verticalScrollBar()
        if verticalScroller is not None:
            val = verticalScroller.value()
            if hasattr(event, 'button') and event.button == 'down':  # pyright: ignore[reportAttributeAccessIssue]
                verticalScroller.setValue(val + 10)
            else:
                verticalScroller.setValue(val - 10)

    # timer_color one of "timer" (black), "slowcoolingtimer" (red), "rstimer" (blue)
    def setTimerColor(self, timer_color: str) -> None:
        self.lcd1.setStyleSheet(
            f'QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF[timer_color]}; background-color: {self.lcdpaletteB[timer_color]};}}')
        self.qmc.setTimerLargeLCDcolorSignal.emit(self.lcdpaletteF[timer_color], self.lcdpaletteB[timer_color])
        # HACK: PID/CONTROL button changes shape/shadow on setTimerColor() as triggered by RESET
        # there reason remains unclear
        # the following prevents this
        try:
            self.buttonCONTROL.setStyleSheet(self.buttonCONTROL.styleSheet())
        except Exception:  # pylint: disable=broad-except
            pass

    def mousePressEvent(self, event: Optional['QMouseEvent']) -> None:
        super().mousePressEvent(event)
        if event is not None and event.button() == Qt.MouseButton.LeftButton:
            self.releaseminieditor()
            self.releaseSliderFocus()

    @pyqtSlot(str)
    def updateSubscription(self, subscription: str) -> None:
        _log.debug('updateSubscription(%s)', subscription)
        if subscription:
            self.plus_subscription = subscription
        else:
            self.plus_subscription = None

    # if any of the parameters is <0 the corresponding variable is not updated
    def updatePlusLimits(self, rlimit: float, used: float) -> None:
        _log.debug('updatePlusLimits(%s, %s)', rlimit, used)
        if rlimit > -1:
            self.plus_rlimit = rlimit
        if used > -1:
            self.plus_used = used

    # if pu is "" the corresponding variable is not updated
    def updatePlusPaidUntil(self, pu: str) -> None:
        _log.debug('updatePlusPaidUntil(%s)', pu)
        try:
            if pu != '':
                self.plus_paidUntil = (
                    dateutil.parser.parse(pu)
                )
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    # if rlimit = -1 or rused = -1 or pu = "", no update information is available and the state is not updated
    @pyqtSlot(float, float, str, int, list)
    def updateLimits(self, rlimit: float, rused: float, pu: str, notifications: int, machines: List[
        str]) -> None:  # for Python >= 3.9 can replace 'List' with the generic type hint 'list'
        _log.debug('updateLimits(%s,%s,%s,%s,%s)', rlimit, rused, pu, notifications, machines)
        self.updatePlusLimits(rlimit, rused)
        self.updatePlusPaidUntil(pu)
        self.updatePlusStatus()
        plus.notifications.updateNotifications(notifications, machines)

    @pyqtSlot(str, str, NotificationType)
    def sendNotificationMessage(self, title: str, message: str, notification_type: NotificationType) -> None:
        if self.notificationManager:
            self.notificationManager.sendNotificationMessage(title.strip(), message.strip(), notification_type)

    # cache curve visibilities on recording start to be able to revert to users settings after recording
    def cacheCurveVisibilities(self) -> None:
        self.qmc.curveVisibilityCache = (
            self.qmc.BTcurve,
            self.qmc.ETcurve,
            self.qmc.DeltaBTflag,
            self.qmc.DeltaETflag,
            self.extraCurveVisibility1,
            self.extraCurveVisibility2,
        )

    # revert curve visibilities to user settings after recording
    def resetCurveVisibilities(self) -> None:
        if self.qmc.curveVisibilityCache is not None:
            (self.qmc.BTcurve,
             self.qmc.ETcurve,
             self.qmc.DeltaBTflag,
             self.qmc.DeltaETflag,
             self.extraCurveVisibility1,
             self.extraCurveVisibility2) = self.qmc.curveVisibilityCache

    @pyqtSlot()
    def toggleBTlcdCurve(self) -> None:
        if self.qmc.swaplcds:
            self.toggleETCurve()
        else:
            self.toggleBTCurve()

    @pyqtSlot()
    def toggleETlcdCurve(self) -> None:
        if self.qmc.swaplcds:
            self.toggleBTCurve()
        else:
            self.toggleETCurve()

    def toggleBTCurve(self) -> None:
        if len(self.qmc.temp2) > 20:
            # only if some data is given to have a visible clue
            self.qmc.BTcurve = not self.qmc.BTcurve
            # we reset the cached main event annotation positions as those annotations are now rendered on the other curve
            self.qmc.l_annotations_dict = {}
            # and redraw
            self.qmc.redraw_keep_view(recomputeAllDeltas=False)

    def toggleETCurve(self) -> None:
        if len(self.qmc.temp1) > 20:
            # only if some data is given to have a visible clue
            self.qmc.ETcurve = not self.qmc.ETcurve
            # we reset the cached main event annotation positions as those annotations are now rendered on the other curve
            self.qmc.l_annotations_dict = {}
            self.qmc.redraw_keep_view(recomputeAllDeltas=False)

    @pyqtSlot()
    def toggleDeltaETlcdCurve(self) -> None:
        if self.qmc.swapdeltalcds:
            self.toggleDeltaBTCurve()
        else:
            self.toggleDeltaETCurve()

    @pyqtSlot()
    def toggleDeltaBTlcdCurve(self) -> None:
        if self.qmc.swapdeltalcds:
            self.toggleDeltaETCurve()
        else:
            self.toggleDeltaBTCurve()

    def toggleDeltaETCurve(self) -> None:
        if len(self.qmc.delta1) > 20:
            # only if some data is given to have a visible clue
            twoAxis_before = self.qmc.twoAxisMode()
            self.qmc.DeltaETflag = not self.qmc.DeltaETflag
            twoAxis_after = self.qmc.twoAxisMode()
            self.qmc.redraw_keep_view(recomputeAllDeltas=False, forceRenewAxis=twoAxis_before != twoAxis_after)

    def toggleDeltaBTCurve(self) -> None:
        if len(self.qmc.delta2) > 20:
            # only if some data is given to have a visible clue
            twoAxis_before = self.qmc.twoAxisMode()
            self.qmc.DeltaBTflag = not self.qmc.DeltaBTflag
            twoAxis_after = self.qmc.twoAxisMode()
            self.qmc.redraw_keep_view(recomputeAllDeltas=False, forceRenewAxis=twoAxis_before != twoAxis_after)

    @pyqtSlot()
    def toggleExtraCurve1(self) -> None:
        try:
            sender = self.sender()
            assert isinstance(sender, ClickableLCDFrame)
            i = self.extraLCDframe1.index(sender)
            if len(self.qmc.extratemp1[i]) > 20:
                # only if some data is given to have a visible clue
                self.extraCurveVisibility1[i] = not self.extraCurveVisibility1[i]
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        self.qmc.redraw_keep_view(recomputeAllDeltas=False)

    @pyqtSlot()
    def toggleExtraCurve2(self) -> None:
        try:
            sender = self.sender()
            assert isinstance(sender, ClickableLCDFrame)
            i = self.extraLCDframe2.index(sender)
            if len(self.qmc.extratemp2[i]) > 20:
                # only if some data is given to have a visible clue
                self.extraCurveVisibility2[i] = not self.extraCurveVisibility2[i]
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        self.qmc.redraw_keep_view(recomputeAllDeltas=False)

    def addLanguage(self, locale: str, menu_entry: str) -> None:
        languageAction = QAction(menu_entry, self)
        languageAction.setCheckable(True)
        languageAction.triggered.connect(self.change_local_action)
        self.language_menu_actions[locale] = languageAction
        if self.languageMenu is not None:
            self.languageMenu.addAction(languageAction)
        if self.locale_str == locale:
            languageAction.setChecked(True)

    def sendLog(self) -> None:
        _log.info('sendLog()')

        from email import encoders, generator
        from email.mime.base import MIMEBase
        from email.mime.multipart import MIMEMultipart
        from email.mime.text import MIMEText

        message = MIMEMultipart()
        if self.plus_email is not None:
            message['From'] = self.plus_email
        message['To'] = f"{'logfile'}@{'artisan.plus'}"
        message['Subject'] = 'artisan log'
        message['X-Unsent'] = '1'
        # message["X-Uniform-Type-Identifier"] = "com.apple.mail-draft"
        message.attach(
            MIMEText(
                f"Please find attached the log files written by Artisan!\nPlease forward this email to {message['To']}\n--\n",
                'plain',
            )
        )
        # try:
        #     directory = getDataDirectory()
        #     if directory is not None:
        #         for log_file_name in ['artisan.log', 'artisanViewer.log']:
        #             try:
        #                 with open(os.path.join(directory, os.path.normpath(log_file_name)), 'rb') as attachment:
        #                     # Add file as application/octet-stream
        #                     # Email client can usually download this automatically
        #                     # as attachment
        #                     part = MIMEBase('application', 'octet-stream')
        #                     part.set_payload(attachment.read())
        #                 # Encode file in ASCII characters to send by email
        #                 encoders.encode_base64(part)
        #                 # Add header as key/value pair to attachment part
        #                 part.add_header(
        #                     'Content-Disposition',
        #                     f'attachment; filename= {log_file_name}',
        #                 )
        #                 # Add attachment to message and convert message to string
        #                 message.attach(part)
        #             except FileNotFoundError:
        #                 _log.debug('log file %s not found', log_file_name)
        # except Exception as e:  # pylint: disable=broad-except
        #     _log.exception(e)
        try:
            with open(self.qmc.device_log_file, 'rb') as attachment:
                # Add file as application/octet-stream
                # Email client can usually download this automatically
                # as attachment
                part2 = MIMEBase('application', 'octet-stream')
                part2.set_payload(attachment.read())
            # Encode file in ASCII characters to send by email
            encoders.encode_base64(part2)
            # Add header as key/value pair to attachment part
            part2.add_header(
                'Content-Disposition',
                f'attachment; filename= {self.qmc.device_log_file_name}.log'
            )
            # Add attachment to message and convert message to string
            message.attach(part2)
        except FileNotFoundError:
            _log.debug('log file %s not found', self.qmc.device_log_file)
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        # Save message to file tmp file
        tmpfile = QDir(QDir.tempPath()).filePath('plus-log.eml')
        try:
            os.remove(tmpfile)
        except OSError:
            pass
        with open(tmpfile, 'w', encoding='utf-8') as outfile:
            gen = generator.Generator(outfile)
            gen.flatten(message)
        QDesktopServices.openUrl(QUrl.fromLocalFile(tmpfile))

    def updateWindowTitle(self) -> None:
        try:
            appTitle = f'{(application_viewer_name if self.app.artisanviewerMode else application_name)} {str(__version__)}'
            dirtySign = '* ' if self.qmc.safesaveflag else ''
            if self.simulator is not None and self.simulatorpath:
                # simulator running
                speed = int(self.qmc.timeclock.getBase() / 1000)
                self.setWindowTitle(f'@{speed}x {self.strippedName(self.simulatorpath)} ** {appTitle}')
            elif self.curFile:
                # profile loaded
                self.setWindowTitle(f'{dirtySign}{self.strippedName(self.curFile)} – {appTitle}')
            # no profile loaded
            elif __release_sponsor_name__:
                self.setWindowTitle(
                    f"{dirtySign}{appTitle} – {__release_sponsor_name__} ({QApplication.translate('About', 'Release Sponsor')})")
            else:
                self.setWindowTitle(f'{dirtySign}{appTitle}')
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    @staticmethod
    def resetDonateCounter() -> None:
        settings = QSettings()
        settings.setValue('lastdonationpopup', int(libtime.time()))
        settings.setValue('starts', 0)
        settings.sync()
        if settings.status() != QSettings.Status.NoError:
            _log.error('Failed to save lastdonationpopup settings')

    @pyqtSlot()
    def logStartupTime(self) -> None:  # pylint: disable=no-self-use # used as slot
        _log.info('MODE: startup time: %.2f', libtime.process_time() - startup_time)

    @pyqtSlot()
    def donate(self) -> None:
        try:
            everytime = 4 * 30 * 24 * 60 * 60  # 4 month in seconds
            everystarts = 30  # number of recordings
            starts = None
            lastdonationpopup = None
            settings = QSettings()
            if settings.contains('starts'):
                starts = toInt(settings.value('starts'))
            if settings.contains('lastdonationpopup'):
                lastdonationpopup = toInt(settings.value('lastdonationpopup'))
            now = int(libtime.time())
            # if not (settings.status() == QSettings.Status.NoError and
            #         lastdonationpopup is not None and
            #         starts is not None and
            #         (now >= lastdonationpopup > now - everytime) and
            #         0 <= starts < everystarts):
            #                message = QApplication.translate('Message', 'Artisan is free to use!<br><br>To keep it free and current please support us<br><br><a href="{0}">{0}</a><br><br>and book<br><br><a href="{1}">{1}</a><br><br>to suppress this dialog')
            #                message = message.format('https://artisan-scope.org/donate/', 'https://artisan.plus')
            # message = QApplication.translate('Message',
            #                                  'Artisan is free to use!\n\nTo keep it free and current please support us with your donation and subscribe to artisan.plus to suppress this dialog!')
            # donate_message_box = QMessageBox()
            # donate_message_box.setText(message)
            # donate_message_box.setIcon(QMessageBox.Icon.Information)
            # donate_message_box.setModal(True)
            # donate_message_box.setStandardButtons(QMessageBox.StandardButton.Cancel | QMessageBox.StandardButton.Ok)
            # donate_message_box.setDefaultButton(QMessageBox.StandardButton.Ok)
            # res = donate_message_box.exec()
            # if res == QMessageBox.StandardButton.Ok:
            #     QDesktopServices.openUrl(QUrl('https://artisan-scope.org/donate/', QUrl.ParsingMode.TolerantMode))
            # self.resetDonateCounter()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot(str)
    def setCanvasColor(self, c: str) -> None:  # pylint: disable=no-self-use # used as slot
        try:
            QColor(c)  # test if color is valid
            if 'canvas_alt' not in self.qmc.palette:
                self.qmc.palette['canvas_alt'] = self.qmc.palette['canvas']
            self.qmc.palette['canvas'] = c
            self.updateCanvasColors()
            self.qmc.redraw()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot()
    def resetCanvasColor(self) -> None:  # pylint: disable=no-self-use # used as slot
        try:
            if 'canvas_alt' in self.qmc.palette:
                self.qmc.palette['canvas'] = self.qmc.palette['canvas_alt']
                self.qmc.palette.pop('canvas_alt')
                self.updateCanvasColors()
                self.qmc.redraw()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    # takes an "Arduino" float time in seconds and returns the corresponding QTime() object
    @staticmethod
    def time2QTime(t: float) -> QTime:
        return QTime(0, int(t // 60), int(t % 60))

    @staticmethod
    def QTime2time(t: QTime) -> float:
        return t.minute() * 60 + t.second()

    def dragEnterEvent(self, event: Optional['QDragEnterEvent']) -> None:
        # pylint: disable=no-self-use # class method
        if event is not None:
            mimeData = event.mimeData()
            if mimeData is not None and mimeData.hasUrls():
                event.accept()
            else:
                event.ignore()

    def dropEvent(self, event: Optional['QDropEvent']) -> None:
        # pylint: disable=no-self-use # class method
        if event is not None:
            mimeData = event.mimeData()
            if mimeData is not None:
                urls = mimeData.urls()
                if urls and len(urls) > 0:
                    self.app.open_url(urls[0])
                    if self.comparator is not None:
                        for url in urls[0:]:
                            self.app.open_url(url)

    def showHelpDialog(self, parent: QWidget, dialog: Optional[HelpDlg], title: str, content: str) -> Optional[HelpDlg]:
        try:  # sip not supported on older PyQt versions (RPi!)
            if dialog is not None and sip.isdeleted(dialog):
                dialog = None
        except Exception:  # pylint: disable=broad-except
            pass
        if dialog is None:
            dialog = HelpDlg(parent, self, title, content)  # parent, application window, title, content
        dialog.show()
        dialog.activateWindow()
        dialog.raise_()
        return dialog

    @staticmethod
    def closeHelpDialog(dialog: Optional[HelpDlg]) -> None:
        if dialog is not None:
            try:
                if not sip.isdeleted(dialog):
                    dialog.close()
            except Exception:  # pylint: disable=broad-except
                try:
                    dialog.close()
                except Exception:  # pylint: disable=broad-except
                    pass

    # takes a fit from numpy.polyfit and renders it as string to be copied as symbolic formula
    @staticmethod
    def fit2str(fit: Optional['npt.NDArray[numpy.double]']) -> str:
        s = ''
        if fit is not None:
            sign = '+'
            fit = fit[::-1]
            try:
                for i, fiti in enumerate(fit):
                    v = abs(fiti)
                    if round(v, 3) != 0.0:
                        if i == 0:
                            s = f'{v:.4f}'
                        elif i == 1:
                            if s != '':
                                s = f' {sign} {s}'
                            s = f'x{s}' if v == 1 else f'{v:.4f}*x{s}'
                        else:
                            if s != '':
                                s = f' {sign} {s}'
                            s = f'x^{i}{s}' if v == 1 else f'{v:.4f}*x^{i}{s}'
                        s = s.rstrip('0').rstrip('.')
                        sign = '-' if fiti < 0 else '+'
                if sign == '-':
                    s = sign + s
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
        return s

    def eventFilter(self, obj: Optional['QObject'], event: Optional[QEvent]) -> bool:
        # pylint: disable=c-extension-no-member
        try:
            if event is not None and event.type() == QEvent.Type.ApplicationPaletteChange and self.app is not None and sys.platform.startswith(
                    'darwin') and QVersionNumber.fromString(qVersion())[0] < QVersionNumber(6, 5,
                                                                                            0) and darkdetect.isDark() != self.app.darkmode:  # pyright:ignore[reportAttributeAccessIssue,reportPossiblyUnboundVariable] # "isDark" is not a known member of module "darkdetect"
                # called if the palette changed (switch between dark and light mode on macOS Legacy builds)
                self.app.darkmode = not self.app.darkmode
                self.updateCanvasColors()
        except Exception:  # pylint: disable=broad-except
            pass
        return super().eventFilter(obj, event)

    # search the given QTable table for a row with the given widget as cellWidget or item in column col or as a sub-widget contained in the layout of a widget in place
    # returns the row number if the widget was found or None
    @staticmethod
    def findWidgetsRow(table: 'QTableWidget', widget: Union['QObject', 'QTableWidgetItem', None], col: int) -> Optional[
        int]:
        if widget is not None:
            for r in range(table.rowCount()):
                cellWidget: Optional[QWidget] = table.cellWidget(r, col)
                cellWidgetLayout: Optional[QLayout] = None
                if cellWidget == widget or table.item(r, col) == widget:
                    return r
                if cellWidget is not None:
                    cellWidgetLayout = cellWidget.layout()
                if cellWidgetLayout is not None and isinstance(widget, QWidget):
                    cw: QWidget = widget
                    if cellWidgetLayout.indexOf(cw) > -1:
                        return r
        return None

    # search the given QTable table for a column with the given widget in row
    # returns the column number if the widget was found or None
    @staticmethod
    def findWidgetsColumn(table: 'QTableWidget', widget: Union['QObject', 'QTableWidgetItem', None], row: int) -> \
            Optional[int]:
        if widget is not None:
            for c in range(table.columnCount()):
                cellWidget: Optional[QWidget] = table.cellWidget(row, c)
                cellWidgetLayout: Optional[QLayout] = None
                if cellWidget == widget or table.item(row, c) == widget:
                    return c
                if cellWidget is not None:
                    cellWidgetLayout = cellWidget.layout()
                if cellWidgetLayout is not None and isinstance(widget, QWidget):
                    cw: QWidget = widget
                    if cellWidgetLayout.indexOf(cw) > -1:
                        return c
        return None

    @pyqtSlot()
    def redraw_action(self) -> None:
        try:
            self.qmc.redraw(False, False)
        except Exception:  # pylint: disable=broad-except
            # self.qmc might not be defined yet
            pass

    # c a QColor instance, returns the standard W3C value for the perceived brightness of an RGB color in the range of 0-255, ignoring the alpha channel
    # see https://www.w3.org/TR/AERT/#color-contrast
    @staticmethod
    def QColorBrightness(c: QColor) -> float:
        r, g, b, _ = c.getRgb()
        if r is not None and g is not None and b is not None:
            return ((r * 299) + (g * 587) + (b * 114)) / 1000
        return 127

    # this is important to have . as decimal separator independent of the systems locale
    @staticmethod
    def createCLocaleDoubleValidator(bot: float, top: float, dec: int, w: QLineEdit) -> MyQDoubleValidator:
        validator = MyQDoubleValidator(bot, top, dec, w)
        validator.setLocale(QLocale.c())
        validator.setNotation(QDoubleValidator.Notation.StandardNotation)
        return validator

    #    @pyqtSlot()
    #    def mainButtonPressed(self):
    #        self.sender().setGraphicsEffect(self.makeShadow(strong=True))
    #
    #    @pyqtSlot()
    #    def mainButtonReleased(self):
    #        self.sender().setGraphicsEffect(self.makeShadow())

    @pyqtSlot(QPoint)
    def setTareET(self, _: QPoint) -> None:
        if not self.qmc.swaplcds:
            self.setTare(0)
        else:
            self.setTare(1)

    @pyqtSlot(QPoint)
    def setTareBT(self, _: QPoint) -> None:
        if not self.qmc.swaplcds:
            self.setTare(1)
        else:
            self.setTare(0)

    @pyqtSlot(QPoint)
    def setTare_slot(self, _: QPoint) -> None:
        sender = self.sender()
        try:
            assert isinstance(sender, ClickableLCDFrame)
            idx = self.extraLCDframe1.index(sender)
            self.setTare(2 + idx * 2)
        except Exception:  # pylint: disable=broad-except
            pass
        try:
            assert isinstance(sender, ClickableLCDFrame)
            idx = self.extraLCDframe2.index(sender)
            self.setTare(2 + idx * 2 + 1)
        except Exception:  # pylint: disable=broad-except
            pass

    # set the tare values per channel (0: ET, 1:BT, 2:E1c0, 3:E1c1, 4:E1c0, 5:E1c1,...)
    @pyqtSlot(int)
    def setTare(self, n: int) -> None:
        if self.qmc.flagon:  # we set the tare value
            if n == 0:
                temp = (self.qmc.temp1 if self.qmc.flagstart else self.qmc.on_temp1)
                symb_formula = self.qmc.ETfunction.strip()
            elif n == 1:
                temp = (self.qmc.temp2 if self.qmc.flagstart else self.qmc.on_temp2)
                symb_formula = self.qmc.BTfunction.strip()
            else:
                i = (n - 2) // 2
                if n % 2 == 0:  # even
                    temp = (self.qmc.extratemp1[i] if self.qmc.flagstart else self.qmc.on_extratemp1[i])
                    symb_formula = self.qmc.extramathexpression1[i].strip()
                else:
                    temp = (self.qmc.extratemp2[i] if self.qmc.flagstart else self.qmc.on_extratemp2[i])
                    symb_formula = self.qmc.extramathexpression2[i].strip()
            postfix = temp[-3:]
            if len(postfix) > 0:
                stable_reading = float(numpy.median(postfix))
                if symb_formula == '':
                    self.channel_tare_values[n] = stable_reading
                else:
                    self.channel_tare_values[n] = self.channel_tare_values[n] + stable_reading
        else:  # we reset the tare value
            self.channel_tare_values[n] = 0

    # PLUS
    @pyqtSlot()
    def updatePlusStatusSlot(self) -> None:
        self.updatePlusStatus()

    def updatePlusStatus(self, ntb: Optional[VMToolbar] = None) -> None:
        if ntb is None:
            ntb = self.ntb
        try:
            subscription_icon = None
            if self.plus_account is not None:
                if plus.controller.is_connected():
                    if self.editgraphdialog is False:
                        # syncing from server in progress
                        plus_icon = 'plus-dirty'
                        tooltip = QApplication.translate('Tooltip', 'Syncing with artisan.plus')
                    elif plus.controller.is_synced():
                        plus_icon = 'plus-connected'
                        tooltip = QApplication.translate('Tooltip', 'Disconnect artisan.plus')
                    else:
                        plus_icon = 'plus-unsynced'
                        tooltip = QApplication.translate('Tooltip', 'Upload to artisan.plus')
                    if self.plus_subscription == 'HOME':
                        subscription_icon = 'plus-home'
                        if self.plus_paidUntil is not None:
                            remaining_days = (self.plus_paidUntil.date() - datetime.datetime.now(
                                datetime.timezone.utc).date()).days
                            if remaining_days <= 0:
                                subscription_icon = 'plus-home-off'
                            elif remaining_days < 31:
                                subscription_icon = 'plus-home-low'
                            if self.plus_rlimit > 0:
                                percent_used = self.plus_used / (self.plus_rlimit / 100)
                                if percent_used >= 100:
                                    subscription_icon = 'plus-home-off'
                                elif percent_used >= 90:
                                    subscription_icon = 'plus-home-low'
                    elif self.plus_subscription == 'PRO':
                        subscription_icon = 'plus-pro'
                        if self.plus_paidUntil is not None:
                            remaining_days = (self.plus_paidUntil.date() - datetime.datetime.now(
                                datetime.timezone.utc).date()).days
                            if remaining_days <= 0:
                                subscription_icon = 'plus-pro-off'
                            elif remaining_days < 31:
                                subscription_icon = 'plus-pro-low'
                            if self.plus_rlimit > 0:
                                percent_used = self.plus_used / (self.plus_rlimit / 100)
                                if percent_used >= 100:
                                    subscription_icon = 'plus-pro-off'
                                elif percent_used >= 90:
                                    subscription_icon = 'plus-pro-low'
                else:
                    plus_icon = 'plus-on'
                    tooltip = QApplication.translate('Tooltip', 'Disconnect artisan.plus')
            else:
                plus_icon = 'plus-off'
                tooltip = QApplication.translate('Tooltip', 'Connect artisan.plus')
            if svgsupport:
                plus_icon += '.svg'
            else:
                plus_icon += '.png'
            if subscription_icon is not None:
                if svgsupport:
                    subscription_icon += '.svg'
                else:
                    subscription_icon += '.png'
            if ntb is not None and len(ntb.actions()) > 0:
                a = ntb.actions()[0]  # the plus action is the first one
                a.setIcon(ntb._icon(plus_icon))  # pylint: disable=protected-access
                a.setToolTip(tooltip)
                if len(ntb.actions()) > 1:
                    a = ntb.actions()[1]  # the plus subscription action is the second one
                    if subscription_icon is None:
                        a.setEnabled(False)
                        a.setIcon(QIcon())
                    else:
                        a.setEnabled(True)
                        a.setIcon(ntb._icon(subscription_icon))  # pylint: disable=protected-access
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' updatePlusStatus(): {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

    # turns channel off after millis
    @pyqtSlot(int, int, str)
    @pyqtSlot(int, int, str, str)
    def processSingleShotPhidgetsPulse(self, channel: int, millis: int, fct: str, serial: Optional[str] = None) -> None:
        if fct == 'OUTsetPWM':
            QTimer.singleShot(int(round(millis)), lambda: self.ser.phidgetOUTsetPWM(channel, 0, serial))
        elif fct == 'OUTsetPWMhub':
            QTimer.singleShot(int(round(millis)), lambda: self.ser.phidgetOUTsetPWMhub(channel, 0, serial))
        elif fct == 'BinaryOUTset':
            QTimer.singleShot(int(round(millis)), lambda: (None if self.ser.phidgetBinaryOUTset(channel, False,
                                                                                                serial) else None))  # return None to fulfill the type signature of QTimer.singleShot()

    ###################################   APPLICATION WINDOW (AW) FUNCTIONS  #####################################

    # if recurse is True (default) and no selection exists, all is selected before calling the copy function again
    def copy_cells_to_clipboard(self, table_widget: 'QTableWidget', adjustment: int = 0,
                                recurse: bool = True) -> None:  # adjustment bitwise 0:None, 1: add leading tab to header, 2: add leading tab to first data row, 4: remove extra cell at the end of header
        sm = table_widget.selectionModel()
        if sm is not None and len(sm.selectedIndexes()) > 0:
            sel_indexes = sm.selectedIndexes()
            # sort select indexes into rows and columns
            previous = sel_indexes[0]
            columns: List[List[Any]] = []
            rows: List[Any] = []
            for index in sel_indexes:
                if previous.row() != index.row():
                    columns.append(rows)
                    rows = []
                rows.append(index.data())
                previous = index
            columns.append(rows)

            # add rows and columns to clipboard
            clipboard = ''
            nrows = len(columns)
            ncols = len(columns[0])
            if adjustment & 4:
                ncols = ncols - 1

            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.KeyboardModifier.AltModifier:  # alt click
                import prettytable  # @UnresolvedImport
                tbl = prettytable.PrettyTable()
                re_strip = re.compile('[\u2009]')  # thin space is not read properly by prettytable
                fields = []
                if adjustment & 1:
                    fields.append(' ')
                for c in range(ncols):
                    hhi = table_widget.horizontalHeaderItem(c)
                    if hhi is not None:
                        hdr = re_strip.sub('', hhi.text())
                        # protect against duplicate header labels
                        while hdr in fields:
                            hdr = hdr + ' '
                        fields.append(hdr)
                tbl.field_names = fields
                for r in range(nrows):
                    tblrows = []
                    if adjustment & 2 and r == 0:
                        tblrows.append(' ')
                    for c in range(ncols):
                        if columns[r][c] is not None:
                            entry = columns[r][c]
                            idx = entry.rfind(' ')
                            if idx > -1 and c == 0:
                                tblrows.append(entry[:idx])
                                tblrows.append(entry[idx + 1:])
                            else:
                                tblrows.append(entry)
                    tbl.add_row(tblrows)
                clipboard = tbl.get_string()
            else:
                if adjustment & 1:
                    clipboard += '' + '\t'
                for c in range(ncols):
                    hhi = table_widget.horizontalHeaderItem(c)
                    if hhi is not None:
                        clipboard += hhi.text()
                        if c != (ncols - 1):
                            clipboard += '\t'
                clipboard += '\n'
                if adjustment & 2:
                    clipboard += '' + '\t'
                for r in range(nrows):
                    for c in range(ncols):
                        if columns[r][c] is not None:
                            entry = columns[r][c]
                            idx = entry.rfind(' ')
                            if idx > -1 and c == 0:
                                entry = entry[:idx] + '\t' + entry[idx + 1:]
                            clipboard += entry
                            if c != (ncols - 1):
                                clipboard += '\t'
                    clipboard = clipboard + '\n'
            # copy to the system clipboard
            sys_clip: Optional['QClipboard'] = QApplication.clipboard()
            if sys_clip is not None:
                sys_clip.setText(clipboard)
        # if nothing is selected, temporary select all and try to copy
        elif recurse:
            table_widget.selectAll()
            self.copy_cells_to_clipboard(table_widget, adjustment, False)
            table_widget.clearSelection()

    @staticmethod
    def createRecentRoast(
            title: str, beans: str, weightIn: float,
            weightUnit: str, volumeIn: float, volumeUnit: str, densityWeight: float, beanSize_min: int,
            beanSize_max: int,
            moistureGreen: float, colorSystem: str, file: Optional[str], roastUUID: Optional[str],
            batchnr: int, batchprefix: str, plus_account: Optional[str], plus_store: Optional[str],
            plus_store_label: Optional[str], plus_coffee: Optional[str],
            plus_coffee_label: Optional[str], plus_blend_label: Optional[str],
            plus_blend_spec: Optional[plus.stock.Blend], plus_blend_spec_labels: Optional[List[str]],
            weightOut: Optional[float], volumeOut: Optional[float], densityRoasted: Optional[float],
            moistureRoasted: Optional[float], wholeColor: Optional[int], groundColor: Optional[int]) -> 'RecentRoast':
        d: RecentRoast = {
            'title': title,
            'weightIn': weightIn,
            'weightUnit': weightUnit,
        }
        d['beans'] = beans
        if weightOut is not None:
            d['weightOut'] = weightOut
        d['volumeIn'] = volumeIn
        if volumeOut is not None:
            d['volumeOut'] = volumeOut
        d['volumeUnit'] = volumeUnit
        d['densityWeight'] = densityWeight
        #        d["densityWeightUnit"] = densityWeightUnit
        #        d["densityVolume"] = densityVolume
        #        d["densityVolumeUnit"] = densityVolumeUnit
        if densityRoasted is not None:
            d['densityRoasted'] = densityRoasted
        d['beanSize_min'] = beanSize_min
        d['beanSize_max'] = beanSize_max
        d['moistureGreen'] = moistureGreen
        if moistureRoasted is not None:
            d['moistureRoasted'] = moistureRoasted
        if wholeColor is not None:
            d['wholeColor'] = wholeColor
        if groundColor is not None:
            d['groundColor'] = groundColor
        if colorSystem is not None:
            d['colorSystem'] = colorSystem
        d['background'] = file
        d['roastUUID'] = roastUUID
        d['batchnr'] = batchnr
        d['batchprefix'] = batchprefix
        d['plus_account'] = plus_account
        d['plus_store'] = plus_store
        d['plus_store_label'] = plus_store_label
        d['plus_coffee'] = plus_coffee
        d['plus_coffee_label'] = plus_coffee_label
        d['plus_blend_label'] = plus_blend_label
        d['plus_blend_spec'] = plus_blend_spec
        d['plus_blend_spec_labels'] = plus_blend_spec_labels
        return d

    # recentRoast activated via NEW
    def setRecentRoast(self, rr: 'RecentRoast') -> None:
        if 'title' in rr and rr['title'] is not None:
            self.qmc.title = rr['title']
            if not self.qmc.flagstart or self.qmc.title_show_always:
                self.qmc.setProfileTitle(self.qmc.title, updatebackground=True)
        if 'weightIn' in rr and 'weightUnit' in rr and rr['weightIn'] is not None and rr['weightUnit'] is not None:
            self.qmc.weight = (rr['weightIn'], self.qmc.weight[1], rr['weightUnit'])
        if 'weightOut' in rr and 'weightUnit' in rr and rr['weightOut'] is not None and rr['weightUnit'] is not None:
            self.qmc.weight = (self.qmc.weight[0], rr['weightOut'], rr['weightUnit'])
        else:
            self.qmc.weight = (self.qmc.weight[0], 0, self.qmc.weight[2])
        if 'volumeIn' in rr and 'volumeUnit' in rr and rr['volumeIn'] is not None and rr['volumeUnit'] is not None:
            self.qmc.volume = (rr['volumeIn'], self.qmc.volume[1], rr['volumeUnit'])
        if 'volumeOut' in rr and 'volumeUnit' in rr and rr['volumeOut'] is not None and rr['volumeUnit'] is not None:
            self.qmc.volume = (self.qmc.volume[0], rr['volumeOut'], rr['volumeUnit'])
        else:
            self.qmc.volume = (self.qmc.volume[0], 0, self.qmc.volume[2])
        if 'densityWeight' in rr and rr['densityWeight'] is not None:
            self.qmc.density = (rr['densityWeight'], self.qmc.density[1], self.qmc.density[2], self.qmc.density[3])
        if 'densityRoasted' in rr and rr['densityRoasted'] is not None:
            self.qmc.density_roasted = (
                rr['densityRoasted'], self.qmc.density_roasted[1], self.qmc.density_roasted[2],
                self.qmc.density_roasted[3])
        else:
            self.qmc.density_roasted = (
                0, self.qmc.density_roasted[1], self.qmc.density_roasted[2], self.qmc.density_roasted[3])
        if 'beans' in rr and rr['beans'] is not None:
            self.qmc.beans = rr['beans']
        if 'beanSize_min' in rr and rr['beanSize_min'] is not None:
            self.qmc.beansize_min = int(rr['beanSize_min'])
        if 'beanSize_max' in rr and rr['beanSize_max'] is not None:
            self.qmc.beansize_max = int(rr['beanSize_max'])
        if 'moistureGreen' in rr and rr['moistureGreen'] is not None:
            self.qmc.moisture_greens = rr['moistureGreen']
        if 'moistureRoasted' in rr and rr['moistureRoasted'] is not None:
            self.qmc.moisture_roasted = rr['moistureRoasted']
        else:
            self.qmc.moisture_roasted = 0
        if 'wholeColor' in rr and rr['wholeColor'] is not None:
            self.qmc.whole_color = rr['wholeColor']
        else:
            self.qmc.whole_color = 0
        if 'groundColor' in rr and rr['groundColor'] is not None:
            self.qmc.ground_color = rr['groundColor']
        else:
            self.qmc.ground_color = 0
        if 'colorSystem' in rr and rr['colorSystem'] is not None:
            if rr['colorSystem'] in self.qmc.color_systems:
                self.qmc.color_system_idx = self.qmc.color_systems.index(rr['colorSystem'])
            elif isinstance(rr['colorSystem'], int) and rr['colorSystem'] < len(self.qmc.color_systems):  # type: ignore
                # to stay compatible with older versions were rr['colorSystem'] was an index instead of the name of a system
                self.qmc.color_system_idx = rr['colorSystem']  # type: ignore[unreachable]

        # Note: the background profile will not be changed if recent roast is activated from Roast Properties
        # PLUS
        if self.plus_account is not None and 'plus_account' in rr and self.plus_account == rr['plus_account']:
            if 'plus_store' in rr:
                self.qmc.plus_store = rr['plus_store']
            if 'plus_store_label' in rr:
                self.qmc.plus_store_label = rr['plus_store_label']
            if 'plus_coffee' in rr:
                self.qmc.plus_coffee = rr['plus_coffee']
            if 'plus_coffee_label' in rr:
                self.qmc.plus_coffee_label = rr['plus_coffee_label']
            if 'plus_blend_label' in rr:
                self.qmc.plus_blend_label = rr['plus_blend_label']
            if 'plus_blend_spec' in rr:
                self.qmc.plus_blend_spec = rr['plus_blend_spec']
            if 'plus_blend_spec_labels' in rr:
                self.qmc.plus_blend_spec_labels = rr['plus_blend_spec_labels']
            if self.qmc.plus_default_store is not None and self.qmc.plus_default_store != self.qmc.plus_store:
                self.qmc.plus_default_store = None  # we reset the defaultstore
            # update blend spec/label/spec_labels and other attributes from current stock
            if self.qmc.plus_blend_spec is not None and 'hr_id' in self.qmc.plus_blend_spec and self.qmc.plus_store is not None:
                try:
                    weight_unit_idx = self.qmc.weight_units.index(rr['weightUnit'])
                    blends = plus.stock.getBlends(weight_unit_idx, self.qmc.plus_store)
                    blend = next(b for b in blends if \
                                 plus.stock.getBlendId(b) == self.qmc.plus_blend_spec['hr_id'] and
                                 plus.stock.getBlendStockDict(b)['location_hr_id'] == self.qmc.plus_store)
                    w = self.convertWeight(self.qmc.weight[0], weight_unit_idx,
                                           self.qmc.weight_units.index('Kg'))  # w is weightIn converted to kg
                    bd: plus.stock.Blend = plus.stock.getBlendBlendDict(blend, w)
                    self.qmc.plus_blend_label = bd['label']
                    if self.qmc.plus_blend_spec is not None:
                        self.qmc.plus_blend_spec_labels = [i['label'] for i in self.qmc.plus_blend_spec['ingredients']]
                        self.qmc.beans = '\n'.join(
                            plus.stock.blend2beans(blend, weight_unit_idx, self.qmc.weight[0]))
                        if 'moisture' in bd and bd['moisture'] is not None:
                            self.qmc.moisture_greens = bd['moisture']
                        else:
                            self.qmc.moisture_greens = 0
                        if 'density' in bd and bd['density'] is not None:
                            density = bd['density']
                        else:
                            density = 0
                        self.qmc.density = (density, self.qmc.density[1], self.qmc.density[2], self.qmc.density[3])
                        if 'screen_min' in bd and bd['screen_min'] is not None:
                            self.qmc.beansize_min = bd['screen_min']
                        else:
                            self.qmc.beansize_min = 0
                        if 'screen_max' in bd and bd['screen_max'] is not None:
                            self.qmc.beansize_max = bd['screen_max']
                        else:
                            self.qmc.beansize_max = 0
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
        self.sendmessage(
            QApplication.translate('Message', f"Recent roast properties '{self.recentRoastLabel(rr)}' set"))

    # returns the list of recentRoasts with the first entry with the given title, weight and weightunit removed
    def delRecentRoast(self, title: str, weightIn: float, weightUnit: str) -> List['RecentRoast']:
        # check for duplications
        entry_with_same_title = None
        for i, rr in enumerate(self.recentRoasts):
            if 'title' in rr and 'weightIn' in rr and 'weightUnit' in rr and rr['title'] == title and rr[
                'weightIn'] == weightIn and rr['weightUnit'] == weightUnit:
                entry_with_same_title = i
                break
        if entry_with_same_title is not None:
            # we remove the duplicate entry first
            return self.recentRoasts[:entry_with_same_title] + self.recentRoasts[entry_with_same_title + 1:]
        return self.recentRoasts

    # d is a recentRoast dict
    def addRecentRoast(self, d: 'RecentRoast') -> None:
        try:
            # check for duplications
            rr = self.delRecentRoast(d['title'], d['weightIn'], d['weightUnit'])
            self.recentRoasts = [d] + rr[:self.maxRecentRoasts - 1]
            self.updateNewMenuRecentRoasts()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' addRecentRoast(): {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

    @staticmethod
    def recentRoastLabel(rr: 'RecentRoast') -> str:
        return f"{rr['title']} ({rr['weightIn']:g}{rr['weightUnit']})"

    @pyqtSlot(bool)
    def newRecentRoast(self, _checked: bool = False) -> None:
        action = self.sender()
        if action:
            modifiers = QApplication.keyboardModifiers()
            alt_modifier = modifiers == Qt.KeyboardModifier.AltModifier
            if hasattr(action, 'data'):
                rr = action.data()
                if 'background' in rr and rr['background'] is not None and rr['background'] != '':
                    background_UUID = rr.get('roastUUID', None)
                    self.qmc.resetlinecountcaches()
                    if self.loadbackgroundUUID(rr['background'], background_UUID):
                        try:
                            self.qmc.background = not self.qmc.hideBgafterprofileload
                            self.qmc.timealign(redraw=False)
                            self.qmc.redraw()
                        except Exception as e:  # pylint: disable=broad-except
                            _log.exception(e)
                if alt_modifier:
                    if self.qmc.flagon:
                        self.setRecentRoast(rr)
                    # only in off mode we first do a reset
                    elif self.qmc.reset():
                        # and if successful (not canceled) we set just the recent roast properties without starting a new roast
                        self.setRecentRoast(rr)
                # in "normal" mode, we do the NEW action
                elif self.newRoast():
                    # and then set the recent roast properties selected
                    self.setRecentRoast(rr)

    def updateNewMenuRecentRoasts(self) -> None:
        if self.newRoastMenu is not None:
            self.newRoastMenu.clear()
            # add NEW menu item
            newRoastAction = QAction(QApplication.translate('Menu', 'New'), self)
            newRoastAction.setShortcut(QKeySequence.StandardKey.New)
            newRoastAction.triggered.connect(
                self.newRoast)  # pyright: ignore [reportGeneralTypeIssues] # error: Argument of type "(_: bool = False) -> bool" cannot be assigned to parameter "slot" of type "PYQT_SLOT" in function "connect"
            self.newRoastMenu.addAction(newRoastAction)
            # add recent roasts items
            if len(self.recentRoasts) > 0:
                self.newRoastMenu.addSeparator()
                for rr in self.recentRoasts:
                    #                act = QAction(self, visible=True,
                    #                                triggered=self.newRecentRoast)
                    act = QAction(self)
                    act.triggered.connect(self.newRecentRoast)
                    act.setData(rr)
                    act.setText(self.recentRoastLabel(rr))
                    self.newRoastMenu.addAction(act)

    def recentRoastsMenuList(self) -> List[str]:
        return [self.recentRoastLabel(rr) for rr in self.recentRoasts]

    def establish_etypes(self) -> None:
        # update ET/BT LCD label substitutions
        self.label2.setText(
            f'<big><b>{self.ETname}</b></big>'.format(self.qmc.etypes[0], self.qmc.etypes[1], self.qmc.etypes[2],
                                                      self.qmc.etypes[3]))
        # self.processInfoLabel.setText(f'<big><b>{self.ETname}</b></big>'.format(self.qmc.etypes[0],self.qmc.etypes[1],self.qmc.etypes[2],self.qmc.etypes[3]))
        self.label3.setText(
            f'<big><b>{self.BTname}</b></big>'.format(self.qmc.etypes[0], self.qmc.etypes[1], self.qmc.etypes[2],
                                                      self.qmc.etypes[3]))

        # update ET/BT Delta LCD label substitutio2ns
        self.label4.setText(
            f'{deltaLabelBigPrefix}{self.ETname}</b></big>'.format(self.qmc.etypes[0], self.qmc.etypes[1],
                                                                   self.qmc.etypes[2], self.qmc.etypes[3]))
        self.label5.setText(
            f'{deltaLabelBigPrefix}{self.BTname}</b></big>'.format(self.qmc.etypes[0], self.qmc.etypes[1],
                                                                   self.qmc.etypes[2], self.qmc.etypes[3]))
        # update extra LCD label substitutions
        for i in range(len(self.qmc.extradevices)):
            if i < len(self.qmc.extraname1):
                l1 = '<b>' + self.qmc.extraname1[i] + '</b>'
                try:
                    self.extraLCDlabel1[i].setText(
                        l1.format(self.qmc.etypes[0], self.qmc.etypes[1], self.qmc.etypes[2], self.qmc.etypes[3]))
                except Exception:  # pylint: disable=broad-except
                    self.extraLCDlabel1[i].setText(l1)
            if i < len(self.qmc.extraname2):
                l2 = '<b>' + self.qmc.extraname2[i] + '</b>'
                try:
                    self.extraLCDlabel2[i].setText(
                        l2.format(self.qmc.etypes[0], self.qmc.etypes[1], self.qmc.etypes[2], self.qmc.etypes[3]))
                except Exception:  # pylint: disable=broad-except
                    self.extraLCDlabel2[i].setText(l2)
        self.settooltip()

    def populateListMenu(self, resourceName: str, ext: str, triggered: Callable[[bool], None], menu: QMenu,
                         addMenu: bool = True,
                         forceSubmenu: bool = False) -> None:
        one_added: bool = False
        res: Dict[str, List[Tuple[str, str]]] = {}
        for root, dirs, files in os.walk(os.path.join(resourceName)):
            dirs.sort()
            files.sort()
            for fl in files:
                if fl.endswith(ext):
                    d = os.path.split(root)[-1]
                    p = os.path.join(root, fl)
                    f = fl.replace(ext, '').replace('_', ' ')
                    if len(d) > 0:
                        if d not in res:
                            res[d] = []
                        res[d].append((f, p))
        keys = list(res.keys())
        keys.sort()
        for k in keys:
            if len(res[k]) > 1:
                if len(keys) == 1 and not forceSubmenu:
                    for e in res[k]:
                        #                        a = QAction(self, visible=True, triggered=triggered)
                        a = QAction(self)
                        a.triggered.connect(triggered)

                        a.setData((e[1], str(k)))
                        if k == resourceName:
                            menu_title = str(e[0])  # + "..."
                        else:
                            menu_title = str(k) + ' ' + str(e[0])  # + "..."
                        menu_title = menu_title.replace('&',
                                                        '&&')  # a & in a menu entry is not displayed, but "&&" is displayed as "&"
                        a.setText(menu_title)
                        menu.addAction(a)
                    one_added = True
                else:
                    submenu_title = k.replace('&',
                                              '&&')  # a & in a menu entry is not displayed, but "&&" is displayed as "&"
                    submenu = menu.addMenu(submenu_title)

                    # avoid slow importing natsort
                    #                    import natsort
                    #                    sorted_subentries = natsort.natsorted(res[k],key=lambda x: x[0])
                    sorted_subentries = sorted(res[k], key=lambda x: natsort(x[0]))

                    if submenu is not None:
                        for e in sorted_subentries:  # res[k]:
                            #                            a = QAction(self, visible=True, triggered=triggered)
                            a = QAction(self)
                            a.triggered.connect(triggered)
                            a.setData((e[1], str(k)))
                            menu_title = str(e[0])
                            menu_title = menu_title.replace('&',
                                                            '&&')  # a & in a menu entry is not displayed, but "&&" is displayed as "&"
                            a.setText(menu_title)
                            submenu.addAction(a)
                            one_added = True
            else:
                entry = res[k][0]
                #                a = QAction(self, visible=True, triggered=triggered)
                a = QAction(self)
                a.triggered.connect(triggered)
                a.setData((entry[1], ''))
                if k == resourceName:
                    menu_title = str(entry[0])
                else:
                    menu_title = str(k) + ' ' + str(entry[0])
                menu_title = menu_title.replace('&',
                                                '&&')  # a & in a menu entry is not displayed, but "&&" is displayed as "&"
                a.setText(menu_title)
                menu.addAction(a)
                one_added = True
        if one_added and addMenu and self.ConfMenu is not None:
            self.ConfMenu.addMenu(menu)

    def populateMachineMenu(self) -> None:
        self.populateListMenu('localJson\Machines', '.aset', self.openMachineSettings, self.machineMenu)


    # def openMachineSettings(self, file_path: str, _checked: bool = False) -> None:
    #     # 重定向输出日志
    #     sys.stdout = open("outputttttttt.log", "w")
    #
    #     try:
    #         # 读取配置文件
    #         config = configparser.ConfigParser()
    #         config.read(file_path, encoding="utf-8")
    #
    #         # 从配置文件中提取字段
    #         data = config.get("Settings", "data", fallback="")
    #         text = config.get("Settings", "text", fallback="")
    #         modbus_host = config.get("OtherSettings", "sethost", fallback="default_host")
    #         s7_host = config.get("S7", "host", fallback="default_host")
    #         ws_host = config.get("WebSocket", "host", fallback="default_host")
    #         comport = config.get("Serial", "comport", fallback="default_comport")
    #         roastersize_setup = config.getfloat("General", "roastersize_setup_default", fallback=0.0)
    #         roasterheating_setup = config.getint("OtherSettings", "setheatingtype", fallback=0)
    #
    #         # 构建机器标签
    #         label = text if data == "" else f"{data} {text}"
    #         label = label.replace("&&", "&")
    #
    #         # 应用配置到属性
    #         self.qmc.device = config.getint("Machine", "device", fallback=0)
    #         self.qmc.machinesetup = label
    #         self.modbus.host = modbus_host
    #         self.s7.host = s7_host
    #         self.ws.host = ws_host
    #         self.ser.comport = comport
    #         self.qmc.roastersize_setup = roastersize_setup
    #         self.qmc.roasterheating_setup = roasterheating_setup
    #
    #         # 配置批量大小
    #         if self.qmc.roastersize_setup > 0:
    #             self.qmc.last_batchsize = self.qmc.roastersize_setup
    #             self.qmc.weight = (self.qmc.roastersize_setup, 0, self.qmc.weight[2])
    #
    #         # 配置加热方式
    #         self.qmc.roasterheating = int(roasterheating_setup)
    #
    #         # 加载能源负载配置（如果存在）
    #         # if "EnergyRatings" in config.sections():
    #         #     self.qmc.machinesetup_energy_ratings = {
    #         #         int(key): eval(value) for key, value in config.items("EnergyRatings")
    #         #     }
    #         #     self.qmc.restoreEnergyLoadDefaults()
    #         if self.qmc.machinesetup_energy_ratings is not None and self.qmc.roastersize_setup > 0 and self.qmc.roasterheating_setup > 0 and \
    #                 self.qmc.roasterheating_setup in self.qmc.machinesetup_energy_ratings:
    #             heating_ratings = self.qmc.machinesetup_energy_ratings[self.qmc.roasterheating_setup]
    #             if self.qmc.roastersize_setup in heating_ratings:
    #                 ratings = heating_ratings[self.qmc.roastersize_setup]
    #                 if 'loadlabels' in ratings and len(ratings['loadlabels']) == 4:
    #                     self.qmc.loadlabels_setup = ratings['loadlabels']
    #                 if 'loadratings' in ratings and len(ratings['loadratings']) == 4:
    #                     self.qmc.loadratings_setup = ratings['loadratings']
    #                 if 'ratingunits' in ratings and len(ratings['ratingunits']) == 4:
    #                     self.qmc.ratingunits_setup = ratings['ratingunits']
    #                 if 'sourcetypes' in ratings and len(ratings['sourcetypes']) == 4:
    #                     self.qmc.sourcetypes_setup = ratings['sourcetypes']
    #                 if 'load_etypes' in ratings and len(ratings['load_etypes']) == 4:
    #                     self.qmc.load_etypes_setup = ratings['load_etypes']
    #                 if 'presssure_percents' in ratings and len(ratings['presssure_percents']) == 4:
    #                     self.qmc.presssure_percents_setup = ratings['presssure_percents']
    #                 if 'loadevent_zeropcts' in ratings and len(ratings['loadevent_zeropcts']) == 4:
    #                     self.qmc.loadevent_zeropcts_setup = ratings['loadevent_zeropcts']
    #                 if 'loadevent_hundpcts' in ratings and len(ratings['loadevent_hundpcts']) == 4:
    #                     self.qmc.loadevent_hundpcts_setup = ratings['loadevent_hundpcts']
    #                 self.qmc.restoreEnergyLoadDefaults()
    #
    #         # 发送消息提示
    #         self.sendmessage(QApplication.translate("Message", f"机器已配置为 {label}"))
    #         _log.info("机器已配置为 %s", label)
    #
    #         # 重绘界面
    #         self.qmc.redraw(False, False)
    #
    #     except Exception as e:
    #         # 捕获异常并记录
    #         _log.exception(e)
    #         self.sendmessage(QApplication.translate("Message", "配置过程中出现错误"))

    # @pyqtSlot(bool)
    # def openMachineSettings(self, _checked: bool = False) -> None:
    #     action = self.sender()
    #     sys.stdout = open("outputttttttt.log", "w")
    #     print(action.data()[1])
    #     try:
    #         if action and hasattr(action, 'data') and hasattr(action, 'text'):
    #             label = (action.text() if action.data()[1] == '' else f'{action.data()[1]} {action.text()}')
    #             label = label.replace('&&',
    #                                   '&')  # we reduce those && again to & that were introduced to have the & rendered in the menu entry
    #             #            string = QApplication.translate('Message', 'Configure for<br>{0}?<br><br>Your current settings will be overwritten!<br><br>It is advisable to save your current settings beforehand via menu Help >> Save Settings.').format(label)
    #             help_menu = QApplication.translate('Menu', 'Help')
    #             string = QApplication.translate('Message',
    #                                             'Configure for<br>{0}?<br><br>Some of your settings will be modified!<br><br>Before proceeding it is best to save your current settings and reset Artisan<br>(first menu {1} >> {2} then {4} >> {3})').format(
    #                 label, help_menu, QApplication.translate('Menu', 'Save Settings...'),
    #                 QApplication.translate('Menu', 'Factory Reset'), help_menu)
    #             reply = QMessageBox.question(self, QApplication.translate('Message', 'Adjust Settings'), string,
    #                                          QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.Cancel)
    #             if reply == QMessageBox.StandardButton.Cancel:
    #                 return
    #             if reply == QMessageBox.StandardButton.Yes and hasattr(action, 'data') and hasattr(action, 'text'):
    #                 self.qmc.etypes = self.qmc.etypesdefault[:]
    #                 # keep original information to Cancel
    #                 org_etypes = self.qmc.etypes
    #                 org_device = self.qmc.device
    #                 org_machinesetup = self.qmc.machinesetup
    #                 org_modbus_host = self.modbus.host
    #                 org_s7_host = self.s7.host
    #                 org_ws_host = self.ws.host
    #                 org_kaleido_host = self.kaleidoHost
    #                 org_comport = self.ser.comport
    #                 org_modbus_comport = self.modbus.comport
    #                 org_roastersize_setup = self.qmc.roastersize_setup
    #                 org_last_batchsize = self.qmc.last_batchsize
    #                 org_roastersize = self.qmc.roastersize
    #                 org_roasterheating_setup = self.qmc.roasterheating_setup
    #                 org_roasterheating = self.qmc.roasterheating
    #                 # reset roaster_setup_default to ensure we do not offer a default from a previously loaded machine setup
    #                 self.qmc.roastersize_setup_default = 0
    #                 self.qmc.roasterheating_setup_default = 0
    #                 # also reset roastersize_setup to have the machine setup work as after a reset on each call
    #                 self.qmc.roastersize_setup = 0
    #                 self.qmc.roasterheating_setup = 0
    #                 #
    #                 self.loadSettings(fn=action.data()[0], remember=False, machine=True, reload=False)
    #                 res: bool = False
    #                 res2: Optional[bool] = None
    #                 if action.data()[1] == 'Phidget':
    #                     if action.text() == 'VINT Ambient Modules':
    #                         elevation, res2 = QInputDialog.getInt(self,
    #                                                               QApplication.translate('Message', 'Ambient'),
    #                                                               QApplication.translate('Message', 'Elevation (MASL)'),
    #                                                               value=self.qmc.elevation)
    #                         if res2 is not None and res2:
    #                             try:
    #                                 self.qmc.elevation = int(elevation)
    #                             except Exception:  # pylint: disable=broad-except
    #                                 pass
    #                         else:
    #                             res = False
    #                             self.sendmessage(QApplication.translate('Message', 'Action canceled'))
    #                     else:
    #                         res = True
    #                         self.qmc.machinesetup = action.text()
    #                     if res:
    #                         QTimer.singleShot(700, self.qmc.startPhidgetManager)
    #                 else:
    #                     self.qmc.machinesetup = action.text()
    #                     res = True
    #                 if (self.qmc.device == 29 or 29 in self.qmc.extradevices) and self.modbus.type in {3,
    #                                                                                                    4}:  # MODBUS TCP or UDP
    #                     # as default we offer the current settings MODBUS host, or if this is set to its default as after a factory reset (self.modbus.default_host) we take the one from the machine setup
    #                     defaultModbusHost: str = (
    #                         self.modbus.host if org_modbus_host == self.modbus.default_host else org_modbus_host)
    #                     host, res2 = QInputDialog.getText(self,
    #                                                       f"{QApplication.translate('Message', 'Machine')} (MODBUS)",
    #                                                       QApplication.translate('Message',
    #                                                                              'Network name or IP address'),
    #                                                       text=defaultModbusHost)
    #                     if res2 is not None and res2:
    #                         res = res2
    #                         self.modbus.host = host
    #                 elif self.qmc.device == 79 or 79 in self.qmc.extradevices:  # S7
    #                     # as default we offer the current settings S7 host, or if this is set to its default as after a factory reset (self.s7.default_host) we take the one from the machine setup
    #                     defaultS7Host: str = (self.s7.host if org_s7_host == self.s7.default_host else org_s7_host)
    #                     host, res2 = QInputDialog.getText(self,
    #                                                       f"{QApplication.translate('Message', 'Machine')} (S7)",
    #                                                       QApplication.translate('Message',
    #                                                                              'Network name or IP address'),
    #                                                       text=defaultS7Host)
    #                     if res2 is not None and res2:
    #                         res = res2
    #                         self.s7.host = host
    #                 elif self.qmc.device == 111 or 111 in self.qmc.extradevices:  # WebSocket
    #                     # as default we offer the current settings WebSocket host, or if this is set to its default as after a factory reset (self.ws.default_host) we take the one from the machine setup
    #                     defaultWSHost: str = (self.ws.host if org_ws_host == self.ws.default_host else org_ws_host)
    #                     host, res2 = QInputDialog.getText(self,
    #                                                       f"{QApplication.translate('Message', 'Machine')} (WebSocket)",
    #                                                       QApplication.translate('Message',
    #                                                                              'Network name or IP address'),
    #                                                       text=defaultWSHost)
    #                     if res2 is not None and res2:
    #                         res = res2
    #                         self.ws.host = host
    #                 elif self.qmc.device == 138 and not self.kaleidoSerial:  # Kaleido Network
    #                     # as default we offer the current settings kaleido host, or if this is set to its default as after a factory reset (self.kaleido_default_host) we take the one from the machine setup
    #                     defaultKaleidoHost: str = (
    #                         self.kaleidoHost if org_kaleido_host == self.kaleido_default_host else org_kaleido_host)
    #                     host, res2 = QInputDialog.getText(self,
    #                                                       QApplication.translate('Message', 'Machine'),
    #                                                       QApplication.translate('Message',
    #                                                                              'Network name or IP address'),
    #                                                       text=defaultKaleidoHost)
    #                     if res2 is not None and res2:
    #                         res = res2
    #                         self.kaleidoHost = host
    #                 elif (self.qmc.device in {0, 9, 19, 53, 101, 115, 126} or (
    #                         (self.qmc.device == 29 or 29 in self.qmc.extradevices) and self.modbus.type in {0, 1, 2}) or
    #                       (self.qmc.device == 134 and self.santokerSerial) or
    #                       (
    #                               self.qmc.device == 138 and self.kaleidoSerial)):  # Fuji, Center301, TC4, Hottop, Behmor or MODBUS serial, HB/ARC
    #                     select_device_name = None
    #                     # as default we offer the current settings serial/modbus port, or if this is set to its default as after a factory reset (self.ser.default_comport or self.modbus.default_comport) we take the one from the machine setup
    #                     defaultComPort: str = ((
    #                                                self.modbus.comport if org_modbus_comport == self.modbus.default_comport else org_modbus_comport) if self.qmc.device == 29 else (
    #                         self.ser.comport if org_comport == self.ser.default_comport else org_comport))
    #                     select_modbus_serial_port: bool = self.qmc.device == 29 or (
    #                                 29 in self.qmc.extradevices and self.qmc.device not in {0, 9, 19, 53, 101, 115, 126,
    #                                                                                         134, 138})
    #                     serial_port_dialog_title: str = QApplication.translate('Message', 'Port Configuration')
    #                     if select_modbus_serial_port:
    #                         serial_port_dialog_title = f'{serial_port_dialog_title} (MODBUS)'
    #                     if self.qmc.device == 53:  # Hottop 2k+:
    #                         select_device_name = 'FT230X Basic UART'
    #                     commPort_dlg: ArtisanPortsDialog = ArtisanPortsDialog(self, self,
    #                                                                           title=serial_port_dialog_title,
    #                                                                           selection=defaultComPort,
    #                                                                           select_device_name=select_device_name)
    #                     res = bool(commPort_dlg.exec())
    #                     if res:
    #                         new_port = commPort_dlg.getSelection()
    #                         if new_port is not None:
    #                             if select_modbus_serial_port:  # MODBUS serial
    #                                 self.modbus.comport = new_port
    #                             else:  # Fuji or HOTTOP
    #                                 self.ser.comport = new_port
    #                 elif self.qmc.device == 142:  # IKAWA
    #                     # we request Bluetooth permission
    #                     permission_status: Optional[bool] = self.app.getBluetoothPermission(request=True)
    #                     if permission_status is False:
    #                         message: str = QApplication.translate('Message', 'Bluetootooth access denied')
    #                         QMessageBox.warning(self, message, message)
    #                 if res:
    #                     if self.qmc.roastersize_setup == 0:
    #                         batchsize, res2 = QInputDialog.getDouble(self,
    #                                                                  QApplication.translate('Message', 'Machine'),
    #                                                                  QApplication.translate('Message',
    #                                                                                         'Machine Capacity (kg)'),
    #                                                                  self.qmc.roastersize_setup_default,
    #                                                                  # default value as loaded from the machine setup
    #                                                                  0,  # min
    #                                                                  999,  # max
    #                                                                  1)  # decimals
    #                         if res2 is not None and res2:
    #                             res = res2
    #                             self.qmc.roastersize_setup = self.qmc.roastersize = batchsize
    #                     else:
    #                         res = self.qmc.roastersize_setup != 0  # roastersize_setup was loaded from machine setup
    #                 if res:
    #                     # first establish roastersize_setup batchsizes as default batchsize (potentially unit converted)
    #                     if self.qmc.roastersize_setup > 0:
    #                         weight_unit = self.qmc.weight[2]
    #                         nominal_batch_size = self.convertWeight(self.qmc.roastersize_setup, 1,
    #                                                                 self.qmc.weight_units.index(self.qmc.weight[2]))
    #                         self.qmc.last_batchsize = nominal_batch_size
    #                         self.qmc.weight = (nominal_batch_size, 0, weight_unit)
    #                     # size set, ask for heating
    #                     resi: Optional[int]
    #                     if self.qmc.roasterheating_setup == 0:
    #                         dlg: ArtisanComboBoxDialog = ArtisanComboBoxDialog(self, self,
    #                                                                            QApplication.translate('Message',
    #                                                                                                   'Machine'),
    #                                                                            QApplication.translate('Label',
    #                                                                                                   'Heating'),
    #                                                                            self.qmc.heating_types,
    #                                                                            self.qmc.roasterheating_setup_default)
    #                         resi = dlg.idx if dlg.exec() else None
    #                     else:
    #                         resi = self.qmc.roasterheating_setup
    #                     if resi is not None:
    #                         res = True
    #                         self.qmc.roasterheating_setup = self.qmc.roasterheating = resi
    #                         # now check if the machine setup contains energy default ratings for the given batch size and energy rating
    #                         if self.qmc.machinesetup_energy_ratings is not None and self.qmc.roastersize_setup > 0 and self.qmc.roasterheating_setup > 0 and \
    #                                 self.qmc.roasterheating_setup in self.qmc.machinesetup_energy_ratings:
    #                             heating_ratings = self.qmc.machinesetup_energy_ratings[self.qmc.roasterheating_setup]
    #                             if self.qmc.roastersize_setup in heating_ratings:
    #                                 ratings = heating_ratings[self.qmc.roastersize_setup]
    #                                 if 'loadlabels' in ratings and len(ratings['loadlabels']) == 4:
    #                                     self.qmc.loadlabels_setup = ratings['loadlabels']
    #                                 if 'loadratings' in ratings and len(ratings['loadratings']) == 4:
    #                                     self.qmc.loadratings_setup = ratings['loadratings']
    #                                 if 'ratingunits' in ratings and len(ratings['ratingunits']) == 4:
    #                                     self.qmc.ratingunits_setup = ratings['ratingunits']
    #                                 if 'sourcetypes' in ratings and len(ratings['sourcetypes']) == 4:
    #                                     self.qmc.sourcetypes_setup = ratings['sourcetypes']
    #                                 if 'load_etypes' in ratings and len(ratings['load_etypes']) == 4:
    #                                     self.qmc.load_etypes_setup = ratings['load_etypes']
    #                                 if 'presssure_percents' in ratings and len(ratings['presssure_percents']) == 4:
    #                                     self.qmc.presssure_percents_setup = ratings['presssure_percents']
    #                                 if 'loadevent_zeropcts' in ratings and len(ratings['loadevent_zeropcts']) == 4:
    #                                     self.qmc.loadevent_zeropcts_setup = ratings['loadevent_zeropcts']
    #                                 if 'loadevent_hundpcts' in ratings and len(ratings['loadevent_hundpcts']) == 4:
    #                                     self.qmc.loadevent_hundpcts_setup = ratings['loadevent_hundpcts']
    #                                 self.qmc.restoreEnergyLoadDefaults()
    #                                 self.sendmessage(QApplication.translate('Message',
    #                                                                         'Energy loads configured for {0} {1}kg').format(
    #                                     label, self.qmc.roastersize_setup))
    #                         self.sendmessage(
    #                             QApplication.translate('Message', 'Artisan configured for {0}').format(label))
    #                         _log.info('Artisan configured for %s', label)
    #                     else:
    #                         res = False
    #                 if not res:
    #                     # reset
    #                     self.qmc.etypes = org_etypes
    #                     self.qmc.device = org_device
    #                     self.qmc.machinesetup = org_machinesetup
    #                     self.modbus.host = org_modbus_host
    #                     self.s7.host = org_s7_host
    #                     self.ws.host = org_ws_host
    #                     self.kaleidoHost = org_kaleido_host
    #                     self.ser.comport = org_comport
    #                     self.modbus.comport = org_modbus_comport
    #                     self.qmc.roastersize_setup = org_roastersize_setup
    #                     self.qmc.last_batchsize = org_last_batchsize
    #                     self.qmc.roastersize = org_roastersize
    #                     self.qmc.roasterheating_setup = org_roasterheating_setup
    #                     self.qmc.roasterheating = org_roasterheating
    #                     #
    #                     self.sendmessage(QApplication.translate('Message', 'Action canceled'))
    #                 else:
    #                     # setup not canceled, we establish the last_batchsize
    #                     self.qmc.weight = (self.qmc.last_batchsize, 0, self.qmc.weight[2])
    #                 self.establish_etypes()
    #             self.qmc.redraw(False, False)
    #     except Exception as e:  # pylint: disable=broad-except
    #         _log.exception(e)

    @pyqtSlot(bool)
    def openMachineSettings(self, file_path: str, _checked: bool = False) -> None:
        action = self.sender()
        sys.stdout=open("lj.log","w")
        # print(action.data())
        try:
            if action and hasattr(action, 'text'):
                print("text")
                label = (action.text())
                # label = label.replace('&&',
                #                       '&')  # we reduce those && again to & that were introduced to have the & rendered in the menu entry
                #            # string = QApplication.translate('Message', 'Configure for<br>{0}?<br><br>Your current settings will be overwritten!<br><br>It is advisable to save your current settings beforehand via menu Help >> Save Settings.').format(label)
                # help_menu = QApplication.translate('Menu', 'Help')
                # string = QApplication.translate('Message',
                #                                 'Configure for<br>{0}?<br><br>Some of your settings will be modified!<br><br>Before proceeding it is best to save your current settings and reset Artisan<br>(first menu {1} >> {2} then {4} >> {3})').format(
                #     label, help_menu, QApplication.translate('Menu', 'Save Settings...'),
                #     QApplication.translate('Menu', 'Factory Reset'), help_menu)
                # reply = QMessageBox.question(self, QApplication.translate('Message', 'Adjust Settings'), string,
                #                              QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.Cancel)
                # if reply == QMessageBox.StandardButton.Cancel:
                #     return
                # if reply == QMessageBox.StandardButton.Yes and hasattr(action, 'data') and hasattr(action, 'text'):
                # try:
                #     config = configparser.ConfigParser()
                #     config.read(file_path, encoding='utf-8')  # 读取文件
                #     print("config:",config)
                #     print("self.modbus.host:" , self.modbus.host)
                #     # 提取 `sethost` 值
                #     if 'OtherSettings' in config and 'sethost' in config['OtherSettings']:
                #         self.modbus.host = config['OtherSettings'].get('sethost', self.modbus.host)
                #         orgResi = config['OtherSettings'].get('setheatingtype', '2')
                #         # self.qmc.device = 29
                #         # self.s7.host = '192.168.2.180'
                # except Exception as e:
                #     print(f"Error reading INI file for 'sethost': {e}")

                orgResi = 1

                if hasattr(action, 'text'):
                    print(self.modbus.host, self.qmc.roasterheating, self.qmc.roastersize)
                    self.qmc.etypes = self.qmc.etypesdefault[:]
                    # keep original information to Cancel
                    org_etypes = self.qmc.etypes
                    org_device = self.qmc.device
                    org_machinesetup = self.qmc.machinesetup
                    org_modbus_host = self.modbus.host
                    org_s7_host = self.s7.host
                    org_ws_host = self.ws.host
                    org_kaleido_host = self.kaleidoHost
                    org_comport = self.ser.comport
                    org_modbus_comport = self.modbus.comport
                    org_roastersize_setup = self.qmc.roastersize_setup
                    org_last_batchsize = self.qmc.last_batchsize
                    org_roastersize = self.qmc.roastersize
                    org_roasterheating_setup = self.qmc.roasterheating_setup
                    org_roasterheating = self.qmc.roasterheating
                    # reset roaster_setup_default to ensure we do not offer a default from a previously loaded machine setup
                    self.qmc.roastersize_setup_default = 0
                    self.qmc.roasterheating_setup_default = 0
                    # also reset roastersize_setup to have the machine setup work as after a reset on each call
                    self.qmc.roastersize_setup = 0
                    self.qmc.roasterheating_setup = 0


                    # self.loadSettings(fn=action.data()[0], remember=False, machine=True, reload=False)
                    res: bool = False
                    res2: Optional[bool] = None
                    if action.data()[1] == 'Phidget':
                        if action.text() == 'VINT Ambient Modules':
                            elevation, res2 = QInputDialog.getInt(self,
                                                                  QApplication.translate('Message', 'Ambient'),
                                                                  QApplication.translate('Message', 'Elevation (MASL)'),
                                                                  value=self.qmc.elevation)
                            if res2 is not None and res2:
                                try:
                                    self.qmc.elevation = int(elevation)
                                except Exception:  # pylint: disable=broad-except
                                    pass
                            else:
                                res = False
                                self.sendmessage(QApplication.translate('Message', 'Action canceled'))
                        else:
                            res = True
                            self.qmc.machinesetup = action.text()
                        if res:
                            QTimer.singleShot(700, self.qmc.startPhidgetManager)
                    else:
                        self.qmc.machinesetup = action.text()
                        res = True
                    if (self.qmc.device == 29 or 29 in self.qmc.extradevices) and self.modbus.type in {3,
                                                                                                       4}:  # MODBUS TCP or UDP
                        # as default we offer the current settings MODBUS host, or if this is set to its default as after a factory reset (self.modbus.default_host) we take the one from the machine setup
                        # defaultModbusHost: str = (self.modbus.host if org_modbus_host == self.modbus.default_host else org_modbus_host)
                        # host, res2 = QInputDialog.getText(self,
                        #                                   f"{QApplication.translate('Message', 'Machine')} (MODBUS)",
                        #                                   QApplication.translate('Message',
                        #                                                          'Network name or IP address'),
                        #                                   text=defaultModbusHost)
                        # if res2 is not None and res2:
                        #     res = res2
                        self.modbus.host = org_modbus_host
                    elif self.qmc.device == 79 or 79 in self.qmc.extradevices:  # S7
                        # as default we offer the current settings S7 host, or if this is set to its default as after a factory reset (self.s7.default_host) we take the one from the machine setup
                        defaultS7Host: str = (self.s7.host if org_s7_host == self.s7.default_host else org_s7_host)
                        host, res2 = QInputDialog.getText(self,
                                                          f"{QApplication.translate('Message', 'Machine')} (S7)",
                                                          QApplication.translate('Message',
                                                                                 'Network name or IP address'),
                                                          text=defaultS7Host)
                        if res2 is not None and res2:
                            res = res2
                            self.s7.host = host
                    elif self.qmc.device == 111 or 111 in self.qmc.extradevices:  # WebSocket
                        # as default we offer the current settings WebSocket host, or if this is set to its default as after a factory reset (self.ws.default_host) we take the one from the machine setup
                        defaultWSHost: str = (self.ws.host if org_ws_host == self.ws.default_host else org_ws_host)
                        host, res2 = QInputDialog.getText(self,
                                                          f"{QApplication.translate('Message', 'Machine')} (WebSocket)",
                                                          QApplication.translate('Message',
                                                                                 'Network name or IP address'),
                                                          text=defaultWSHost)
                        if res2 is not None and res2:
                            res = res2
                            self.ws.host = host
                    elif self.qmc.device == 138 and not self.kaleidoSerial:  # Kaleido Network
                        # as default we offer the current settings kaleido host, or if this is set to its default as after a factory reset (self.kaleido_default_host) we take the one from the machine setup
                        defaultKaleidoHost: str = (
                            self.kaleidoHost if org_kaleido_host == self.kaleido_default_host else org_kaleido_host)
                        host, res2 = QInputDialog.getText(self,
                                                          QApplication.translate('Message', 'Machine'),
                                                          QApplication.translate('Message',
                                                                                 'Network name or IP address'),
                                                          text=defaultKaleidoHost)
                        if res2 is not None and res2:
                            res = res2
                            self.kaleidoHost = host
                    elif (self.qmc.device in {0, 9, 19, 53, 101, 115, 126} or (
                            (self.qmc.device == 29 or 29 in self.qmc.extradevices) and self.modbus.type in {0, 1, 2}) or
                          (self.qmc.device == 134 and self.santokerSerial) or
                          (
                                  self.qmc.device == 138 and self.kaleidoSerial)):  # Fuji, Center301, TC4, Hottop, Behmor or MODBUS serial, HB/ARC
                        select_device_name = None
                        # as default we offer the current settings serial/modbus port, or if this is set to its default as after a factory reset (self.ser.default_comport or self.modbus.default_comport) we take the one from the machine setup
                        defaultComPort: str = ((
                                                   self.modbus.comport if org_modbus_comport == self.modbus.default_comport else org_modbus_comport) if self.qmc.device == 29 else (
                            self.ser.comport if org_comport == self.ser.default_comport else org_comport))
                        select_modbus_serial_port: bool = self.qmc.device == 29 or (
                                29 in self.qmc.extradevices and self.qmc.device not in {0, 9, 19, 53, 101, 115, 126,
                                                                                        134, 138})
                        # serial_port_dialog_title: str = QApplication.translate('Message', 'Port Configuration')
                        # if select_modbus_serial_port:
                        #     serial_port_dialog_title = f'{serial_port_dialog_title} (MODBUS)'
                        # if self.qmc.device == 53:  # Hottop 2k+:
                        #     select_device_name = 'FT230X Basic UART'
                        # commPort_dlg: ArtisanPortsDialog = ArtisanPortsDialog(self, self,
                        #                                                       title=serial_port_dialog_title,
                        #                                                       selection=defaultComPort,
                        #                                                       select_device_name=select_device_name)
                        res = bool(commPort_dlg.exec())
                        if res:
                            new_port = commPort_dlg.getSelection()
                            if new_port is not None:
                                if select_modbus_serial_port:  # MODBUS serial
                                    self.modbus.comport = new_port
                                else:  # Fuji or HOTTOP
                                    self.ser.comport = new_port
                    elif self.qmc.device == 142:  # IKAWA
                        # we request Bluetooth permission
                        permission_status: Optional[bool] = self.app.getBluetoothPermission(request=True)
                        if permission_status is False:
                            message: str = QApplication.translate('Message', 'Bluetootooth access denied')
                            QMessageBox.warning(self, message, message)
                    if res:
                        if self.qmc.roastersize_setup == 0:
                            # batchsize, res2 = QInputDialog.getDouble(self,
                            #                                          QApplication.translate('Message', 'Machine'),
                            #                                          QApplication.translate('Message',
                            #                                                                 'Machine Capacity (kg)'),
                            #                                          self.qmc.roastersize_setup_default,
                            #                                          # default value as loaded from the machine setup
                            #                                          0,  # min
                            #                                          999,  # max
                            #                                          1)  # decimals
                            # if res2 is not None and res2:
                            #     res = res2
                            self.qmc.roastersize_setup = self.qmc.roastersize = batchsize
                        else:
                            res = self.qmc.roastersize_setup != 0  # roastersize_setup was loaded from machine setup
                    if res:
                        # first establish roastersize_setup batchsizes as default batchsize (potentially unit converted)
                        if self.qmc.roastersize_setup > 0:
                            weight_unit = self.qmc.weight[2]
                            nominal_batch_size = self.convertWeight(self.qmc.roastersize_setup, 1,
                                                                    self.qmc.weight_units.index(self.qmc.weight[2]))
                            self.qmc.last_batchsize = nominal_batch_size
                            self.qmc.weight = (nominal_batch_size, 0, weight_unit)
                        # size set, ask for heating
                        resi: Optional[int] = int(orgResi)
                        # if self.qmc.roasterheating_setup == 0:
                        #     dlg: ArtisanComboBoxDialog = ArtisanComboBoxDialog(self, self,
                        #                                                        QApplication.translate('Message',
                        #                                                                               'Machine'),
                        #                                                        QApplication.translate('Label',
                        #                                                                               'Heating'),
                        #                                                        self.qmc.heating_types,
                        #                                                        self.qmc.roasterheating_setup_default)
                        #     resi = dlg.idx if dlg.exec() else None
                        # else:
                        #     resi = self.qmc.roasterheating_setup
                        if resi is not None:
                            res = True
                            self.qmc.roasterheating_setup = self.qmc.roasterheating = resi
                            # now check if the machine setup contains energy default ratings for the given batch size and energy rating
                            if self.qmc.machinesetup_energy_ratings is not None and self.qmc.roastersize_setup > 0 and self.qmc.roasterheating_setup > 0 and \
                                    self.qmc.roasterheating_setup in self.qmc.machinesetup_energy_ratings:
                                heating_ratings = self.qmc.machinesetup_energy_ratings[self.qmc.roasterheating_setup]
                                if self.qmc.roastersize_setup in heating_ratings:
                                    ratings = heating_ratings[self.qmc.roastersize_setup]
                                    if 'loadlabels' in ratings and len(ratings['loadlabels']) == 4:
                                        self.qmc.loadlabels_setup = ratings['loadlabels']
                                    if 'loadratings' in ratings and len(ratings['loadratings']) == 4:
                                        self.qmc.loadratings_setup = ratings['loadratings']
                                    if 'ratingunits' in ratings and len(ratings['ratingunits']) == 4:
                                        self.qmc.ratingunits_setup = ratings['ratingunits']
                                    if 'sourcetypes' in ratings and len(ratings['sourcetypes']) == 4:
                                        self.qmc.sourcetypes_setup = ratings['sourcetypes']
                                    if 'load_etypes' in ratings and len(ratings['load_etypes']) == 4:
                                        self.qmc.load_etypes_setup = ratings['load_etypes']
                                    if 'presssure_percents' in ratings and len(ratings['presssure_percents']) == 4:
                                        self.qmc.presssure_percents_setup = ratings['presssure_percents']
                                    if 'loadevent_zeropcts' in ratings and len(ratings['loadevent_zeropcts']) == 4:
                                        self.qmc.loadevent_zeropcts_setup = ratings['loadevent_zeropcts']
                                    if 'loadevent_hundpcts' in ratings and len(ratings['loadevent_hundpcts']) == 4:
                                        self.qmc.loadevent_hundpcts_setup = ratings['loadevent_hundpcts']
                                    self.qmc.restoreEnergyLoadDefaults()
                                    self.sendmessage(QApplication.translate('Message',
                                                                            'Energy loads configured for {0} {1}kg').format(
                                        label, self.qmc.roastersize_setup))
                            self.sendmessage(
                                QApplication.translate('Message', 'Artisan configured for {0}').format(label))
                            _log.info('Artisan configured for %s', label)
                        else:
                            res = False
                    if not res:
                        # reset
                        self.qmc.etypes = org_etypes
                        self.qmc.device = org_device
                        self.qmc.machinesetup = org_machinesetup
                        self.modbus.host = org_modbus_host
                        self.s7.host = org_s7_host
                        self.ws.host = org_ws_host
                        self.kaleidoHost = org_kaleido_host
                        self.ser.comport = org_comport
                        self.modbus.comport = org_modbus_comport
                        self.qmc.roastersize_setup = org_roastersize_setup
                        self.qmc.last_batchsize = org_last_batchsize
                        self.qmc.roastersize = org_roastersize
                        self.qmc.roasterheating_setup = org_roasterheating_setup
                        self.qmc.roasterheating = org_roasterheating
                        #
                        self.sendmessage(QApplication.translate('Message', 'Action canceled'))
                    else:
                        # setup not canceled, we establish the last_batchsize
                        self.qmc.weight = (self.qmc.last_batchsize, 0, self.qmc.weight[2])
                    self.establish_etypes()
                self.qmc.redraw(False, False)

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    def populateThemeMenu(self) -> None:
        self.themeMenu.clear()
        # self.populateListMenu('Themes', '.athm', self.openThemeSettings, self.themeMenu, False, True)
        submenu = self.themeMenu.addMenu('User')
        if submenu is not None:
            for i in range(self.MaxRecentFiles):
                submenu.addAction(self.recentThemeActs[i])

            self.loadThemeAction = QAction(QApplication.translate('Menu', 'Load Theme...'), self)
            self.loadThemeAction.triggered.connect(self.loadSettings_theme_Slot)
            self.loadThemeAction.setMenuRole(QAction.MenuRole.NoRole)  # avoid specific handling of settings menu

            self.saveAsThemeAction = QAction(QApplication.translate('Menu', 'Save Theme...'), self)
            self.saveAsThemeAction.triggered.connect(self.saveSettings_theme)
            self.saveAsThemeAction.setMenuRole(QAction.MenuRole.NoRole)  # avoid specific handling of settings menu

            submenu.addSeparator()
            submenu.addAction(self.loadThemeAction)
            submenu.addAction(self.saveAsThemeAction)

    @pyqtSlot(bool)
    def openThemeSettings(self, _checked: bool = False) -> None:
        action = self.sender()
        if action and hasattr(action, 'data') and hasattr(action, 'text'):
            label = (action.text() if action.data()[1] == '' else f'{action.data()[1]} {action.text()}')
            string = QApplication.translate('Message', 'Load theme {0}?').format(label)
            reply = QMessageBox.question(self, QApplication.translate('Message', 'Adjust Theme Related Settings'),
                                         string,
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.Cancel)
            if reply == QMessageBox.StandardButton.Cancel:
                return
            if reply == QMessageBox.StandardButton.Yes:
                self.loadSettings(fn=action.data()[0], remember=False, reset=False, theme=True)
                self.sendmessage(QApplication.translate('Message', 'Loaded theme {0}').format(action.text()))
                libtime.sleep(.8)
                self.qmc.redraw(True)

    def getcolorPairsToCheck(self) -> List[Tuple[str, str, str, str]]:
        colorPairsToCheck = []
        try:
            colorPairsToCheck = [
                # self.qmc.palette
                (QApplication.translate('Label', 'BT'), self.qmc.palette['bt'],
                 QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                (QApplication.translate('Label', 'ET'), self.qmc.palette['et'],
                 QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                (deltaLabelPrefix + QApplication.translate('Label', 'BT'), self.qmc.palette['deltabt'],
                 QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                (deltaLabelPrefix + QApplication.translate('Label', 'ET'), self.qmc.palette['deltaet'],
                 QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                (QApplication.translate('Label', 'Markers'), self.qmc.palette['markers'],
                 QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                (QApplication.translate('Label', 'Text'), self.qmc.palette['text'],
                 QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                (QApplication.translate('Label', 'Time Guide'), self.qmc.palette['timeguide'],
                 QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                (QApplication.translate('Label', 'Background ET'), self.qmc.backgroundmetcolor,
                 QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                (QApplication.translate('Label', 'Background BT'), self.qmc.backgroundbtcolor,
                 QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                (
                    QApplication.translate('Label', 'Background') + ' ' + deltaLabelPrefix + QApplication.translate(
                        'Label',
                        'ET'),
                    self.qmc.backgrounddeltaetcolor,
                    QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                (
                    QApplication.translate('Label', 'Background') + ' ' + deltaLabelPrefix + QApplication.translate(
                        'Label',
                        'BT'),
                    self.qmc.backgrounddeltabtcolor,
                    QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                (QApplication.translate('Label', 'Background Extra'), self.qmc.palette['xt'],
                 QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                (QApplication.translate('Label', 'X Label'), self.qmc.palette['xlabel'],
                 QApplication.translate('Label', 'Canvas'), self.qmc.palette['canvas']),

                (QApplication.translate('Label', 'Y Label'), self.qmc.palette['ylabel'],
                 QApplication.translate('Label', 'Canvas'), self.qmc.palette['canvas']),

                (QApplication.translate('Label', 'Title'), self.qmc.palette['title'],
                 QApplication.translate('Label', 'Canvas'), self.qmc.palette['canvas']),

                (QApplication.translate('Label', 'SpecialEventText'), self.qmc.palette['specialeventtext'],
                 QApplication.translate('Label', 'SpecialEventBox'), self.qmc.palette['specialeventbox']),

                (QApplication.translate('Label', 'Bg SpecialEventText'), self.qmc.palette['bgeventtext'],
                 QApplication.translate('Label', 'Bg SpecialEventBox'), self.qmc.palette['bgeventmarker']),

                (QApplication.translate('Label', 'ET'), self.qmc.palette['et'],
                 QApplication.translate('Label', 'Legend bkgnd'), self.qmc.palette['legendbg']),

                (QApplication.translate('Label', 'BT'), self.qmc.palette['bt'],
                 QApplication.translate('Label', 'Legend bkgnd'), self.qmc.palette['legendbg']),

                (deltaLabelPrefix + QApplication.translate('Label', 'ET'), self.qmc.palette['deltaet'],
                 QApplication.translate('Label', 'Legend bkgnd'), self.qmc.palette['legendbg']),

                (deltaLabelPrefix + QApplication.translate('Label', 'BT'), self.qmc.palette['deltabt'],
                 QApplication.translate('Label', 'Legend bkgnd'), self.qmc.palette['legendbg']),

                (QApplication.translate('Label', 'MET Text'), self.qmc.palette['mettext'],
                 QApplication.translate('Label', 'MET Box'), self.qmc.palette['metbox']),

                (QApplication.translate('Label', 'MET Box'), self.qmc.palette['metbox'],
                 QApplication.translate('Label', 'Background'), self.qmc.palette['background']),

                # self.lcdpalette
                (QApplication.translate('Label', 'Timer LCD Digits'), self.lcdpaletteF['timer'],
                 QApplication.translate('Label', 'Timer LCD Background'), self.lcdpaletteB['timer']),

                (QApplication.translate('Label', 'ET LCD Digits'), self.lcdpaletteF['et'],
                 QApplication.translate('Label', 'ET LCD Background'), self.lcdpaletteB['et']),

                (QApplication.translate('Label', 'BT LCD Digits'), self.lcdpaletteF['bt'],
                 QApplication.translate('Label', 'BT LCD Background'), self.lcdpaletteB['bt']),

                (deltaLabelPrefix + QApplication.translate('Label', 'ET LCD Digits'), self.lcdpaletteF['deltaet'],
                 deltaLabelPrefix + QApplication.translate('Label', 'ET LCD Background'), self.lcdpaletteB['deltaet']),

                (deltaLabelPrefix + QApplication.translate('Label', 'BT LCD Digits'), self.lcdpaletteF['deltabt'],
                 deltaLabelPrefix + QApplication.translate('Label', 'BT LCD Background'), self.lcdpaletteB['deltabt']),

                (QApplication.translate('Label', 'Extra/PID LCD Digits'), self.lcdpaletteF['sv'],
                 QApplication.translate('Label', 'Extra/PID LCD Background'), self.lcdpaletteB['sv']),
            ]

            # extra devices
            for i in range(len(self.qmc.extradevices)):
                if self.extraCurveVisibility1[i]:
                    colorPairsToCheck.append(
                        (self.qmc.extraname1[i], self.qmc.extradevicecolor1[i],
                         QApplication.translate('Label', 'Background'), self.qmc.palette['background']),
                    )
                    colorPairsToCheck.append(
                        (self.qmc.extraname1[i], self.qmc.extradevicecolor1[i],
                         QApplication.translate('Label', 'Legend bkgnd'), self.qmc.palette['background']),
                    )
                if self.extraCurveVisibility2[i]:
                    colorPairsToCheck.append(
                        (self.qmc.extraname2[i], self.qmc.extradevicecolor2[i],
                         QApplication.translate('Label', 'Background'), self.qmc.palette['background']),
                    )
                    colorPairsToCheck.append(
                        (self.qmc.extraname2[i], self.qmc.extradevicecolor2[i],
                         QApplication.translate('Label', 'Legend bkgnd'), self.qmc.palette['background']),
                    )

            # special events
            for i, ec in enumerate(self.qmc.EvalueColor):
                colorPairsToCheck.append(
                    (self.qmc.etypes[i] + ' ' + QApplication.translate('Label', 'Event'), ec,
                     QApplication.translate('Label', 'Background'), self.qmc.palette['background']),
                )
                colorPairsToCheck.append(
                    (self.qmc.etypes[i] + ' ' + QApplication.translate('Label', 'Event'), ec,
                     QApplication.translate('Label', 'Legend bkgnd'), self.qmc.palette['background']),
                )
                colorPairsToCheck.append(
                    (self.qmc.etypes[i] + ' ' + QApplication.translate('Label', 'Slider'), ec,
                     QApplication.translate('Label', 'Background'), self.qmc.palette['canvas']),
                )
                colorPairsToCheck.append(
                    (self.qmc.etypes[i] + ' ' + QApplication.translate('Label', 'Text'), self.qmc.EvalueTextColor[i],
                     self.qmc.etypes[i] + ' ' + QApplication.translate('Label', 'Event'), ec),
                )

            # events buttons
            for i in range(len(self.extraeventstypes)):
                colorPairsToCheck.append(
                    (QApplication.translate('Label', 'Event button') + ' ' + self.extraeventslabels[i],
                     self.extraeventbuttoncolor[i], ' ' + QApplication.translate('Label', 'its text'),
                     self.extraeventbuttontextcolor[i]),
                )

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' getcolorPairsToCheck() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

        return colorPairsToCheck

    def colorDifference(self, color1: Optional[str], color2: Optional[str]) -> float:
        cDiff = 100
        try:
            from colorspacious import deltaE  # type: ignore
            if color1 is None or color1 == 'None':
                color1 = 'transparent'
            if color2 is None or color2 == 'None':
                color2 = 'transparent'
            if color1.lower() == 'transparent':
                if self.qmc.palette['canvas'] is None or self.qmc.palette['canvas'] == 'None':
                    color1 = 'transparent'
                else:
                    color1 = self.qmc.palette['canvas']
            if color2.lower() == 'transparent':
                if self.qmc.palette['canvas'] is None or self.qmc.palette['canvas'] == 'None':
                    color2 = 'transparent'
                else:
                    color2 = self.qmc.palette['canvas']
            c1 = str(QColor(color1).name())
            c2 = str(QColor(color2).name())
            c1_rgb = tuple(int(c1[i:i + 2], 16) for i in (1, 3, 5))
            c2_rgb = tuple(int(c2[i:i + 2], 16) for i in (1, 3, 5))
            cDiff = deltaE(c1_rgb, c2_rgb, input_space='sRGB255', uniform_space='CIELab')
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' colorDifference() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

        return cDiff

    def checkColors(self, colorPairsToCheck: Optional[List[Tuple[str, str, str, str]]] = None,
                    showMsg: bool = True) -> float:
        if colorPairsToCheck is None:
            colorPairsToCheck = []
        val: float = -1
        try:
            for c in colorPairsToCheck:
                c1 = c[1]
                c3 = c[3]
                # if one color is the canvas color set to None (transparent), we try to avoid a false warning
                if str(c1) == 'None' and c[0] == 'Canvas':
                    c1 = '#000000' if self.app.darkmode else '#ffffff'
                if str(c3) == 'None' and c[2] == 'Canvas':
                    c3 = '#000000' if self.app.darkmode else '#ffffff'
                val = self.colorDifference(c1, c3)
                if val < self.qmc.colorDifferenceThreshold:
                    val = self.float2float(val, 1)
                    if showMsg:
                        self.sendmessage(QApplication.translate('Message',
                                                                'Detected a color pair that may be hard to see: ') + f'{c[0]!s} ({c[1]!s}) <-> {c[2]!s} ({c[3]!s}) [deltaE={val:.1f}]')
        #                    print("checkColors", str(c[0]), "/", str(c[2]), "  Too similar", str(c[1]), str(c[3]), str(val)) #debugprint
        #                else: #debugprint
        #                    print("checkColors", str(c[0]), "/", str(c[2]), "  Okay", str(c[1]), str(c[3]), str(val))  #debugprint
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' checkColors() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

        return val

    def convertToGreyscale(self, c: str) -> str:
        nc = c
        try:
            from colorspacious import cspace_convert
            if c is None or c == 'None':
                return 'None'
            if isinstance(c, str) and c.lower() == 'transparent':
                return 'transparent'
            cq = str(QColor(c).name())
            c_rgb = tuple(int(cq[i:i + 2], 16) for i in (1, 3, 5))
            nc_greyscale_JCh = cspace_convert(c_rgb, 'sRGB255', 'JCh')
            nc_greyscale_JCh[..., 1] = 0
            nc_greyscale_sRGB = cspace_convert(nc_greyscale_JCh, 'JCh', 'sRGB255')
            nc_greyscale_sRGB = numpy.clip(nc_greyscale_sRGB, 0, 255)
            nc_greyscale = f'#{int(nc_greyscale_sRGB[0]):2x}{int(nc_greyscale_sRGB[1]):2x}{int(nc_greyscale_sRGB[2]):2x}'
            nc = str(QColor(nc_greyscale).name())
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' convertToGreyscale() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))
        return nc

    def labelBorW(self, backgroundcolor: str) -> str:
        base = self.convertToGreyscale(backgroundcolor)
        if self.checkColors([('base', base, 'white', '#ffffff')], False) > self.checkColors(
                [('base', base, 'black', '#000000')], False):
            return '#ffffff'
        return '#000000'

    def setLCDsBW(self) -> None:
        self.lcdpaletteB['timer'] = '#000000'
        self.lcdpaletteF['timer'] = '#ffffff'
        self.lcdpaletteB['et'] = '#000000'
        self.lcdpaletteF['et'] = '#ffffff'
        self.lcdpaletteB['bt'] = '#000000'
        self.lcdpaletteF['bt'] = '#ffffff'
        self.lcdpaletteB['deltaet'] = '#000000'
        self.lcdpaletteF['deltaet'] = '#ffffff'
        self.lcdpaletteB['deltabt'] = '#000000'
        self.lcdpaletteF['deltabt'] = '#ffffff'
        self.lcdpaletteB['sv'] = '#000000'
        self.lcdpaletteF['sv'] = '#ffffff'
        self.lcdpaletteB['rstimer'] = '#ffffff'
        self.lcdpaletteF['rstimer'] = '#000000'
        self.lcdpaletteB['slowcoolingtimer'] = '#000000'
        self.lcdpaletteF['slowcoolingtimer'] = '#ffffff'
        self.setTimerColor('timer')
        self.lcd2.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['et']}; background-color: {self.lcdpaletteB['et']};}}")
        self.lcd3.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['bt']}; background-color: {self.lcdpaletteB['bt']};}}")
        self.lcd4.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['deltaet']}; background-color: {self.lcdpaletteB['deltaet']};}}")
        self.lcd5.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['deltabt']}; background-color: {self.lcdpaletteB['deltabt']};}}")
        self.lcd6.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['sv']}; background-color: {self.lcdpaletteB['sv']};}}")
        self.lcd7.setStyleSheet(
            f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['sv']}; background-color: {self.lcdpaletteB['sv']};}}")
        self.updateExtraLCDvisibility()

    # switches slider layout to its alternative layout if 'alternativeLayout' is True,
    # other wise to standard layout
    def updateSliderLayout(self, alternativeLayout: bool) -> None:
        if alternativeLayout != self.eventsliderAlternativeLayout:
            if self.eventsliderAlternativeLayout:  # we activate standard layout
                # remove alternative layout sliders
                self.sliderGrp12.removeItem(self.sliderGrpBox1x)
                self.sliderGrp12.removeItem(self.sliderGrpBox4x)
                self.sliderGrp34.removeItem(self.sliderGrpBox2x)
                self.sliderGrp34.removeItem(self.sliderGrpBox3x)
                # add standard layout sliders
                self.sliderGrp12.addLayout(self.sliderGrpBox1x)
                self.sliderGrp12.addLayout(self.sliderGrpBox2x)
                self.sliderGrp34.addLayout(self.sliderGrpBox3x)
                self.sliderGrp34.addLayout(self.sliderGrpBox4x)
            else:  # we activate alternative layout
                # remove standard layout sliders
                self.sliderGrp12.removeItem(self.sliderGrpBox1x)
                self.sliderGrp12.removeItem(self.sliderGrpBox2x)
                self.sliderGrp34.removeItem(self.sliderGrpBox3x)
                self.sliderGrp34.removeItem(self.sliderGrpBox4x)
                # add alternative layout sliders
                self.sliderGrp12.addLayout(self.sliderGrpBox1x)
                self.sliderGrp12.addLayout(self.sliderGrpBox4x)
                self.sliderGrp34.addLayout(self.sliderGrpBox2x)
                self.sliderGrp34.addLayout(self.sliderGrpBox3x)
            self.eventsliderAlternativeLayout = alternativeLayout

    # True if background color is light, otherwise false
    @functools.cached_property
    def light_background_p(self) -> bool:
        background_color = self.qmc.palette['background']
        return self.colorDifference('#ffffff', background_color) < self.colorDifference('#000000', background_color)

    def updateCanvasColors(self, checkColors: bool = True) -> None:
        canvas_color = self.qmc.palette['canvas']
        if canvas_color is not None and canvas_color != 'None' and not QColor.isValidColor(canvas_color):
            # we re-initialize broken canvas color
            canvas_color = self.qmc.palette['canvas'] = '#F8F8F8'
        try:
            if self.qmc.ax is not None and str(canvas_color) == 'None' and sys.platform.startswith('darwin'):
                if self.app.darkmode:
                    # in dark mode on macOS, the transparent canvas of the classic Artisan theme leeds to unreadable text, thus we switch to standard gray
                    canvas_color = self.qmc.palette['canvas'] = '#333333'  # for light: "#F8F8F8"
                    self.qmc.palette['title'] = '#e6e6e6'
                    self.qmc.palette['xlabel'] = '#cccccc'
                    self.qmc.palette['ylabel'] = '#cccccc'
                else:
                    if self.qmc.palette['title'] == '#e6e6e6':
                        self.qmc.palette['title'] = '#000000'
                    if self.qmc.palette['xlabel'] == '#cccccc':
                        self.qmc.palette['xlabel'] = '#000000'
                    if self.qmc.palette['ylabel'] == '#cccccc':
                        self.qmc.palette['ylabel'] = '#000000'
                for label in self.qmc.ax.xaxis.get_ticklabels():
                    label.set_color(self.qmc.palette['xlabel'])
                for label in self.qmc.ax.yaxis.get_ticklabels():
                    label.set_color(self.qmc.palette['ylabel'])
                if self.qmc.delta_ax is not None:
                    for label in self.qmc.delta_ax.yaxis.get_ticklabels():
                        label.set_color(self.qmc.palette['ylabel'])
                    self.qmc.delta_ax.yaxis.get_label().set_color(self.qmc.palette['ylabel'])
                self.qmc.ax.xaxis.get_label().set_color(self.qmc.palette['xlabel'])
                self.qmc.ax.yaxis.get_label().set_color(self.qmc.palette['ylabel'])
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

        title_color = self.qmc.palette['title']

        current_background_color = None
        try:
            s = self.styleSheet()[12 + len('background-color:'):]
            current_background_color = s[:s.index(';')]
        except Exception:  # pylint: disable=broad-except
            pass

        # whitep = True in darkmode (dark canvas)
        if str(canvas_color) == 'None':
            if sys.platform.startswith('darwin'):
                whitep = self.app.darkmode
            else:
                whitep = False
        else:
            whitep = self.colorDifference('#ffffff', canvas_color) > self.colorDifference('#000000', canvas_color)

        self.qmc.fig.patch.set_facecolor(str(canvas_color))
        self.setStyleSheet('QMainWindow{background-color:' + str(canvas_color) + ';'
                           + 'border: 0px solid black;'
                           + '}')

        if current_background_color is None or current_background_color != str(canvas_color) or (
                whitep and self.qmc.palette[
            'messages'] != '#ffffff'):  # canvas color did not change, we do not need to redo the navigation bar
            # update navigationbar
            self.level1layout.removeWidget(self.ntb)  # remove current bar

            if self.ntb.mode == MPL_Mode.PAN:
                self.ntb.pan()  # type:ignore # PAN is active, we deactivate it before changing the ToolBar
            if self.ntb.mode == MPL_Mode.ZOOM:
                self.ntb.zoom()  # type:ignore # ZOOM is active, we deactivate it before changing the ToolBar
            self.removeToolBar(self.ntb)
            #            self.ntb.hide() # seems not to be necessary anymore with the removeToolBar() above
            self.ntb.destroy()
            self.ntb = VMToolbar(self.qmc, self.main_widget, whitep)

        if whitep:
            self.qmc.palette['messages'] = '#ffffff'
        else:
            self.qmc.palette['messages'] = '#000000'
        self.sendmessage('', append=False)
        self.ntb.setMinimumHeight(50)

        self.sliderFrame.setStyleSheet('QGroupBox {background-color:' + str(canvas_color) + ';'
                                       + 'color: ' + str(title_color) + ';'
                                       + 'border: 0px solid gray;'
                                       + 'border-width: 0px;'
                                       + 'padding-top: 12px;'
                                       + 'padding-bottom: 5px;'
                                       + 'padding-left: 0px;'
                                       + 'padding-right: 0px;'
                                       + '}'
                                       + 'QGroupBox::title {background-color:' + str(canvas_color) + ';'
                                       + 'subcontrol-origin: margin;'  # or border or margin
                                       + 'subcontrol-position: top center;'  # /* position at the top center */
                                       + 'color: ' + self.qmc.palette['messages'] + ';'
                                       + '}')

        # ensure x/y coordinates are readable
        self.ntb.locLabel.setStyleSheet('QWidget {background-color:' + str(canvas_color) + ';'
                                        + 'color: ' + str(title_color) + ';'
                                        + '}')
        # make QToolBar background transparent
        self.ntb.setStyleSheet('QToolBar {background-color:' + str(canvas_color) + ';'
                               + 'border: 5px solid ' + str(canvas_color) + ';'
                               + 'color: ' + str(title_color) + ';'
                               + '}')

        self.qmc.setProfileTitle(self.qmc.title, updatebackground=True)

        self.level1layout.insertWidget(0, self.ntb)

        if str(canvas_color) == 'None':
            self.qmc.setStyleSheet('background-color:transparent;')
            self.ntb.setStyleSheet('QToolBar {background-color:transparent;}')

        self.updateSliderColors()
        self.updatePhasesLCDsColors()

        if checkColors:
            colorPairsToCheck = self.getcolorPairsToCheck()
            self.checkColors(colorPairsToCheck)

        if hasattr(self, 'light_background_p'):
            # reset the cached property self.light_background_p
            del self.light_background_p

    # called from within the sample loop thread!
    def process_active_quantifiers(self) -> None:
        # called every sampling interval
        for i in range(4):
            if self.eventquantifieractive[i]:
                # we reduce the block values by one for each channel
                self.block_quantification_sampling_ticks[i] = max(0, self.block_quantification_sampling_ticks[i] - 1)

                # if source of event quantifier is a SV, we do not block further quantification for self.sampling_ticks_to_block_quantifiction (only for PV values that lag behind)
                if self.eventquantifierSV[i] or not self.block_quantification_sampling_ticks[i]:
                    temp, _ = self.quantifier2tempandtime(i)
                    if temp is not None and len(temp) > 0:  # corresponding curve is available
                        linespace = self.eventquantifierlinspaces[i]
                        if self.eventquantifiercoarse[i] == 1:  # slider step size 10
                            threshold = self.eventquantifierthresholdcoarse
                        elif self.eventquantifiercoarse[i] == 2:  # slider step size 5
                            threshold = self.eventquantifierthresholdmed
                        else:  # slider step size 1
                            threshold = self.eventquantifierthresholdfine
                        linespacethreshold = abs(linespace[1] - linespace[0]) * threshold
                        t = temp[-1]
                        if t != -1:  # -1 is an error value
                            d = self.digitize(t, linespace, self.eventquantifiercoarse[i], i)
                            ld = self.lastdigitizedvalue[i]  # in internal format so 8 representing 70%
                            lt = self.lastdigitizedtemp[i]  # last digitized raw value corresponding to ld
                            if (d is not None and (ld is None or ld != d) and
                                    (ld is None or lt is None or linespacethreshold < abs(
                                        t - lt))):  # and only if significantly different than previous to avoid fluktuation
                                # test if t is increasing or decreasing
                                v = d * 10.
                                # establish this one
                                self.lastdigitizedvalue[i] = d
                                self.lastdigitizedtemp[i] = t
                                lv = self.lastEventValue(i)
                                # now move corresponding slider and add event if its value is not equal to the previous one
                                if (self.float2float((v + 10.0) / 10.0)) != lv:
                                    # we set the last value to be used for relative +- button action as base
                                    self.extraeventsactionslastvalue[i] = int(round(v))
                                    self.establishQuantifiedEventSignal.emit(i, v)

    # signalled from the sampling thread via process_active_quantifiers, but runs in the GUI thread (required for this moveslider call!)
    @pyqtSlot(int, float)
    def establishQuantifiedEventSlot(self, event_type: int, event_value: float) -> None:
        try:
            self.moveslider(event_type, event_value)
            if self.qmc.flagstart:
                evalue = self.float2float((event_value + 10.0) / 10.0)
                self.qmc.eventRecordActionSignal.emit(event_type, evalue, 'Q' + self.qmc.eventsvalues(evalue),
                                                      False)  # don't call updategraphics!
            if self.qmc.flagon and self.eventquantifieraction[event_type]:
                self.fireslideractionSignal.emit(event_type)
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    def updateSliderColors(self) -> None:
        self.sliderLCD1.setStyleSheet(f'font-weight: bold; color: {self.qmc.EvalueColor[0]};')
        self.sliderLCD2.setStyleSheet(f'font-weight: bold; color: {self.qmc.EvalueColor[1]};')
        self.sliderLCD3.setStyleSheet(f'font-weight: bold; color: {self.qmc.EvalueColor[2]};')
        self.sliderLCD4.setStyleSheet(f'font-weight: bold; color: {self.qmc.EvalueColor[3]};')
        self.sliderLCDSV.setStyleSheet(f"font-weight: bold; color: {self.qmc.palette['title']};")
        self.slider1.setStyleSheet(artisan_slider_style.format(color=self.qmc.EvalueColor[0]))
        self.slider2.setStyleSheet(artisan_slider_style.format(color=self.qmc.EvalueColor[1]))
        self.slider3.setStyleSheet(artisan_slider_style.format(color=self.qmc.EvalueColor[2]))
        self.slider4.setStyleSheet(artisan_slider_style.format(color=self.qmc.EvalueColor[3]))
        self.sliderSV.setStyleSheet(artisan_slider_style.format(color=self.qmc.palette['title']))

    def updatePhasesLCDsColors(self) -> None:
        label_style = 'QLabel { color : ' + self.qmc.palette['messages'] + '; }'
        self.TPlabel.setStyleSheet(label_style)
        self.TP2DRYlabel.setStyleSheet(label_style)
        self.DRYlabel.setStyleSheet(label_style)
        self.DRY2FCslabel.setStyleSheet(label_style)
        self.FCslabel.setStyleSheet(label_style)
        self.AUClabel.setStyleSheet(label_style)

    # timex: if True, adjust time axis
    # deltas: if True adjust delta axis
    # background: if True, adjust such that background from CHARGE to DROP is fully in view
    #      (automatic set if time axis adjust is active, timex=True, during sampling and recording)
    #      if background is False, the RESET min/max times are respected even if a background profile is loaded
    def autoAdjustAxis(self, background: bool = False, timex: bool = True, deltas: bool = True) -> None:
        try:
            if self.qmc.autotimex and timex:
                # auto timex adjust
                if self.qmc.flagon and self.qmc.background:
                    # if we are recording and background profile is loaded and shown
                    background = True
                if background:
                    t_min, t_max = self.calcAutoAxisBackground()
                    if self.qmc.timeindex[0] != -1 and len(self.qmc.timex) > self.qmc.timeindex[0]:
                        t_max = t_max - self.qmc.timex[self.qmc.timeindex[0]]
                elif len(self.qmc.timex) > 3:
                    t_min, t_max = self.calcAutoAxisForeground()
                    if self.qmc.timeindex[0] != -1 and len(self.qmc.timex) > self.qmc.timeindex[0]:
                        t_max = t_max - self.qmc.timex[self.qmc.timeindex[0]]
                else:
                    t_min = self.qmc.chargemintime
                    t_max = self.qmc.resetmaxtime
                if self.qmc.background and self.qmc.autotimexMode != 2:
                    if background:
                        t_max_b = t_max
                    else:
                        _, t_max_b = self.calcAutoAxisBackground()
                        if self.qmc.timeindex[0] != -1 and len(self.qmc.timex) > self.qmc.timeindex[0]:
                            t_max_b = t_max_b - self.qmc.timex[self.qmc.timeindex[0]]
                    t_max = max(t_max, t_max_b)

                if background and self.qmc.timeindexB[0] != -1 and len(self.qmc.timeB) > self.qmc.timeindexB[0]:
                    self.qmc.startofx = t_min - self.qmc.timeB[self.qmc.timeindexB[0]]
                else:
                    self.qmc.startofx = t_min
                self.qmc.endofx = t_max
            if (self.qmc.autodeltaxET or self.qmc.autodeltaxBT) and deltas:
                # auto delta adjust
                if background:
                    dmax = self.calcAutoDeltaAxisBackground()
                else:
                    dmax = self.calcAutoDeltaAxis()
                if self.qmc.background:
                    if background:
                        dmax_b = dmax
                    else:
                        dmax_b = self.calcAutoDeltaAxisBackground()
                else:
                    dmax_b = 0
                dmax = max(dmax, dmax_b)
                # we only adjust the upper limit automatically
                if dmax > self.qmc.zlimit_min:
                    self.qmc.zlimit = int(dmax) + 1
                else:
                    self.qmc.zlimit = self.qmc.zlimit_min + 1
                # adjust zgrid (only if zgrid not deactivated)
                if self.qmc.zgrid != 0:
                    d = self.qmc.zlimit - self.qmc.zlimit_min
                    steps = int(round(d / 5))
                    if steps > 50:
                        steps = int(round(steps / 10)) * 10
                    elif steps > 10:
                        steps = int(round(steps / 5)) * 5
                    elif steps > 5:
                        steps = 5
                    else:
                        steps = int(round(steps / 2)) * 2
                    auto_grid = max(2, steps)
                    self.qmc.zgrid = auto_grid
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' autoAdjustAxis() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleFullscreen(self, _: bool = False) -> None:
        if self.full_screen_mode_active or self.isFullScreen():
            self.full_screen_mode_active = False
            self.showNormal()
            if not (platform.system() == 'Darwin' and self.qmc.locale_str == 'en'):
                self.fullscreenAction.setChecked(False)
        else:
            self.full_screen_mode_active = True
            self.showFullScreen()
            if not (platform.system() == 'Darwin' and self.qmc.locale_str == 'en'):
                self.fullscreenAction.setChecked(True)

    def calcAutoAxisForeground(self) -> Tuple[float, float]:
        return self.calcAutoAxis(self.qmc.timex, self.qmc.timeindex,
                                 self.qmc.foregroundShowFullflag or self.qmc.flagstart)

    # returns time axis min and max
    # min to be about 1min (1/16 of total time) before CHARGE or first recording if no CHARGE
    # max to be about 1min (1/10 of total time) after COOL or DROP or last recording if no DROP nor COOL
    def calcAutoAxis(self, timex: List[float], timeindex: List[int], beyondDROP: bool) -> Tuple[float, float]:
        if len(timex) > 3:
            # profile loaded?
            t_start = self.qmc.startofx
            t_end = self.qmc.endofx
            if self.qmc.autotimexMode == 0 and timeindex[0] > -1:  # CHARGE set
                t_start = timex[timeindex[0]]
            else:
                t_start = timex[0]
            if self.qmc.autotimexMode == 2 and timeindex[0] > -1:
                t_end = timex[timeindex[0]]
            elif timeindex[7] > 0 and self.qmc.buttonvisibility[
                7] and beyondDROP:  # COOL set, COOL button shown and the curves are drawn beyond DROP or recording
                t_end = timex[timeindex[7]]
            elif timeindex[6] > 0:  # DROP set
                t_end = timex[timeindex[6]]
            else:
                t_end = timex[-1]
            # add padding
            time_period = t_end - t_start
            t_start -= 1 / 16 * time_period
            t_end += 1 / 10 * time_period
            return t_start, t_end
        return self.qmc.startofx, self.qmc.endofx

    def calcAutoDelta(self, d1: List[Optional[float]], d2: List[Optional[float]],
                      timeindex: List[int], d1flag: bool, d2flag: bool) -> float:
        # returns the max ET/BT RoR between CHARGE and DROP
        start = 0
        end = min(len(d1), len(d2)) - 1
        if timeindex[0] != -1:
            start = timeindex[0]
        if timeindex[6] > 0:
            end = timeindex[6]
        try:
            visible_readings = []
            if d1flag and self.qmc.autodeltaxET:
                visible_readings.extend(d1[start:end])
            if d2flag and self.qmc.autodeltaxBT:
                visible_readings.extend(d2[start:end])
            if len(visible_readings) > 0:
                return max(filter(None, visible_readings))
            return 0
        except Exception:  # pylint: disable=broad-except
            # if filtered list is empty, max fails and we return 0
            return 0

    def calcAutoDeltaAxis(self) -> float:
        if not (self.qmc.flagstart) and (len(self.qmc.delta1) > 3 or len(self.qmc.delta2) > 3):
            return self.calcAutoDelta(self.qmc.delta1, self.qmc.delta2, self.qmc.timeindex, self.qmc.DeltaETflag,
                                      self.qmc.DeltaBTflag)
        if self.qmc.flagon:
            if self.qmc.mode == 'C':
                return self.qmc.zlimit_C_default - 1
            return self.qmc.zlimit_F_default - 1
        return 0

    def calcAutoDeltaAxisBackground(self) -> float:
        if len(self.qmc.delta1B) > 3 or len(self.qmc.delta2B) > 3:
            return self.calcAutoDelta(self.qmc.delta1B, self.qmc.delta2B, self.qmc.timeindexB, self.qmc.DeltaETBflag,
                                      self.qmc.DeltaBTBflag)
        return 0

    def calcAutoAxisBackground(self) -> Tuple[float, float]:
        return self.calcAutoAxis(self.qmc.timeB, self.qmc.timeindexB,
                                 self.qmc.backgroundShowFullflag or self.qmc.flagstart)

    # returns the last event value of the given type, or None if no event was ever recorded
    def lastEventValue(self, tp: int) -> Optional[float]:
        res_last = None
        try:
            r = range(len(self.qmc.specialeventstype) - 1, -1, -1)  # @UndefinedVariable
            for i in r:
                if self.qmc.specialeventstype[i] == tp:
                    res_last = self.qmc.specialeventsvalue[i]
                    break
        except Exception:  # pylint: disable=broad-except
            pass
        return res_last

    # order event table by time
    def orderEvents(self, lock: bool = True) -> None:
        try:
            #### lock shared resources #####
            if lock:
                self.qmc.profileDataSemaphore.acquire(1)
            nevents = len(self.qmc.specialevents)
            packed_events = []
            # pack
            for i in range(nevents):
                packed_events.append(
                    (self.qmc.specialevents[i],
                     self.qmc.specialeventstype[i],
                     self.qmc.specialeventsStrings[i],
                     self.qmc.specialeventsvalue[i]))
            # sort
            packed_events.sort(key=lambda tup: tup[0])
            # unpack
            for i in range(nevents):
                self.qmc.setEvent(i,
                                  packed_events[i][0],
                                  packed_events[i][1],
                                  packed_events[i][2],
                                  packed_events[i][3])
            # we have to clear the event flag positions as those are now out of order
            self.qmc.l_event_flags_dict = {}
            self.qmc.l_event_flags_pos_dict = {}
            # update minievent editor
            self.changeEventNumber(0)
        finally:
            if lock and self.qmc.profileDataSemaphore.available() < 1:
                self.qmc.profileDataSemaphore.release(1)

    # if only_active then only the event types with quantifiers activated are grouped
    def clusterEvents(self, only_active: bool = False) -> None:
        for i in range(4):
            if not only_active or self.eventquantifieractive[i]:
                self.clusterEventsType(i)

    # cluster of events of the given type (0-3)
    def clusterEventsType(self, tp: int) -> None:
        try:
            #### lock shared resources #####
            self.qmc.profileDataSemaphore.acquire(1)
            nevents = len(self.qmc.specialevents)
            if nevents:
                # first order the events table
                self.orderEvents(lock=False)
                # second detect the minimum time span between two events (could be equal to the sampling rate)
                min_span: Optional[float] = None
                last_event_idx: Optional[int] = None  # index of last event analyzed
                for i, se in enumerate(self.qmc.specialevents):
                    if self.qmc.specialeventstype[i] == tp and last_event_idx is not None:
                        time_diff = se - self.qmc.specialevents[last_event_idx]
                        if min_span is None or time_diff < min_span:
                            min_span = time_diff
                    last_event_idx = i
                if min_span is not None:
                    min_span = min(1, min_span, self.qmc.delay / 1000 * 3)
                    indexes_to_be_removed = []
                    last_event_idx = None  # index of last event analyzed
                    last_index_not_removed: Optional[int] = None
                    # group those with minimally 2x min_span time delta by keeping the first with the value of the last
                    for i, se in enumerate(self.qmc.specialevents):
                        if self.qmc.specialeventstype[i] == tp and last_event_idx is not None:
                            if self.qmc.specialeventsvalue[last_event_idx] == self.qmc.specialeventsvalue[
                                i]:  # type: ignore # mypy: Statement is unreachable  [unreachable]
                                # if the value of the event is the same as the previous, we remove it
                                indexes_to_be_removed.append(i)
                            else:
                                time_diff = se - self.qmc.specialevents[last_event_idx]
                                if time_diff < 2 * min_span:
                                    indexes_to_be_removed.append(i)
                                    if last_index_not_removed is not None:
                                        self.qmc.specialeventsvalue[last_index_not_removed] = \
                                            self.qmc.specialeventsvalue[i]
                                else:
                                    last_index_not_removed = i
                        if self.qmc.specialeventstype[i] == tp:
                            last_event_idx = i
                    # remove marked events
                    self.qmc.deleteEvents(indexes_to_be_removed)
        finally:
            if self.qmc.profileDataSemaphore.available() < 1:
                self.qmc.profileDataSemaphore.release(1)

    # decides on visibility of the Control button based on the selected devices and configuration
    def showControlButton(self) -> None:
        res: bool = False
        lcds: bool = False
        if self.qmc.device in {0, 26}:  # FUJI, DTA
            res = True
            if self.ser.showFujiLCDs:
                lcds = True
        #        elif self.qmc.device == 19 and self.qmc.PIDbuttonflag: # ARDUINOTC4
        #            res = True
        elif self.qmc.Controlbuttonflag:
            res = True
        if res:
            self.pidcontrol.activateONOFFeasySV(self.pidcontrol.svButtons)
            self.pidcontrol.activateSVSlider(self.pidcontrol.svSlider)
        else:
            self.pidcontrol.activateONOFFeasySV(False)
            self.pidcontrol.activateSVSlider(False)
        if self.app.artisanviewerMode:
            self.buttonCONTROL.setVisible(False)
        else:
            self.buttonCONTROL.setVisible(res)
        self.LCD6frame.setVisible(lcds)
        self.LCD7frame.setVisible(lcds)

    # i/o: 0:g, 1:Kg, 2:lb (pound), 3:oz (ounce)
    @staticmethod
    def convertWeight(v: float, i: int, o: int) -> float:
        #                g,            kg,         lb,             oz,
        convtable = [
            [1., 0.001, 0.00220462262, 0.035274],  # g
            [1000, 1., 2.205, 35.274],  # Kg
            [453.591999, 0.45359237, 1., 16.],  # lb
            [28.3495, 0.0283495, 0.0625, 1.]  # oz
        ]
        return v * convtable[i][o]

    # i/o: 0:l (liter), 1:gal (gallons US), 2:qt, 3:pt, 4:cup, 5:cm^3/ml
    @staticmethod
    def convertVolume(v: float, i: int, o: int) -> float:
        # liter          gal             qt              pt              cup             ml/cm^3
        convtable = [
            [1., 0.26417205, 1.05668821, 2.11337643, 4.22675284, 1000.],  # liter
            [3.78541181, 1., 4., 8., 16, 3785.4117884],  # gallon
            [0.94635294, 0.25, 1., 2., 4., 946.352946],  # quart
            [0.47317647, 0.125, 0.5, 1., 2., 473.176473],  # pint
            [0.23658823, 0.0625, 0.25, 0.5, 1., 236.5882365],  # cup
            [0.001, 2.6417205e-4, 1.05668821e-3, 2.11337641e-3, 4.2267528e-3, 1.]  # cm^3
        ]
        return v * convtable[i][o]

    @pyqtSlot()
    def superusermodeLeftClicked(self) -> None:
        if self.simulator is not None and self.qmc.flagstart:
            try:
                self.qmc.samplingSemaphore.acquire(1)
                self.sample_loop_running = not self.sample_loop_running
                if self.sample_loop_running:
                    period_stopped = (self.qmc.timeclock.elapsed() / self.qmc.timeclock.getBase()) - self.time_stopped
                    self.qmc.timeclock.addClock(period_stopped)

                    # restart the stopped simulator
                    modifiers = QApplication.keyboardModifiers()
                    control_modifier = modifiers == Qt.KeyboardModifier.ControlModifier  # command/apple key on macOS, Control key on Windows
                    alt_modifier = modifiers == Qt.KeyboardModifier.AltModifier  # OPTION on macOS, ALT on Windows
                    shift_modifier = modifiers == Qt.KeyboardModifier.ShiftModifier  # SHIFT
                    if control_modifier or alt_modifier or shift_modifier:
                        # if a modifier we change the speed instead of leaving the simulator (shift: 1x, alt: 2x, control: 4x):
                        speed = 1
                        if alt_modifier:
                            speed = 2
                        elif control_modifier:
                            speed = 4
                        old_base = self.qmc.timeclock.getBase()
                        old_speed = old_base / 1000
                        if old_speed != speed:
                            old_elapsed = self.qmc.timeclock.elapsed()
                            # switch to new speed:
                            new_base = 1000 * speed
                            self.qmc.timeclock.setBase(new_base)
                            # time-base changed, we have to adjust our clock
                            new_elapsed = self.qmc.timeclock.elapsed()
                            offset = (new_elapsed - old_elapsed) / new_base
                            self.qmc.timeclock.addClock(offset)
                            self.updateWindowTitle()
                        self.sendmessage(QApplication.translate('Message', 'Simulator started @{}x').format(speed))
                    self.qmc.updateDeltaSamples()  # to get the delta_spans right
                else:
                    # remember the time on stopping the simulator
                    self.time_stopped = self.qmc.timeclock.elapsed() / self.qmc.timeclock.getBase()
            finally:
                if self.qmc.samplingSemaphore.available() < 1:
                    self.qmc.samplingSemaphore.release(1)
        else:
            self.superusermode = not self.superusermode
            if self.superusermode:
                self.sendmessage(QApplication.translate('Message', 'super on'))
                _log.info('Hottop super on')
            else:
                self.sendmessage(QApplication.translate('Message', 'super off'))
                _log.info('Hottop super off')

    @pyqtSlot(QPoint)
    def PhaseslcdClicked(self, _: QPoint) -> None:  # pylint: disable=no-self-use # used as slot
        self.qmc.phasesLCDmode = (self.qmc.phasesLCDmode + 1) % 3
        self.updatePhasesLCDs()

    @pyqtSlot(QPoint)
    def AUClcdClicked(self, _: QPoint) -> None:
        self.qmc.AUCLCDmode = (self.qmc.AUCLCDmode + 1) % 3
        if self.qmc.AUCLCDmode == 0:
            label = QApplication.translate('Label', 'AUC')
        elif self.qmc.AUCLCDmode == 1:
            label = '&raquo;' + QApplication.translate('Label', 'AUC')
        else:
            label = QApplication.translate('Label', 'AUC FCs')
        self.AUClabel.setText('<small><b>' + label + '</b></small>')
        if self.LargePhasesLCDsFlag and self.largePhasesLCDs_dialog:
            self.largePhasesLCDs_dialog.updatePhasesLabels([None, None, None, label])
        self.updateAUCLCD()

    def colordialog(self, c: QColor, noButtons: bool = False, parent: Optional[QWidget] = None) -> QColor:
        if platform.system() == 'Darwin' and noButtons:
            if parent is None:
                parent = self
            cd = QColorDialog(parent)
            cd.setModal(True)
            cd.setWindowModality(Qt.WindowModality.ApplicationModal)
            cd.setOption(QColorDialog.ColorDialogOption.NoButtons, True)
            # cd.setOption(QColorDialog.ColorDialogOption.ShowAlphaChannel,True)
            # cd.setOption(QColorDialog.ColorDialogOption.NoButtons | QColorDialog.ColorDialogOption.ShowAlphaChannel,True)
            cd.setCurrentColor(c)
            cd.exec()
            return cd.currentColor()
        return QColorDialog.getColor(c)

    @pyqtSlot(int)
    def adjustPIDsv(self, x: int) -> None:
        if self.qmc.device == 0:  # Fuji PID
            self.fujipid.adjustsv(x)
        #        elif self.qmc.device == 19: # Arduino TC4
        else:  # Arduino TC4, internal Software PID or MODBUS/S7 external PID
            self.pidcontrol.adjustsv(x)

    @pyqtSlot(int)
    def setPIDsv(self, sv: int) -> None:
        if self.qmc.device == 0 and sv != self.fujipid.sv:  # Fuji PID
            self.fujipid.setsv(sv, silent=True)
        elif sv != self.pidcontrol.sv:
            self.pidcontrol.setSV(sv, init=False)

    @pyqtSlot(bool)
    def adjustPIDsv5(self, _: bool = False) -> None:
        self.adjustPIDsv(5)

    @pyqtSlot(bool)
    def adjustPIDsv10(self, _: bool = False) -> None:
        self.adjustPIDsv(10)

    @pyqtSlot(bool)
    def adjustPIDsv20(self, _: bool = False) -> None:
        self.adjustPIDsv(20)

    @pyqtSlot(bool)
    def adjustPIDsv20m(self, _: bool = False) -> None:
        self.adjustPIDsv(-20)

    @pyqtSlot(bool)
    def adjustPIDsv10m(self, _: bool = False) -> None:
        self.adjustPIDsv(-10)

    @pyqtSlot(bool)
    def adjustPIDsv5m(self, _: bool = False) -> None:
        self.adjustPIDsv(-5)

    # compute the 12 (if step size is 10) or 21 (if step size is 5) or 102 (if step size is 1) event quantifier linespace for type n in [0,3]
    def computeLinespace(self, n: int) -> 'npt.NDArray[numpy.double]':
        if self.eventquantifiercoarse[n] == 1:  # step size 10
            num = int(round((self.eventslidermax[n] - self.eventslidermin[n]) / 10.)) + 1
        elif self.eventquantifiercoarse[n] == 2:  # step size 5
            num = int(round((self.eventslidermax[n] - self.eventslidermin[n]) / 5.)) + 1
        else:  # step size 1
            num = self.eventslidermax[n] - self.eventslidermin[n] + 1
        return numpy.linspace(self.eventquantifiermin[n], self.eventquantifiermax[n], num=num)

    # update all 4 event quantifier linespaces
    def computeLinespaces(self) -> None:
        for n in range(4):
            self.eventquantifierlinspaces[n] = self.computeLinespace(n)

    # returns temp and time arrays corresponding to the quantifier source
    # temp might be None if there is no corresponding curve
    def quantifier2tempandtime(self, i: int) -> Tuple[Optional[List[float]], List[float]]:
        temp = None
        if self.qmc.flagstart or not self.qmc.flagon:
            timex = self.qmc.timex
        else:
            timex = self.qmc.on_timex
        if self.eventquantifiersource[i] == 0:
            if self.qmc.flagstart or not self.qmc.flagon:
                temp = self.qmc.temp1
            else:
                temp = self.qmc.on_temp1
        elif self.eventquantifiersource[i] == 1:
            if self.qmc.flagstart or not self.qmc.flagon:
                temp = self.qmc.temp2
            else:
                temp = self.qmc.on_temp2
        else:
            x = self.eventquantifiersource[i] - 2
            try:
                if self.qmc.flagstart or not self.qmc.flagon:
                    timex = self.qmc.extratimex[x // 2]
                else:
                    timex = self.qmc.on_extratimex[x // 2]
                if x % 2 == 0:
                    # even
                    if len(self.qmc.extratemp1) > (x / 2):
                        if self.qmc.flagstart or not self.qmc.flagon:
                            temp = self.qmc.extratemp1[x // 2]
                        else:
                            temp = self.qmc.on_extratemp1[x // 2]
                # odd
                elif len(self.qmc.extratemp2) > (x / 2):
                    if self.qmc.flagstart or not self.qmc.flagon:
                        temp = self.qmc.extratemp2[x // 2]
                    else:
                        temp = self.qmc.on_extratemp2[x // 2]
            except Exception:  # pylint: disable=broad-except
                # timex might not have an index x // 2
                pass
        return temp, timex

    # returns as min/max the values  (self.eventslidermin / 10) and (self.eventslidermax / 10) for values outside of the given linespace ls defining the interval
    # otherwise the bin number
    # NOTE: the value returned is the event value divided by 10, but not with the internal offset of +1 !!
    def digitize(self, v: float, ls: 'npt.NDArray[numpy.double]', coarse: int, i: int) -> float:
        factor: int = 1  # slider step size 1
        if coarse == 1:  # slider step size 10
            factor = 10
        elif coarse == 2:  # slider step size 5
            factor = 5
        r = float(((numpy.digitize([v], ls)[0] - 1) * factor + self.eventslidermin[i]) / 10.)
        return max(self.eventslidermin[i] / 10., min(self.eventslidermax[i] / 10., r))

    def curveSimilarity2(self, exp: int = -1, analysis_starttime: float = 0,
                         analysis_endtime: float = 0) -> 'CurveSimilarity':  # pylint: disable=no-self-use
        result: CurveSimilarity = {
            'mse_BT': float('nan'),
            'mse_deltaBT': float('nan'),
            'rmse_BT': float('nan'),
            'rmse_deltaBT': float('nan'),
            'r2_BT': float('nan'),
            'r2_deltaBT': float('nan'),
            'ror_fcs_act': '--',  # prettytable accepts text or number; floats will be converted to str
            'ror_fcs_delta': '--',  # prettytable accepts text or number; floats will be converted to str
            'ror_max_delta': float('nan'),
            'ror_min_delta': float('nan'),
            'segmentresultstr': ''
        }
        mask = numpy.empty(0)
        fitRoR = '--'  # not a type issue, prettytable accepts text or number
        RoR_FCs_act = '--'  # not a type issue, prettytable accepts text or number
        mse_BT = float('nan')
        mse_deltaBT = float('nan')
        rmse_BT = float('nan')
        rmse_deltaBT = float('nan')
        r2_BT = float('nan')
        r2_deltaBT = float('nan')
        RoR_FCs_delta: str = '--'  # not a type issue, prettytable accepts text or number # ML: we convert floats to str to make mypy happy
        maxdelta = float('nan')
        mindelta = float('nan')
        ioi_start = ''
        ioi_duration = ''
        ioi_maxdelta = ''
        ioi_abcprime = ''
        maxdeltas_seg = numpy.empty(0)
        deltatimes_seg: 'npt.NDArray[numpy.double]' = numpy.empty(0)
        timeindexs_seg: 'npt.NDArray[numpy.int64]' = numpy.empty(0, dtype=numpy.int64)
        segment_rmse_deltas = numpy.empty(0)  # segment root mean square error (difference)
        segment_mse_deltas = numpy.empty(0)  # segment mean square error (difference)
        segment_abc_deltas = numpy.empty(0)  # segmnt area between the curves
        try:
            if self.qmc.background:
                analysis_start = self.qmc.time2index(analysis_starttime)
                analysis_end = self.qmc.time2index(analysis_endtime) + 1  # +1 was added 9/25
                np_bt = numpy.array(self.qmc.stemp2[analysis_start:analysis_end])
                np_dbt = numpy.array(self.qmc.delta2[analysis_start:analysis_end])
                # compare to background curve?
                if exp == 4:
                    # create background BT and background delta BT arrays over the interval of interest
                    xarray = numpy.array(self.qmc.timex[analysis_start:analysis_end])
                    # replace None entries with 0 in the background delta list
                    _delta2B = [0 if x is None else x for x in self.qmc.delta2B]
                    np_dbtb = numpy.array([self.qmc.timetemparray2temp(self.qmc.timeB, _delta2B, x) for x in xarray])
                    np_btb = numpy.array(
                        [self.qmc.timetemparray2temp(self.qmc.timeB, self.qmc.temp2B, x) for x in xarray])
                else:
                    np_btb = numpy.array(self.qmc.stemp2B[analysis_start:analysis_end])
                    np_dbtb = numpy.array(self.qmc.delta2B[analysis_start:analysis_end])

                # Replace None values in the Delta curves with the closest numeric value on the right
                def replNone(a: 'npt.NDArray[numpy.double]',
                             nv: 'npt.NDArray[numpy.int64]') -> 'npt.NDArray[numpy.double]':
                    for i, nvi in enumerate(nv):
                        if i == len(nv) - 1:
                            a[nvi] = 0
                        elif a[nvi + 1] is None:
                            a[nvi] = 0
                        else:
                            a[nvi] = a[nvi + 1]
                    return a

                nv = numpy.where(np_dbt is None)[0]
                nvb = numpy.where(np_dbtb is None)[0]
                np_dbt = replNone(np_dbt, nv)
                np_dbtb = replNone(np_dbtb, nvb)

                if len(np_dbt) == 0:
                    raise ValueError('Length of np_dbt is zero')
                if len(np_dbtb) == 0:
                    raise ValueError('Length of np_dbtb is zero')

                # MSE
                mse_BT = numpy.mean(numpy.square(np_bt - np_btb))
                mse_deltaBT = numpy.mean(numpy.square(np_dbt - np_dbtb))

                # RMSE
                rmse_BT = numpy.sqrt(mse_BT)
                rmse_deltaBT = numpy.sqrt(mse_deltaBT)

                # R squared - Coefficient of determination from 0 to 1 (1 is a good result, 0 is not good)
                # residual sum of squares
                ss_res_bt = float(numpy.sum((np_bt - np_btb) ** 2))
                ss_res_dbt = float(numpy.sum((np_dbt - np_dbtb) ** 2))
                # total sum of squares
                ss_tot_bt = float(numpy.sum((np_bt - numpy.mean(np_bt)) ** 2))
                ss_tot_dbt = float(numpy.sum((np_dbt - numpy.mean(np_dbt)) ** 2))
                # r-squared
                r2_BT = 1 - (ss_res_bt / ss_tot_bt)
                r2_deltaBT = 1 - (ss_res_dbt / ss_tot_dbt)

                # Tests that require FCs is marked
                if self.qmc.timeindex[2]:
                    # RoR at time of FCs, and Actual RoR versus Template RoR at FCs
                    RoR_FCs_act_float = self.qmc.delta2[self.qmc.timeindex[2]]
                    try:
                        fcs_idx = self.qmc.timeindex[2] - analysis_start
                        RoR_FCs_delta = f'{RoR_FCs_act_float - np_dbtb[fcs_idx]:.2f}'
                    except Exception:  # pylint: disable=broad-except
                        RoR_FCs_delta = str(float('nan'))
                    RoR_FCs_act = f'{RoR_FCs_act_float:.2f}'

                # max and min difference between actual RoR and template RoR
                maxdelta = numpy.max(np_dbt - np_dbtb)
                mindelta = numpy.min(np_dbt - np_dbtb)

                # calculate the rise, crash and flick
                # create array of differences between actual curve and the fit curve
                deltas_all = numpy.array(np_dbt - np_dbtb, dtype=float)
                # array indicating the actual curve is greater than the fit curve (+1) or is less than (-1)
                signs_all = numpy.sign(deltas_all).astype(int)
                # array with start index of each interval between crossings
                starts = numpy.r_[0, numpy.flatnonzero(~numpy.isclose(signs_all[1:], signs_all[:-1])) + 1.].astype(int)
                # array with the length (number of samples) of each internal between crossings
                lengths = numpy.diff(numpy.r_[starts, len(signs_all)])
                # array of all the time index values
                timeindexs_all = numpy.arange(analysis_start, analysis_end, 1)
                # time indexes of the start of segments
                timeindexs = timeindexs_all[starts]
                # array with all time values
                times_all = numpy.array(self.qmc.timex[analysis_start:analysis_end])
                # array with start times of segments
                times = times_all[starts]
                # add the ending (DROP) time to use when creating deltatimes
                times = numpy.append(times, times_all[-1])
                # array containing the delta times from segment start to end
                deltatimes = numpy.diff(times)
                # array indicating segment has actual greater than fit (+1) or actual less than fit (-1)
                signs = signs_all[starts]

                # array of max difference for each segment
                maxdeltas = numpy.empty(0)
                for i, ss in enumerate(starts):
                    x = deltas_all[ss:ss + lengths[i]]
                    maxdeltas = numpy.append(maxdeltas, x[abs(x).argmax()])

                # thresholds

                if self.qmc.profile_sampling_interval is None:
                    speed = self.qmc.timeclock.getBase() / 1000
                    interval = speed * (self.qmc.delay / 1000)
                else:
                    interval = self.qmc.profile_sampling_interval

                segtimethreshold = self.qmc.segmentsamplesthreshold * interval
                segdeltathreshold = self.qmc.segmentdeltathreshold
                reductions = numpy.zeros_like(signs).astype(int)

                # mark segments that are insignificant and should be combined (reduced) to the left
                for i in range(len(starts)):
                    if deltatimes[i] <= segtimethreshold or abs(maxdeltas[i]) <= segdeltathreshold:
                        reductions[i] = 1

                # extend the reduction to include the sample on the right when its sign matches the sign of the first segment in the reduction
                prevsign = signs[0]
                prevreduction = 0
                reductions[0] = 0  # the first entry is never combined to the left.
                for i in range(1, len(starts)):
                    if reductions[i] == 1:
                        prevreduction = 1
                    elif signs[i] == prevsign and prevreduction == 1:
                        reductions[i] = 1
                    else:
                        prevreduction = 0
                        prevsign = signs[i]

                # generate the reduced segment arrays
                rs_starts = numpy.zeros_like(starts)
                rs_deltatimes = numpy.zeros_like(starts, dtype=float)
                rs_lengths = numpy.zeros_like(starts, dtype=int)
                lasti = 0
                for i, ss in enumerate(starts):
                    if reductions[i] == 1 and i + 1 < len(starts):
                        rs_lengths[lasti] += lengths[i]
                        rs_deltatimes[lasti] += deltatimes[i]
                    elif reductions[i] == 1:
                        rs_lengths[lasti] += numpy.sum(lengths[i:])
                        rs_deltatimes[lasti] += numpy.sum(deltatimes[i:])
                    else:
                        rs_starts[i] = ss
                        rs_lengths[i] = lengths[i]
                        rs_deltatimes[i] = deltatimes[i]
                        lasti = i
                mask = numpy.r_[0, numpy.flatnonzero(rs_starts)]
                starts_seg = rs_starts[mask]
                lengths_seg = rs_lengths[mask]
                deltatimes_seg = rs_deltatimes[mask]
                timeindexs_seg = timeindexs[mask]

                for i, mm in enumerate(mask):
                    if i < len(mask) - 1:
                        x = maxdeltas[mm:mask[i + 1]]
                    else:
                        x = maxdeltas[mm:]
                    maxdeltas_seg = numpy.append(maxdeltas_seg, x[abs(x).argmax()])

                # Per segment metrics
                for i, ss in enumerate(starts_seg):
                    segment_deltas = deltas_all[ss:ss + lengths_seg[i] + 1]
                    segment_abs_deltas = numpy.absolute(segment_deltas)
                    segment_rmse_deltas = numpy.append(segment_rmse_deltas,
                                                       numpy.sqrt(numpy.mean(numpy.square(segment_deltas))))
                    segment_mse_deltas = numpy.append(segment_mse_deltas, numpy.mean(numpy.square(segment_deltas)))
                    segment_times = times_all[ss:ss + lengths_seg[i] + 1]
                    segment_abc_deltas = numpy.append(segment_abc_deltas,
                                                      numpy.trapz(segment_abs_deltas, x=segment_times))

                # interval of interest metrics
                ioi_start = self.eventtime2string(
                    self.qmc.timex[timeindexs_seg[0]] - self.qmc.timex[self.qmc.timeindex[0]])
                ioi_seconds = analysis_endtime - analysis_starttime
                ioi_duration = self.eventtime2string(ioi_seconds)
                ioi_abs_deltas = numpy.absolute(deltas_all)
                ioi_maxdelta = deltas_all[numpy.asarray(ioi_abs_deltas == numpy.amax(ioi_abs_deltas)).nonzero()[0][0]]
                ioi_abc_deltas = numpy.sum(numpy.trapz(ioi_abs_deltas, x=times_all))
                ioi_abcprime = ioi_abc_deltas / ioi_seconds

                # fit RoR in C/min/min
                # if exp == 2:
                #     fitRoR = 60 * (np_dbtb[-1] - np_dbtb[0]) / (
                #                 self.qmc.timex[timeindexs_all[-1]] - self.qmc.timex[timeindexs_all[0]])
                #     fitRoR = f'{fitRoR:.2f}'
            else:
                # there is no background
                pass

            # general information
            fitTypes = [QApplication.translate('Label', 'ln()'),
                        '',
                        QApplication.translate('Label', 'x') + '\u00b2',
                        QApplication.translate('Label', 'x') + '\u00b3',
                        QApplication.translate('Label', 'Bkgnd'), '']
            fitType = fitTypes[exp]
            if self.qmc.filterDropOuts:
                smoothspikes = QApplication.translate('Label', 'On')
            else:
                smoothspikes = QApplication.translate('Label', 'Off')
            if self.qmc.optimalSmoothing:
                optimal = QApplication.translate('Label', 'On')
            else:
                optimal = QApplication.translate('Label', 'Off')
            if self.qmc.polyfitRoRcalc:
                polyfit = QApplication.translate('Label', 'On')
            else:
                polyfit = QApplication.translate('Label', 'Off')

            # build a table of results
            import prettytable  # @UnresolvedImport
            tbl = prettytable.PrettyTable()
            tbl.field_names = [QApplication.translate('Label', 'Start'),
                               QApplication.translate('Label', 'Duration'),
                               QApplication.translate('Label', 'Max Delta'),
                               QApplication.translate('Label', 'Swing'),
                               QApplication.translate('Label', 'ABC/secs')]
            tbl.float_format = '5.2'
            for i in range(len(mask)):
                thistime = self.eventtime2string(
                    self.qmc.timex[timeindexs_seg[i]] - self.qmc.timex[self.qmc.timeindex[0]])
                duration = self.eventtime2string(deltatimes_seg[i])
                swing = maxdeltas_seg[i] - maxdeltas_seg[i - 1] if i > 0 else ''
                abcprime = segment_abc_deltas[i] / deltatimes_seg[i]
                tbl.add_row([thistime, duration, maxdeltas_seg[i], swing, abcprime])
            if len(mask) > 1:
                tbl.add_row(['~~~~~', '~~~~~', '~~~~~', '~~~~~', '~~~~~'])
                tbl.add_row([ioi_start, ioi_duration, ioi_maxdelta, '-', ioi_abcprime])
            segmentresultstr = QApplication.translate('Label', 'Segment Analysis (rise, crash and flick)') + '\n'
            segmentresultstr += tbl.get_string(border=True)

            # set background alignment information for Fit to Bkgnd
            if exp == 4:  # background fit
                bgAlignLabel = QApplication.translate('Label', 'Background Align')
                bgAlignType = self.qmc.alignnames[self.qmc.alignEvent]
            else:
                bgAlignLabel = ''
                bgAlignType = ''

            # build table of general information
            tbl2 = prettytable.PrettyTable()
            tbl2.field_names = ['A', 'A1', 'B', 'B1']
            tbl2.align = 'l'
            tbl2.align['A1'] = 'r'  # type: ignore # Unsupported target for indexed assignment ("str")
            tbl2.align['B1'] = 'r'  # type: ignore # Unsupported target for indexed assignment ("str")
            tbl2.float_format = '5.2'
            tbl2.add_row([QApplication.translate('Label', 'Curve Fit'), fitType, bgAlignLabel, bgAlignType])
            tbl2.add_row([QApplication.translate('Label', 'Samples Threshold'), self.qmc.segmentsamplesthreshold,
                          QApplication.translate('Label', 'Delta Threshold'), self.qmc.segmentdeltathreshold])
            tbl2.add_row([QApplication.translate('Label', 'Sample rate (secs)'), self.qmc.profile_sampling_interval,
                          QApplication.translate('Label', 'Smooth Curves/Spikes'),
                          f'{str(int((self.qmc.curvefilter - 1) / 2))}/{str(smoothspikes)}'])
            tbl2.add_row([QApplication.translate('Label', 'Delta Span/Smoothing'),
                          f'{str(self.qmc.deltaBTspan)}/{str(int((self.qmc.deltaBTfilter - 1) / 2))}',
                          QApplication.translate('Label', 'Polyfit/Optimal Smoothing'),
                          f'{str(polyfit)}/{str(optimal)}'])
            # tbl2.add_row([QApplication.translate('Label', 'Fit RoRoR (C/min/min)'), fitRoR,
            #               QApplication.translate('Label', 'Actual RoR at FCs'), RoR_FCs_act])
            segmentresultstr += '{}{}'.format('\n', tbl2.get_string(border=False, header=False))

            result['segmentresultstr'] = segmentresultstr

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' curveSimilatrity2(): {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

        # build the dict to return
        result['mse_BT'] = float(mse_BT)
        result['mse_deltaBT'] = float(mse_deltaBT)
        result['rmse_BT'] = float(rmse_BT)
        result['rmse_deltaBT'] = float(rmse_deltaBT)
        result['r2_BT'] = float(r2_BT)
        result['r2_deltaBT'] = float(r2_deltaBT)
        result['ror_fcs_act'] = RoR_FCs_act
        result['ror_fcs_delta'] = RoR_FCs_delta
        result['ror_max_delta'] = float(maxdelta)
        result['ror_min_delta'] = float(mindelta)

        return result

    # computes the similarity between BT and backgroundBT as well as ET and backgroundET
    # known as CM (idea by Hungary roasting company Casino Mocca)
    # computes from profile DRY END as set in Phases dialog through DROP
    # returns None in case no similarity can be computed
    # refactored to use numpy arrays.
    def curveSimilarity(self) -> Tuple[Optional[float], Optional[float]]:  # pylint: disable=no-self-use
        try:
            # if background profile is loaded and both profiles have a DROP event set
            if self.qmc.backgroundprofile is not None and self.qmc.timeindex[6] and self.qmc.timeindexB[6]:

                #                _log.debug(f"curveSimilarity: {self.qmc.profile_sampling_interval=}")  #pylint: disable=logging-fstring-interpolation
                #                _log.debug(f"curveSimilarity: {self.qmc.background_profile_sampling_interval=}")  #pylint: disable=logging-fstring-interpolation

                # create arrays using smoothed data if available
                if self.qmc.stemp1 is not None and len(self.qmc.stemp1) == len(self.qmc.temp1):
                    # take smoothed data if available
                    np_et = numpy.array(self.qmc.stemp1)
                else:
                    np_et = numpy.array(self.qmc.temp1)
                    _log.debug('curveSimilarity: using non-smoothed ET')
                if self.qmc.stemp2 is not None and len(self.qmc.stemp2) == len(self.qmc.temp2):
                    # take smoothed data if available
                    np_bt = numpy.array(self.qmc.stemp2)
                else:
                    np_bt = numpy.array(self.qmc.temp2)
                    _log.debug('curveSimilarity: using non-smoothed BT')

                # CM is based on the Phases Dry not marked Dry
                # Find the DRY point
                # create a view of the original with a stride that accesses it in reverse order
                rev_np_bt = np_bt[::-1]
                # Find TP or if there is not one then find the minimum temp before DROP
                # Note - CHARGE is not considered
                len_bt = len(self.qmc.stemp2)
                rev_drop_idx: int = len_bt - self.qmc.timeindex[6]
                BTlimit = self.qmc.phases[1]
                if len(rev_np_bt[rev_drop_idx:]) == 0:
                    return None, None
                rev_min_idx: int = int(numpy.argmin(rev_np_bt[rev_drop_idx:])) + rev_drop_idx

                if len(rev_np_bt[rev_drop_idx:rev_min_idx]) == 0:
                    return None, None
                # Find the first sample less than the phases DRY temp (going backwards from DROP)
                rev_dry_idx: int = int(numpy.argmin(numpy.sign(rev_np_bt[rev_drop_idx:rev_min_idx] - BTlimit)))

                # Flip the index to forward looking
                dry_idx: int = len_bt - (rev_drop_idx + rev_dry_idx)

                # set start and end indexes
                start: int = dry_idx
                end: int = self.qmc.timeindex[6] + 1  # the +1 adjusts for Python indexing

                # create arrays from Dry to DROP,
                np_et = np_et[start:end]
                np_bt = np_bt[start:end]
                np_timex = numpy.array(self.qmc.timex[start:end])

                # difference in time between DROPs in profile and background
                dropTimeDelta = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timeB[self.qmc.timeindexB[6]]

                # these are not the smoothed background temps, which is how the old CM was done
                np_etb = numpy.array(self.qmc.temp1B)
                np_btb = numpy.array(self.qmc.temp2B)
                np_timeB = numpy.array(self.qmc.timeB) + dropTimeDelta

                # hack to work like OLD method where any temp before timeB[0] is -1
                np_etb = numpy.insert(np_etb, 0, -1)
                np_btb = numpy.insert(np_btb, 0, -1)
                np_timeB = numpy.insert(np_timeB, 0, np_timeB[0] - 0.1)

                interp_np_etb = numpy.interp(np_timex, np_timeB, np_etb)
                interp_np_btb = numpy.interp(np_timex, np_timeB, np_btb)

                det = numpy.sqrt(numpy.mean(numpy.square(np_et - interp_np_etb)))
                dbt = numpy.sqrt(numpy.mean(numpy.square(np_bt - interp_np_btb)))

                if numpy.isnan(det):
                    det = None
                if numpy.isnan(dbt):
                    dbt = None

                return det, dbt

            # no DROP event registered
            return None, None
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' curveSimilatrity(): {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return None, None

    def setLCDsDigitCount(self, n: int) -> None:
        self.lcd2.setDigitCount(n)
        self.lcd2.setMinimumWidth(n * 16)
        self.lcd3.setDigitCount(n)
        self.lcd3.setMinimumWidth(n * 16)
        self.lcd4.setDigitCount(n)
        self.lcd4.setMinimumWidth(n * 16)
        self.lcd5.setDigitCount(n)
        self.lcd5.setMinimumWidth(n * 16)
        self.lcd6.setDigitCount(n)
        self.lcd6.setMinimumWidth(n * 16)
        self.lcd7.setDigitCount(n)
        self.lcd7.setMinimumWidth(n * 16)
        for i in range(self.nLCDS):
            self.extraLCD1[i].setDigitCount(n)
            self.extraLCD1[i].setMinimumWidth(n * 16)
            self.extraLCD2[i].setDigitCount(n)
            self.extraLCD2[i].setMinimumWidth(n * 16)

        if not self.qmc.flagon:
            zz = '-.-' if self.qmc.LCDdecimalplaces else '--'
            self.lcd2.display(zz)
            self.lcd3.display(zz)
            self.lcd4.display(zz)
            self.lcd5.display(zz)
            self.lcd6.display(zz)
            self.lcd7.display(zz)
            for i in range(self.nLCDS):
                self.extraLCD1[i].display(zz)
                self.extraLCD2[i].display(zz)
        #
        if self.largeLCDs_dialog is not None:
            self.largeLCDs_dialog.updateDecimals()
        if self.largeDeltaLCDs_dialog is not None:
            self.largeDeltaLCDs_dialog.updateDecimals()
        if self.largePIDLCDs_dialog is not None:
            self.largePIDLCDs_dialog.updateDecimals()
        if self.largeExtraLCDs_dialog is not None:
            self.largeExtraLCDs_dialog.updateDecimals()

    def ArtisanLCD(self) -> MyQLCDNumber:
        lcd = MyQLCDNumber()
        lcd.setSegmentStyle(QLCDNumber.SegmentStyle.Flat)
        lcd.setFrameStyle(QFrame.Shadow.Plain)
        lcd.setSmallDecimalPoint(False)
        lcd.setMinimumHeight(35)
        x = 16
        if self.qmc.LCDdecimalplaces:
            lcd.setDigitCount(5)  # default is 5
            lcd.setMinimumWidth(5 * x)
            lcd.setMaximumWidth(5 * x)
        else:
            lcd.setDigitCount(3)  # default is 5
            lcd.setMinimumWidth(3 * x)
            lcd.setMaximumWidth(3 * x)
        return lcd

    def releaseSliderFocus(self) -> None:
        for s in [self.slider1, self.slider2, self.slider3, self.slider4]:
            s.releaseKeyboard()
            s.clearFocus()

    # set slider focus to Qt.FocusPolicy.StrongFocus to allow keyboard control and
    # Qt.FocusPolicy.NoFocus to deactivate it
    def setSliderFocusPolicy(self, focus: Qt.FocusPolicy) -> None:
        if self.eventsliderKeyboardControl and bool(self.eventslidervisibilities[0]):
            self.slider1.setFocusPolicy(focus)
        else:
            self.slider1.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.slider1.clearFocus()
        if self.eventsliderKeyboardControl and bool(self.eventslidervisibilities[1]):
            self.slider2.setFocusPolicy(focus)
        else:
            self.slider2.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.slider2.clearFocus()
        if self.eventsliderKeyboardControl and bool(self.eventslidervisibilities[2]):
            self.slider3.setFocusPolicy(focus)
        else:
            self.slider3.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.slider3.clearFocus()
        if self.eventsliderKeyboardControl and bool(self.eventslidervisibilities[3]):
            self.slider4.setFocusPolicy(focus)
        else:
            self.slider4.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.slider4.clearFocus()
        if self.eventsliderKeyboardControl and bool(self.pidcontrol.svSlider):
            self.sliderSV.setFocusPolicy(focus)
        else:
            self.sliderSV.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.sliderSV.clearFocus()

    def setFonts(self, redraw: bool = True) -> None:
        # try to select the right font for matplotlib according to the given locale and platform
        if self.qmc.graphfont == 0:
            try:
                rcParams['axes.unicode_minus'] = True
                rcParams['font.size'] = 12.0
                if platform.system() == 'Darwin':
                    mpl.rcParams['font.family'] = 'Arial Unicode MS'
                    self.mpl_fontproperties = FontProperties()
                elif platform.system() == 'Linux':
                    mpl.rcParams['font.family'] = ['DejaVu Sans', 'DejaVu Sans Mono']  # default; works for Greek
                    if self.locale_str == 'ar':
                        mpl.rcParams['font.family'] = ['DejaVu Sans', 'DejaVu Sans Mono', 'Times New Roman']
                    elif self.locale_str == 'ja':
                        mpl.rcParams['font.family'] = ['TakaoPGothic']
                    elif self.locale_str == 'zh_CN':
                        mpl.rcParams['font.family'] = ['NanumGothic', 'DejaVu Sans Mono']
                    elif self.locale_str == 'zh_TW':
                        mpl.rcParams['font.family'] = ['NanumGothic', 'DejaVu Sans Mono']
                    self.mpl_fontproperties = FontProperties()
                else:  # Windows:
                    mpl.rcParams['font.family'] = ['Microsoft Sans Serif', 'Arial']  # works for Greek and Arabic
                    self.mpl_fontproperties = FontProperties()
                    # for asian languages on Windows we have to set the parameters directly to *.ttc fonts (mpl supports only *.ttf)
                    if self.locale_str == 'ja':
                        self.set_mpl_fontproperties('C:\\Windows\\Fonts\\MSGOTHIC.ttc')
                    elif self.locale_str == 'zh_CN':
                        self.set_mpl_fontproperties('C:\\Windows\\Fonts\\simsun.ttc')
                    elif self.locale_str == 'zh_TW':
                        self.set_mpl_fontproperties('C:\\Windows\\Fonts\\mingliu.ttc')
                    elif self.locale_str == 'ko':
                        self.set_mpl_fontproperties('C:\\Windows\\Fonts\\batang.ttc')
            #                    elif self.locale_str == "ar":
            #                        mpl.rcParams['font.family'] = "TraditionalArabic"
            #                        self.mpl_fontproperties = FontProperties()
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
        elif self.qmc.graphfont == 3:  # WenQuanYi Zen Hei
            # font WenQuanYi selected
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['WenQuanYi Zen Hei']
            rcParams['axes.unicode_minus'] = False
            #            self.set_mpl_fontproperties(self.getResourcePath() + "wqy-zenhei.ttc") # .ttc fonts are not supported yet by the PDF backend
            self.set_mpl_fontproperties(getResourcePath() + 'WenQuanYiZenHei-01.ttf')
        elif self.qmc.graphfont == 4:  # Source Han Sans CN
            # font Source Han Sans selected, Simplified Chinese
            rcParams['axes.unicode_minus'] = True
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Source Han Sans CN']
            self.set_mpl_fontproperties(getResourcePath() + 'SourceHanSansCN-Regular.otf')
        elif self.qmc.graphfont == 5:  # Source Han Sans TW
            # font Source Han Sans selected, Traditional Chinese, Taiwan
            rcParams['axes.unicode_minus'] = True
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Source Han Sans TW']
            self.set_mpl_fontproperties(getResourcePath() + 'SourceHanSansTW-Regular.otf')
        elif self.qmc.graphfont == 6:  # Source Han Sans HK
            # font Source Han Sans selected, Traditional Chinese, Hong Kong
            rcParams['axes.unicode_minus'] = True
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Source Han Sans HK']
            self.set_mpl_fontproperties(getResourcePath() + 'SourceHanSansHK-Regular.otf')
        elif self.qmc.graphfont == 7:  # Source Han Sans KR
            # font Source Han Sans selected, Korean
            rcParams['axes.unicode_minus'] = True
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Source Han Sans KR']
            self.set_mpl_fontproperties(getResourcePath() + 'SourceHanSansKR-Regular.otf')
        elif self.qmc.graphfont == 8:  # Source Han Sans JP
            # font Source Han Sans selected, Japanese
            rcParams['axes.unicode_minus'] = True
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Source Han Sans JP']
            self.set_mpl_fontproperties(getResourcePath() + 'SourceHanSansJP-Regular.otf')
        elif self.qmc.graphfont == 9:
            # font Dijkstra selected
            rcParams['font.size'] = 10.0
            rcParams['font.family'] = ['Dijkstra']
            rcParams['axes.unicode_minus'] = False
            self.set_mpl_fontproperties(getResourcePath() + 'dijkstra.ttf')
        elif self.qmc.graphfont == 10:
            # font xkcd Script selected
            # https://github.com/ipython/xkcd-font/
            rcParams['axes.unicode_minus'] = False
            rcParams['font.size'] = 14.0
            if platform.system() == 'Linux':
                rcParams['font.family'] = ['xkcd Script']
            else:
                rcParams['font.family'] = ['xkcd Script', 'Comic Sans MS']
            self.set_mpl_fontproperties(getResourcePath() + 'xkcd-script.ttf')
        elif self.qmc.graphfont == 1:
            # font Humor selected
            rcParams['axes.unicode_minus'] = False
            rcParams['font.size'] = 15.0
            if platform.system() == 'Linux':
                rcParams['font.family'] = ['Humor Sans']
            else:
                rcParams['font.family'] = ['Humor Sans', 'Comic Sans MS']
            self.set_mpl_fontproperties(getResourcePath() + 'Humor-Sans.ttf')
        elif self.qmc.graphfont == 11 or platform.system() == 'Linux':  # no Comic on Linux, we subst it with Comic Neue
            # font Comic Neue selected
            # http://comicneue.com/
            rcParams['axes.unicode_minus'] = False
            rcParams['font.size'] = 12.0
            if platform.system() == 'Linux':
                rcParams['font.family'] = ['Comic Neue']
            else:
                rcParams['font.family'] = ['Comic Neue', 'Comic Sans MS']
            self.set_mpl_fontproperties(getResourcePath() + 'ComicNeue-Regular.ttf')
        elif self.qmc.graphfont == 2 and platform.system() != 'Linux':
            # font Comic selected
            rcParams['axes.unicode_minus'] = True
            rcParams['font.size'] = 12.0
            rcParams['font.family'] = ['Comic Sans MS', 'Humor Sans']
            self.mpl_fontproperties = FontProperties()
        if redraw:
            self.qmc.redraw(recomputeAllDeltas=False, forceRenewAxis=True, re_smooth_background=True)

    def set_mpl_fontproperties(self, fontpath: str) -> None:
        if os.path.exists(fontpath):
            fontManager.addfont(fontpath)
            self.mpl_fontproperties = FontProperties(fname=fontpath)

    # trims arabic strings to be rendered correctly with unicode fonts if arabic locale is active
    # if s is a string with one {0} placeholder and a is an argument, the argument is reversed, and then the whole string result is reversed
    # if it contains any arabic characters
    #    def arabicReshape(self, s:str, a:Optional[str]=None) -> str:
    #        if self.locale_str in {'ar', 'fa'}:
    #            st = str(s)
    #            if artisanlib.arabic_reshaper.has_arabic_letters(st):
    #                if a:
    #                    return str(artisanlib.arabic_reshaper.reshape(str(s.format(a[::-1])))[::-1])
    #                return str(artisanlib.arabic_reshaper.reshape(st)[::-1])
    #            if a:
    #                return s.format(a)
    #            return s
    #        if self.locale_str == 'he':
    #            if a:
    #                return (s.format(a[::-1]))[::-1]
    #            return s[::-1]
    #        if a:
    #            return s.format(a)
    #        return s
    def arabicReshape(self, s: str, a: Optional[str] = None) -> str:
        if self.locale_str in {'ar', 'fa'}:
            if a:
                return str(get_display(arabic_reshaper.reshape(s.format(a))))
            return str(get_display(arabic_reshaper.reshape(s)))
        if self.locale_str == 'he':
            if a:
                return str(get_display(s.format(a)))
            return str(get_display(s))
        if a:
            return s.format(a)
        return s

    @staticmethod
    def makePhasesLCDbox(label: QLabel, lcd: QLCDNumber) -> QFrame:
        label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        lcd.setMinimumHeight(30)
        lcd.setMinimumWidth(
            80)  # NOTE: with minimumWidth 84 the lcds not always fit in on Mac, 80 works! Better to keep at default.
        lcd.setSegmentStyle(QLCDNumber.SegmentStyle.Flat)
        lcd.setFrameStyle(QFrame.Shadow.Plain)
        lcd.setNumDigits(6)
        lcd.setLineWidth(0)
        lcd.setContentsMargins(0, 0, 0, 0)
        frame = QFrame()
        LCDVbox = QVBoxLayout()
        LCDVbox.addWidget(label)
        LCDVbox.addWidget(lcd)
        LCDVbox.addSpacing(5)
        LCDVbox.setSpacing(0)
        LCDVbox.setContentsMargins(0, 0, 0, 0)
        frame.setStyleSheet(
            'QLCDNumber{border-radius:4; border-width: 0; border-color: black; border-style:solid; color: black; background-color: #e6e6e6;}')
        #        frame.setFrameShadow(QFrame.Shadow.Sunken)
        #        frame.setLineWidth(1)
        #        frame.setFrameShape(QFrame.Shape.Panel)
        frame.setLayout(LCDVbox)

        return frame

    def updateAUCLCD(self) -> None:
        try:
            auc_value_str = '---'
            auc_style = 'QLCDNumber { color: black; }'
            if ((self.qmc.AUCbegin == 0 and self.qmc.timeindex[0] > -1) or
                    (self.qmc.AUCbegin == 1 and self.qmc.TPalarmtimeindex) or
                    (self.qmc.AUCbegin == 2 and self.qmc.timeindex[1] > 0) or
                    (self.qmc.AUCbegin == 3 and self.qmc.timeindex[2] > 0)):
                if self.qmc.AUCLCDmode == 0:  # AUC abs value
                    v = int(round(self.qmc.AUCvalue))
                    if v > 9999:
                        auc_value_str = '--'
                        self.AUClcd.setNumDigits(3)
                    else:
                        auc_value_str = str(v)
                        if v > 999:
                            self.AUClcd.setNumDigits(4)
                        else:
                            self.AUClcd.setNumDigits(3)
                    auc_style = 'QLCDNumber { color: black; }'
                elif self.qmc.AUCLCDmode == 1:  # AUC delta to target/background
                    if self.qmc.AUCtargetFlag and self.qmc.backgroundprofile is not None and self.qmc.AUCbackground > 0:
                        # background AUC as target
                        target = self.qmc.AUCbackground
                    else:
                        # use target AUC as specified by the user
                        target = self.qmc.AUCtarget
                    d = self.qmc.AUCvalue - target
                    if d < 0:
                        # too low => blue
                        auc_style = 'QLCDNumber { color: blue; }'
                    else:
                        # too high => red
                        auc_style = 'QLCDNumber { color: red; }'
                        self.AUClabel.setText(
                            '<small><b>' + QApplication.translate('Label', 'AUC') + '&laquo;</b></small>')
                    v = abs(int(round(d)))
                    if v > 9999:
                        auc_value_str = '--'
                        auc_style = 'QLCDNumber { color: black; }'
                        self.AUClcd.setNumDigits(3)
                    else:
                        auc_value_str = str(v)
                        if v > 999:
                            self.AUClcd.setNumDigits(4)
                        else:
                            self.AUClcd.setNumDigits(3)
                elif self.qmc.timeindex[2] > 0:  # AUC since FCs
                    v = int(round(self.qmc.AUCsinceFCs))
                    if v > 9999:
                        auc_value_str = '--'
                        self.AUClcd.setNumDigits(3)
                    else:
                        auc_value_str = str(v)
                        if v > 999:
                            self.AUClcd.setNumDigits(4)
                        else:
                            self.AUClcd.setNumDigits(3)
                    auc_style = 'QLCDNumber { color: black; }'
                else:
                    self.AUClcd.setNumDigits(3)
                    auc_value_str = '--'
                    auc_style = 'QLCDNumber { color: black; }'
            self.AUClcd.display(auc_value_str)
            self.AUClcd.setStyleSheet(auc_style)
            if self.LargePhasesLCDsFlag and self.largePhasesLCDs_dialog:
                self.largePhasesLCDs_dialog.updateValues([None, None], [None, auc_value_str])
                self.largePhasesLCDs_dialog.updateAUCstyle(auc_style)
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' updateAUCLCD(): {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

    # returns multiple results on the current state of the phases:
    #  TP, TPlabel, DRY, DRY, FCs, FCslabel
    #  TP2DRYlabel, DRY2FCslabel
    #  TP2DRYframeTooltip
    #  DRY2FCsframeTooltip
    #  phasesLCDsTooltip
    # all are returning strings with the actual values or None if values did not change
    def getPhasesLCDsData(self) -> Tuple[
        Optional[str], Optional[str], Optional[str], Optional[str], Optional[str], Optional[str],
        Optional[str], Optional[str], Optional[str], Optional[str], Optional[str]]:
        TP: Optional[str] = None
        TPlabel: Optional[str] = None
        DRY: Optional[str] = None
        DRYlabel: Optional[str] = None
        FCs: Optional[str] = None
        FCslabel: Optional[str] = None
        TP2DRYlabel: Optional[str] = None
        DRY2FCslabel: Optional[str] = None
        TP2DRYframeTooltip: Optional[str] = None
        DRY2FCsframeTooltip: Optional[str] = None
        phasesLCDsTooltip: Optional[str] = None
        try:
            if self.qmc.timex:  # requires at least some recordings
                window_width = self.width()
                fmtstr = '%.1f' if self.qmc.LCDdecimalplaces else '%.0f'
                tx = self.qmc.timex[-1]
                if self.qmc.timeindex[0]:
                    chrg = self.qmc.timex[self.qmc.timeindex[0]]
                else:
                    chrg = 0
                if self.qmc.timeindex[6]:  # after drop
                    totaltime = self.qmc.timex[self.qmc.timeindex[6]] - chrg
                else:  # before drop
                    totaltime = tx - chrg

                if self.qmc.backgroundprofile is not None and self.qmc.timeindexB[
                    1] and not self.qmc.autoDRYflag:  # with AutoDRY, we always use the set DRY phase temperature as target
                    drytarget = self.qmc.temp2B[self.qmc.timeindexB[1]]  # Background DRY BT temperature
                else:
                    drytarget = self.qmc.phases[1]  # Drying max phases definition

                if self.qmc.phasesLCDmode_all[2] and self.qmc.timeindex[1] and self.qmc.timeindex[2]:  # DRY and FCs
                    # show all finish phase values: time/percent/temp
                    # FIN phase temp on LCD1
                    # FIN phase time on LCD2
                    # FIN phase percentage on LCD3
                    phasesLCDsTooltip = QApplication.translate('Tooltip', 'Phase LCDs\nCurrently in ALL FINISHING MODE')
                    if self.qmc.timeindex[6]:  # after drop
                        ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.timeindex[2]]
                    else:  # before drop
                        ts = tx - self.qmc.timex[self.qmc.timeindex[2]]
                    DRY2FCsframeTooltip = QApplication.translate('Label', 'ALL FINISHING MODE')
                    TPlabel = QApplication.translate('Label', 'FCs') + '&raquo;'
                    # time
                    TP = stringfromseconds(ts, leadingzero=False)
                    # temp
                    if self.qmc.timeindex[6]:  # after drop
                        dBTf = self.qmc.temp2[self.qmc.timeindex[6]]
                    else:
                        dBTf = self.qmc.temp2[-1]
                    dBT = fmtstr % (dBTf - self.qmc.temp2[self.qmc.timeindex[2]])
                    DRYlabel = QApplication.translate('Label', 'FCs') + '&raquo;'
                    DRY = dBT + self.qmc.mode
                    # percentage
                    if totaltime:
                        finishphaseP = fmtstr % (ts * 100. / totaltime)
                    else:
                        finishphaseP = ' --- '
                    if not self.qmc.LCDdecimalplaces and totaltime:
                        finishphaseP += ' '
                    FCslabel = QApplication.translate('Label', 'DEV%')
                    FCs = finishphaseP
                    # DRY2FCs
                    if window_width > 950 and self.qmc.timeindex[1]:
                        t = self.qmc.timex[self.qmc.timeindex[2]] - self.qmc.timex[self.qmc.timeindex[1]]
                        DRY2FCslabel = stringfromseconds(t, leadingzero=False)
                    else:
                        DRY2FCslabel = ''
                else:
                    # show the regular phases LCD values split by phase

                    # 1st PhaseLCD: TP
                    if self.qmc.phasesLCDmode == 0:  # time mode
                        phasesLCDsTooltip = QApplication.translate('Tooltip',
                                                                   'Phase LCDs: right-click to cycle through TIME, PERCENTAGE and TEMP MODE\nCurrently in TIME MODE')
                        TPlabel = QApplication.translate('Label', 'TP') + '&raquo;'
                        if self.qmc.flagon:
                            TP_index = self.qmc.TPalarmtimeindex
                        else:
                            TP_index = self.findTP()
                        if TP_index and TP_index < len(self.qmc.timex):
                            # after TP
                            if self.qmc.timeindex[6]:
                                ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[TP_index]
                            else:
                                ts = tx - self.qmc.timex[TP_index]
                            tss = stringfromseconds(ts, leadingzero=False)
                            TP = tss
                        else:
                            # before TP
                            TP = '--:--'
                    elif self.qmc.phasesLCDmode == 1:  # percentage mode
                        phasesLCDsTooltip = QApplication.translate('Tooltip',
                                                                   'Phase LCDs: right-click to cycle through TIME, PERCENTAGE and TEMP MODE\nCurrently in PERCENTAGE MODE')
                        TPlabel = QApplication.translate('Label', 'DRY%')
                        if self.qmc.timeindex[1]:  # after DRY
                            ts = self.qmc.timex[self.qmc.timeindex[1]] - chrg
                            if totaltime:
                                dryphaseP = fmtstr % (ts * 100. / totaltime)
                            else:
                                dryphaseP = ' --- '
                            if not self.qmc.LCDdecimalplaces and totaltime:
                                dryphaseP += ' '
                            TP = dryphaseP
                        else:
                            TP = ' --- '
                    elif self.qmc.phasesLCDmode == 2:  # temp mode
                        phasesLCDsTooltip = QApplication.translate('Tooltip',
                                                                   'Phase LCDs: right-click to cycle through TIME, PERCENTAGE and TEMP MODE\nCurrently in TEMP MODE')
                        TPlabel = QApplication.translate('Label', 'TP') + '&raquo;'
                        if self.qmc.flagon:
                            TP_index = self.qmc.TPalarmtimeindex
                        else:
                            TP_index = self.findTP()
                        if TP_index:
                            if self.qmc.timeindex[6]:  # after drop
                                dBTf = self.qmc.temp2[self.qmc.timeindex[6]]
                            else:
                                dBTf = self.qmc.temp2[-1]
                            dBT = fmtstr % (dBTf - self.qmc.temp2[TP_index])
                            TP = dBT + self.qmc.mode
                        else:
                            # before TP
                            TP = ' --- '

                    # 2nd PhaseLCD: DRY
                    if self.qmc.timeindex[1]:
                        # after DRY
                        if self.qmc.timeindex[6]:
                            ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.timeindex[1]]
                        else:
                            ts = tx - self.qmc.timex[self.qmc.timeindex[1]]
                        if self.qmc.phasesLCDmode == 0:  # time mode
                            TP2DRYframeTooltip = QApplication.translate('Label', 'TIME MODE')
                            DRYlabel = QApplication.translate('Label', 'DRY') + '&raquo;'
                            DRY = stringfromseconds(ts, leadingzero=False)
                        elif self.qmc.phasesLCDmode == 1:  # percentage mode
                            TP2DRYframeTooltip = QApplication.translate('Label', 'PERCENTAGE MODE')
                            if self.qmc.timeindex[2]:
                                ts = self.qmc.timex[self.qmc.timeindex[2]] - self.qmc.timex[self.qmc.timeindex[1]]
                            if totaltime:
                                midphaseP = fmtstr % (ts * 100. / totaltime)
                            else:
                                midphaseP = ' --- '
                            if not self.qmc.LCDdecimalplaces and totaltime:
                                midphaseP += ' '
                            DRYlabel = QApplication.translate('Label', 'RAMP%')
                            DRY = midphaseP
                        elif self.qmc.phasesLCDmode == 2:  # temp mode
                            TP2DRYframeTooltip = QApplication.translate('Label', 'TEMP MODE')
                            if self.qmc.timeindex[6]:  # after drop
                                dBTf = self.qmc.temp2[self.qmc.timeindex[6]]
                            else:
                                dBTf = self.qmc.temp2[-1]
                            dBT = fmtstr % (dBTf - self.qmc.temp2[self.qmc.timeindex[1]])
                            DRYlabel = QApplication.translate('Label', 'DRY') + '&raquo;'
                            DRY = dBT + self.qmc.mode
                        # TP2DRY
                        if window_width > 950 and self.qmc.TPalarmtimeindex:
                            t = self.qmc.timex[self.qmc.timeindex[1]] - self.qmc.timex[self.qmc.TPalarmtimeindex]
                            TP2DRYlabel = stringfromseconds(t, leadingzero=False)
                        else:
                            TP2DRYlabel = ''
                    else:
                        # before DRY
                        dryexpectedtime = None
                        if self.qmc.phasesLCDmode == 2:
                            DRYlabel = '&darr;' + QApplication.translate('Label', 'DRY')
                        else:
                            DRYlabel = '&raquo;' + QApplication.translate('Label', 'DRY')
                        if self.qmc.timeindex[0] > -1 and self.qmc.TPalarmtimeindex and len(self.qmc.delta2) > 0 and \
                                self.qmc.delta2[-1] and self.qmc.delta2[-1] > 0:
                            # display expected time to reach DRY as defined in the background profile or the phases dialog
                            if drytarget > self.qmc.temp2[-1]:
                                dryexpectedtime = (drytarget - self.qmc.temp2[-1]) / (self.qmc.delta2[-1] / 60.)
                                if self.qmc.phasesLCDmode == 2:
                                    tstring = stringfromseconds(dryexpectedtime, leadingzero=False)
                                else:
                                    tstring = stringfromseconds(
                                        tx - self.qmc.timex[self.qmc.timeindex[0]] + dryexpectedtime, leadingzero=False)
                                DRY = tstring
                            else:
                                DRY = '--:--'
                        else:
                            DRY = '--:--'

                        # TP2DRY (display estimated time between TP and DRY)
                        if dryexpectedtime and window_width > 950 and self.qmc.TPalarmtimeindex:
                            t = tx - self.qmc.timex[
                                self.qmc.TPalarmtimeindex] + dryexpectedtime  # time after TP plus expected-time-to-DRY = total time expected for 1st phase
                            if t > 3600:
                                TP2DRYlabel = ''
                            else:
                                TP2DRYlabel = stringfromseconds(t, leadingzero=False)
                        else:
                            TP2DRYlabel = ''

                    # 3rd PhasesLCD: FCs
                    if self.qmc.timeindex[2]:
                        # after FCs
                        if self.qmc.timeindex[6]:  # after drop
                            ts = self.qmc.timex[self.qmc.timeindex[6]] - self.qmc.timex[self.qmc.timeindex[2]]
                        else:  # before drop
                            ts = tx - self.qmc.timex[self.qmc.timeindex[2]]
                        if self.qmc.phasesLCDmode == 0:  # time mode
                            DRY2FCsframeTooltip = QApplication.translate('Label', 'TIME MODE')
                            TP2DRYframeTooltip = QApplication.translate('Label', 'TIME MODE')
                            FCslabel = QApplication.translate('Label', 'FCs') + '&raquo;'
                            FCs = stringfromseconds(ts, leadingzero=False)
                        elif self.qmc.phasesLCDmode == 1:  # percentage mode
                            DRY2FCsframeTooltip = QApplication.translate('Label', 'PERCENTAGE MODE')
                            TP2DRYframeTooltip = QApplication.translate('Label', 'PERCENTAGE MODE')
                            FCslabel = QApplication.translate('Label', 'DEV%')
                            if totaltime:
                                finishphaseP = fmtstr % (ts * 100. / totaltime)
                            else:
                                finishphaseP = ' --- '
                            if not self.qmc.LCDdecimalplaces and totaltime:
                                finishphaseP += ' '
                            FCs = finishphaseP
                        elif self.qmc.phasesLCDmode == 2:  # temp mode
                            DRY2FCsframeTooltip = QApplication.translate('Label', 'TEMP MODE')
                            TP2DRYframeTooltip = QApplication.translate('Label', 'TEMP MODE')
                            FCslabel = QApplication.translate('Label', 'FCs') + '&raquo;'
                            if self.qmc.timeindex[6]:  # after drop
                                dBTf = self.qmc.temp2[self.qmc.timeindex[6]]
                            else:
                                dBTf = self.qmc.temp2[-1]
                            dBTstr = fmtstr % (dBTf - self.qmc.temp2[self.qmc.timeindex[2]])
                            FCs = dBTstr + self.qmc.mode
                        # DRY2FCs
                        if window_width > 950 and self.qmc.timeindex[1]:
                            t = self.qmc.timex[self.qmc.timeindex[2]] - self.qmc.timex[self.qmc.timeindex[1]]
                            DRY2FCslabel = stringfromseconds(t, leadingzero=False)
                        else:
                            DRY2FCslabel = ''
                    else:
                        # before FCs
                        fcsexpectedtime = None
                        if self.qmc.phasesLCDmode == 0:
                            DRY2FCsframeTooltip = QApplication.translate('Label', 'TIME MODE')
                            TP2DRYframeTooltip = QApplication.translate('Label', 'TIME MODE')
                            FCslabel = '&raquo;' + QApplication.translate('Label', 'FCs')
                        elif self.qmc.phasesLCDmode == 1:
                            DRY2FCsframeTooltip = QApplication.translate('Label', 'PERCENTAGE MODE')
                            TP2DRYframeTooltip = QApplication.translate('Label', 'PERCENTAGE MODE')
                            FCslabel = '&raquo;' + QApplication.translate('Label', 'FCs')
                        elif self.qmc.phasesLCDmode == 2:
                            DRY2FCsframeTooltip = QApplication.translate('Label', 'TEMP MODE')
                            TP2DRYframeTooltip = QApplication.translate('Label', 'TEMP MODE')
                            FCslabel = '&darr;' + QApplication.translate('Label', 'FCs')
                        if self.qmc.timeindex[0] > -1 and (
                                self.qmc.timeindex[1] or (drytarget <= self.qmc.temp2[-1])) and len(
                            self.qmc.delta2) > 0 and self.qmc.delta2[-1] and self.qmc.delta2[-1] > 0:
                            ## after DRY:
                            # display expected time to reach FCs as defined in the background profile or the phases dialog
                            if self.qmc.backgroundprofile is not None and self.qmc.timeindexB[2]:
                                fcstarget = self.qmc.temp2B[self.qmc.timeindexB[2]]  # Background FCs BT temperature
                            else:
                                fcstarget = self.qmc.phases[2]  # FCs min phases definition
                            if fcstarget > self.qmc.temp2[-1]:
                                fcsexpectedtime = (fcstarget - self.qmc.temp2[-1]) / (self.qmc.delta2[-1] / 60.)
                                if self.qmc.phasesLCDmode == 2:
                                    tstring = stringfromseconds(fcsexpectedtime, leadingzero=False)
                                else:
                                    tstring = stringfromseconds(
                                        tx - self.qmc.timex[self.qmc.timeindex[0]] + fcsexpectedtime, leadingzero=False)
                                FCs = tstring
                            else:
                                FCs = '--:--'
                        else:
                            FCs = '--:--'

                        # DRY2FCs (display estimated time between DRY and FCs)
                        if fcsexpectedtime and window_width > 950 and self.qmc.timeindex[1]:
                            t = tx - self.qmc.timex[self.qmc.timeindex[
                                1]] + fcsexpectedtime  # time after DRY plus expected-time-to-FCs = total time expected for 2nd phase
                            DRY2FCslabel = stringfromseconds(t, leadingzero=False)
                        else:
                            DRY2FCslabel = ''
            else:
                if self.qmc.phasesLCDmode == 0:  # time mode
                    TP = '--:--'
                    TPlabel = QApplication.translate('Label', 'TP') + '&raquo;'
                elif self.qmc.phasesLCDmode == 1:  # percentage mode
                    TP = ' --- '
                    TPlabel = QApplication.translate('Label', 'DRY%')
                elif self.qmc.phasesLCDmode == 2:  # temp mode
                    TP = ' --- '
                    TPlabel = QApplication.translate('Label', 'TP') + '&raquo;'
                DRYlabel = '&raquo;' + QApplication.translate('Label', 'DRY')
                FCslabel = '&raquo;' + QApplication.translate('Label', 'FCs')
                TP2DRYlabel = ''
                DRY2FCslabel = ''
                DRY = '--:--'
                FCs = '--:--'
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' updatePhasesLCDs() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))
        return TP, TPlabel, DRY, DRYlabel, FCs, FCslabel, TP2DRYlabel, DRY2FCslabel, TP2DRYframeTooltip, DRY2FCsframeTooltip, phasesLCDsTooltip

    def updatePhasesLCDs(self) -> None:
        try:
            if self.qmc.phasesLCDflag or self.LargePhasesLCDsFlag:
                TP, TPlabel, DRY, DRYlabel, FCs, FCslabel, TP2DRYlabel, DRY2FCslabel, TP2DRYframeTooltip, DRY2FCsframeTooltip, phasesLCDsTooltip = self.getPhasesLCDsData()

                if self.qmc.phasesLCDflag:
                    label_fmt = '<small><b>{}</b></small>'
                    #
                    if TP is not None:
                        self.TPlcd.display(TP)
                    if DRY is not None:
                        self.DRYlcd.display(DRY)
                    if FCs is not None:
                        self.FCslcd.display(FCs)
                    #
                    if TPlabel is not None:
                        self.TPlabel.setText(label_fmt.format(TPlabel))
                    if DRYlabel is not None:
                        self.DRYlabel.setText(label_fmt.format(DRYlabel))
                    if FCslabel is not None:
                        self.FCslabel.setText(label_fmt.format(FCslabel))
                    #
                    if TP2DRYlabel is not None:
                        self.TP2DRYlabel.setText(TP2DRYlabel)
                        if TP2DRYlabel == '':
                            width = 0
                        else:
                            width = self.TP2DRYlabel.fontMetrics().boundingRect('88:::88').width()
                        self.TP2DRYlabel.setMinimumWidth(width)
                    if DRY2FCslabel is not None:
                        self.DRY2FCslabel.setText(DRY2FCslabel)
                        if DRY2FCslabel == '':
                            width = 0
                        else:
                            width = self.DRY2FCslabel.fontMetrics().boundingRect('88:::88').width()
                        self.DRY2FCslabel.setMinimumWidth(width)
                    #
                    if TP2DRYframeTooltip is not None:
                        self.TP2DRYframe.setToolTip(TP2DRYframeTooltip)
                    if DRY2FCsframeTooltip is not None:
                        self.DRY2FCsframe.setToolTip(DRY2FCsframeTooltip)
                    if phasesLCDsTooltip is not None:
                        self.phasesLCDs.setToolTip(phasesLCDsTooltip)

                if self.LargePhasesLCDsFlag:
                    # update large phases LCDs
                    try:
                        if self.largePhasesLCDs_dialog is not None:
                            values1 = [TP, FCs]  # TP and FCs phase LCDs
                            values2 = [DRY, None]  # DRY phase and AUC LCDs
                            self.largePhasesLCDs_dialog.updateValues(values1, values2)
                            self.largePhasesLCDs_dialog.updatePhasesLabels([TPlabel, DRYlabel, FCslabel, None])
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' updatePhasesLCDs() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

    @staticmethod
    def makeLCDbox(label: QLabel, lcd: MyQLCDNumber, lcdframe: QFrame) -> QFrame:
        LCDbox = QVBoxLayout()
        LCDbox.setSizeConstraint(QLayout.SizeConstraint.SetFixedSize)
        LCDbox.setSpacing(0)
        LCDbox.addWidget(label)
        LCDhBox = QHBoxLayout()
        LCDhBox.addStretch()
        LCDhBox.addWidget(lcd)
        LCDbox.addLayout(LCDhBox)
        LCDhBox.setContentsMargins(0, 0, 0, 0)
        LCDbox.setContentsMargins(0, 0, 0, 0)
        lcdframe.setContentsMargins(0, 10, 0, 3)
        lcdframe.setLayout(LCDbox)
        return lcdframe

    @staticmethod
    def setSliderNumber(lcd: QLCDNumber, v: float) -> None:
        if v < 10:
            lcd.setNumDigits(1)
        elif v > 99:
            lcd.setNumDigits(3)
        else:
            lcd.setNumDigits(2)
        lcd.display(v)

    def updateSliderLCD(self, n: int, v: float) -> None:
        if n == 0:
            self.setSliderNumber(self.sliderLCD1, v)
        elif n == 1:
            self.setSliderNumber(self.sliderLCD2, v)
        elif n == 2:
            self.setSliderNumber(self.sliderLCD3, v)
        elif n == 3:
            self.setSliderNumber(self.sliderLCD4, v)

    @pyqtSlot(int)
    def updateSVSliderLCD(self, v: int) -> None:
        v = max(min(v, self.pidcontrol.svSliderMax), self.pidcontrol.svSliderMin)
        self.sliderLCDSV.display(v)
        if self.SVslidermoved:
            if self.sliderLCDSV.intValue() != self.sliderSV.value():
                # if slider was moved by a keyboard action, we have to explicitly update the value and send the signals
                self.sliderSV.setValue(self.sliderLCDSV.intValue())
            self.sliderSVreleased()
            self.SVslidermoved = 0

    @pyqtSlot(int)
    def sliderSVactionTriggered(self, n: int) -> None:
        if n in {
            1, 2, 3, 4,
        }:  # keyboard moves enable the slider value change
            # we set a fake-release-event for keyboard triggered slider moves
            self.SVslidermoved = 1

    @pyqtSlot()
    def sliderSVreleased(self) -> None:
        try:
            if self.qmc.device == 0:
                self.fujipid.setsv(self.sliderSV.value(), silent=True)
            else:
                self.pidcontrol.setSV(self.sliderSV.value(), False)
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    # if setValue=False, the slider is only moved without a change signal being issued
    def moveSVslider(self, v: float, setValue: bool = True) -> None:
        v = int(round(v))
        if self.pidcontrol.svSlider:
            if setValue:
                self.sliderSV.setValue(v)
            else:
                self.sliderSV.setSliderPosition(v)

    # NOTE on those slider signals:
    # there are different ways to move the sliders
    # - by click into the slider bar
    # - by drag and release the slider handle
    # - by using the up/down cursor keys or page up/down keys
    # - using the Artisan slider shortcuts via keys Q, W, E, R
    # - using an Artisan Command (eg. via an alarm)
    # - programmatically (PID)
    # The drag-and-release action (at least on Mac OS X) in some cases triggers
    # a valueChanged signal short after fetching the handle and before moving it.
    # To avoid the generation of an additional event with an event value close to the last one, the eventslidermoved variable has been added.
    # It is set after a slider move. If it is not set, only value changes above a certain limit (here 3) are accepted.

    # the following are only needed with the slider tracking off work around:
    #    @pyqtSlot(int)
    #    def slider1Moved(self,v):
    #        self.eventslidermoved[0]=1
    #        self.updateSliderLCD(0,v)
    #    @pyqtSlot(int)
    #    def slider2Moved(self,v):
    #        self.eventslidermoved[1]=1
    #        self.updateSliderLCD(1,v)
    #    @pyqtSlot(int)
    #    def slider3Moved(self,v):
    #        self.eventslidermoved[2]=1
    #        self.updateSliderLCD(2,v)
    #    @pyqtSlot(int)
    #    def slider4Moved(self,v):
    #        self.eventslidermoved[3]=1
    #        self.updateSliderLCD(3,v)

    # required for the default tracking sliders
    @pyqtSlot()
    def slider1released(self) -> None:
        self.sliderReleased(0, force=True, updateLCD=False)

    @pyqtSlot()
    def slider2released(self) -> None:
        self.sliderReleased(1, force=True, updateLCD=False)

    @pyqtSlot()
    def slider3released(self) -> None:
        self.sliderReleased(2, force=True, updateLCD=False)

    @pyqtSlot()
    def slider4released(self) -> None:
        self.sliderReleased(3, force=True, updateLCD=False)

    # returns the step size (1, 5 or 10) of the eventslider of the given number n [0,..,3]
    def eventSliderStepSize(self, n: int) -> int:
        if self.eventslidercoarse[n] == 1:
            return 10
        if self.eventslidercoarse[n] == 2:
            return 5
        return 1

    def eventSliderPageSize(self, n: int) -> int:
        if self.eventslidercoarse[n] == 1:
            # step size is 10
            return 20
        # step size is 1 or 5
        return 10

    # n the slider number 0,..,3; v the slider value
    # returns the slider value quantified by the sliders step size
    def applySliderStepSize(self, n: int, v: int) -> int:
        if self.eventslidercoarse[n] == 1:  # step size is 10
            return int(round(v / 10.)) * 10
        if self.eventslidercoarse[n] == 2:  # step size is 5
            return int(round(v / 5.)) * 5
        # otherwise slider step size is 1 and no quantification is applied
        return v

    # required for the default tracking sliders
    @pyqtSlot(int)
    def updateSlider1LCD(self, v: int) -> None:
        self.updateSliderLCD(0, self.applySliderStepSize(0, v))
        if self.eventslidermoved[0]:
            # if slider was moved by a keyboard action, we have to explicitly update the value and send the signals
            if self.sliderLCD1.intValue() != self.slider1.value():
                self.slider1.setValue(self.sliderLCD1.intValue())
                self.setFm.setText(self.sliderLCD1.intValue())
            self.slider1released()
            self.eventslidermoved[0] = 0

    @pyqtSlot(int)
    def updateSlider2LCD(self, v: int) -> None:
        self.updateSliderLCD(1, self.applySliderStepSize(1, v))
        if self.eventslidermoved[1]:
            # if slider was moved by a keyboard action, we have to explicitly update the value and send the signals
            if self.sliderLCD2.intValue() != self.slider2.value():
                self.slider2.setValue(self.sliderLCD2.intValue())
                self.setZs.setText(self.sliderLCD1.intValue())
            self.slider2released()
            self.eventslidermoved[1] = 0

    @pyqtSlot(int)
    def updateSlider3LCD(self, v: int) -> None:
        self.updateSliderLCD(2, self.applySliderStepSize(2, v))
        if self.eventslidermoved[2]:
            # if slider was moved by a keyboard action, we have to explicitly update the value and send the signals
            if self.sliderLCD3.intValue() != self.slider3.value():
                self.slider3.setValue(self.sliderLCD3.intValue())
            self.slider3released()
            self.eventslidermoved[2] = 0

    @pyqtSlot(int)
    def updateSlider4LCD(self, v: int) -> None:
        self.updateSliderLCD(3, self.applySliderStepSize(3, v))
        if self.eventslidermoved[3]:
            # if slider was moved by a keyboard action, we have to explicitly update the value and send the signals
            if self.sliderLCD4.intValue() != self.slider4.value():
                self.slider4.setValue(self.sliderLCD4.intValue())
                self.setHl.setText(self.sliderLCD1.intValue())
            self.slider4released()
            self.eventslidermoved[3] = 0

    @pyqtSlot(int)
    def slider1actionTriggered(self, n: int) -> None:
        self.sliderNactionTriggered(n, 0)

    @pyqtSlot(int)
    def slider2actionTriggered(self, n: int) -> None:
        self.sliderNactionTriggered(n, 1)

    @pyqtSlot(int)
    def slider3actionTriggered(self, n: int) -> None:
        self.sliderNactionTriggered(n, 2)

    @pyqtSlot(int)
    def slider4actionTriggered(self, n: int) -> None:
        self.sliderNactionTriggered(n, 3)

    def sliderNactionTriggered(self, n: int, m: int) -> None:
        if n in {
            1, 2, 3, 4,
        }:  # keyboard moves enable the slider value change
            # we set a fake-release-event for keyboard triggered slider moves
            self.eventslidermoved[m] = 1

    # if updateLCD=True, call moveslider() which in turn updates the LCD
    def sliderReleased(self, n: int, force: bool = False, updateLCD: bool = False) -> bool:
        if n == 0:
            sv1 = self.slider1.value()
            if force or (self.eventslidermoved[0] and sv1 != self.eventslidervalues[0]) or abs(
                    sv1 - self.eventslidervalues[0]) > 3:
                self.eventslidermoved[0] = 0
                sv1 = self.applySliderStepSize(0, sv1)
                self.eventslidervalues[0] = sv1
                if updateLCD or (self.eventslidercoarse[0] and sv1 != self.slider1.value()):
                    self.moveslider(0, sv1, forceLCDupdate=True)  # move slider if need and update slider LCD
                self.recordsliderevent(n)
        elif n == 1:
            sv2 = self.slider2.value()
            if force or (self.eventslidermoved[1] and sv2 != self.eventslidervalues[1]) or abs(
                    sv2 - self.eventslidervalues[1]) > 3:
                self.eventslidermoved[1] = 0
                sv2 = self.applySliderStepSize(1, sv2)
                self.eventslidervalues[1] = sv2
                if updateLCD or (self.eventslidercoarse[1] and sv2 != self.slider2.value()):
                    self.moveslider(1, sv2, forceLCDupdate=True)  # move slider if need and update slider LCD
                self.recordsliderevent(n)
        elif n == 2:
            sv3 = self.slider3.value()
            if force or (self.eventslidermoved[2] and sv3 != self.eventslidervalues[2]) or abs(
                    sv3 - self.eventslidervalues[2]) > 3:
                self.eventslidermoved[2] = 0
                sv3 = self.applySliderStepSize(2, sv3)
                self.eventslidervalues[2] = sv3
                if updateLCD or (self.eventslidercoarse[2] and sv3 != self.slider3.value()):
                    self.moveslider(2, sv3, forceLCDupdate=True)  # move slider if need and update slider LCD
                self.recordsliderevent(n)
        elif n == 3:
            sv4 = self.slider4.value()
            if force or (self.eventslidermoved[3] and sv4 != self.eventslidervalues[3]) or abs(
                    sv4 - self.eventslidervalues[3]) > 3:
                self.eventslidermoved[3] = 0
                sv4 = self.applySliderStepSize(3, sv4)
                self.eventslidervalues[3] = sv4
                if updateLCD or (self.eventslidercoarse[3] and sv4 != self.slider4.value()):
                    self.moveslider(3, sv4, forceLCDupdate=True)  # move slider if need and update slider LCD
                self.recordsliderevent(n)
        return False

    # n=0 : slider1; n=1 : slider2; n=2 : slider3; n=3 : slider4
    @pyqtSlot(int)
    def fireslideraction(self, n: int) -> None:
        action = self.eventslideractions[n]
        if action:
            try:
                # before adaption:
                # action =0 (None), =1 (Serial), =2 (Modbus), =3 (DTA Command), =4 (Call Program [with argument])
                #  =5 (Hottop Heater), =6 (Hottop Fan), =7 (Hottop Command), =8 (Fuji Command), =9 (PWM Command), =10 (VOUT Command)
                #  =11 (IO Command), =12 (S7 Command), =13 (Aillio R1 Heater Command), =14 (Aillio R1 Fan Command), =15 (Aillio R1 Drum Command)
                #  =16 (Artisan Command), 17= (RC Command)
                action = (action + 2 if action > 1 else action)  # skipping (2 Call Program and 3 Multiple Event)
                if action > 5:
                    action = action + 1  # skip the 6:IO Command
                    if 15 > action > 10:
                        action = action + 1  # skip the 11 p-i-d action
                        if action == 15:
                            action = 6  # map IO Command back
                    if action > 18:
                        action = action + 1  # skip the 19: Aillio PRS
                # after adaption: (see eventaction)
                value = self.calcSliderSendValue(n)
                if action not in [6, 14, 15, 21]:  # only for IO, VOUT, S7 and RC Commands we keep the floats
                    value = int(round(value))
                if action in {8, 9, 16, 17, 18}:  # for Hottop/R1 Heater or Fan, we just forward the value
                    cmd = str(int(round(value)))
                else:
                    cmd = self.eventslidercommands[n]
                    cmd = cmd.format(*(tuple([value] * cmd.count('{}'))))
                self.eventaction(action, cmd)  # cmd needs to be a string!
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
                _, _, exc_tb = sys.exc_info()
                self.qmc.adderror(
                    (QApplication.translate('Error Message', 'Exception:') + ' fireslideraction() {0}').format(str(e)),
                    getattr(exc_tb, 'tb_lineno', '?'))

    # from a given value and the event type number, calc the event value respecting the event types slider offset, factor and bernulli settings
    def calcEventValue(self, n: int, slider_value: float) -> float:
        if self.eventsliderBernoulli[n]:
            # if ticked we add the Bernoulli's gas law factor to the computed value
            # (see https://www.home-barista.com/home-roasting/coffee-roasting-best-practices-scott-rao-t65601-70.html#p724654)
            # so we have f(x) = (max-min) * ((x-min)/(max-min))^2 + min
            slider_delta = self.eventslidermax[n] - self.eventslidermin[n]
            slider_value = slider_delta * pow((slider_value - self.eventslidermin[n]) / slider_delta, 2) + \
                           self.eventslidermin[n]
        # f(x) = k*x + o
        return (self.eventsliderfactors[n] * slider_value) + self.eventslideroffsets[n]

    def calcSliderSendValue(self, n: int) -> float:
        return self.calcEventValue(n, self.eventslidervalues[n])

    def recordsliderevent(self, n: int) -> None:
        self.block_quantification_sampling_ticks[n] = self.sampling_ticks_to_block_quantifiction
        self.extraeventsactionslastvalue[n] = self.eventslidervalues[n]
        if self.qmc.flagstart:
            #            value = self.float2float((self.eventslidervalues[n] + 10.0) / 10.0)
            value = self.qmc.eventsExternal2InternalValue(self.eventslidervalues[n])
            description = str(self.float2float(self.calcSliderSendValue(n), 2)).rstrip('0').rstrip('.') + \
                          self.eventsliderunits[n]
            self.qmc.EventRecordAction(extraevent=1, eventtype=n, eventvalue=value, eventdescription=description)
        self.fireslideraction(n)

    @staticmethod
    def sliderLCD() -> QLCDNumber:
        slcd = QLCDNumber()
        slcd.setSegmentStyle(QLCDNumber.SegmentStyle.Flat)
        slcd.setNumDigits(1)
        slcd.setMinimumHeight(35)
        slcd.setMinimumWidth(50)
        slcd.setMaximumWidth(50)
        slcd.setFrameStyle(QFrame.Shape.Panel | QFrame.Shadow.Plain)
        slcd.setLineWidth(0)
        slcd.setContentsMargins(0, 0, 0, 0)
        return slcd

    @staticmethod
    def slider() -> QSlider:
        s = QSlider()
        s.setTickPosition(QSlider.TickPosition.TicksBothSides)
        s.setTickInterval(10)
        s.setSingleStep(1)
        s.setPageStep(10)
        s.setMaximum(100)
        s.setMinimumWidth(50)
        s.setMaximumWidth(50)
        s.setContentsMargins(0, 0, 0, 0)
        return s

    def updateSliderMinMax(self) -> None:
        # first block slider signals to avoid sending out signals
        self.slider1.blockSignals(True)
        self.slider2.blockSignals(True)
        self.slider3.blockSignals(True)
        self.slider4.blockSignals(True)
        try:
            # reset limits
            self.slider1.setMinimum(self.eventslidermin[0])
            self.slider1.setMaximum(self.eventslidermax[0])
            self.slider2.setMinimum(self.eventslidermin[1])
            self.slider2.setMaximum(self.eventslidermax[1])
            self.slider3.setMinimum(self.eventslidermin[2])
            self.slider3.setMaximum(self.eventslidermax[2])
            self.slider4.setMinimum(self.eventslidermin[3])
            self.slider4.setMaximum(self.eventslidermax[3])
            # update slider LCDs
            self.updateSliderLCD(0, min(self.eventslidermax[0], max(self.eventslidermin[0], self.slider1.value())))
            self.updateSliderLCD(1, min(self.eventslidermax[1], max(self.eventslidermin[1], self.slider2.value())))
            self.updateSliderLCD(2, min(self.eventslidermax[2], max(self.eventslidermin[2], self.slider3.value())))
            self.updateSliderLCD(3, min(self.eventslidermax[3], max(self.eventslidermin[3], self.slider4.value())))
        finally:
            # unblock sliders signaling
            self.slider1.blockSignals(False)
            self.slider2.blockSignals(False)
            self.slider3.blockSignals(False)
            self.slider4.blockSignals(False)

    # creates a drop shadow effect
    def makeShadow(self, strong: bool = False) -> QGraphicsDropShadowEffect:
        shadow = QGraphicsDropShadowEffect(self)
        if strong:
            shadow.setBlurRadius(20)
        else:
            shadow.setBlurRadius(20)
        shadow.setOffset(0, 0.9)
        return shadow

    @staticmethod
    def setLabelColor(label: QLabel, color: QColor) -> None:
        label.setStyleSheet(f'QLabel {{ color: {color.name()}; }}')

    # adds to serial log
    def addserial(self, serialstring: str) -> None:
        if self.seriallogflag:
            try:
                #### lock shared resources #####
                self.qmc.seriallogsemaphore.acquire(1)
                timez = QDateTime.currentDateTime().toString('hh:mm:ss.zzz')  # zzz = milliseconds
                # keep a max of 1000 comm strings
                if len(self.seriallog) > 999:
                    self.seriallog = self.seriallog[1:]
                self.seriallog.append(timez + ' ' + serialstring)
                # if logging is not on, we have to update the serial log here:
                if self.serial_dlg is not None:
                    self.updateSerialLogSignal.emit()  # as addserial might be called from another (samplinig) thread we need to ensure that this is processed this within the GUI thread via a signal
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
            finally:
                if self.qmc.seriallogsemaphore.available() < 1:
                    self.qmc.seriallogsemaphore.release(1)

    def resizeEvent(self, event: 'Optional[QResizeEvent]') -> None:
        if not self.qmc.flagon and self.qmc.statssummary and len(self.qmc.timex) > 3:
            self.redrawTimer.start(500)  # (re-) start the redraw time to be fired in half a second
        super().resizeEvent(event)

    def setdpi(self, dpi: int, moveWindow: bool = True) -> None:
        if dpi >= 40:
            try:
                self.dpi = dpi
                # on mpl >= v2 we assume hidpi support and consider the pixel ratio
                self.qmc.fig.set_dpi(dpi * self.devicePixelRatio())
                # move widget to update display
                if moveWindow:
                    with warnings.catch_warnings():
                        warnings.simplefilter('ignore')
                        self.qmc.fig.canvas.draw()
                    #                        self.qmc.fig.canvas.update()
                    self.qmc.adjustSize()
                    FigureCanvas.updateGeometry(self.qmc)  # @UndefinedVariable
                    QApplication.processEvents()
                    if self.qmc.statssummary:
                        self.qmc.redraw(recomputeAllDeltas=False)
                if self.qpc:
                    self.qpc.setdpi(dpi, moveWindow)
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)

    def enableSaveActions(self) -> None:
        self.fileSaveAction.setEnabled(True)
        self.fileSaveAsAction.setEnabled(True)
        # self.ConfMenu.setEnabled(True)
        self.calibrateDelayAction.setEnabled(True)

    def disableSaveActions(self) -> None:
        self.fileSaveAction.setEnabled(False)
        self.fileSaveAsAction.setEnabled(False)
        # self.ConfMenu.setEnabled(False)
        self.calibrateDelayAction.setEnabled(False)

    # relocate event actions, by skippig 3=MultipleEvent and 7=Call Program SliderAction
    def eventactionx(self, a: int, cmd: str) -> None:
        try:
            # we added "Multiple Events" at position 20 which has to be mapped to action 3
            self.eventaction((a if (a < 3) else (3 if (a == 20) else ((a + 2) if (21 > a > 5) else (a + 1)))), cmd)
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    # actions: 0 = None; 1= Serial Command; 2= Call program; 3= Multiple Event; 4= Modbus Command; 5=DTA Command; 6=IO Command (Phidgets/Yocto IO);
    #         7= Call Program with argument (slider action); 8= HOTTOP Heater; 9= HOTTOP Main Fan; 10= HOTTOP Command; 11= p-i-d; 12= Fuji Command;
    #         13= PWM Command; 14= VOUT Command; 15= S7 Command; 16= Aillio R1 Heater; 17= Aillio R1 Fan; 18= Aillio R1 Drum; 19= Aillio R1 Command;
    #         20= Artisan Command; 21= RC Command; 22= WebSocket Command
    # eventtype is one of the custom event types (0-3), only given if called for a button action with relative event type and event value 0
    # in this case the event button is not generating an event entry during recording, but a button action could receive an event value from calling its action
    # and generate a corresponding event entry via a self.qmc.eventRecordActionSignal as done by the kaleido button IO Command action
    # eventtrype is -1 if the even action should await a result to be bound to _
    def eventaction(self, action: int, cmd: str, parallel: bool = True, eventtype: Optional[int] = None) -> None:
        # split on an octothorpe '#' that is not inside parentheses '()'
        cmd = re.split(r'\#(?![^\(]*\))', cmd)[0].strip()
        if action:
            if not parallel:  # or action==3: # subactions of multiple event actions, may crash if run in parallel, especially if they update the UI like button shape!
                self.eventaction_internal(action, cmd, eventtype)
            else:
                eventActionThread = EventActionThread(self, action, cmd, eventtype)
                eventActionThread.finished.connect(self.eventactionThreadDone_slot)
                try:
                    self.qmc.eventactionsemaphore.acquire(1)
                    self.eventaction_running_threads.append(eventActionThread)
                finally:
                    if self.qmc.eventactionsemaphore.available() < 1:
                        self.qmc.eventactionsemaphore.release(1)
                eventActionThread.start()

    @pyqtSlot()
    def eventactionThreadDone_slot(self) -> None:
        try:
            self.qmc.eventactionsemaphore.acquire(1)
            actionthread = self.sender()
            assert isinstance(actionthread, EventActionThread)
            if actionthread in self.eventaction_running_threads:
                self.eventaction_running_threads.remove(actionthread)
            actionthread.disconnect()
        finally:
            if self.qmc.eventactionsemaphore.available() < 1:
                self.qmc.eventactionsemaphore.release(1)

    #        if self.qmc.flagstart:
    #            self.qmc.updateBackground()
    #            self.qmc.updategraphicsSignal.emit() # we need this to have the projections redrawn immediately

    # 注意:这可能在单独的EventActionThread中运行，而不是在GUI线程中运行，因此修改GUI的操作可能需要使用信号来
    # 确保它们在GUI线程中运行，以避免硬崩溃(参见pidON/pidOFF)
    def eventaction_internal(self, action: int, cmd: str, eventtype: Optional[
        int]) -> None:  # pyright: ignore [reportGeneralTypeIssues] # Code is too complex to analyze; reduce complexity by refactoring into subroutines or reducing conditional code paths
        if action:
            try:
                if self.simulator and action not in [2, 3,
                                                     20]:  # 2 (Call Program) 3 (Multiple Event), 20 (Artisan Command)
                    # disable all communicating commands in simulation mode
                    return

                cmd_str = str(cmd)

                # we add {BT}, {ET}, {time} substitutions for Serial/CallProgram/MODBUS/S7/Artisan/WebSocket command actions
                if action in {1, 2, 4, 7, 15, 20, 22}:
                    BT_subst = -1.
                    ET_subst = -1.
                    timex = 0.
                    BTB_subst = -1.
                    ETB_subst = -1.
                    if (self.qmc.flagstart and len(self.qmc.timex) > 0 or (
                            self.qmc.flagon and len(self.qmc.on_timex) > 0)):
                        try:
                            if self.qmc.flagstart and len(self.qmc.timex) > 0:
                                timex = self.qmc.timex[-1]
                                if self.qmc.timeindex[0] != -1 and self.qmc.timeindex[0] < len(self.qmc.timex):
                                    timex -= self.qmc.timex[self.qmc.timeindex[0]]
                                BT_subst = self.qmc.temp2[-1]
                                ET_subst = self.qmc.temp1[-1]
                                if self.qmc.background:
                                    btb = self.qmc.backgroundSmoothedBTat(timex)
                                    if btb != -1:
                                        BTB_subst = btb
                                    etb = self.qmc.backgroundSmoothedETat(timex)
                                    if etb != -1:
                                        ETB_subst = etb
                            elif self.qmc.flagon:
                                timex = self.qmc.on_timex[-1]
                                if self.qmc.timeindex[0] != -1 and self.qmc.timeindex[0] < len(self.qmc.on_timex):
                                    timex -= self.qmc.on_timex[self.qmc.timeindex[0]]
                                BT_subst = self.qmc.on_temp2[-1]
                                ET_subst = self.qmc.on_temp1[-1]
                        except Exception as e:  # pylint: disable=broad-except
                            _log.exception(e)
                    try:
                        if action == 22:
                            # in JSON we have to do string substitution
                            cmd_str = cmd_str.replace('{BT}', str(BT_subst))
                            cmd_str = cmd_str.replace('{ET}', str(ET_subst))
                            cmd_str = cmd_str.replace('{t}', str(timex))
                            cmd_str = cmd_str.replace('{BTB}', str(BTB_subst))
                            cmd_str = cmd_str.replace('{ETB}', str(ETB_subst))
                        else:
                            cmd_str = cmd_str.format(BT=BT_subst, ET=ET_subst, t=timex, BTB=BTB_subst, ETB=ETB_subst)
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)

                lastbuttonpressed = self.lastbuttonpressed  # we remember that here as it might be reset to -1 by some button commands to avoid changing its state
                if action == 1:  # Serial Command
                    cmd_str_bin = b''
                    # example a2b_uu("Hello") sends Hello in binary format instead of ASCII
                    if 'a2b_uu' in cmd_str:
                        cmd_str = cmd_str[(len('a2b_uu') + 1):][:1]  # removes function-name + char ( and )
                        import binascii
                        cmd_str_bin = binascii.a2b_uu(cmd_str)
                    if cmd_str_bin:
                        self.ser.sendTXcommand(cmd_str_bin)
                    else:
                        cmd_str = cmd_str.replace('\\r\\n', '\n\r').replace('\\n', '\n').replace('\\t', '\t')
                        self.ser.sendTXcommand(cmd_str)
                elif action == 2:  # button call program action
                    try:
                        if cmd_str:
                            self.call_prog_with_args(cmd_str)
                    #                        if cmd_str and (len(cmd_str.split(" ")) > 1 or platform.system() == 'Darwin' or platform.system() == 'Linux'):
                    #                            self.call_prog_with_args(cmd_str) # a command with argument
                    #                        else:
                    ## take care, the QDir().current() directory changes with loads and saves
                    ##                        QDesktopServices.openUrl(QUrl("file:///" + str(QDir().current().absolutePath()) + "/" + cmd_str, QUrl.ParsingMode.TolerantMode))
                    #                            if platform.system() in ['Windows','Linux']:
                    #                                QDesktopServices.openUrl(QUrl("file:///" + str(QApplication.applicationDirPath()) + "/" + cmd_str, QUrl.ParsingMode.TolerantMode))
                    #                            else: # on Darwin
                    #                                QDesktopServices.openUrl(QUrl("file:///" + str(QApplication.applicationDirPath()) + "/../../../" + cmd_str, QUrl.ParsingMode.TolerantMode))
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                        _, _, exc_tb = sys.exc_info()
                        self.qmc.adderror(
                            (QApplication.translate('Error Message', 'Exception:') + ' eventaction() {0}').format(
                                str(e)), getattr(exc_tb, 'tb_lineno', '?'))
                elif action == 3:  # Multiple Event
                    cmd_list = cmd_str.split(',')
                    for cs in cmd_list:
                        if cs.startswith('sleep'):
                            try:
                                cmds = eval(cs[len('sleep'):])  # pylint: disable=eval-used
                                if isinstance(cmds, (float, int)):
                                    # cmd has format "sleep(xx.yy)"
                                    libtime.sleep(cmds)
                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                        else:
                            buttonnumber = int(cs) - 1
                            # if self.extraeventsactions[buttonnumber] != 3:   #avoid calling other buttons with multiple actions to avoid possible infinite loops
                            self.recordextraevent(buttonnumber, parallel=False, updateButtons=False)
                elif action == 4:  # MODBUS Command
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(
                            ';'))  # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        followupCmd = 0.  # contains the required sleep time
                        for c in cmds:
                            cs = c.strip().replace('_', ('0' if self.modbus.lastReadResult is None else str(
                                self.modbus.lastReadResult)))  # the last read value can be accessed via the "_" symbol

                            # $ is substituted by the state of the current button (1:pressed, 0:normal)
                            last = 0  # defaults to 0
                            if lastbuttonpressed != -1 and len(self.buttonlist) > lastbuttonpressed:
                                last = self.buttonStates[lastbuttonpressed]
                            cs = cs.replace('$', str(last))
                            if followupCmd:
                                if followupCmd == 0.08:
                                    self.modbus.sleepBetween(write=True)
                                else:
                                    self.modbus.sleepBetween(write=False)
                                # libtime.sleep(followupCmd) #this guarantees a minimum of 30 milliseconds between readings and 80ms between writes (according to the Modbus spec)
                            if cs.startswith('writem'):
                                try:
                                    cmds = eval(cs[len('writem'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple) and len(cmds) == 3:
                                        # cmd has format "writem(s,r,[v1,..,vn])"
                                        self.modbus.writeRegisters(*cmds)
                                        followupCmd = 0.08
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('sleep'):
                                try:
                                    cmds = eval(cs[len('sleep'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, (float, int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                        followupCmd = 0.08
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('writeBCD'):
                                try:
                                    cmds = eval(cs[len('writeBCD'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0], list):
                                            # cmd has format "writeBCD(s,r,v)"
                                            self.modbus.writeBCD(*cmds)
                                            followupCmd = 0.08
                                        else:
                                            # cmd has format "writeBCD([s,r,v],..,[s,r,v])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(
                                                        followupCmd)  # respect the MODBUS timing (a MODBUS command might have preceded)
                                                self.modbus.writeBCD(*cx)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "writeBCD([s,r,v])"
                                        self.modbus.writeBCD(*cmds)
                                        followupCmd = 0.08
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('writeWord'):  # writing directly floats
                                try:
                                    cmds = eval(cs[len('writeWord'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0], list):
                                            # cmd has format "writeWord(s,r,v)"
                                            self.modbus.writeWord(*cmds)
                                            followupCmd = 0.08
                                        else:
                                            # cmd has format "writeWord([s,r,v],..,[s,r,v])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(
                                                        followupCmd)  # respect the MODBUS timing (a MODBUS command might have preceded)
                                                self.modbus.writeWord(*cx)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "write(Word[s,r,v])"
                                        self.modbus.writeWord(*cmds)
                                        followupCmd = 0.08
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith(
                                    'writeLong'):  # writing directly 32bit integers in two consecutive registers
                                try:
                                    cmds = eval(cs[len('writeLong'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0], list):
                                            # cmd has format "writeLong(s,r,v)"
                                            self.modbus.writeLong(*cmds)
                                            followupCmd = 0.08
                                        else:
                                            # cmd has format "writeLong([s,r,v],..,[s,r,v])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(
                                                        followupCmd)  # respect the MODBUS timing (a MODBUS command might have preceded)
                                                self.modbus.writeLong(*cx)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "writeLong([s,r,v])"
                                        self.modbus.writeLong(*cmds)
                                        followupCmd = 0.08
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('writeSingle'):
                                try:
                                    cmds = eval(cs[len('writeSingle'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0], list):
                                            # cmd has format "writeSingle(s,r,v)"
                                            self.modbus.writeSingleRegister(*cmds)
                                            followupCmd = 0.08
                                        else:
                                            # cmd has format "writeSingle([s,r,v],..,[s,r,v])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(
                                                        followupCmd)  # respect the MODBUS timing (a MODBUS command might have preceded)
                                                self.modbus.writeSingleRegister(*cx)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "writeSingle([s,r,v])"
                                        self.modbus.writeSingleRegister(*cmds)
                                        followupCmd = 0.08
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('write'):
                                try:
                                    cmds = eval(cs[len('write'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0], list):
                                            # cmd has format "write(s,r,v)"
                                            self.modbus.writeRegister(*cmds)
                                            followupCmd = 0.08
                                        else:
                                            # cmd has format "write([s,r,v],..,[s,r,v])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(
                                                        followupCmd)  # respect the MODBUS timing (a MODBUS command might have preceded)
                                                self.modbus.writeRegister(*cx)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "write([s,r,v])"
                                        self.modbus.writeRegister(*cmds)
                                        followupCmd = 0.08
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('mwrite'):
                                try:
                                    cmds = eval(cs[len('mwrite'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple):
                                        if len(cmds) == 4 and not isinstance(cmds[0], list):
                                            # cmd has format "mwrite(s,r,am,om)"
                                            self.modbus.maskWriteRegister(*cmds)
                                            followupCmd = 0.08
                                        elif len(cmds) == 5 and not isinstance(cmds[0], list):
                                            # cmd has format "mwrite(s,r,am,om,v)" with v the new value that might be evaluated from _ (last MODBUS read result)
                                            # here a local mask write is computed on v and send via MODBUS fct. 6 (instead of fct.25 used by the standard mwrite function below)
                                            self.modbus.localMaskWriteRegister(*cmds)
                                        else:
                                            # cmd has format "mwrite([s,r,am,om],..,[s,r,am,om])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(
                                                        followupCmd)  # respect the MODBUS timing (a MODBUS command might have preceded)
                                                if len(cmd) == 4:
                                                    self.modbus.maskWriteRegister(*cx)
                                                elif len(cmd) == 5:
                                                    self.modbus.localMaskWriteRegister(*cx)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "write([s,r,am,om])"
                                        self.modbus.maskWriteRegister(*cmds)
                                        followupCmd = 0.08
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('wcoils'):
                                try:
                                    cmds = eval(cs[len('wcoils'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple) and len(cmds) == 3 and not isinstance(cmds[0], list):
                                        # cmd has format "wcoils(s,r,[<b>,..<b>])"
                                        self.modbus.writeCoils(*cmds)
                                        followupCmd = 0.08
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('wcoil'):
                                try:
                                    cmds = eval(cs[len('wcoil'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple) and len(cmds) == 3:
                                        # cmd has format "wcoil(s,r,<b>)"
                                        self.modbus.writeCoil(*cmds)
                                        followupCmd = 0.08
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('read'):
                                try:
                                    cmds = eval(cs[len('read'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple) and len(cmds) == 2:
                                        # cmd has format "read(s,r)"
                                        self.modbus.lastReadResult = self.modbus.readSingleRegister(*cmds, force=True)
                                        followupCmd = 0.03
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('readSigned'):
                                try:
                                    cmds = eval(cs[len('readSigned'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple) and len(cmds) == 2:
                                        # cmd has format "readSigned(s,r)"
                                        self.modbus.lastReadResult = self.modbus.readSingleRegister(*cmds, force=True,
                                                                                                    signed=True)
                                        followupCmd = 0.03
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('readBCD'):
                                try:
                                    cmds = eval(cs[len('readBCD'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple) and len(cmds) == 2:
                                        # cmd has format "readBCD(s,r)"
                                        self.modbus.lastReadResult = self.modbus.readBCDint(*cmds, force=True)
                                        followupCmd = 0.03
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('read32'):
                                try:
                                    cmds = eval(cs[len('read32'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple) and len(cmds) == 2:
                                        # cmd has format "read32(s,r)"
                                        self.modbus.lastReadResult = self.modbus.readInt32(*cmds, force=True)
                                        followupCmd = 0.03
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('read32Signed'):
                                try:
                                    cmds = eval(cs[len('read32Signed'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple) and len(cmds) == 2:
                                        # cmd has format "read32Signed(s,r)"
                                        self.modbus.lastReadResult = self.modbus.readInt32(*cmds, force=True,
                                                                                           signed=True)
                                        followupCmd = 0.03
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('read32BCD'):
                                try:
                                    cmds = eval(cs[len('read32BCD'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple) and len(cmds) == 2:
                                        # cmd has format "read32BCD(s,r)"
                                        self.modbus.lastReadResult = self.modbus.readBCD(*cmds, force=True)
                                        followupCmd = 0.03
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('readFloat'):
                                try:
                                    cmds = eval(cs[len('readFloat'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple) and len(cmds) == 2:
                                        # cmd has format "readFloat(s,r)"
                                        res: Optional[float] = self.modbus.readFloat(*cmds, force=True)
                                        self.modbus.lastReadResult = (res if res is None else int(round(res)))
                                        followupCmd = 0.03
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('button'):
                                # cmd has format "button(<bool>)" # 0 or 1 or True or False
                                try:
                                    try:
                                        args = eval(cs[len('button'):])  # pylint: disable=eval-used
                                    except Exception:  # pylint: disable=broad-except
                                        arg = cs[len('button('):-1]
                                        if ',' in arg and '(' not in arg:
                                            # no function definition in arg, and exactly on comma, we split into the two args (could be just "button(1,false)" which does not eval above)
                                            cs_a = [a.strip() for a in arg.split(',')]
                                        else:
                                            args = [
                                                c[len('button('):-1].strip()]  # just a tag like true would fail to eval
                                    cs_len = 1
                                    if isinstance(args, (list, tuple)):
                                        cs_len = len(args)
                                    else:
                                        args = [args]
                                    last = self.lastbuttonpressed
                                    if cs_len > 1:
                                        # just set the button style of the indicated button
                                        b = toInt(args[0]) - 1  # gui button list is indexed from 1
                                        bv = toBool(args[1])
                                        if 0 <= b < len(self.buttonlist):
                                            # block resetting style of last button
                                            self.lastbuttonpressed = -1
                                            if bv:
                                                self.buttonStates[b] = 1
                                                self.setExtraEventButtonStyleSignal.emit(b, 'pressed')
                                            else:
                                                self.buttonStates[b] = 0
                                                self.setExtraEventButtonStyleSignal.emit(b, 'normal')
                                    elif cs_len > 0:
                                        bv = toBool(args[0])
                                        if last != -1 and len(self.buttonlist) > last:
                                            # block resetting style of last button
                                            self.lastbuttonpressed = -1
                                            self.buttonStates[lastbuttonpressed] = int(bv)
                                            if bv:
                                                self.setExtraEventButtonStyleSignal.emit(last, 'pressed')
                                            else:
                                                self.setExtraEventButtonStyleSignal.emit(last, 'normal')
                                    elif len(self.buttonlist) > lastbuttonpressed > -1:
                                        self.lastbuttonpressed = -1  # block resetting style of last button
                                        if self.buttonStates[lastbuttonpressed]:
                                            self.buttonStates[lastbuttonpressed] = 0
                                            self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'normal')
                                        else:
                                            self.buttonStates[lastbuttonpressed] = 1
                                            self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'pressed')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('MODBUS Command <%s> not recognized', cs)
                elif action == 5:  # DTA Command
                    try:
                        DTAvalue = cmd_str.split(':')[1]
                        DTAaddress = cmd_str.split(':')[0]
                        self.dtapid.writeDTE(DTAvalue, DTAaddress)
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                elif action == 6:  # IO Command
                    # PHIDGETS   sn : has the form <hub_serial>[:<hub_port>], an optional serial number of the hub, optionally specifying the port number the module is connected to
                    ##  set(c,b[,sn])   : switches channel c off (b=0) and on (b=1)
                    ##  toggle(c[,sn])  : toggles channel c
                    ##  pulse(c,t[,sn]) : sets the output of channel c to on for time t in milliseconds
                    ##  out(c,v[,sn])   : sets voltage output of channel c to v (float)
                    ##  accel(c,v[,sn]) : sets acceleration of channel c to v (float) on a DCMotor phidget
                    ##  vel(c,v[,sn])   : sets target velocity of channel c to v (float) on a DCMotor phidget
                    ##  limit(c,v[,sn]) : sets current limit of channel c to v (float) on a DCMotor phidget
                    #
                    # YOCTOPUCE
                    ##  on(c[,sn])   : turn channel c of the relay module on
                    ##  off(c[,sn])  : turn channel c of the relay module off
                    ##  yset(c,b[,sn]) : switch channel c off (b=0) and on (b=1)
                    ##  flip(c[,sn]) : toggle the state of channel c
                    ##  pip(c,delay,duration[,sn]) : pulse the channel c on after a delay of delay milliseconds for the duration of duration milliseconds
                    ##  powerReset([,sn]) : reset the power meter of the Yocto Watt
                    #
                    # OTHERS
                    ##  slider(c,v)   : move slider c to value v (c from [0,..3], zero based),
                    ##  button(i,c,b[,sn]) : switches channel c off (b=0) and on (b=1) and sets button i to pressed or normal depending on the value b (sn cannot contain port!)
                    ##  button(i,b): sets button i to pressed if b evals to True and normal else
                    ##  button(b): sets current button to pressed if b to True and normal else
                    ##  button(): toggles state of current button
                    ##  sleep(s) : sleep for s seconds, s a float
                    ##  santoker(<target>,<value>) : the byte <target> indicates where <value> of type integer should be written to
                    ##  kaleido(<target>,<value>) : the <target> string indicates where <value> of type string should be written to
                    #
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(
                            ';'))  # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        lastbuttonpressed = self.lastbuttonpressed  # we remember that here as it might be reset to -1 by some button commands to avoid changing its state
                        for cs in cmds:
                            c = cs.strip().replace('_', (
                                '0' if self.lastIOResult is None else f'{self.lastIOResult:g}'))  # the last read value can be accessed via the "_" symbol
                            # $ is substituted by the state of the current button (1:pressed, 0:normal)
                            last = 0  # defaults to 0
                            if lastbuttonpressed != -1 and len(self.buttonlist) > lastbuttonpressed:
                                last = self.buttonStates[lastbuttonpressed]
                            c = c.replace('$', str(last))
                            try:
                                if c.startswith('set'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len > 2:
                                        channel = toInt(cs_a[1])
                                        value = toBool(cs_a[2])
                                    if cs_len == 3:
                                        if not self.ser.phidgetBinaryOUTset(channel, value):
                                            self.sendmessage(QApplication.translate('Message',
                                                                                    f'Failed to set({cs_a[1]}, {cs_a[2]})'))
                                        else:
                                            # update last result
                                            self.lastIOResult = float(value)
                                    elif cs_len == 4:
                                        serial = cs_a[3]
                                        if not self.ser.phidgetBinaryOUTset(channel, value, serial):
                                            self.sendmessage(QApplication.translate('Message',
                                                                                    f'Failed to set({cs_a[1]}, {cs_a[2]}, {serial})'))
                                        else:
                                            # update last result
                                            self.lastIOResult = float(value)

                                elif c.startswith('toggle'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len > 1:
                                        cx = toInt(cs_a[1])
                                        sn = cs_a[2] if cs_len > 2 else None
                                        #                                #keep state of this gpio, rather than rely on phidget and use non-zero value to set button color
                                        #                                # NOTE: with this strategy the modules state might be different to this one if also a set command is used
                                        #                                newValue = (self.buttonStates[lastbuttonpressed] + 1) & 0x1
                                        # we rather take the new value from the Phidget itself
                                        newValue = not self.ser.phidgetBinaryOUTget(cx, sn)
                                        if self.ser.phidgetBinaryOUTset(cx, bool(newValue), sn):
                                            self.buttonStates[lastbuttonpressed] = int(newValue)
                                            self.lastIOResult = float(newValue)
                                        else:
                                            self.sendmessage(QApplication.translate('Message',
                                                                                    'Failed to toggle(%s)' % (cs_a[
                                                                                        1])))  # pylint: disable=consider-using-f-string
                                        # clear style that got set in button press event handler
                                        if self.buttonStates[lastbuttonpressed] == 1:
                                            self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'pressed')
                                        else:
                                            self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'normal')
                                        # block resetting style of last button
                                        self.lastbuttonpressed = -1

                                # -----

                                elif c.startswith('pulse'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len > 2:
                                        ci = toInt(cs_a[1])
                                        te = toInt(cs_a[2])
                                        sn = cs_a[3] if cs_len > 3 else None
                                        if 0.0 <= te <= 999999:
                                            self.ser.phidgetBinaryOUTpulse(ci, te, sn)
                                        else:
                                            self.sendmessage(QApplication.translate('Message',
                                                                                    'Pulse out of range (%d)') % te)  # pylint: disable=consider-using-f-string

                                elif c.startswith('out'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len > 2:
                                        sn = cs_a[3] if cs_len > 3 else None
                                        if not self.ser.phidgetVOUTsetVOUT(toInt(cs_a[1]), toFloat(eval(cs_a[2])),
                                                                           sn):  # pylint: disable=eval-used
                                            self.sendmessage(QApplication.translate('Message',
                                                                                    f'Failed to set VOUT({cs_a[1]}, {cs_a[2]})'))  # pylint: disable=consider-using-f-string

                                elif c.startswith('accel'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len > 2:
                                        sn = cs_a[3] if cs_len > 3 else None
                                        self.ser.phidgetDCMotorSetAcceleration(toInt(cs_a[1]), toFloat(eval(cs_a[2])),
                                                                               sn)  # pylint: disable=eval-used

                                elif c.startswith('vel'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len > 2:
                                        sn = cs_a[3] if cs_len > 3 else None
                                        self.ser.phidgetDCMotorSetVelocity(toInt(cs_a[1]), toFloat(eval(cs_a[2])),
                                                                           sn)  # pylint: disable=eval-used

                                elif c.startswith('limit'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len > 2:
                                        sn = cs_a[3] if cs_len > 3 else None
                                        self.ser.phidgetDCMotorSetCurrentLimit(toInt(cs_a[1]), toFloat(eval(cs_a[2])),
                                                                               sn)  # pylint: disable=eval-used

                                elif c.startswith('slider'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len == 3:
                                        v = toFloat(cs_a[2])
                                        self.moveslider(toInt(cs_a[1]), v)

                                elif c.startswith('button'):
                                    try:
                                        cs_ab = eval(c[len('button'):])  # pylint: disable=eval-used
                                    except Exception:  # pylint: disable=broad-except
                                        arg = cs[len('button('):-1]
                                        if ',' in arg and '(' not in arg:
                                            # no function definition in arg, and exactly on comma, we split into the two args (could be just "button(1,false)" which does not eval above)
                                            cs_ab = [a.strip() for a in arg.split(',')]
                                        else:
                                            cs_ab = [c[len('button('):-1].strip()]
                                    cs_len = 1
                                    if isinstance(cs_ab, (list, tuple)):
                                        cs_len = len(cs_ab)
                                    else:
                                        cs_ab = [cs_ab]
                                    if cs_len > 2:
                                        # PHIDGET Binary Output
                                        b = toInt(cs_ab[0]) - 1  # gui button list is indexed from 1
                                        ci = toInt(cs_ab[1])
                                        v = toInt(cs_ab[2])
                                        sn = cs_ab[3] if cs_len > 4 else None
                                        if self.ser.phidgetBinaryOUTset(ci, bool(v & 0x1), sn):
                                            self.buttonStates[b] = v & 0x1
                                        else:
                                            self.sendmessage(QApplication.translate('Message',
                                                                                    f'Failed to set button({cs_ab[0]}, {cs_ab[1]}, {cs_ab[2]})'))
                                        self.lastbuttonpressed = -1  # block resetting style of last button
                                        if self.buttonStates[b] != 0:
                                            self.setExtraEventButtonStyleSignal.emit(b, 'pressed')
                                        else:
                                            self.setExtraEventButtonStyleSignal.emit(b, 'normal')
                                    elif cs_len > 1:
                                        # just set the button style of the indicated button
                                        b = toInt(cs_ab[0]) - 1  # gui button list is indexed from 1
                                        bv = toBool(cs_ab[1])
                                        if 0 <= b < len(self.buttonlist):
                                            # block resetting style of last button
                                            self.lastbuttonpressed = -1
                                            if bv:
                                                self.buttonStates[b] = 1
                                                self.setExtraEventButtonStyleSignal.emit(b, 'pressed')
                                            else:
                                                self.buttonStates[b] = 0
                                                self.setExtraEventButtonStyleSignal.emit(b, 'normal')
                                    elif cs_len > 0:
                                        bv = toBool(cs_ab[0])
                                        if len(self.buttonlist) > lastbuttonpressed > -1:
                                            # block resetting style of last button
                                            self.lastbuttonpressed = -1
                                            self.buttonStates[lastbuttonpressed] = int(bv)
                                            if bv:
                                                self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'pressed')
                                            else:
                                                self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'normal')
                                    elif len(self.buttonlist) > lastbuttonpressed > -1:
                                        self.lastbuttonpressed = -1  # block resetting style of last button
                                        if self.buttonStates[lastbuttonpressed]:
                                            self.buttonStates[lastbuttonpressed] = 0
                                            self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'normal')
                                        else:
                                            self.buttonStates[lastbuttonpressed] = 1
                                            self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'pressed')

                                elif c.startswith('sleep'):  # in seconds
                                    cs_aa = eval(c[len('sleep'):])  # pylint: disable=eval-used
                                    if isinstance(cs_aa, (float, int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cs_aa)

                                ##  santoker(<target>,<value>) : the <target> hex string indicates where <value> of type integer should be written to
                                elif c.startswith('santoker'):
                                    if self.santoker is not None:
                                        args = c[len('santoker'):]
                                        if args.startswith('(') and args.endswith(')'):
                                            comma_pos = args.index(',')
                                            target = args[1:comma_pos]
                                            fv = float(eval(args[comma_pos + 1:-1]))  # pylint: disable=eval-used
                                            # interpret target as hex string
                                            bts = bytes.fromhex(target)
                                            if len(bts) > 0:
                                                self.santokerSendMessageSignal.emit(bts[0:1], int(round(fv)))

                                ##  kaleido(<target>,<value>) : the <target> string indicates where <value> of type string should be written to
                                elif c.startswith('kaleido'):
                                    if self.kaleido is not None:
                                        args = c[len('kaleido'):]
                                        if args.startswith('(') and args.endswith(')'):
                                            comma_pos = args.index(',')
                                            target = args[1:comma_pos].strip()
                                            vs: str = args[comma_pos + 1:-1].strip()
                                            try:
                                                # <value> can be a formula like "1 - _" or "1 - $"
                                                vs = str(eval(vs))  # pylint: disable=eval-used
                                            except Exception:  # pylint: disable=broad-except
                                                # or <value> is just a string like "UP", "DW"
                                                pass
                                            if eventtype is None:
                                                # send message without awaiting a result
                                                if target in {'CS', 'HS'}:
                                                    # by clamping event type to -1 we fore kaleidoSendMessageAwait() to not generate an event, but just update the button state based on the response received
                                                    self.kaleidoSendMessageAwaitSignal.emit(target, vs, -1,
                                                                                            lastbuttonpressed)
                                                else:
                                                    self.kaleidoSendMessageSignal.emit(target, vs)
                                            else:
                                                # button has relative event type and value set to 0 (decided in recordextraevent())! # used in relative +- event buttons receiving change from machine
                                                # or event type is set to -1 and result of event action should be awaited and bound to $ changing event button state # used by toggle buttons
                                                # send message, await new value and create an event with the new value
                                                self.kaleidoSendMessageAwaitSignal.emit(target, vs, eventtype,
                                                                                        lastbuttonpressed)

                                # Yoctopuce Relay Command Actions
                                # yset(c,b[,sn])
                                elif c.startswith('yset'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len > 2:
                                        b = toBool(cs_a[2])
                                    ser: Optional[str] = None
                                    if cs_len == 4:
                                        ser = cs_a[3]
                                    if b:
                                        self.ser.yoctoRELon(int(cs_a[1]), ser)
                                    else:
                                        self.ser.yoctoRELoff(int(cs_a[1]), ser)
                                # on(c[,sn])
                                elif c.startswith('on'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len == 2:
                                        self.ser.yoctoRELon(int(cs_a[1]), None)
                                    elif cs_len == 3:
                                        self.ser.yoctoRELon(int(cs_a[1]), cs_a[2])

                                # off(c[,sn])
                                elif c.startswith('off'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len == 2:
                                        self.ser.yoctoRELoff(int(cs_a[1]), None)
                                    elif cs_len == 3:
                                        self.ser.yoctoRELoff(int(cs_a[1]), cs_a[2])

                                # flip(c[,sn])
                                elif c.startswith('flip'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len == 2:
                                        self.ser.yoctoRELflip(int(cs_a[1]), None)
                                    elif cs_len == 3:
                                        self.ser.yoctoRELflip(int(cs_a[1]), cs_a[2])

                                # pip(c,delay,duration[,sn])
                                elif c.startswith('pip'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len == 4:
                                        self.ser.yoctoRELpulse(int(cs_a[1]), int(cs_a[2]), int(cs_a[3]), None)
                                    elif cs_len == 5:
                                        self.ser.yoctoRELpulse(int(cs_a[1]), int(cs_a[2]), int(cs_a[3]), cs_a[4])

                                #  powerReset([,sn]) : reset the power meter of the Yocto Watt
                                elif c.startswith('powerReset'):
                                    cs_a = re.findall(r'[0-9a-zA-Z-.:]+', c)
                                    cs_len = len(cs_a)
                                    if cs_len == 1:
                                        self.ser.yoctoPowerReset(None)
                                    elif cs_len == 2:
                                        self.ser.yoctoPowerReset(cs_a[1])

                                else:
                                    _log.info('IO Command <%s> not recognized', cs)
                                    self.sendmessage(QApplication.translate('Message',
                                                                            'No match for command [%s], continuing' % (
                                                                                cs)))  # pylint: disable=consider-using-f-string

                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)


                elif action == 7:  # slider call-program action
                    try:
                        self.call_prog_with_args(cmd_str)
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                        _, _, exc_tb = sys.exc_info()
                        self.qmc.adderror(
                            (QApplication.translate('Error Message', 'Exception:') + ' callProgram(): {0}').format(
                                str(e)), getattr(exc_tb, 'tb_lineno', '?'))
                elif action == 8:  # HOTTOP Heater
                    if self.hottop is not None:
                        self.hottop.setHottop(heater=int(cmd))
                elif action == 9:  # HOTTOP Main Fan
                    if self.hottop is not None:
                        self.hottop.setHottop(main_fan=int(cmd))
                elif action == 10:  # HOTTOP Command (one of "heater", "fan", "motor", "solenoid", "stirrer"); "drum" accepted as alias for "motor"
                    if cmd_str and self.hottop is not None:
                        cmds = filter(None, cmd_str.split(
                            ';'))  # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            if cs.startswith('heater'):
                                try:
                                    cmds = eval(cs[len('heater'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, int):
                                        self.hottop.setHottop(heater=min(max(cmds, 0), 100))
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('fan'):
                                try:
                                    cmds = eval(cs[len('fan'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, int):
                                        self.hottop.setHottop(main_fan=int(min(max(cmds, 0), 10) * 10))
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('drum'):  # drum as an alias for motor
                                try:
                                    cmds = eval(cs[len('drum'):])  # pylint: disable=eval-used
                                    if cmds:
                                        self.hottop.setHottop(drum_motor=True)
                                    else:
                                        self.hottop.setHottop(drum_motor=False)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('motor'):
                                try:
                                    cmds = eval(cs[len('motor'):])  # pylint: disable=eval-used
                                    if cmds:
                                        self.hottop.setHottop(drum_motor=True)
                                    else:
                                        self.hottop.setHottop(drum_motor=False)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('solenoid'):
                                try:
                                    cmds = eval(cs[len('solenoid'):])  # pylint: disable=eval-used
                                    if cmds:
                                        self.hottop.setHottop(solenoid=True)
                                    else:
                                        self.hottop.setHottop(solenoid=False)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('stirrer'):
                                try:
                                    cmds = eval(cs[len('stirrer'):])  # pylint: disable=eval-used
                                    if cmds:
                                        self.hottop.setHottop(cooling_motor=True)
                                    else:
                                        self.hottop.setHottop(cooling_motor=False)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('sleep') and cs.endswith(')'):  # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, (float, int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('HOTTOP Command <%s> not recognized', cs)
                elif action == 11:  # p-i-d, expects 3 float numbers separated by semicolon
                    if cmd_str:
                        cmds = list(filter(None, cmd_str.split(';')))  # "<p>;<i>;<d>"
                        if len(cmds) == 3:
                            kp = float(cmds[0])
                            ki = float(cmds[1])
                            kd = float(cmds[2])
                            # FUJI/DELTA pid
                            if self.qmc.device in {0, 26}:
                                # set-p-i-d currently only set from dialog
                                if self.ser.controlETpid[0] == 0:
                                    # 1. get current PID
                                    N = self.fujipid.getCurrentPIDnumberPXG()
                                    if N != -1:
                                        # 2. call setpid(self,k) with k that active pid
                                        self.fujipid.setpidPXG(N, kp, ki, kd)
                                elif self.ser.controlETpid[0] == 1:
                                    self.fujipid.setpidPXR('p', kp)
                                    libtime.sleep(0.035)
                                    self.fujipid.setpidPXR('i', ki)
                                    libtime.sleep(0.035)
                                    self.fujipid.setpidPXR('d', kd)
                                elif self.ser.controlETpid[0] == 4:  # PXF
                                    # 1. get current PID
                                    N = self.fujipid.getCurrentPIDnumberPXF()
                                    if N != -1:
                                        # 2. call setpid(self,k) with k that active pid
                                        self.fujipid.setpidPXF(N, kp, ki, kd)
                            else:
                                self.pidcontrol.confPID(kp, ki, kd, pOnE=self.pidcontrol.pOnE)
                                # self.pidcontrol.setPID(kp,ki,kd) # we don't set the new values in the dialog
                elif action == 12:  # Fuji Command (currently only "write(<unitId>,<register>,<value>)" is supported
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(
                            ';'))  # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        followupCmd = 0.  # contains the required sleep time
                        for c in cmds:
                            if self.modbus.lastReadResult is None:
                                self.modbus.lastReadResult = 0
                            cs = c.strip().replace('_',
                                                   str(self.modbus.lastReadResult))  # the last read value can be accessed via the "_" symbol
                            if followupCmd:
                                try:
                                    if followupCmd == 0.08:
                                        self.modbus.sleepBetween(write=True)
                                    else:
                                        self.modbus.sleepBetween(write=False)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            if cs.startswith('write'):
                                try:
                                    cmds = eval(cs[len('write'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, tuple):
                                        if len(cmds) == 3 and not isinstance(cmds[0], list):
                                            # cmd has format "write(s,r,v)"
                                            command = self.fujipid.message2send(cmds[0], 6, cmds[1], cmds[2])
                                            self.ser.sendFUJIcommand(command, 8)
                                            followupCmd = 0.08
                                        else:
                                            # cmd has format "write([s,r,v],..,[s,r,v])"
                                            for cx in cmds:
                                                if followupCmd:
                                                    libtime.sleep(
                                                        followupCmd)  # respect the MODBUS timing (a MODBUS command might have preceded)
                                                command = self.fujipid.message2send(cx[0], 6, cx[1], cx[2])
                                                self.ser.sendFUJIcommand(command, 8)
                                                followupCmd = 0.08
                                    else:
                                        # cmd has format "write([s,r,v])"
                                        command = self.fujipid.message2send(cmds[0], 6, cmds[1], cmds[2])
                                        self.ser.sendFUJIcommand(command, 8)
                                        followupCmd = 0.08
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                elif action == 13:  # PWM Command
                    # PHIDGET  <sn> : has the form <hub_serial>[:<hub_port>], an optional serial number of the hub, optionally specifying the port number the module is connected to
                    #
                    ## out(<channel>,<value>[,<sn>])  with <value> in [0-100]
                    ## frequency(<value>[,<sn>])  with <value> a real number
                    ## toggle(<channel>[,<sn>])
                    ## outhub(<channel>,<value>[,<sn>])
                    ## togglehub(<channel>[,<sn>])
                    ## pulse(<channel>,<millis>[,<sn>])
                    ## pulsehub(<channel>,<millis>[,<sn>])
                    #
                    # YOCTOPUCE
                    #
                    ## enabled(c,b[,sn])
                    ## freq(c,f[,sn])
                    ## duty(c,d[,sn])
                    ## move(c,d,t[,sn])
                    ##
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(
                            ';'))  # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            try:
                                if cs.startswith('out(') and len(cs) > 7:
                                    cs_split = cs[4:-1].split(',')
                                    if len(cs_split) > 1:
                                        channel = toInt(cs_split[0])
                                        int_value = toInt(eval(cs_split[1]))  # pylint: disable=eval-used
                                        if len(cs_split) == 2:
                                            self.ser.phidgetOUTsetPWM(channel, int_value)
                                        elif len(cs_split) == 3:
                                            serial = cs_split[2]
                                            self.ser.phidgetOUTsetPWM(channel, int_value, serial)
                                elif cs.startswith('frequency(') and len(cs) > 14:
                                    cs_split = cs[10:-1].split(',')
                                    if len(cs_split) == 2:
                                        self.ser.phidgetOUTsetPWMfrequency(int(cs_split[0]), toFloat(
                                            eval(cs_split[1])))  # pylint: disable=eval-used
                                    elif len(cs_split) == 3:
                                        self.ser.phidgetOUTsetPWMfrequency(int(cs_split[0]), toFloat(eval(cs_split[1])),
                                                                           cs_split[2])  # pylint: disable=eval-used
                                elif cs.startswith('toggle(') and len(cs) > 8:
                                    cs_split = cs[7:-1].split(',')
                                    if len(cs_split) == 1:
                                        self.ser.phidgetOUTtogglePWM(int(cs_split[0]))
                                    elif len(cs_split) == 2:
                                        self.ser.phidgetOUTtogglePWM(int(cs_split[0]), cs_split[1])
                                elif cs.startswith('outhub(') and len(cs) > 10:
                                    cs_split = cs[7:-1].split(',')
                                    if len(cs_split) == 2:
                                        self.ser.phidgetOUTsetPWMhub(int(cs_split[0]), toInt(
                                            eval(cs_split[1])))  # pylint: disable=eval-used
                                    elif len(cs_split) == 3:
                                        self.ser.phidgetOUTsetPWMhub(int(cs_split[0]), toInt(eval(cs_split[1])),
                                                                     cs_split[2])  # pylint: disable=eval-used
                                elif cs.startswith('togglehub(') and len(cs) > 11:
                                    cs_split = cs[10:-1].split(',')
                                    if len(cs_split) == 1:
                                        self.ser.phidgetOUTtogglePWMhub(int(cs_split[0]))
                                    elif len(cs_split) == 2:
                                        self.ser.phidgetOUTtogglePWMhub(int(cs_split[0]), cs_split[1])
                                elif cs.startswith('pulsehub(') and len(cs) > 12:
                                    cs_split = cs[9:-1].split(',')
                                    if len(cs_split) == 2:
                                        self.ser.phidgetOUTpulsePWMhub(int(cs_split[0]), int(cs_split[1]))
                                    elif len(cs_split) == 3:
                                        self.ser.phidgetOUTpulsePWMhub(int(cs_split[0]), int(cs_split[1]), cs_split[2])
                                elif cs.startswith('pulse(') and len(cs) > 9:
                                    cs_split = cs[6:-1].split(',')
                                    if len(cs_split) == 2:
                                        self.ser.phidgetOUTpulsePWM(int(cs_split[0]), int(cs_split[1]))
                                    elif len(cs_split) == 3:
                                        self.ser.phidgetOUTpulsePWM(int(cs_split[0]), int(cs_split[1]), cs_split[2])
                                elif cs.startswith('sleep') and cs.endswith(')'):  # in seconds
                                    cmds = eval(cs[len('sleep'):])  # pylint: disable=eval-used # pylint: disable=W0123
                                    if isinstance(cmds, (float, int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)


                                # Commands for the YoctoPWM module

                                # enabled(c,b[,sn])
                                elif cs.startswith('enabled') and cs.endswith(')') and len(cs) > 11:
                                    try:
                                        cs_split = cs[len('enabled('):-1].split(',')
                                        if len(cs_split) > 2:
                                            self.ser.yoctoPWMenabled(int(cs_split[0]), toBool(eval(cs_split[1])),
                                                                     cs_split[2])  # pylint: disable=eval-used
                                        else:
                                            self.ser.yoctoPWMenabled(int(cs_split[0]), toBool(
                                                eval(cs_split[1])))  # pylint: disable=eval-used
                                    except Exception as e:  # pylint: disable=broad-except
                                        _log.exception(e)
                                # freq(c,f[,sn])
                                elif cs.startswith('freq') and cs.endswith(')') and len(cs) > 8:
                                    try:
                                        cs_split = cs[len('freq('):-1].split(',')
                                        if len(cs_split) > 2:
                                            self.ser.yoctoPWMsetFrequency(int(cs_split[0]), toInt(eval(cs_split[1])),
                                                                          cs_split[2])  # pylint: disable=eval-used
                                        else:
                                            self.ser.yoctoPWMsetFrequency(int(cs_split[0]), toInt(
                                                eval(cs_split[1])))  # pylint: disable=eval-used
                                    except Exception as e:  # pylint: disable=broad-except
                                        _log.exception(e)
                                # duty(c,d[,sn])
                                elif cs.startswith('duty') and cs.endswith(')') and len(cs) > 8:
                                    try:
                                        cs_split = cs[len('duty('):-1].split(',')
                                        if len(cs_split) > 2:
                                            self.ser.yoctoPWMsetDuty(int(cs_split[0]), toFloat(eval(cs_split[1])),
                                                                     cs_split[2])  # pylint: disable=eval-used
                                        else:
                                            self.ser.yoctoPWMsetDuty(int(cs_split[0]), toFloat(
                                                eval(cs_split[1])))  # pylint: disable=eval-used
                                    except Exception as e:  # pylint: disable=broad-except
                                        _log.exception(e)
                                # move(c,d,t[,sn])
                                elif cs.startswith('move') and cs.endswith(')') and len(cs) > 10:
                                    try:
                                        cs_split = cs[len('move('):-1].split(',')
                                        if len(cs_split) > 3:
                                            self.ser.yoctoPWMmove(int(cs_split[0]), toFloat(eval(cs_split[1])),
                                                                  int(cs_split[2]),
                                                                  cs_split[3])  # pylint: disable=eval-used
                                        else:
                                            self.ser.yoctoPWMmove(int(cs_split[0]), toFloat(eval(cs_split[1])),
                                                                  int(cs_split[2]))  # pylint: disable=eval-used
                                    except Exception as e:  # pylint: disable=broad-except
                                        _log.exception(e)
                                else:
                                    # command not recognized
                                    _log.info('PMW Command <%s> not recognized', cs)
                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                elif action == 14:  # VOUT Command to drive Phidget/Yocto Output Modules
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(
                            ';'))  # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            # for Phidgets OUT modules "out(<channel>,<value>[,<serial>])" with <value> a float
                            if cs.startswith('out(') and len(cs) > 7:
                                try:
                                    cs_split = cs[4:-1].split(',')
                                    if len(cs_split) == 2:
                                        self.ser.phidgetVOUTsetVOUT(int(cs_split[0]), toFloat(
                                            eval(cs_split[1])))  # pylint: disable=eval-used
                                    elif len(cs_split) == 3:
                                        self.ser.phidgetVOUTsetVOUT(int(cs_split[0]), toFloat(eval(cs_split[1])),
                                                                    cs_split[2])  # pylint: disable=eval-used
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('range(') and len(cs) > 7:
                                try:
                                    cs_split = cs[6:-1].split(',')
                                    if len(cs_split) == 2:
                                        self.ser.phidgetVOUTsetRange(int(cs_split[0]), int(cs_split[1]))
                                    elif len(cs_split) == 3:
                                        self.ser.phidgetVOUTsetRange(int(cs_split[0]), int(cs_split[1]), cs_split[2])
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # for YOCTOPUCE VOLTAGE OUT modules "vout(c,v[,sn])" with c the channel (1 or 2),v the voltage as float [0.0-10.0] and the optional sn either the modules serial number or its name
                            elif cs.startswith('vout(') and len(cs) > 8:
                                try:
                                    cs_split = cs[5:-1].split(',')
                                    if len(cs_split) > 2:
                                        self.ser.yoctoVOUTsetVOUT(int(cs_split[0]), toFloat(eval(cs_split[1])),
                                                                  cs_split[2])  # pylint: disable=eval-used
                                    else:
                                        self.ser.yoctoVOUTsetVOUT(int(cs_split[0]), toFloat(
                                            eval(cs_split[1])))  # pylint: disable=eval-used
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # for YOCTOPUCE CURRENT OUT modules "cout(c[,sn])" with c the current as float [3.0-21.0] and the optional sn either the modules serial number or its name
                            elif cs.startswith('cout(') and len(cs) > 6:
                                try:
                                    # c = cs[5:-1]
                                    cs_split = cs[5:-1].split(',')
                                    if len(cs_split) > 1:
                                        self.ser.yoctoCOUTsetCOUT(toFloat(eval(cs_split[0])),
                                                                  cs_split[1])  # pylint: disable=eval-used
                                    else:
                                        self.ser.yoctoCOUTsetCOUT(
                                            toFloat(eval(cs_split[0])))  # pylint: disable=eval-used
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('sleep') and cs.endswith(')'):  # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, (float, int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('VOUT Command <%s> not recognized', cs)
                elif action == 15:  # S7 Command
                    # getDBbool(<dbnumber>,<start>,<index>)
                    # getDBint(<dbnumber>,<start>)
                    # getDBfloat(<dbnumber>,<start>)
                    # -
                    # setDBbool(<dbnumber>,<start>,<index>,<value>)
                    # setDBint(<dbnumber>,<start>,<value>)
                    # msetDBint(<dbnumber>,<start>,andMaks,orMask,value)
                    # setDBfloat(<dbnumber>,<start>,<value>)
                    # -
                    # button(<b>)
                    # sleep(<xx.yy>) xx.yy in seconds
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(
                            ';'))  # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip().replace('_',
                                                   str(self.s7.lastReadResult))  # the last read value can be accessed via the "_" symbol

                            # $ is substituted by the state of the current button (1:pressed, 0:normal)
                            last = 0  # defaults to 0
                            if lastbuttonpressed != -1 and len(self.buttonlist) > lastbuttonpressed:
                                last = self.buttonStates[lastbuttonpressed]
                            cs = cs.replace('$', str(last))

                            if cs.startswith('setDBint(') and len(cs) > 14:
                                try:
                                    dbnr, s, v_str = cs[len('setDBint('):-1].split(',')
                                    self.s7.writeInt(5, int(dbnr), int(s), eval(v_str))  # pylint: disable=eval-used
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('msetDBint(') and len(cs) > 16:
                                try:
                                    dbnr, s, a, o, v_str = cs[len('msetDBint('):-1].split(',')
                                    self.s7.maskWriteInt(5, int(dbnr), int(s), int(a), int(o),
                                                         eval(v_str))  # pylint: disable=eval-used
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('getDBint(') and len(cs) > 13:
                                try:
                                    dbnr, s = cs[len('getDBint('):-1].split(',')
                                    resi = self.s7.readInt(5, int(dbnr), int(s), force=True)
                                    if resi is not None:
                                        self.s7.lastReadResult = resi
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('setDBfloat(') and len(cs) > 16:
                                try:
                                    dbnr, s, v_str = cs[len('setDBfloat('):-1].split(',')
                                    self.s7.writeFloat(5, int(dbnr), int(s), eval(v_str))  # pylint: disable=eval-used
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('getDBfloat(') and len(cs) > 14:
                                try:
                                    dbnr, s = cs[len('getDBfloat('):-1].split(',')
                                    resf = self.s7.readFloat(5, int(dbnr), int(s), force=True)
                                    if resf is not None:
                                        self.s7.lastReadResult = resf
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('setDBbool(') and len(cs) > 17:
                                try:
                                    dbnr, s, si, v_str = cs[len('setDBbool('):-1].split(',')
                                    self.s7.writeBool(5, int(dbnr), int(s), int(si),
                                                      eval(v_str))  # pylint: disable=eval-used
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('getDBbool(') and len(cs) > 15:
                                try:
                                    dbnr, s, si = cs[len('getDBbool('):-1].split(',')
                                    resb: Optional[bool] = self.s7.readBool(5, int(dbnr), int(s), int(si), force=True)
                                    if resb is not None:
                                        self.s7.lastReadResult = resb
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)

                            elif cs.startswith('button'):
                                # cmd has format "button(<bool>)" # 0 or 1 or True or False
                                try:
                                    try:
                                        args = eval(cs[len('button'):])  # pylint: disable=eval-used
                                    except Exception:  # pylint: disable=broad-except
                                        arg = cs[len('button('):-1]
                                        if ',' in arg and '(' not in arg:
                                            # no function definition in arg, and exactly on comma, we split into the two args (could be just "button(1,false)" which does not eval above)
                                            cs_a = [a.strip() for a in arg.split(',')]
                                        else:
                                            args = [
                                                c[len('button('):-1].strip()]  # just a tag like True would fail to eval
                                    cs_len = 1
                                    if isinstance(args, (list, tuple)):
                                        cs_len = len(args)
                                    else:
                                        args = [args]
                                    last = self.lastbuttonpressed
                                    if cs_len > 1:
                                        # just set the button style of the indicated button
                                        b = toInt(args[0]) - 1  # gui button list is indexed from 1
                                        bv = toBool(args[1])
                                        if 0 <= b < len(self.buttonlist):
                                            # block resetting style of last button
                                            self.lastbuttonpressed = -1
                                            if bv:
                                                self.buttonStates[b] = 1
                                                self.setExtraEventButtonStyleSignal.emit(b, 'pressed')
                                            else:
                                                self.buttonStates[b] = 0
                                                self.setExtraEventButtonStyleSignal.emit(b, 'normal')
                                    elif cs_len > 0:
                                        bv = toBool(args[0])
                                        if last != -1 and len(self.buttonlist) > last:
                                            # block resetting style of last button
                                            self.lastbuttonpressed = -1
                                            self.buttonStates[lastbuttonpressed] = int(bv)
                                            if bv:
                                                self.setExtraEventButtonStyleSignal.emit(last, 'pressed')
                                            else:
                                                self.setExtraEventButtonStyleSignal.emit(last, 'normal')
                                    elif len(self.buttonlist) > lastbuttonpressed > -1:
                                        self.lastbuttonpressed = -1  # block resetting style of last button
                                        if self.buttonStates[lastbuttonpressed]:
                                            self.buttonStates[lastbuttonpressed] = 0
                                            self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'normal')
                                        else:
                                            self.buttonStates[lastbuttonpressed] = 1
                                            self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'pressed')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('sleep') and cs.endswith(')'):  # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, (float, int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('S7 Command <%s> not recognized', cs)
                elif action == 16 and self.ser is not None and self.ser.R1 is not None:  # Aillio Heater
                    self.ser.R1.set_heater(int(cmd) / 10)
                elif action == 17 and self.ser.R1 is not None:  # Aillio Fan
                    self.ser.R1.set_fan(int(cmd) / 10)
                elif action == 18 and self.ser.R1 is not None:  # Aillio Drum
                    self.ser.R1.set_drum(int(cmd) / 10)
                elif action == 19 and self.ser.R1 is not None:
                    if cmd_str == 'PRS':
                        self.ser.R1.prs()
                elif action == 20:  # Artisan Command
                    if cmd_str:
                        cmds = filter(None, cmd_str.split(
                            ';'))  # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        lastbuttonpressed = self.lastbuttonpressed  # we remember that here as it might be reset to -1 by some button commands to avoid changing its state
                        for c in cmds:
                            cs = c.strip().replace('_', (
                                '0' if self.lastArtisanResult is None else f'{self.lastArtisanResult:g}'))  # the last read value can be accessed via the "_" symbol
                            # $ is substituted by the state of the current button (1:pressed, 0:normal)
                            last = 0  # defaults to 0
                            if lastbuttonpressed != -1 and len(self.buttonlist) > lastbuttonpressed:
                                last = self.buttonStates[lastbuttonpressed]
                            cs = cs.replace('$', str(last))

                            # alarms(<bool>) enable/disable alarms
                            if cs.startswith('alarms(') and cs.endswith(')'):
                                try:
                                    value_str = cs[len('alarms('):-1]
                                    if value_str.lower() in {'yes', 'true', 't', '1'}:
                                        self.qmc.silent_alarms = False
                                        self.sendmessage(QApplication.translate('Message', 'Alarms on'))
                                    else:
                                        self.qmc.silent_alarms = True
                                        self.sendmessage(QApplication.translate('Message', 'Alarms off'))
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # autoCHARGE(<bool>) enable/disable autoCHARGE
                            elif cs.startswith('autoCHARGE(') and cs.endswith(')'):
                                try:
                                    value_str = cs[len('autoCHARGE('):-1]
                                    if value_str.lower() in {'yes', 'true', 't', '1'}:
                                        self.qmc.autoChargeFlag = True
                                        self.sendmessage(QApplication.translate('Message', 'autoCHARGE on'))
                                    else:
                                        self.qmc.autoChargeFlag = False
                                        self.sendmessage(QApplication.translate('Message', 'autoCHARGE off'))
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # autoDROP(<bool>) enable/disable autoDROP
                            elif cs.startswith('autoDROP(') and cs.endswith(')'):
                                try:
                                    value_str = cs[len('autoDROP('):-1]
                                    if value_str.lower() in {'yes', 'true', 't', '1'}:
                                        self.qmc.autoDropFlag = True
                                        self.sendmessage(QApplication.translate('Message', 'autoDROP on'))
                                    else:
                                        self.qmc.autoDropFlag = False
                                        self.sendmessage(QApplication.translate('Message', 'autoDROP off'))
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # sleep(<n>) sleep <n> seconds (might be a float like in "sleep(1.2)"
                            elif cs.startswith('sleep') and cs.endswith(')'):  # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, (float, int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # tare(<n>) tare channel <n> with 1 => ET, 2 => BT, 3 => E1c1, 4: E1c2,..
                            elif cs.startswith('tare') and cs.endswith(')'):  # in seconds
                                try:
                                    cmds = eval(cs[len('tare'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, int):
                                        self.setTareSignal.emit(cmds - 1)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs == 'PIDoff':
                                if self.qmc.device == 0:  # Fuji
                                    standby = self.fujipid.getONOFFstandby()
                                    if standby == 0:  # standby is off (=0), turn it on (=1)
                                        self.fujipid.setONOFFstandby(1)
                                        self.sendmessage(QApplication.translate('Message', 'PID set to OFF'))
                                else:
                                    self.pidOffSignal.emit()
                                    self.lastArtisanResult = 0
                            elif cs == 'PIDon':
                                if self.qmc.device == 0:  # Fuji
                                    standby = self.fujipid.getONOFFstandby()
                                    if standby == 1:  # standby is on (=1), turn it off (=0)
                                        self.fujipid.setONOFFstandby(0)
                                        self.sendmessage(QApplication.translate('Message', 'PID set to ON'))
                                else:
                                    self.pidOnSignal.emit()
                                    if self.qmc.flagon:
                                        self.lastArtisanResult = 1
                            elif cs == 'PIDtoggle':
                                if self.qmc.device == 0:  # Fuji
                                    standby = self.fujipid.getONOFFstandby()
                                    if standby == 1:  # standby is on (=1), turn it off (=0)
                                        self.fujipid.setONOFFstandby(0)
                                        self.sendmessage(QApplication.translate('Message', 'PID set to ON'))
                                    elif standby == 0:  # standby is off (=0), turn it on (=1)
                                        self.fujipid.setONOFFstandby(1)
                                        self.sendmessage(QApplication.translate('Message', 'PID set to OFF'))
                                else:
                                    self.lastArtisanResult = (
                                        1 if (self.qmc.flagon and not self.pidcontrol.pidActive) else 0)
                                    self.pidToggleSignal.emit()
                            # pidmode(<n>) : 0: manual, 1: RS, 2: background follow
                            elif cs.startswith('pidmode(') and cs.endswith(')'):
                                try:
                                    value_int = int(cs[len('pidmode('):-1])
                                    if self.qmc.device == 0:  # Fuji PID
                                        # rs state =0 OFF, = 1 ON, = 2 hold
                                        if value_int == 0:
                                            self.fujipid.setrampsoak(0)
                                            self.fujipid.followBackground = False
                                            self.sendmessage(QApplication.translate('Message', 'PID mode manual'))
                                        elif value_int == 1:
                                            self.fujipid.setrampsoak(1)
                                            self.fujipid.followBackground = False
                                            self.sendmessage(QApplication.translate('Message', 'PID mode Ramp/Soak'))
                                        elif value_int == 2:
                                            self.fujipid.setrampsoak(0)
                                            self.fujipid.followBackground = True
                                            self.sendmessage(QApplication.translate('Message', 'PID mode background'))
                                    # software PID
                                    elif value_int == 0:
                                        self.pidcontrol.svMode = 0
                                        self.sendmessage(QApplication.translate('Message', 'PID mode manual'))
                                    elif value_int == 1:
                                        self.pidcontrol.svMode = 1
                                        self.sendmessage(QApplication.translate('Message', 'PID mode Ramp/Soak'))
                                    elif value_int == 2:
                                        self.pidcontrol.svMode = 2
                                        self.sendmessage(QApplication.translate('Message', 'PID mode background'))
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # playbackmode(<n>) with 0: off, 1: time, 2: BT, 3: ET
                            elif cs.startswith('playbackmode(') and cs.endswith(')'):
                                try:
                                    value_int = int(cs[len('playbackmode('):-1])
                                    if value_int == 0:
                                        self.qmc.replayType = 0
                                        self.qmc.backgroundPlaybackEvents = False
                                        self.sendmessage(QApplication.translate('Message', 'playback off'))
                                    elif value_int == 1:
                                        self.qmc.replayType = 0
                                        self.qmc.backgroundPlaybackEvents = True
                                        self.sendmessage(QApplication.translate('Message', 'playback by time'))
                                    elif value_int == 2:
                                        self.qmc.replayType = 1
                                        self.qmc.backgroundPlaybackEvents = True
                                        self.sendmessage(QApplication.translate('Message', 'playback by BT'))
                                    elif value_int == 3:
                                        self.qmc.replayType = 2
                                        self.qmc.backgroundPlaybackEvents = True
                                        self.sendmessage(QApplication.translate('Message', 'playback by ET'))
                                    self.updatePlaybackIndicatorSignal.emit()
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # openProperties : open Roast Properties dialog
                            elif cs == 'openProperties':
                                self.openPropertiesSignal.emit()
                            # popup(<m>[,<t>]) with <m> the message and <t> the optional timeout in seconds
                            # message can be a quoted string or just a sequence of characters
                            elif cs.startswith('popup(') and cs.endswith(')'):
                                try:
                                    # quoted string message
                                    values = cs[len('popup('):-1].split(',')
                                    message = str(eval(values[0]))  # pylint: disable=eval-used
                                    timeout = 0
                                    if len(values) > 1:
                                        timeout = int(eval(values[1]))  # pylint: disable=eval-used
                                    self.qmc.showAlarmPopupSignal.emit(message, timeout)
                                except Exception:  # pylint: disable=broad-except
                                    # sequence of character message
                                    try:
                                        message = str(values[0])
                                        timeout = 0
                                        if len(values) > 1:
                                            timeout = int(eval(values[1]))  # pylint: disable=eval-used
                                        self.qmc.showAlarmPopupSignal.emit(message, timeout)
                                    except Exception as e:  # pylint: disable=broad-except
                                        _log.exception(e)
                            # message(<m>) with <m> the message
                            elif cs.startswith('message(') and cs.endswith(')'):
                                try:
                                    message = str(eval(cs[len('message('):-1]))  # pylint: disable=eval-used
                                    self.sendmessageSignal.emit(message, True, None)
                                except Exception:  # pylint: disable=broad-except
                                    try:
                                        message = cs[len('message('):-1]
                                        self.sendmessageSignal.emit(message, True, None)
                                    except Exception as e:  # pylint: disable=broad-except
                                        _log.exception(e)
                            # notify(<t>[,<m>) with <t> the title of the notification and <m> an optional message
                            elif cs.startswith('notify(') and cs.endswith(')'):
                                try:
                                    cs_split = cs[len('notify('):-1].split(',')
                                    try:
                                        title = str(eval(cs_split[0]))  # pylint: disable=eval-used
                                    except Exception:  # pylint: disable=broad-except
                                        title = str(cs_split[0])
                                    message = ''
                                    if len(cs_split) > 1:
                                        try:
                                            message = str(eval(cs_split[1]))  # pylint: disable=eval-used
                                        except Exception:  # pylint: disable=broad-except
                                            message = str(cs_split[1])
                                    self.sendnotificationMessageSignal.emit(title, message,
                                                                            NotificationType.ARTISAN_USER)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # notifications(<bool>) enable/disable notifications
                            elif cs.startswith('notifications(') and cs.endswith(')'):
                                try:
                                    if self.notificationManager:
                                        value_str = cs[len('notifications('):-1]
                                        if value_str.lower() in {'yes', 'true', 't', '1'}:
                                            self.notificationsSetEnabledSignal.emit(True)
                                            self.sendmessage(QApplication.translate('Message', 'Notifications on'))
                                        else:
                                            self.notificationsSetEnabledSignal.emit(False)
                                            self.sendmessage(QApplication.translate('Message', 'Notifications off'))
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # setCanvasColor(<c>) with <c> the color in RGB-hex format like #ae12f7
                            elif cs.startswith('setCanvasColor(') and cs.endswith(')'):
                                try:
                                    color = str(eval(cs[len('setCanvasColor('):-1]))  # pylint: disable=eval-used
                                    self.setCanvasColorSignal.emit(color)
                                    self.sendmessage(f'Artisan Command: {cs}')
                                except Exception:  # pylint: disable=broad-except
                                    try:
                                        color = cs[len('setCanvasColor('):-1].strip()
                                        self.setCanvasColorSignal.emit(color)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                    except Exception as e:  # pylint: disable=broad-except
                                        _log.exception(e)
                            # resetCanvasColor()
                            elif cs == 'resetCanvasColor':
                                try:
                                    self.resetCanvasColorSignal.emit()
                                    self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)

                            ##  visible(<i>,<b>) : sets the visibility of <button> visible
                            #        (visibility=ON) if value b is yes, true, t, or 1, otherwise to hidden (visibility=OFF)
                            elif cs.startswith('visible'):
                                try:
                                    cs_aac = eval(cs[len('visible'):])  # pylint: disable=eval-used
                                except Exception:  # pylint: disable=broad-except
                                    arg = cs[len('visible('):-1]
                                    if ',' in arg and '(' not in arg:
                                        # no function definition in arg, and exactly on comma, we split into the two args (could be just "button(1,false)" which does not eval above)
                                        cs_aac = [a.strip() for a in arg.split(',')]
                                    else:
                                        cs_aac = [c[len('button('):-1].strip()]
                                if isinstance(cs_aac, (list, tuple)):
                                    cs_len = len(cs_aac)
                                    if cs_len == 2:
                                        ci = max(0, toInt(cs_aac[0]) - 1)
                                        vb = toBool(cs_aac[1])
                                        if len(self.extraeventsvisibility) > ci:
                                            self.extraeventsvisibility[ci] = (1 if vb else 0)
                                            self.updateExtraEventButtonsVisibilitySignal.emit()
                                            self.realignButtonsSignal.emit()

                            # button(<e>) with <e> one of { ON, START, CHARGE, DRY, FCs, FCe, SCs, SCe, DROP, COOL, OFF }
                            elif cs.startswith('button(') and cs.endswith(')'):
                                try:
                                    try:
                                        cs_ac = eval(cs[len('button'):])  # pylint: disable=eval-used
                                    except Exception:  # pylint: disable=broad-except
                                        arg = cs[len('button('):-1]
                                        if ',' in arg and '(' not in arg:
                                            # no function definition in arg, and exactly on comma, we split into the two args (could be just "button(1,false)" which does not eval above)
                                            cs_ac = [a.strip() for a in arg.split(',')]
                                        else:
                                            cs_ac = [cs[len('button('):-1].strip()]
                                    cs_len = 1
                                    if isinstance(cs_ac, (list, tuple)):
                                        cs_len = len(cs_ac)
                                    else:
                                        cs_ac = [cs_ac]
                                    if cs_len > 1:
                                        # just set the button style of the indicated button
                                        b = toInt(cs_ac[0]) - 1  # gui button list is indexed from 1
                                        bv = toBool(cs_ac[1])
                                        if 0 <= b < len(self.buttonlist):
                                            # block resetting style of last button
                                            self.lastbuttonpressed = -1
                                            if bv:
                                                self.buttonStates[b] = 1
                                                self.setExtraEventButtonStyleSignal.emit(b, 'pressed')
                                            else:
                                                self.buttonStates[b] = 0
                                                self.setExtraEventButtonStyleSignal.emit(b, 'normal')
                                    elif cs_len > 0:
                                        event = cs_ac[0]
                                        if event == 'ON' and not self.qmc.flagon:
                                            # self.lastbuttonpressed = -1 # action triggers reset which resets all button states
                                            self.qmc.toggleMonitorSignal.emit()
                                        elif event == 'START' and not self.qmc.flagstart:
                                            # self.lastbuttonpressed = -1 # action triggers reset which resets all button states
                                            self.qmc.toggleRecorderSignal.emit()
                                        elif event == 'CHARGE':
                                            self.qmc.markChargeDelaySignal.emit(0)
                                        elif event == 'DRY':
                                            self.qmc.markDRYSignal.emit(False)
                                        elif event == 'FCs':
                                            self.qmc.markFCsSignal.emit(False)
                                        elif event == 'FCe':
                                            self.qmc.markFCeSignal.emit(False)
                                        elif event == 'SCs':
                                            self.qmc.markSCsSignal.emit(False)
                                        elif event == 'SCe':
                                            self.qmc.markSCeSignal.emit(False)
                                        elif event == 'DROP':
                                            self.qmc.markDropSignal.emit(False)
                                        elif event == 'COOL':
                                            self.qmc.markCoolSignal.emit(False)
                                        elif event == 'OFF' and self.qmc.flagon:
                                            self.qmc.toggleMonitorSignal.emit()
                                        else:
                                            bv = toBool(event)
                                            if len(self.buttonlist) > lastbuttonpressed > -1:
                                                # block resetting style of last button
                                                self.lastbuttonpressed = -1
                                                self.buttonStates[lastbuttonpressed] = int(bv)
                                                if bv:
                                                    self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed,
                                                                                             'pressed')
                                                else:
                                                    self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed,
                                                                                             'normal')
                                    elif len(self.buttonlist) > lastbuttonpressed > -1:
                                        self.lastbuttonpressed = -1  # block resetting style of last button
                                        if self.buttonStates[lastbuttonpressed]:
                                            self.buttonStates[lastbuttonpressed] = 0
                                            self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'normal')
                                        else:
                                            self.buttonStates[lastbuttonpressed] = 1
                                            self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'pressed')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)

                            # p-i-d(<p>,<i>,<d>) with <p>, <i>, <d> numbers to set the p-i-d parameters
                            elif cs.startswith('p-i-d(') and cs.endswith(')'):
                                try:
                                    args = cs[len('p-i-d('):-1].split(',')
                                    if len(args) == 3:
                                        kp = float(args[0])
                                        ki = float(args[1])
                                        kd = float(args[2])
                                        # FUJI/DELTA pid
                                        if self.qmc.device in {0, 26}:
                                            # set-p-i-d currently only set from dialog
                                            if self.ser.controlETpid[0] == 0:  # PXG
                                                # 1. get current PID
                                                N = self.fujipid.getCurrentPIDnumberPXG()
                                                if N != -1:
                                                    # 2. call setpid(self,k) with k that active pid
                                                    self.fujipid.setpidPXG(N, kp, ki, kd)
                                                    self.sendmessage(f'Artisan Command: {cs}')
                                            elif self.ser.controlETpid[0] == 1:  # PRG
                                                self.fujipid.setpidPXR('p', kp)
                                                libtime.sleep(0.035)
                                                self.fujipid.setpidPXR('i', ki)
                                                libtime.sleep(0.035)
                                                self.fujipid.setpidPXR('d', kd)
                                                self.sendmessage(f'Artisan Command: {cs}')
                                            elif self.ser.controlETpid[0] == 4:  # PXF
                                                # 1. get current PID
                                                N = self.fujipid.getCurrentPIDnumberPXF()
                                                if N != -1:
                                                    # 2. call setpid(self,k) with k that active pid
                                                    self.fujipid.setpidPXF(N, kp, ki, kd)
                                                    self.sendmessage(f'Artisan Command: {cs}')
                                        else:
                                            self.pidcontrol.confPID(kp, ki, kd, pOnE=self.pidcontrol.pOnE)
                                            self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # pidSVC(<n>) with <n> a number in C to be used as PID SV (if temperature mode is F, n will be first converted to F
                            elif cs.startswith('pidSVC(') and cs.endswith(')'):
                                try:
                                    sv = max(0, int(round(convertTemp(float(eval(cs[len('pidSVC('):-1])), 'C',
                                                                      self.qmc.mode))))  # we don't send SV < 0 # pylint: disable=eval-used
                                    if self.qmc.device == 0 and sv != self.fujipid.sv:
                                        self.fujipid.setsv(sv, silent=True)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                    elif sv != self.pidcontrol.sv:
                                        self.pidcontrol.setSV(sv, init=False)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # pidSV(<n>) with <n> a number to be used as PID SV
                            elif cs.startswith('pidSV(') and cs.endswith(')'):
                                try:
                                    sv = max(0, int(eval(
                                        cs[len('pidSV('):-1])))  # we don't send SV < 0 # pylint: disable=eval-used
                                    if self.qmc.device == 0 and sv != self.fujipid.sv:
                                        self.fujipid.setsv(sv, silent=True)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                    elif sv != self.pidcontrol.sv:
                                        self.pidcontrol.setSV(sv, init=False)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # pidRS(<n>) with <n> a number to be used to select the PID RS pattern (1-based for the internal software PID)
                            elif cs.startswith('pidRS(') and cs.endswith(')'):
                                try:
                                    rs = int(eval(cs[len('pidRS('):-1]))  # pylint: disable=eval-used
                                    if self.qmc.device in {0, 26}:
                                        if self.ser.controlETpid[0] == 0:  # PXG
                                            pass
                                        elif self.ser.controlETpid[0] == 1:  # PRG
                                            pass
                                        elif self.ser.controlETpid[0] == 4:  # PXF
                                            pass
                                    elif rs > 0:
                                        self.pidcontrol.setRSpattern(rs - 1)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                except Exception:  # pylint: disable=broad-except
                                    # might be a label
                                    try:
                                        label = str(eval(cs[len('pidRS('):-1]))  # pylint: disable=eval-used
                                        rs2 = self.pidcontrol.findRSset(label)  # here rs is 0-based!!
                                        if rs2 is not None:
                                            self.pidcontrol.setRSpattern(rs2)
                                            self.sendmessage(f'Artisan Command: {cs}')
                                    except Exception as e:  # pylint: disable=broad-except
                                        _log.exception(e)
                            # pidSource(<n>) with <n> 0: BT, 1: ET (Artisan internal software PID); <n> in {0,..,3} (Arduino PID)
                            elif cs.startswith('pidSource(') and cs.endswith(')'):
                                try:
                                    source = int(cs[len('pidSource('):-1]) + 1  # internally pidSource counts from 1
                                    if self.qmc.device not in (0, 26):
                                        kp = self.pidcontrol.pidKp
                                        ki = self.pidcontrol.pidKi
                                        kd = self.pidcontrol.pidKd
                                        self.pidcontrol.confPID(kp, ki, kd, pOnE=self.pidcontrol.pOnE, source=source)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # palette(<n>) with <n> a number between 0 and 9 or an existing palette label
                            elif cs.startswith('palette(') and cs.endswith(')'):
                                try:
                                    p = min(9, max(0, int(cs[len('palette('):-1])))
                                    self.setbuttonsfromSignal.emit(p)
                                    self.sendmessage(f'Artisan Command: {cs}')
                                except Exception:  # pylint: disable=broad-except
                                    # might be a label
                                    try:
                                        label = str(eval(cs[len('palette('):-1]))  # pylint: disable=eval-used
                                        pl = self.findPalette(label)
                                        if pl is not None:
                                            self.setbuttonsfromSignal.emit(pl)
                                            self.sendmessage(f'Artisan Command: {cs}')
                                    except Exception as e:  # pylint: disable=broad-except
                                        _log.exception(e)
                            # loadBackground(<filepath>)
                            elif cs.startswith('loadBackground(') and cs.endswith(')'):
                                try:
                                    try:
                                        # note we use here c instead of cs as we do not want _ or $ symbols to be substituted here
                                        fp = str(eval(c[len('loadBackground('):-1]))  # pylint: disable=eval-used
                                    except Exception:  # pylint: disable=broad-except
                                        fp = str(cs[len('loadBackground('):-1])
                                    self.loadBackgroundSignal.emit(fp)
                                    self.sendmessage(f'Artisan Command: {c}')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # clearBackground
                            elif cs == 'clearBackground':
                                try:
                                    self.clearBackgroundSignal.emit()
                                    self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # alarmset(<n>) with <n> a number between 0 and 9 or an existing alarmset label
                            elif cs.startswith('alarmset(') and cs.endswith(')'):
                                try:
                                    p = min(9, max(0, int(cs[len('alarmset('):-1])))
                                    self.qmc.alarmsetSignal.emit(p)
                                    self.sendmessage(f'Artisan Command: {cs}')
                                except Exception:  # pylint: disable=broad-except
                                    # might be a label
                                    try:
                                        label = str(eval(cs[len('alarmset('):-1]))  # pylint: disable=eval-used
                                        pp: Optional[int] = self.qmc.findAlarmSet(label)
                                        if pp is not None:
                                            self.qmc.alarmsetSignal.emit(pp)
                                            self.sendmessage(f'Artisan Command: {cs}')
                                    except Exception as e:  # pylint: disable=broad-except
                                        _log.exception(e)
                            # adjustSV(<n>) adds <n> to the current SV. Note that n can be negative
                            elif cs.startswith('adjustSV(') and cs.endswith(')'):
                                try:
                                    sv_offset = int(eval(cs[len('adjustSV('):-1]))  # pylint: disable=eval-used
                                    if self.qmc.device != 26:  # not for DTA
                                        self.adjustSVSignal.emit(sv_offset)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # moveBackground(<direction>,<step>) with <direction> one of up,down,left,right and <step> the length of the move
                            elif cs.startswith('moveBackground(') and cs.endswith(')'):
                                try:
                                    args = cs[len('moveBackground('):-1].split(',')
                                    if len(args) == 2:
                                        direction = args[0].lower()
                                        if len(direction) > 3 and direction[0] in {'"', "'"} and direction[-1] in {'"',
                                                                                                                   "'"}:
                                            direction = eval(direction)  # pylint: disable=eval-used
                                        step = int(args[1])
                                        self.qmc.moveBackgroundSignal.emit(direction, step)
                                        self.sendmessage(f'Artisan Command: {cs}')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # pidLookahead(<n>) adds <n> to the current SV. Note that n can be negative
                            elif cs.startswith('pidLookahead(') and cs.endswith(')'):
                                try:
                                    lookahead = toInt(eval(cs[len('pidLookahead('):-1]))  # pylint: disable=eval-used
                                    if self.qmc.device == 0 and self.fujipid and self.qmc.Controlbuttonflag:  # FUJI PID
                                        self.fujipid.lookahead = lookahead
                                        self.sendmessage(QApplication.translate('Message', 'PID Lookahead: {0}').format(
                                            self.fujipid.lookahead))
                                    elif (self.pidcontrol and self.qmc.Controlbuttonflag):  # MODBUS hardware PID
                                        self.pidcontrol.svLookahead = lookahead
                                        self.sendmessage(QApplication.translate('Message', 'PID Lookahead: {0}').format(
                                            self.pidcontrol.svLookahead))
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # keyboard(<bool>) enable/disable keyboard mode
                            elif cs.startswith('keyboard(') and cs.endswith(')'):
                                try:
                                    value_str = cs[len('keyboard('):-1]
                                    if ((value_str.lower() in {'yes', 'true', 't',
                                                               '1'} and self.qmc.flagstart and self.keyboardmoveflag == 0) or
                                            (value_str.lower() not in (
                                                    'yes', 'true', 't', '1') and self.keyboardmoveflag == 1)):
                                        self.moveButtonSignal.emit('enter')
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # keepON(<bool>) enable/disable Keep ON mode
                            elif cs.startswith('keepON(') and cs.endswith(')'):
                                try:
                                    value_str = cs[len('keepON('):-1]
                                    if value_str.lower() in {'yes', 'true', 't', '1'}:
                                        self.qmc.flagKeepON = True
                                        self.sendmessage(QApplication.translate('Message', 'Keep ON enabled'))
                                    else:
                                        self.qmc.flagKeepON = False
                                        self.sendmessage(QApplication.translate('Message', 'Keep ON disable'))
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # showCurve(<name>, <bool>) with <name> one of { ET, BT, DeltaET, DeltaBT, BackgroundET, BackgroundBT}
                            elif cs.startswith('showCurve(') and cs.endswith(')'):
                                try:
                                    args = cs[len('showCurve('):-1].split(',')
                                    if len(args) == 2:
                                        curve_name = args[0]
                                        state = toBool(eval(args[1]))  # pylint: disable=eval-used
                                        self.qmc.showCurveSignal.emit(curve_name, state)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # showExtraCurve(<extra_device>, <curve>, <bool>) with <extra_device> zero-based number of extra device, curve one of { T1, T2 }
                            elif cs.startswith('showExtraCurve(') and cs.endswith(')'):
                                try:
                                    args = cs[len('showExtraCurve('):-1].split(',')
                                    if len(args) == 3:
                                        extra_device = int(args[0])
                                        curve = args[1]
                                        state = toBool(eval(args[2]))  # pylint: disable=eval-used
                                        self.qmc.showExtraCurveSignal.emit(extra_device, curve, state)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # showEvents(<event>, <bool>) with <event_type> a number from [1, 5]
                            elif cs.startswith('showEvents(') and cs.endswith(')'):
                                try:
                                    args = cs[len('showEvents('):-1].split(',')
                                    if len(args) == 2:
                                        event_type = int(args[0])
                                        state = toBool(eval(args[1]))  # pylint: disable=eval-used
                                        self.qmc.showEventsSignal.emit(event_type, state)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # showBackgroundEvents(<bool>)
                            elif cs.startswith('showBackgroundEvents(') and cs.endswith(')'):
                                try:
                                    args = cs[len('showBackgroundEvents('):-1].split(',')
                                    if len(args) == 1:
                                        state = toBool(eval(args[0]))  # pylint: disable=eval-used
                                        self.qmc.showBackgroundEventsSignal.emit(state)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('Artisan Command <%s> not recognized', cs)
                elif action == 21:  # RC Command
                    # PHIDGETS   sn : has the form <hub_serial>[:<hub_port>], an optional serial number of the hub, optionally specifying the port number the module is connected to
                    ##  pulse(ch,min,max[,sn]) : sets the min/max pulse width in microseconds
                    ##  pos(ch,min,max[,sn]) : sets the min/max position
                    ##  engaged(ch,b[,sn]) : engage (b=1) or disengage (b = 0)
                    ##  ramp(ch,b[,sn]) : activates or deactivates the speed ramping state
                    ##  volt(ch,v[,sn]) : set the voltage to one of 5, 6 or 7.4 in Volt
                    ##  accel(ch,a[,sn]) : set the acceleration
                    ##  veloc(ch,v[,sn]) : set the velocity
                    ##  set(ch,pos[,sn]) : set the target position
                    #
                    # YOCTOPUCE
                    #
                    ## enabled(c,b[,sn])
                    ## move(c,p[,t][,sn])
                    ## neutral(c,n[,sn])
                    ## range(c,r[,sn])
                    ##

                    if cmd_str:
                        cmds = filter(None, cmd_str.split(
                            ';'))  # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                        for c in cmds:
                            cs = c.strip()
                            # pulse(ch,min,max[,sn]) # sets min/max pulse width
                            if cs.startswith('pulse(') and len(cs) > 11:
                                try:
                                    n = 3
                                    cs_split = cs[len('pulse('):-1].split(',')
                                    channel_str, min_pulse, max_pulse = cs_split[0:n]
                                    if len(cs_split) > n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    self.ser.phidgetRCpulse(int(channel_str), int(min_pulse), int(max_pulse), sn)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('pos(') and len(cs) > 9:
                                # pos(ch,min,max[,sn]) # sets min/max position
                                try:
                                    n = 3
                                    cs_split = cs[len('pos('):-1].split(',')
                                    channel_str, min_pos, max_pos = cs_split[0:n]
                                    if len(cs_split) > n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    self.ser.phidgetRCpos(int(channel_str), float(min_pos), float(max_pos), sn)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('engaged(') and len(cs) > 11:
                                # engaged(ch,state[,sn]) # engage channel
                                try:
                                    n = 2
                                    cs_split = cs[len('engaged('):-1].split(',')
                                    channel_str, state_str = cs_split[0:n]
                                    if len(cs_split) > n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    state_engaged: bool = bool(state_str.lower() in {'yes', 'true', 't', '1'})
                                    self.ser.phidgetRCengaged(int(channel_str), state_engaged, sn)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('set(') and len(cs) > 7:
                                # set(ch,pos[,sn]) # set position
                                try:
                                    n = 2
                                    cs_split = cs[len('set('):-1].split(',')
                                    channel_str, pos = cs_split[0:n]
                                    if len(cs_split) > n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    self.ser.phidgetRCset(int(channel_str), toFloat(eval(pos)),
                                                          sn)  # pylint: disable=eval-used
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('ramp(') and len(cs) > 8:
                                # ramp(ch,state) # set speed ramping state per channel
                                try:
                                    n = 2
                                    # cs_split = s[len('ramp('):-1].split(',')
                                    channel_str, state_str = cs_split[0:n]
                                    if len(cs_split) > n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    state_ramp: bool = bool(state_str.lower() in {'yes', 'true', 't', '1'})
                                    self.ser.phidgetRCspeedRamping(int(channel_str), state_ramp, sn)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('volt(') and len(cs) > 8:
                                # volt(ch,v) # sets voltage
                                try:
                                    n = 2
                                    cs_split = cs[len('volt('):-1].split(',')
                                    channel_str, volt = cs_split[0:n]
                                    if len(cs_split) > n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    self.ser.phidgetRCvoltage(int(channel_str), float(volt), sn)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('accel(') and len(cs) > 9:
                                # accel(ch,accel) # sets acceleration
                                try:
                                    n = 2
                                    cs_split = cs[len('accel('):-1].split(',')
                                    channel_str, accel = cs_split[0:n]
                                    if len(cs_split) > n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    self.ser.phidgetRCaccel(int(channel_str), float(accel), sn)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('veloc(') and len(cs) > 9:
                                # veloc(ch,veloc) # sets velocity
                                try:
                                    n = 2
                                    cs_split = cs[len('veloc('):-1].split(',')
                                    channel_str, veloc = cs_split[0:n]
                                    if len(cs_split) > n:
                                        sn = cs_split[n]
                                    else:
                                        sn = None
                                    self.ser.phidgetRCveloc(int(channel_str), float(veloc), sn)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            elif cs.startswith('sleep('):  # in seconds
                                try:
                                    cmds = eval(cs[len('sleep'):])  # pylint: disable=eval-used
                                    if isinstance(cmds, (float, int)):
                                        # cmd has format "sleep(xx.yy)"
                                        libtime.sleep(cmds)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)

                            # functions supporting the Yoctopuce RC module
                            # enabled(c,b[,sn]) with c:int the channel, b a bool (eg. enabled(0,1) or enabled(0,True)), sn the optional modules serial number or logical name
                            elif cs.startswith('enabled(') and len(cs) > 11:
                                try:
                                    cs_split = cs[8:-1].split(',')
                                    cv = int(cs_split[0])
                                    b = toBool(eval(cs_split[1]))  # pylint: disable=eval-used
                                    if len(cs_split) > 2:
                                        sn = cs_split[2]
                                        self.ser.yoctoSERVOenabled(cv, b, sn)
                                    else:
                                        self.ser.yoctoSERVOenabled(cv, b)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # move(c,p[,t][,sn]) with c:int the channel, p:int the target position, the optional t the duration in ms, sn the optional modules serial number or logical name
                            elif cs.startswith('move(') and len(cs) > 8:
                                try:
                                    cs_split = cs[5:-1].split(',')
                                    cv = int(cs_split[0])
                                    p = toInt(eval(cs_split[1]))  # pylint: disable=eval-used
                                    if len(cs_split) > 2:
                                        try:
                                            t = int(cs_split[2])
                                            if len(cs_split) > 3:
                                                self.ser.yoctoSERVOmove(cv, p, t, cs_split[3])
                                            else:
                                                self.ser.yoctoSERVOmove(cv, p, t)
                                        except Exception:  # pylint: disable=broad-except
                                            self.ser.yoctoSERVOposition(cv, p, cs_split[2])
                                    else:
                                        self.ser.yoctoSERVOposition(cv, p)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # neutral(c,n[,sn]) with n an int [0..65000] in us, sn the modules serial number or logical name
                            elif cs.startswith('neutral(') and len(cs) > 11:
                                try:
                                    cs_split = cs[8:-1].split(',')
                                    cv = int(cs_split[0])
                                    n = int(cs_split[1])
                                    if len(cs_split) > 2:
                                        sn = cs_split[1]
                                        self.ser.yoctoSERVOneutral(cv, n, sn)
                                    else:
                                        self.ser.yoctoSERVOneutral(cv, n)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            # range(c,r[,sn]) with r an int in %, sn the modules serial number or logical name
                            elif cs.startswith('range(') and len(cs) > 8:
                                try:
                                    cs_split = cs[6:-1].split(',')
                                    cv = int(cs_split[0])
                                    r = int(cs_split[1])
                                    if len(cs_split) > 2:
                                        sn = cs_split[1]
                                        self.ser.yoctoSERVOrange(cv, r, sn)
                                    else:
                                        self.ser.yoctoSERVOrange(cv, r)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                            else:
                                # command not recognized
                                _log.info('RC Command <%s> not recognized', cs)
                elif action == 22 and cmd_str:  # WebSocket Command
                    # send(<json>)
                    # sleep(xx.yy)  with xx.yy sleep time in seconds
                    # button(<b>)
                    # read(request) request is a JSON request in brackets; full JSON response is bound to _
                    cmds = filter(None, cmd_str.split(
                        ';'))  # allows for sequences of commands like in "<cmd>;<cmd>;...;<cmd>"
                    for c in cmds:
                        cs = c.strip()
                        if self.ws.lastReadResult is not None:
                            cs = cs.replace('_',
                                            str(self.ws.lastReadResult))  # the last read value can be accessed via the "_" symbol

                        # $ is substituted by the state of the current button (1:pressed, 0:normal)
                        last = 0  # defaults to 0
                        if lastbuttonpressed != -1 and len(self.buttonlist) > lastbuttonpressed:
                            last = self.buttonStates[lastbuttonpressed]
                        cs = cs.replace('$', str(last))

                        # send(<json>) : send <json> request to connected WebSocket
                        if cs.startswith('send') and cs.endswith(')'):
                            try:
                                request = eval(cs[len('send('):-1])  # pylint: disable=eval-used
                                self.ws.send(request, block=False)
                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                        elif cs.startswith('sleep') and cs.endswith(')'):  # in seconds
                            try:
                                cmds = eval(cs[len('sleep'):])  # pylint: disable=eval-used
                                if isinstance(cmds, (float, int)):
                                    # cmd has format "sleep(xx.yy)"
                                    libtime.sleep(cmds)
                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                        elif cs.startswith('read'):
                            try:
                                request = eval(cs[len('read'):])  # pylint: disable=eval-used
                                if isinstance(request, dict):
                                    # cmd has format "read(<requestJSON>)"
                                    self.ws.lastReadResult = self.ws.send(request)
                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                        elif cs.startswith('button'):
                            # cmd has format "button(<bool>)" # 0 or 1 or True or False
                            try:
                                try:
                                    args = eval(cs[len('button'):])  # pylint: disable=eval-used
                                except Exception:  # pylint: disable=broad-except
                                    arg = cs[len('button('):-1]
                                    if ',' in arg and '(' not in arg:
                                        # no function definition in arg, and exactly on comma, we split into the two args (could be just "button(1,false)" which does not eval above)
                                        cs_a = [a.strip() for a in arg.split(',')]
                                    else:
                                        args = [c[len('button('):-1].strip()]  # just a tag like True would fail to eval
                                cs_len = 1
                                if isinstance(args, (list, tuple)):
                                    cs_len = len(args)
                                else:
                                    args = [args]
                                last = self.lastbuttonpressed
                                if cs_len > 1:
                                    # just set the button style of the indicated button
                                    b = toInt(args[0]) - 1  # gui button list is indexed from 1
                                    bv = toBool(args[1])
                                    if 0 <= b < len(self.buttonlist):
                                        # block resetting style of last button
                                        self.lastbuttonpressed = -1
                                        if bv:
                                            self.buttonStates[b] = 1
                                            self.setExtraEventButtonStyleSignal.emit(b, 'pressed')
                                        else:
                                            self.buttonStates[b] = 0
                                            self.setExtraEventButtonStyleSignal.emit(b, 'normal')
                                elif cs_len > 0:
                                    bv = toBool(args[0])
                                    if last != -1 and len(self.buttonlist) > last:
                                        # block resetting style of last button
                                        self.lastbuttonpressed = -1
                                        self.buttonStates[lastbuttonpressed] = int(bv)
                                        if bv:
                                            self.setExtraEventButtonStyleSignal.emit(last, 'pressed')
                                        else:
                                            self.setExtraEventButtonStyleSignal.emit(last, 'normal')
                                elif len(self.buttonlist) > lastbuttonpressed > -1:
                                    self.lastbuttonpressed = -1  # block resetting style of last button
                                    if self.buttonStates[lastbuttonpressed]:
                                        self.buttonStates[lastbuttonpressed] = 0
                                        self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'normal')
                                    else:
                                        self.buttonStates[lastbuttonpressed] = 1
                                        self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'pressed')
                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                        else:
                            # command not recognized
                            _log.info('WebSocket Command <%s> not recognized', cs)
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)

    @staticmethod
    @functools.lru_cache(maxsize=None)  # for Python >= 3.9 can use @functools.cache
    def calc_env() -> Dict[str, str]:
        # we try to set the users standard environment, replacing the one pointing to the restrictive python build in Artisan
        my_env = os.environ.copy()
        try:
            for v in ['PYTHONHOME', 'PYTHONPATH', 'LD_LIBRARY_PATH']:
                if v in my_env:
                    del my_env[v]
            # try to source users environment to make external Python scripts run in their "natural" env
            if platform.system() in {'Darwin', 'Linux'}:
                command = ['bash', '-c', 'source ~/.bash_profile ~/.bash_login ~/.profile 2>/dev/null && env']
                try:
                    from subprocess import Popen as subprocessPopen, PIPE as subprocessPIPE  # @Reimport
                    with subprocessPopen(command, stdout=subprocessPIPE) as proc:
                        if proc.stdout is not None:
                            for line in proc.stdout:
                                value: str
                                k: str
                                if isinstance(line, bytes):
                                    (kb, _, valueb) = line.partition(b'=')
                                    k = kb.decode('UTF-8')
                                    value = valueb.decode('UTF-8')
                                    #                                else: # this branch is most likely never reached
                                    #                                    (k, _, value) = line.partition('=') # pyright: ignore [reportGeneralTypeIssues] # "Never" is not iterable
                                    # don't copy PYTHONHOME nor PYTHONPATH if it points to the Artisan.app
                                    if not ((k in {'PYTHONHOME', 'PYTHONPATH'}) and (
                                            ('Artisan.app' in value) or 'artisan' in value)):
                                        my_env[k] = value.rstrip('\n')
                            proc.communicate()
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        _log.debug('my_env: %s', my_env)
        return my_env

    @staticmethod
    def re_split(s: str) -> List[str]:
        def strip_quotes(s: str) -> str:
            if s and s[0] in {'"', "'"} and s[0] == s[-1]:
                return s[1:-1]
            return s

        return [strip_quotes(p).replace('\\"', '"').replace("\\'", "'") for p in
                re.findall(r'"(?:\\.|[^"])*"|\'(?:\\.|[^\'])*\'|[^\s]+', s)]

    # dummy ' for syntax parsers confused by odd numbers of quotes

    def call_prog_with_args(self, cmd_str: str) -> None:
        #        cmd_str_parts = cmd_str.split(" ") # does split quoted strings ('this "is a" test' => ['this','"is','a"','test'])
        cmd_str_parts = self.re_split(
            cmd_str)  # this preserves quoted strings ('this "is a" test' => ['this','is a','test'])
        if len(cmd_str_parts) > 0:
            try:
                import subprocess  # @Reimport
                cmd = cmd_str_parts[0].strip()
                qd = QDir(cmd)
                current = QDir.current()
                QDir.setCurrent(getAppPath())
                my_env = self.calc_env()
                if platform.system() == 'Windows':
                    startupinfo = subprocess.STARTUPINFO()  # type:ignore[unused-ignore,attr-defined]
                    try:
                        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW  # type:ignore[unused-ignore,attr-defined]
                    except AttributeError:
                        try:
                            startupinfo.dwFlags |= subprocess._subprocess.STARTF_USESHOWWINDOW  # type: ignore # @UndefinedVariable # pylint: disable=maybe-no-member # pylint: disable=protected-access
                        except AttributeError:
                            pass
                    prg_file = str(qd.absolutePath())
                    #                    CREATE_NEW_PROCESS_GROUP = 0x00000200
                    #                    DETACHED_PROCESS = 0x00000008
                    # subprocess.Popen([prg_file] + [x.strip() for x in cmd_str_parts[1:]], shell=False,env=my_env)
                    subprocess.Popen([prg_file] + [x.strip() for x in cmd_str_parts[1:]],
                                     # pylint: disable=consider-using-with
                                     startupinfo=startupinfo,
                                     #                        creationflags=DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP, # with this the process ends before sleep
                                     #                        close_fds=True, # this seems not to change a thing
                                     env=my_env,
                                     stdin=None,
                                     # suppress output:
                                     stdout=subprocess.DEVNULL,
                                     stderr=subprocess.STDOUT
                                     )  # .wait() # with this wait(), the script blocks the Artisan event loop
                else:
                    subprocess.Popen(os.path.expanduser(cmd_str),  # pylint: disable=consider-using-with
                                     shell=True,
                                     close_fds=True,
                                     env=my_env,
                                     stdin=None,
                                     # suppress output:
                                     stdout=subprocess.DEVNULL,
                                     stderr=subprocess.STDOUT)
                QDir.setCurrent(current.absolutePath())
                # alternative approach, that seems to fail on some Mac OS X versions:
                # QProcess.startDetached(prg_file)
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)

    def sliderpos(self, n: int) -> float:
        if n == 0:
            return self.slider1.value()
        if n == 1:
            return self.slider2.value()
        if n == 2:
            return self.slider3.value()
        return self.slider4.value()

    # n=0 : slider1; n=1 : slider2; n=2 : slider3; n=3 : slider4
    # updates corresponding eventslidervalues
    def moveslider(self, n: int, v: float, forceLCDupdate: bool = False) -> None:
        v = min(max(int(round(v)), self.eventslidermin[n]), self.eventslidermax[n])
        self.eventslidervalues[n] = v
        # first update slider LCDs if needed
        if n == 0 and (forceLCDupdate or self.slider1.value() != v):
            self.updateSliderLCD(0, v)
        elif n == 1 and (forceLCDupdate or self.slider2.value() != v):
            self.updateSliderLCD(1, v)
        elif n == 2 and (forceLCDupdate or self.slider3.value() != v):
            self.updateSliderLCD(2, v)
        elif n == 3 and (forceLCDupdate or self.slider4.value() != v):
            self.updateSliderLCD(3, v)
        # now move sliders to actual values if needed
        if n == 0 and self.slider1.value() != v:
            self.slider1.setValue(v)
        elif n == 1 and self.slider2.value() != v:
            self.slider2.setValue(v)
        elif n == 2 and self.slider3.value() != v:
            self.slider3.setValue(v)
        elif n == 3 and self.slider4.value() != v:
            self.slider4.setValue(v)

    def extraEventButtonStyle(self, tee: int, style: str = 'normal') -> str:
        left_rounded_style = 'border-radius:0px;border-top-left-radius:4px;border-bottom-left-radius:4px;'
        right_rounded_style = 'border-radius:0px;border-top-right-radius:4px;border-bottom-right-radius:4px;'
        fully_rounded_style = 'border-radius:4px;'
        square_style = 'border-radius:0px;'
        if self.buttonsize == 0:
            # tiny
            button_min_width = self.tiny_button_min_width_str
            button_font_size = self.button_font_size_micro
        elif self.buttonsize == 2:
            # large
            button_min_width = str(self.standard_button_min_width_px)
            button_font_size = self.button_font_size_small
        else:
            # small (default)
            button_min_width = self.small_button_min_width_str
            button_font_size = self.button_font_size_tiny
        ##
        rounding = square_style
        if len(self.extraeventbuttonround) > tee:
            if self.extraeventbuttonround[tee] == 1:  # left-side rounded
                rounding = left_rounded_style
            elif self.extraeventbuttonround[tee] == 2:  # right-side rounded
                rounding = right_rounded_style
            elif self.extraeventbuttonround[tee] == 3:  # both-sides rounded
                rounding = fully_rounded_style
        #
        if style == 'normal':
            color = self.extraeventbuttontextcolor[tee]
            backgroundcolor = self.extraeventbuttoncolor[tee]
        else:  # style=="pressed":
            # set color of this button to "pressed"
            color = self.extraeventbuttoncolor[tee]
            backgroundcolor = self.extraeventbuttontextcolor[tee]
        buttonstyle = f'min-width:{button_min_width};margin:0px;padding:0px;border-style:solid;border-color:darkgrey;border-width:0px;font-size:{button_font_size};font-weight:bold;{rounding}color:{color};'
        #
        plain_style = f'QPushButton {{{buttonstyle}background:{createGradient(backgroundcolor)}}}'
        pressed_style = f'QPushButton:hover:pressed {{background:{createGradient(QColor(backgroundcolor).lighter(80).name())}}}'
        hover_style = f'QPushButton:hover:!pressed {{background:{createGradient(QColor(backgroundcolor).lighter(110).name())}}}'
        return f'{plain_style}{hover_style}{pressed_style}'

    # style is one of 'pressed' or 'normal'
    @pyqtSlot(int, str)
    def setExtraEventButtonStyle(self, tee: int, style: str) -> None:
        if len(self.extraeventstypes) > tee and len(self.buttonlist) > tee:
            button_style = self.extraEventButtonStyle(tee, style)
            self.buttonlist[tee].setStyleSheet(button_style)
            self.buttonlist[tee].setText(
                self.substButtonLabel(tee, self.extraeventslabels[tee], self.extraeventstypes[tee]))

    @pyqtSlot(bool)
    def recordextraevent_slot(self, _: bool) -> None:
        try:
            sender = self.sender()
            assert isinstance(sender, QPushButton)
            self.recordextraevent(self.buttonlist.index(sender))
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    # called from user configured event buttons
    # by default actions are processed in a parallel thread, but components of multiple button actions not to avoid crashes
    def recordextraevent(self, ee: int, parallel: bool = True, updateButtons: bool = True) -> None:
        eventtype = self.extraeventstypes[ee]
        if updateButtons and self.mark_last_button_pressed:  # not if triggered from mutiplebutton actions:
            try:
                self.qmc.eventactionsemaphore.acquire(1)
                # reset color of last pressed button
                if self.lastbuttonpressed != -1 and len(self.buttonlist) > self.lastbuttonpressed:
                    self.setExtraEventButtonStyleSignal.emit(self.lastbuttonpressed, 'normal')

                # toggle button if it has nonzero state prior to toggling
                if self.buttonStates[ee] != 0:
                    self.setExtraEventButtonStyleSignal.emit(ee, 'normal')
                else:
                    self.setExtraEventButtonStyleSignal.emit(ee, 'pressed')

            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
            finally:
                if self.qmc.eventactionsemaphore.available() < 1:
                    self.qmc.eventactionsemaphore.release(1)
        # reset lastbuttonpressed
        self.lastbuttonpressed = ee
        cmdvalue = self.qmc.eventsInternal2ExternalValue(self.extraeventsvalues[ee])
        if eventtype < 4 or eventtype > 4:  ## if eventtype == 4 we have an button event of type " " that does not add an event; if eventtype == 9 ("-") we have an untyped event
            if eventtype == 9:  # an untyped event
                # we just fire the action
                # split on an octothorpe '#' that is not inside parentheses '()'
                cmd = re.split(r'\#(?![^\(]*\))', self.extraeventsactionstrings[ee])[0].strip()
                cmd = cmd.format(*(tuple([cmdvalue] * cmd.count('{}'))))
                self.eventaction(self.extraeventsactions[ee], cmd, parallel=parallel)
                # and record the event
                if self.qmc.flagstart:
                    # we use event handling to enable the doupdategraphics/doupdatebackground also if running in background thread
                    self.qmc.eventRecordSignal.emit(ee)
            else:
                # if eventtype < 4: # absolute values
                etype = eventtype
                new_value = cmdvalue
                if eventtype > 4:  # relative values for +/- actions
                    etype = eventtype - 5  # the real event type has a offset of 5 in this case
                    p = self.extraeventsactionslastvalue[etype]
                    new_value = cmdvalue if p is None else p + cmdvalue
                # limit value w.r.t. the event slider min/max specification
                new_value = min(self.eventslidermax[etype], max(self.eventslidermin[etype], new_value))

                # the new_value is combined with the event factor and offset as specified in the slider definition
                actionvalue = self.calcEventValue(etype, new_value)
                if self.extraeventsactions[ee] != 14:  # only for VOUT Commands we keep the floats
                    actionvalue = int(round(actionvalue))
                event_record: bool = True
                if self.extraeventsactions[ee] in {8, 9, 16, 17,
                                                   18}:  # for Hottop Heater/Fan/CoolingFan action we take the event value instead of the event string as cmd action
                    self.eventaction(self.extraeventsactions[ee], str(int(new_value)), parallel=parallel)
                else:
                    # split on an octothorpe '#' that is not inside parentheses '()'
                    cmd = re.split(r'\#(?![^\(]*\))', self.extraeventsactionstrings[ee])[0].strip()
                    try:
                        cmd = cmd.format(*(tuple([actionvalue] * cmd.count('{}'))))
                    except Exception:  # pylint: disable=broad-except
                        pass
                    if eventtype > 4 and cmdvalue == 0:  # relative values for +/- actions and event value is 0
                        self.eventaction(self.extraeventsactions[ee], cmd, parallel=parallel, eventtype=etype)
                        event_record = False  # we prevent recording an event here, as we assume that it will be added by the eventaction once the response is received
                    else:
                        self.eventaction(self.extraeventsactions[ee], cmd, parallel=parallel)
                # remember the new value as the last value set for this event
                self.block_quantification_sampling_ticks[etype] = self.sampling_ticks_to_block_quantifiction
                self.extraeventsactionslastvalue[etype] = new_value
                # move corresponding slider to new value:
                self.moveslider(etype, new_value)
                if self.qmc.flagstart and event_record:
                    # we use event handling to enable the doupdategraphics/doupdatebackground also if running in background thread
                    self.qmc.eventRecordSignal.emit(ee)
        else:
            # just issue the eventaction (no cmd substitution here)
            # split on an octothorpe '#' that is not inside parentheses '()'
            cmd = re.split(r'\#(?![^\(]*\))', self.extraeventsactionstrings[ee])[0].strip()
            cmd = cmd.format(*(tuple([cmdvalue] * cmd.count('{}'))))
            if cmdvalue == 0 and eventtype == 4:
                # no event type and cmdvalue is 0 => cmd actions should await response and bind result to _
                self.eventaction(self.extraeventsactions[ee], cmd, parallel=parallel, eventtype=-1)
            else:
                self.eventaction(self.extraeventsactions[ee], cmd, parallel=parallel)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resetApplication(self, _: bool = False) -> None:
        if self.app.artisanviewerMode:
            string = QApplication.translate('Message',
                                            'Do you want to reset all settings?<br> ArtisanViewer has to be restarted!')
        else:
            string = QApplication.translate('Message',
                                            'Do you want to reset all settings?<br> Artisan has to be restarted!')
        reply = QMessageBox.warning(self, QApplication.translate('Message', 'Factory Reset'), string,
                                    QMessageBox.StandardButton.Cancel | QMessageBox.StandardButton.Reset,
                                    QMessageBox.StandardButton.Cancel)
        if reply == QMessageBox.StandardButton.Reset:
            # raise flag. Next time app will open, the settings (bad settings) will not be loaded.
            self.resetqsettings = 1
            self.clearExtraDeviceSettingsBackup()
            _log.info('Factory reset')
            self.close()
        elif reply == QMessageBox.StandardButton.Cancel:
            return

    @pyqtSlot()
    @pyqtSlot(bool)
    def on_actionCut_triggered(self, _: bool = False) -> None:  # pylint: disable=no-self-use # used as slot
        try:
            active_window: Optional[QWidget] = self.app.activeWindow()
            if active_window is not None:
                fw = active_window.focusWidget()
                if fw is not None and hasattr(fw, 'cut') and callable(getattr(fw, 'cut')):  # noqa: B009
                    fw.cut()  # pyright: ignore[reportAttributeAccessIssue]
        except Exception:  # pylint: disable=broad-except
            pass  # not every QWidget has a cut method

    @pyqtSlot()
    @pyqtSlot(bool)
    def on_actionCopy_triggered(self, _: bool = False) -> None:  # pylint: disable=no-self-use # used as slot
        try:
            active_window: Optional[QWidget] = self.app.activeWindow()
            if active_window is not None:
                fw = active_window.focusWidget()
                if fw is not None and hasattr(fw, 'copy') and callable(getattr(fw, 'copy')):  # noqa: B009
                    fw.copy()  # pyright: ignore[reportAttributeAccessIssue]
        except Exception:  # pylint: disable=broad-except
            pass  # not every QWidget has a copy method

    @pyqtSlot()
    @pyqtSlot(bool)
    def on_actionPaste_triggered(self, _: bool = False) -> None:  # pylint: disable=no-self-use # used as slot
        try:
            active_window: Optional[QWidget] = self.app.activeWindow()
            if active_window is not None:
                fw = active_window.focusWidget()
                if fw is not None and hasattr(fw, 'paste') and callable(getattr(fw, 'paste')):  # noqa: B009
                    fw.paste()  # pyright: ignore[reportAttributeAccessIssue]
        except Exception:  # pylint: disable=broad-except
            pass  # not every QWidget has a paste method

    # clears the message line without appending to the message log
    def clearMessageLine(self, style: Optional[str] = None) -> None:
        self.sendmessage('', append=False, style=style)

    # this should only be called from within the main GUI thread (and never from the sampling thread!)
    @pyqtSlot(str, bool, str)
    def sendmessage(self, message: str, append: bool = True, style: Optional[str] = None) -> None:
        if isinstance(threading.current_thread(),
                      threading._MainThread):  # type: ignore # pylint: disable=protected-access
            # we are running in the main thread thus we can call sendmessage_internal via a QTimer to avoid redraw issues
            QTimer.singleShot(2, lambda: self.sendmessage_internal(message, append, style))
        else:
            # we are not running in the main thread thus we CANNOT call sendmessage_internal via a QTimer
            self.sendmessageSignal.emit(message, append,
                                        style)  # we emit a signal to the main thread to resend this message and then process it via the QTimer
            # self.sendmessage_internal(message,append,style,repaint=False)
            # if this is executed via a QTimer we receive "QObject::startTimer: Timers can only be used with threads started with QThread"

    def sendmessage_internal(self, message: str, append: bool = True, style: Optional[str] = None,
                             repaint: bool = True) -> None:
        try:
            #### lock shared resources #####
            self.qmc.messagesemaphore.acquire(1)
            if message and not self.qmc.designerflag:
                _log.debug('message: %s', message)
            if style is not None and style != '':
                self.messagelabel.setStyleSheet(style)
            else:
                self.messagelabel.setStyleSheet(
                    f"background-color:'transparent'; color: {self.qmc.palette['messages']};")
            message = self.arabicReshape(message)
            # keep a max of 100 messages
            if append:
                if len(self.messagehist) > 99:
                    self.messagehist = self.messagehist[1:]
                timez = QDateTime.currentDateTime().toString('hh:mm:ss.zzz ')  # zzz = milliseconds
                self.messagehist.append(f'{timez}{message}')
            self.messagelabel.setText(message)
            if repaint:  # if repaint is executed in the main thread we receive "QWidget::repaint: Recursive repaint detected"
                self.messagelabel.repaint()
            # update messages window
            if self.message_dlg:
                self.updateMessageLogSignal.emit()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        finally:
            if self.qmc.messagesemaphore.available() < 1:
                self.qmc.messagesemaphore.release(1)

    def hideDefaultButtons(self) -> None:
        self.lowerbuttondialog.setVisible(False)

    def showDefaultButtons(self) -> None:
        self.lowerbuttondialog.setVisible(True)

    # update the visibility of the extra event buttons based on the users preference for the current state
    def updateExtraButtonsVisibility(self) -> None:
        # update visibility (based on the app state)
        if self.qmc.flagstart:
            visible = self.extraeventsbuttonsflags[2]
        elif self.qmc.flagon:
            visible = self.extraeventsbuttonsflags[1]
        else:
            visible = self.extraeventsbuttonsflags[0]
        if visible:
            self.showExtraButtons(False)
        else:
            self.hideExtraButtons(False)
        if self.app.artisanviewerMode:
            self.hideExtraButtons(True)

    def hideExtraButtons(self, changeDefault: bool = True) -> None:
        focused_widget = QApplication.focusWidget()
        if focused_widget and focused_widget != self.centralWidget():
            focused_widget.clearFocus()
        self.extrabuttondialogs.setVisible(False)
        self.buttonsAction.setChecked(False)
        # remember state
        if changeDefault:
            if self.qmc.flagstart:
                self.extraeventsbuttonsflags[2] = 0
            elif self.qmc.flagon:
                self.extraeventsbuttonsflags[1] = 0
            else:
                self.extraeventsbuttonsflags[0] = 0

    def showExtraButtons(self, changeDefault: bool = True) -> None:
        focused_widget = QApplication.focusWidget()
        if focused_widget and focused_widget != self.centralWidget():
            focused_widget.clearFocus()
        self.extrabuttondialogs.setVisible(True)
        self.buttonsAction.setChecked(True)
        # remember state
        if changeDefault:
            if self.qmc.flagstart:
                self.extraeventsbuttonsflags[2] = 1
            elif self.qmc.flagon:
                self.extraeventsbuttonsflags[1] = 1
            else:
                self.extraeventsbuttonsflags[0] = 1

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleExtraButtons(self, _: bool = False) -> None:
        if self.extrabuttondialogs.isVisible():
            self.hideExtraButtons()
        else:
            self.showExtraButtons()

    # update the visibility of the sliders based on the users preference for the current state
    def updateSlidersVisibility(self) -> None:
        if self.app.artisanviewerMode:
            self.hideSliders(True)
        else:
            # update visibility (based on the app state)
            if self.qmc.flagstart:
                visible = self.eventslidersflags[2]
            elif self.qmc.flagon:
                visible = self.eventslidersflags[1]
            else:
                visible = self.eventslidersflags[0]
            if visible:
                self.showSliders(False)
            else:
                self.hideSliders(False)

    def hideSliders(self, changeDefault: bool = True) -> None:
        focused_widget = QApplication.focusWidget()
        if focused_widget and focused_widget != self.centralWidget():
            focused_widget.clearFocus()
        self.setSliderFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.slider1.setVisible(False)
        self.slider2.setVisible(False)
        self.slider3.setVisible(False)
        self.slider4.setVisible(False)
        self.sliderSV.setVisible(False)
        self.sliderFrame.setVisible(False)
        self.slidersAction.setChecked(False)
        # remember state
        if changeDefault:
            if self.qmc.flagstart:
                self.eventslidersflags[2] = 0
            elif self.qmc.flagon:
                self.eventslidersflags[1] = 0
            else:
                self.eventslidersflags[0] = 0

    def showSliders(self, changeDefault: bool = True) -> None:
        focused_widget = QApplication.focusWidget()
        if focused_widget and focused_widget != self.centralWidget():
            focused_widget.clearFocus()
        self.sliderFrame.setVisible(True)
        self.slider1.setVisible(True)
        self.slider2.setVisible(True)
        self.slider3.setVisible(True)
        self.slider4.setVisible(True)
        self.sliderSV.setVisible(True)
        if self.keyboardmoveflag == 0:
            self.setSliderFocusPolicy(Qt.FocusPolicy.StrongFocus)
        # set slider singleStep
        self.slider1.setSingleStep(self.eventSliderStepSize(0))
        self.slider2.setSingleStep(self.eventSliderStepSize(1))
        self.slider3.setSingleStep(self.eventSliderStepSize(2))
        self.slider4.setSingleStep(self.eventSliderStepSize(3))
        # set slider pageStep
        self.slider1.setPageStep(self.eventSliderPageSize(0))
        self.slider2.setPageStep(self.eventSliderPageSize(1))
        self.slider3.setPageStep(self.eventSliderPageSize(2))
        self.slider4.setPageStep(self.eventSliderPageSize(3))
        #
        self.slidersAction.setChecked(True)
        if changeDefault:
            if self.qmc.flagstart:
                self.eventslidersflags[2] = 1
            elif self.qmc.flagon:
                self.eventslidersflags[1] = 1
            else:
                self.eventslidersflags[0] = 1

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleSliders(self, _: bool = False) -> None:
        if self.sliderFrame.isVisible():
            self.hideSliders()
        else:
            self.showSliders()

    def hideControls(self) -> None:
        self.level1frame.hide()
        self.controlsAction.setChecked(False)

    def showControls(self) -> None:
        self.level1frame.show()
        self.controlsAction.setChecked(True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleControls(self, _: bool = False) -> None:
        if self.level1frame.isVisible():
            self.hideControls()
        else:
            self.showControls()

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggleReadings(self, _: bool = False) -> None:
        if self.lcdFrame.isVisible():
            self.hideLCDs()
        else:
            self.showLCDs()

    def updateSlidersProperties(self) -> None:
        # update slider properties and event type names
        if bool(self.eventslidervisibilities[0]):
            self.sliderGrpBox1.setVisible(True)
            self.sliderGrpBox1.setTitle(self.qmc.etypesf(0))
        else:
            self.sliderGrpBox1.setVisible(False)
            self.sliderGrpBox1.setTitle('')
        if bool(self.eventslidervisibilities[1]):
            self.sliderGrpBox2.setVisible(True)
            self.sliderGrpBox2.setTitle(self.qmc.etypesf(1))
        else:
            self.sliderGrpBox2.setVisible(False)
            self.sliderGrpBox2.setTitle('')
        if bool(self.eventslidervisibilities[2]):
            self.sliderGrpBox3.setVisible(True)
            self.sliderGrpBox3.setTitle(self.qmc.etypesf(2))
        else:
            self.sliderGrpBox3.setVisible(False)
            self.sliderGrpBox3.setTitle('')
        if bool(self.eventslidervisibilities[3]):
            self.sliderGrpBox4.setVisible(True)
            self.sliderGrpBox4.setTitle(self.qmc.etypesf(3))
        else:
            self.sliderGrpBox4.setVisible(False)
            self.sliderGrpBox4.setTitle('')

    def hideLCDs(self, changeDefault: bool = True) -> None:
        self.lcd1.setVisible(False)
        self.lcdFrame.setVisible(False)
        self.readingsAction.setChecked(False)
        if changeDefault:
            if self.qmc.flagstart:
                self.readingslcdsflags[2] = 0
            elif self.qmc.flagon:
                self.readingslcdsflags[1] = 0
            else:
                self.readingslcdsflags[0] = 0

    def showLCDs(self, changeDefault: bool = True) -> None:
        self.lcd1.setVisible(True)
        self.lcdFrame.setVisible(True)
        self.readingsAction.setChecked(True)
        if changeDefault:
            if self.qmc.flagstart:
                self.readingslcdsflags[2] = 1
            elif self.qmc.flagon:
                self.readingslcdsflags[1] = 1
            else:
                self.readingslcdsflags[0] = 1

    def updateReadingsLCDsVisibility(self) -> None:
        # update visibility (based on the app state)
        if self.qmc.flagstart:
            visible = self.readingslcdsflags[2]
        elif self.qmc.flagon:
            visible = self.readingslcdsflags[1]
        else:
            visible = self.readingslcdsflags[0]
        if visible:
            self.showLCDs(False)
        else:
            self.hideLCDs(False)
        if self.app.artisanviewerMode:
            self.hideLCDs(True)

    def hideEventsMinieditor(self) -> None:
        self.EventsGroupLayout.setVisible(False)

    def showEventsMinieditor(self) -> None:
        self.EventsGroupLayout.setVisible(True)

    def updateLCDproperties(self) -> None:
        # set LCDframe visibilities and labels
        ndev = len(self.qmc.extradevices)
        for i in range(ndev):
            self.extraLCDframe1[i].setVisible(bool(self.extraLCDvisibility1[i]))
            if i < len(self.qmc.extraname1):
                l1 = '<b>' + self.qmc.extraname1[i] + '</b>'
                try:
                    self.extraLCDlabel1[i].setText(
                        l1.format(self.qmc.etypes[0], self.qmc.etypes[1], self.qmc.etypes[2], self.qmc.etypes[3]))
                except Exception:  # pylint: disable=broad-except
                    self.extraLCDlabel1[i].setText(l1)
                self.setLabelColor(self.extraLCDlabel1[i], QColor(self.qmc.extradevicecolor1[i]))
            self.extraLCD1[i].setStyleSheet(
                f"QLCDNumber {{ border-radius:4; color: {self.lcdpaletteF['sv']}; background-color: {self.lcdpaletteB['sv']};}}")
            self.extraLCDframe2[i].setVisible(bool(self.extraLCDvisibility2[i]))
            if i < len(self.qmc.extraname2):
                l2 = '<b>' + self.qmc.extraname2[i] + '</b>'
                try:
                    self.extraLCDlabel2[i].setText(
                        l2.format(self.qmc.etypes[0], self.qmc.etypes[1], self.qmc.etypes[2], self.qmc.etypes[3]))
                except Exception:  # pylint: disable=broad-except
                    self.extraLCDlabel2[i].setText(l2)
                self.setLabelColor(self.extraLCDlabel2[i], QColor(self.qmc.extradevicecolor2[i]))
            self.extraLCD2[i].setStyleSheet(
                f"QLCDNumber {{ border-radius:4; color: {self.lcdpaletteF['sv']}; background-color: {self.lcdpaletteB['sv']};}}")
        # hide the rest (just in case)
        for i in range(ndev, self.nLCDS):
            self.extraLCDframe1[i].setVisible(False)
            self.extraLCDframe2[i].setVisible(False)
        self.LCD2frame.setVisible(self.qmc.BTlcd if self.qmc.swaplcds else self.qmc.ETlcd)
        self.LCD3frame.setVisible(self.qmc.ETlcd if self.qmc.swaplcds else self.qmc.BTlcd)
        self.LCD4frame.setVisible(self.qmc.DeltaBTlcdflag if self.qmc.swapdeltalcds else self.qmc.DeltaETlcdflag)
        self.LCD5frame.setVisible(self.qmc.DeltaETlcdflag if self.qmc.swapdeltalcds else self.qmc.DeltaBTlcdflag)
        #
        if self.largeLCDs_dialog is not None:
            self.largeLCDs_dialog.updateVisiblitiesETBT()
        if self.largeDeltaLCDs_dialog is not None:
            self.largeDeltaLCDs_dialog.updateVisiblitiesDeltaETBT()
        if self.largePIDLCDs_dialog is not None:
            self.largePIDLCDs_dialog.updateVisiblitiesPID()
        if self.largeExtraLCDs_dialog is not None:
            self.largeExtraLCDs_dialog.updateVisiblitiesExtra()
        if self.largePhasesLCDs_dialog is not None:
            self.largePhasesLCDs_dialog.updateVisiblitiesPhases()
        #
        if self.ser.showFujiLCDs and self.qmc.device in {0, 26}:  # extra LCDs for Fuji or DTA pid
            self.LCD6frame.setVisible(True)
            self.LCD7frame.setVisible(True)
        else:
            self.LCD6frame.setVisible(False)
            self.LCD7frame.setVisible(False)
        if self.qmc.LCDdecimalplaces:
            self.setLCDsDigitCount(5)
        else:
            self.setLCDsDigitCount(3)

    def disableLoadImportConvertMenus(self) -> None:
        self.fileLoadAction.setEnabled(False)  # open
        if self.openRecentMenu is not None:
            self.openRecentMenu.setEnabled(False)  # open recent
        if self.importMenu is not None:
            self.importMenu.setEnabled(False)  # import
        if self.convMenu is not None:
            self.convMenu.setEnabled(False)  # convert

    def enableLoadImportConvertMenus(self) -> None:
        self.fileLoadAction.setEnabled(True)  # open
        if self.openRecentMenu is not None:
            self.openRecentMenu.setEnabled(True)  # open recent
        if self.importMenu is not None:
            self.importMenu.setEnabled(True)  # import
        if self.convMenu is not None:
            self.convMenu.setEnabled(True)  # convert

    def enableEditMenus(self) -> None:
        if self.newRoastMenu is not None:
            self.newRoastMenu.setEnabled(True)
        self.fileLoadAction.setEnabled(True)  # open
        if self.openRecentMenu is not None:
            self.openRecentMenu.setEnabled(True)  # open recent
        if self.importMenu is not None:
            self.importMenu.setEnabled(True)  # import
        self.fileSaveAction.setEnabled(True)
        self.fileSaveAsAction.setEnabled(True)
        self.fileSaveCopyAsAction.setEnabled(True)
        if self.exportMenu is not None:
            self.exportMenu.setEnabled(True)
        if self.convMenu is not None:
            self.convMenu.setEnabled(True)
        if self.saveGraphMenu is not None:
            self.saveGraphMenu.setEnabled(True)
        self.htmlAction.setEnabled(True)
        if self.QtWebEngineSupport:
            self.roastReportPDFAction.setEnabled(True)
        if self.reportMenu is not None:
            self.reportMenu.setEnabled(True)
        if self.productionMenu is not None:
            self.productionMenu.setEnabled(True)
        if self.rankingMenu is not None:
            self.rankingMenu.setEnabled(True)
        self.printAction.setEnabled(True)
        self.editGraphAction.setEnabled(True)
        self.backgroundAction.setEnabled(True)
        self.switchAction.setEnabled(True)
        self.switchETBTAction.setEnabled(True)
        self.flavorAction.setEnabled(True)
        if self.temperatureMenu is not None:
            self.temperatureMenu.setEnabled(True)
        if self.temperatureConfMenu is not None:
            self.temperatureConfMenu.setEnabled(True)
        if self.languageMenu is not None:
            self.languageMenu.setEnabled(True)
        self.deviceAction.setEnabled(True)
        self.commportAction.setEnabled(True)
        self.curvesAction.setEnabled(True)
        if self.analyzeMenu is not None:
            self.analyzeMenu.setEnabled(True)
        self.roastCompareAction.setEnabled(True)
        self.designerAction.setEnabled(True)
        self.simulatorAction.setEnabled(True)
        self.wheeleditorAction.setEnabled(True)
        self.transformAction.setEnabled(True)
        self.loadSettingsAction.setEnabled(True)
        if self.openRecentSettingMenu is not None:
            self.openRecentSettingMenu.setEnabled(True)
        self.saveAsSettingsAction.setEnabled(True)
        self.resetAction.setEnabled(True)
        self.switchAction.setEnabled(True)
        if self.machineMenu is not None:
            self.machineMenu.setEnabled(True)
        self.editGraphAction.setEnabled(True)
        self.backgroundAction.setEnabled(True)
        self.switchETBTAction.setEnabled(True)
        self.eventsAction.setEnabled(True)
        self.phasesGraphAction.setEnabled(True)
        self.StatisticsAction.setEnabled(True)
        self.WindowconfigAction.setEnabled(True)
        self.colorsAction.setEnabled(True)
        if self.themeMenu is not None:
            self.themeMenu.setEnabled(True)
        self.controlsAction.setEnabled(True)
        self.readingsAction.setEnabled(True)
        self.eventsEditorAction.setEnabled(True)
        self.buttonsAction.setEnabled(True)
        self.slidersAction.setEnabled(True)

        if self.qmc.statssummary:
            self.savestatisticsAction.setEnabled(True)
        self.displayonlymenus()

    def disableEditMenus(self, designer: bool = False, wheel: bool = False, compare: bool = False,
                         sampling: bool = False) -> None:
        # FILE menu
        if self.newRoastMenu is not None:
            if designer or wheel or compare:
                self.newRoastMenu.setEnabled(False)
            else:
                self.newRoastMenu.setEnabled(True)
        if compare:
            self.fileLoadAction.setEnabled(True)  # open
            if self.openRecentMenu is not None:
                self.openRecentMenu.setEnabled(True)  # open recent
        else:
            self.fileLoadAction.setEnabled(False)  # open
            if self.openRecentMenu is not None:
                self.openRecentMenu.setEnabled(False)  # open recent
        if self.importMenu is not None:
            self.importMenu.setEnabled(False)  # import
        if not sampling:
            self.fileSaveAction.setEnabled(False)
            self.fileSaveAsAction.setEnabled(False)
            self.fileSaveCopyAsAction.setEnabled(False)
            if self.exportMenu is not None:
                self.exportMenu.setEnabled(False)
        if self.convMenu is not None:
            self.convMenu.setEnabled(False)
        if self.saveGraphMenu is not None and not wheel and not compare and not sampling:
            self.saveGraphMenu.setEnabled(False)
        self.htmlAction.setEnabled(False)
        self.roastReportPDFAction.setEnabled(False)
        if self.reportMenu is not None:
            self.reportMenu.setEnabled(False)
        if self.productionMenu is not None:
            self.productionMenu.setEnabled(False)
        if self.rankingMenu is not None:
            self.rankingMenu.setEnabled(False)
        if not compare and not sampling:
            self.printAction.setEnabled(False)
        self.savestatisticsAction.setEnabled(False)
        # EDIT menu
        # ROAST menu
        if compare or wheel:
            self.editGraphAction.setEnabled(False)
            self.backgroundAction.setEnabled(False)
        self.flavorAction.setEnabled(False)
        self.switchAction.setEnabled(False)
        self.switchETBTAction.setEnabled(False)
        # CONFIG menu
        if not compare:
            self.machineMenu.setEnabled(False)
            self.deviceAction.setEnabled(False)
            self.commportAction.setEnabled(False)
        if designer or wheel:
            self.curvesAction.setEnabled(False)  # Curves menu
        else:
            self.curvesAction.setEnabled(True)
        if wheel or designer:
            self.eventsAction.setEnabled(False)
            self.phasesGraphAction.setEnabled(False)
            self.StatisticsAction.setEnabled(False)
            self.WindowconfigAction.setEnabled(False)
            self.colorsAction.setEnabled(False)
        if self.themeMenu is not None:
            self.themeMenu.setEnabled(False)
        if self.temperatureConfMenu is not None:
            self.temperatureConfMenu.setEnabled(False)
        if self.languageMenu is not None:
            self.languageMenu.setEnabled(False)
        # TOOLS menu
        if self.analyzeMenu is not None:
            self.analyzeMenu.setEnabled(False)
        if not compare:
            self.roastCompareAction.setEnabled(False)
        else:
            self.roastCompareAction.setEnabled(True)
        if not designer:
            self.designerAction.setEnabled(False)
        else:
            self.designerAction.setEnabled(True)
        self.simulatorAction.setEnabled(False)
        if not wheel:
            self.wheeleditorAction.setEnabled(False)
        else:
            self.wheeleditorAction.setEnabled(True)
        self.transformAction.setEnabled(False)
        if self.temperatureMenu is not None:
            self.temperatureMenu.setEnabled(False)
        # VIEW menu
        if wheel:
            self.controlsAction.setEnabled(False)
        if wheel or designer:
            self.readingsAction.setEnabled(False)
            self.eventsEditorAction.setEnabled(False)
            self.buttonsAction.setEnabled(False)
            self.slidersAction.setEnabled(False)
        # HELP menu
        self.loadSettingsAction.setEnabled(False)
        if self.openRecentSettingMenu is not None:
            self.openRecentSettingMenu.setEnabled(False)
        self.saveAsSettingsAction.setEnabled(False)
        self.resetAction.setEnabled(False)
        #
        self.displayonlymenus()

    def displayonlymenus(self) -> None:
        if self.app.artisanviewerMode:
            if self.newRoastMenu is not None:
                self.newRoastMenu.setEnabled(False)
            self.calibrateDelayAction.setEnabled(False)
            self.saveAsSettingsAction.setEnabled(False)
            if self.machineMenu is not None:
                self.machineMenu.setEnabled(False)
            self.alarmAction.setEnabled(False)
            self.autosaveAction.setEnabled(False)
            self.batchAction.setEnabled(False)
            self.readingsAction.setEnabled(False)
            self.buttonsAction.setChecked(False)
            self.buttonsAction.setEnabled(False)
            self.slidersAction.setChecked(False)
            self.slidersAction.setEnabled(False)
            self.eventsEditorAction.setChecked(False)
            self.eventsEditorAction.setEnabled(False)
            self.simulatorAction.setEnabled(False)
        else:
            return

    def update_minieventline_visibility(self) -> None:
        # update visibility (based on the app state)
        if self.qmc.flagstart:
            visible = self.minieventsflags[2]
        elif self.qmc.flagon:
            visible = self.minieventsflags[1]
        else:
            visible = self.minieventsflags[0]
        if visible:
            self.show_minieventline(False)
        else:
            self.hide_minieventline(False)

    @pyqtSlot()
    @pyqtSlot(bool)
    def toggle_minieventline(self, _: bool = False) -> None:
        if self.EventsGroupLayout.isVisible():
            self.hide_minieventline()
        else:
            self.show_minieventline()

    def hide_minieventline(self, changeDefault: bool = True) -> None:
        self.releaseminieditor()
        focused_widget = QApplication.focusWidget()
        if focused_widget and focused_widget != self.centralWidget():
            focused_widget.clearFocus()
        self.EventsGroupLayout.setVisible(False)
        self.eventsEditorAction.setChecked(False)
        if changeDefault:
            if self.qmc.flagstart:
                self.minieventsflags[2] = 0
            elif self.qmc.flagon:
                self.minieventsflags[1] = 0
            else:
                self.minieventsflags[0] = 0

    def show_minieventline(self, changeDefault: bool = True) -> None:
        self.EventsGroupLayout.setVisible(True)
        self.eventsEditorAction.setChecked(True)
        if changeDefault:
            if self.qmc.flagstart:
                self.minieventsflags[2] = 1
            elif self.qmc.flagon:
                self.minieventsflags[1] = 1
            else:
                self.minieventsflags[0] = 1

    def toggleForegroundShowfullFlag(self) -> None:
        if not self.qmc.designerflag:
            self.qmc.foregroundShowFullflag = not self.qmc.foregroundShowFullflag
            self.autoAdjustAxis(background=self.qmc.background and (not len(self.qmc.timex) > 3), deltas=False)
            self.qmc.redraw(recomputeAllDeltas=False)

    def toggleBackroundShowfullFlag(self) -> None:
        self.qmc.backgroundShowFullflag = not self.qmc.backgroundShowFullflag
        if self.qmc.designerflag:
            self.qmc.redrawdesigner(force=True)
        else:
            self.autoAdjustAxis(background=self.qmc.background and (not len(self.qmc.timex) > 3), deltas=False)
            self.qmc.redraw(recomputeAllDeltas=False)

    @pyqtSlot()
    def updatePlaybackIndicator(self) -> None:
        if self.qmc.l_subtitle is not None and self.qmc.ax is not None:
            if self.qmc.backgroundprofile is not None and self.qmc.backgroundPlaybackEvents:
                self.qmc.l_subtitle.set_color(self.qmc.palette['title_focus'])
            elif self.qmc.background:
                self.qmc.l_subtitle.set_color(self.qmc.palette['title'])
            else:
                self.qmc.l_subtitle.set_color(self.qmc.palette['title_hidden'])
            self.qmc.ax.draw_artist(self.qmc.l_subtitle)
            if self.qmc.ax.figure is not None:
                self.qmc.ax.figure.canvas.blit()
                self.qmc.ax.figure.canvas.flush_events()
            self.qmc.ax_background = None

    def togglePlaybackEvents(self) -> None:
        self.qmc.backgroundPlaybackEvents = not self.qmc.backgroundPlaybackEvents
        if self.qmc.backgroundPlaybackEvents:
            self.sendmessage(QApplication.translate('ComboBox', 'Playback ON'))
        else:
            self.sendmessage(QApplication.translate('ComboBox', 'Playback OFF'))
        self.updatePlaybackIndicatorSignal.emit()

    # keyboard presses. There must not be widgets (pushbuttons, comboboxes, etc) in focus in order to work
    def keyPressEvent(self, event: Optional['QKeyEvent']) -> None:
        if not self.processingKeyEvent and event is not None:
            try:
                self.processingKeyEvent = True
                k = int(event.key())
                k_txt = event.text()
                modifiers = event.modifiers()
                # Note: Windows only - PyQt will sometimes, but not always, interpret a shortcut k as a menu k.  For that
                #    reason only CTRL and CTRL+SHIFT modifier should be used with shortcut keys f,e,r,c,t,v, and h.
                control_modifier = modifiers == Qt.KeyboardModifier.ControlModifier  # command/apple k on macOS, CONTROL on Windows
                alt_modifier = modifiers == Qt.KeyboardModifier.AltModifier  # OPTION on macOS, ALT on Windows
                shift_modifier = modifiers == Qt.KeyboardModifier.ShiftModifier  # SHIFT
                control_alt_modifier = modifiers == (
                        Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.AltModifier)
                control_shift_modifier = modifiers == (
                        Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.ShiftModifier)
                # meta_modifier = modifiers == Qt.KeyboardModifier.MetaModifier # Control on macOS, Meta on Windows
                # uncomment next line to find the integer value of a k
                # print(k,event.text())
                # _log.info("PRINT key: %s",k)

                numberkeys = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57]  # keycodes for number keys 0,1,...,9

                if k == 70:  # F (enters full screen mode)
                    self.toggleFullscreen()
                elif k == 71:  # G (toggle time auto axis mode)
                    if not self.qmc.designerflag and not self.qmc.wheelflag:
                        if self.comparator is not None:
                            self.comparator.modeComboBox.setCurrentIndex(
                                (self.comparator.modeComboBox.currentIndex() + 1) % 3)
                        else:
                            self.qmc.autotimexMode = (self.qmc.autotimexMode + 1) % 3
                            if self.qmc.autotimexMode == 0:
                                self.sendmessage(QApplication.translate('Message', 'Auto Axis Graph Mode: Roast'))
                            elif self.qmc.autotimexMode == 1:
                                self.sendmessage(QApplication.translate('Message', 'Auto Axis Graph Mode: BBP+Roast'))
                            elif self.qmc.autotimexMode == 2:
                                self.sendmessage(QApplication.translate('Message', 'Auto Axis Graph Mode: BBP'))
                            if not self.qmc.flagon:
                                # adjust foreground or if no foreground but background is loaded the background
                                self.autoAdjustAxis(background=self.qmc.background and (not len(self.qmc.timex) > 3),
                                                    deltas=False)
                                self.qmc.redraw()
                elif self.buttonpalette_shortcuts and control_modifier and k in numberkeys:  # palette switch via SHIFT-NUM-Keys
                    self.setbuttonsfrom(numberkeys.index(k))
                elif k == 74:  # J (toggle Playback Events)
                    self.togglePlaybackEvents()
                elif k == 73:  # I (toggle foreground showfull flag)
                    self.toggleForegroundShowfullFlag()
                elif k == 79:  # O (toggle background showfull flag)
                    self.toggleBackroundShowfullFlag()
                elif k == 72:  # H  (load / delete background profile)
                    if self.comparator is None:
                        # delete background when there are platform specific modifiers
                        if ((alt_modifier or shift_modifier) and platform.system() != 'Windows') or (
                                control_shift_modifier or control_alt_modifier and platform.system() == 'Windows'):  # control_alt_modifier here for backward compatibility only, see note above
                            self.deleteBackground()
                            if not self.qmc.flagon:
                                self.autoAdjustAxis()
                            self.qmc.redraw()
                        # load background when there are no modifiers
                        else:
                            filename = self.ArtisanOpenFileDialog(
                                msg=QApplication.translate('Message', 'Load Background'), ext_alt='.alog')
                            if len(filename) != 0:
                                try:
                                    self.qmc.resetlinecountcaches()
                                    self.loadbackground(filename)
                                except Exception as e:  # pylint: disable=broad-except
                                    _log.exception(e)
                                self.qmc.background = True
                                self.autoAdjustAxis()
                                self.qmc.timealign(redraw=False)
                                self.qmc.redraw()
                elif k == 76:  # L (load alarms)
                    if not self.qmc.designerflag and self.comparator is None:
                        filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message', 'Load Alarms'),
                                                              ext='*.alrm')
                        if len(filename) == 0:
                            return
                        try:
                            self.loadAlarms(filename)
                        except Exception as e:  # pylint: disable=broad-except
                            _log.exception(e)
                elif k == 80:  # P
                    # switch PID mode
                    if self.qmc.device == 0 and self.fujipid and self.qmc.Controlbuttonflag:  # FUJI PID
                        # toggle mode: manual => RS => background
                        if not self.fujipid.rampsoak and not self.fujipid.followBackground:  # => RS
                            self.fujipid.setrampsoak(1)
                            self.fujipid.rampsoak = True  # even if activation failed to allow to further toggle around
                            self.fujipid.followBackground = False
                            self.sendmessage(QApplication.translate('Message', 'PID Mode: Ramp/Soak'))
                        elif self.fujipid.rampsoak:  # => background
                            self.fujipid.setrampsoak(0)
                            self.fujipid.rampsoak = False  # even if activation failed to allow to further toggle around
                            self.fujipid.followBackground = True
                            self.sendmessage(QApplication.translate('Message', 'PID Mode: Background'))
                        else:  # => manual
                            self.fujipid.setrampsoak(0)
                            self.fujipid.followBackground = False
                            self.sendmessage(QApplication.translate('Message', 'PID Mode: Manual'))
                    elif (self.pidcontrol and self.qmc.Controlbuttonflag):  # MODBUS hardware/software PID
                        self.pidcontrol.svMode = (self.pidcontrol.svMode + 1) % 3
                        # 0: manual, 1: Ramp/Soak, 2: Follow (background profile)
                        if self.pidcontrol.svMode == 0:
                            self.sendmessage(QApplication.translate('Message', 'PID Mode: Manual'))
                        elif self.pidcontrol.svMode == 1:
                            self.sendmessage(QApplication.translate('Message', 'PID Mode: Ramp/Soak'))
                        elif self.pidcontrol.svMode == 2:
                            self.sendmessage(QApplication.translate('Message', 'PID Mode: Background'))
                elif k_txt == '-':  # k == 45:          #- (decrease dpi, zoom out / decrease PID lookahead)
                    #                    # the following does not work on US keyboards, we use shortcuts instead, see above self.zoomInShortcut()/self.zoomOutShortcut()
                    #                    if control_modifier or control_shift_modifier:
                    #                        self.setdpi(self.dpi-10)
                    #                    else:
                    if not (control_modifier or control_shift_modifier):
                        if self.qmc.device == 0 and self.fujipid and self.qmc.Controlbuttonflag:  # FUJI PID
                            self.fujipid.lookahead = max(0, self.fujipid.lookahead - 1)
                            self.sendmessage(
                                QApplication.translate('Message', 'PID Lookahead: {0}').format(self.fujipid.lookahead))
                        elif (self.pidcontrol and self.qmc.Controlbuttonflag):  # MODBUS hardware PID
                            self.pidcontrol.svLookahead = max(0, self.pidcontrol.svLookahead - 1)
                            self.sendmessage(QApplication.translate('Message', 'PID Lookahead: {0}').format(
                                self.pidcontrol.svLookahead))
                elif k_txt == '+':  # k == 43:         #+ (increase dpi, zoom in / increase PID lookahead)
                    #                    # the following does not work on US keyboards, we use shortcuts instead, see above self.zoomInShortcut()/self.zoomOutShortcut()
                    #                    if control_modifier or control_shift_modifier:
                    #                        self.setdpi(self.dpi+10)
                    #                    else:
                    if not (control_modifier or control_shift_modifier):
                        if self.qmc.device == 0 and self.fujipid and self.qmc.Controlbuttonflag:  # FUJI PID
                            self.fujipid.lookahead = self.fujipid.lookahead + 1
                            self.sendmessage(
                                QApplication.translate('Message', 'PID Lookahead: {0}').format(self.fujipid.lookahead))
                        elif (self.pidcontrol and self.qmc.Controlbuttonflag):  # MODBUS hardware PID
                            self.pidcontrol.svLookahead = self.pidcontrol.svLookahead + 1
                            self.sendmessage(QApplication.translate('Message', 'PID Lookahead: {0}').format(
                                self.pidcontrol.svLookahead))
                elif k == 32:  # SPACE (selects active button)
                    if self.qmc.flagstart:
                        if self.keyboardmoveflag:
                            # if recording and manual keyboard move mode is on and
                            # EVENT button is not enabled and all visible buttons are disabled (flat)
                            # and selected button is NOT DROP (to enable undo DROP) nor the EVENT button
                            if (all(not self.qmc.buttonvisibility[i] or b.isFlat() for i, b in
                                    enumerate(self.keyboardButtonList[:-1])) and
                                self.keyboardmoveindex != 6) and (
                                    not self.eventsbuttonflag or self.keyboardmoveindex != 8):
                                self.qmc.toggleRecorderSignal.emit()
                            else:
                                self.moveKbutton('space')
                        else:
                            self.qmc.EventRecord()
                    elif self.qmc.flagon:
                        self.qmc.toggleRecorderSignal.emit()
                elif k == 16777220:  # ENTER (turns ON/OFF keyboard moves; COMMAND+ENTER starts record, SHIFT+ENTER turns Artisan OFF)
                    if shift_modifier and self.qmc.flagon:
                        self.qmc.OffMonitor()
                    elif control_modifier and not self.qmc.flagstart:
                        self.qmc.OnRecorder()
                    else:
                        self.releaseminieditor()
                        self.moveKbutton('enter')
                elif k == 16777216:  # ESCAPE (exists full screen mode / clears message line / resets event short cut / exits designer/wheel graph / releases minieditor)
                    self.quickEventShortCut = None
                    self.clearMessageLine()
                    macfullscreen = False
                    try:
                        if platform.system() == 'Darwin' and self.app.allWindows()[
                            0].visibility() == QWindow.Visibility.FullScreen:
                            macfullscreen = True
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                    if self.full_screen_mode_active or self.isFullScreen() or macfullscreen:
                        self.toggleFullscreen()
                    else:
                        # if designer ON
                        if self.qmc.designerflag:
                            string = QApplication.translate('Message', 'Exit Designer?')
                            reply = QMessageBox.question(self, QApplication.translate('Message', 'Designer Mode ON'),
                                                         string,
                                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.Cancel)
                            if reply == QMessageBox.StandardButton.Yes:
                                self.stopdesigner()
                            else:
                                return
                        # if wheel graph ON
                        elif self.qmc.wheelflag:
                            self.qmc.wheelflag = False
                            self.wheeleditorAction.setChecked(self.qmc.wheelflag)
                            self.qmc.exitviewmode()
                            self.enableEditMenus()
                            self.showControls()
                        self.releaseminieditor()
                elif k == 16777234:  # LEFT (moves background left / moves button selection left)
                    if self.keyboardmoveflag and self.qmc.flagstart:
                        self.moveKbutton('left')
                    elif self.qmc.background and self.qmc.backgroundKeyboardControlFlag:
                        self.qmc.moveBackgroundSignal.emit('left', self.qmc.backgroundmovespeed)
                elif k == 16777236:  # RIGHT (moves background right / moves button selection right)
                    if self.keyboardmoveflag and self.qmc.flagstart:
                        self.moveKbutton('right')
                    elif self.qmc.background and self.qmc.backgroundKeyboardControlFlag:
                        self.qmc.moveBackgroundSignal.emit('right', self.qmc.backgroundmovespeed)
                elif k == 16777235:  # UP (moves background up)
                    if self.qmc.background and self.qmc.backgroundKeyboardControlFlag:
                        self.qmc.moveBackgroundSignal.emit('up', self.qmc.backgroundmovespeed)
                elif k == 16777237:  # DOWN (moves background down)
                    if self.qmc.background and self.qmc.backgroundKeyboardControlFlag:
                        self.qmc.moveBackgroundSignal.emit('down', self.qmc.backgroundmovespeed)
                elif k == 65:  # A (automatic save)
                    if not self.app.artisanviewerMode and self.qmc.flagon and not self.qmc.designerflag and self.comparator is None:
                        self.automaticsave()
                elif k == 68:  # D (toggle xy coordinates between temp and RoR scale)
                    if not self.qmc.wheelflag:
                        if not self.qmc.fmt_data_ON:
                            self.qmc.fmt_data_ON = True
                        elif not self.qmc.fmt_data_RoR and self.qmc.twoAxisMode():
                            self.qmc.fmt_data_RoR = True
                        else:
                            self.qmc.fmt_data_RoR = False
                            self.qmc.fmt_data_ON = False
                        self.ntb.update_message()
                        # force redraw crosslines if active
                        if self.qmc.crossmarker:
                            try:
                                self.ntb.mouse_move(mplLocationevent.lastevent)
                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                elif k == 90:  # Z (toggle xy coordinates between 0: cursor, 1: BT, 2: ET, 3: BTB, 4: ETB)
                    if not self.qmc.designerflag and not self.qmc.wheelflag and self.comparator is None:
                        self.qmc.nextFmtDataCurve()
                elif k == 85:  # U (toggle running LCDs on/off)
                    if not self.qmc.flagon:
                        if self.qmc.running_LCDs == 0 and self.curFile:
                            self.qmc.running_LCDs = 1
                            self.sendmessage(QApplication.translate('Message', 'LCD cursor on profile data'))
                        elif self.qmc.running_LCDs in {0, 1} and self.qmc.backgroundprofile:
                            self.qmc.running_LCDs = 2
                            self.sendmessage(QApplication.translate('Message', 'LCD cursor on template data'))
                        elif self.qmc.running_LCDs in {1, 2}:
                            self.qmc.running_LCDs = 0
                            self.sendmessage(QApplication.translate('Message', 'LCD cursor OFF'))
                        if self.qmc.running_LCDs == 0:
                            self.qmc.updateLCDs(
                                -1,
                                self.qmc.temp1,
                                self.qmc.temp2,
                                self.qmc.delta1,
                                self.qmc.delta2,
                                self.qmc.extratemp1,
                                self.qmc.extratemp2,
                                idx=None)  # show default OFF placeholders in LCDs
                        else:
                            self.ntb.update_message()
                elif k == 67:  # C (toggle controls)
                    if not self.qmc.wheelflag:
                        self.toggleControls()
                elif k == 88:  # X (toggle readings)
                    if not self.app.artisanviewerMode and not self.qmc.designerflag and not self.qmc.wheelflag:
                        self.toggleReadings()
                elif k == 89:  # Y (toggle minieditor)
                    if not self.qmc.designerflag and not self.qmc.wheelflag:
                        self.toggle_minieventline()
                elif k == 83:  # S (toggle sliders)
                    if not self.app.artisanviewerMode and not self.qmc.designerflag and not self.qmc.wheelflag:
                        self.toggleSliders()
                elif k == 84 and not self.qmc.flagon:  # T (toggle mouse cross)
                    self.qmc.togglecrosslines()
                elif k == 81:  # Q (quick entry of custom event 1)
                    if not self.qmc.designerflag and self.comparator is None:
                        self.quickEventShortCut = (0, '')
                        self.sendmessage(self.qmc.etypes[0])
                elif k == 87:  # W (quick entry of custom event 2)
                    if not self.qmc.designerflag and self.comparator is None:
                        self.quickEventShortCut = (1, '')
                        self.sendmessage(self.qmc.etypes[1])
                elif k == 69:  # E (quick entry of custom event 3)
                    if not self.qmc.designerflag and self.comparator is None:
                        self.quickEventShortCut = (2, '')
                        self.sendmessage(self.qmc.etypes[2])
                elif k == 82:  # R (quick entry of custom event 4)
                    if not self.qmc.designerflag and self.comparator is None:
                        self.quickEventShortCut = (3, '')
                        self.sendmessage(self.qmc.etypes[3])
                elif k == 86:  # V (set SV)
                    if not self.qmc.designerflag and self.comparator is None:
                        self.quickEventShortCut = (4, '')
                        self.sendmessage('SV')
                elif k == 66:  # B (hides/shows extra rows of event buttons / actives custom event button <nr>)
                    if (alt_modifier and platform.system() != 'Windows') or (
                            control_shift_modifier and platform.system() == 'Windows'):
                        # activate custom event button
                        self.quickEventShortCut = (-1, '')
                        self.sendmessage(f"{QApplication.translate('Label', 'Event button')}")
                    elif not self.app.artisanviewerMode and not self.qmc.designerflag and not self.qmc.wheelflag:
                        self.toggleextraeventrows()
                elif k == 77:  # M (hides/shows standard buttons row)
                    if self.qmc.flagstart:
                        self.standardButtonsVisibility()
                # Extra event buttons palette. Numerical keys [0,1,2,3,4,5,6,7,8,9]
                elif 47 < k < 58:
                    if not self.app.artisanviewerMode:
                        button = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57]
                        if self.quickEventShortCut:
                            # quick custom event entry
                            eventNr = self.quickEventShortCut[0]
                            eventValueStr = self.quickEventShortCut[1] + str(button.index(k))
                            if eventNr == -1:
                                self.sendmessage(f"{QApplication.translate('Label', 'Event button')} {eventValueStr}")
                            elif eventNr == 4:
                                self.sendmessage(f'SV {eventValueStr}')
                            else:
                                self.sendmessage(f'{self.qmc.etypes[eventNr]} {eventValueStr}')
                            if eventNr == -1:  # Custom Event Button
                                if len(eventValueStr) == 2:
                                    buttonnumber = int(eventValueStr) - 1
                                    if buttonnumber < len(self.extraeventstypes):
                                        self.recordextraevent(buttonnumber, parallel=False, updateButtons=False)
                                    else:
                                        try:
                                            self.sendmessage(QApplication.translate('Message',
                                                                                    f'Button {int(eventValueStr)} not defined'))
                                        except Exception:  # pylint: disable=broad-except
                                            pass
                                else:
                                    # keep on looking for digits
                                    self.quickEventShortCut = (eventNr, eventValueStr)
                            elif eventNr == 4:  # SV
                                if len(eventValueStr) == 3:
                                    # three digits entered, set the SV
                                    self.quickEventShortCut = None
                                    value = int(eventValueStr)
                                    self.clearMessageLine()
                                    self.SVslidermoved = 1
                                    self.updateSVSliderLCD(value)
                                else:
                                    # keep on looking for digits
                                    self.quickEventShortCut = (eventNr, eventValueStr)
                            elif (len(eventValueStr) == 2 and self.eventslidermax[eventNr] <= 100) or (
                                    len(eventValueStr) == 3 and self.eventslidermax[eventNr] > 100):
                                # both digits entered, create the event
                                self.quickEventShortCut = None
                                value = max(self.eventslidermin[eventNr],
                                            min(self.eventslidermax[eventNr], int(eventValueStr)))
                                self.moveslider(eventNr, value)
                                self.recordsliderevent(eventNr)
                            else:
                                # keep on looking for digits
                                self.quickEventShortCut = (eventNr, eventValueStr)
                # now shift modifier is required to switch palettes via number keys
                #                       else:
                #                            if self.buttonpalette_shortcuts:
                #                               self.setbuttonsfrom(button.index(k))
                # note Qt/PyQt maps the ';' and ',' keys reversed from the ASCII mapping
                elif k_txt == ';' and not self.qmc.flagon:  # k == 58    # ";" (application screenshots only if not sampling)
                    self.applicationscreenshot()
                elif k_txt == ':' and not self.qmc.flagon:  # k == 59    # ":" (desktop screenshots only if not sampling)
                    self.desktopscreenshot()
                else:
                    QWidget.keyPressEvent(self, event)
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
            finally:
                self.processingKeyEvent = False

    def releaseminieditor(self) -> None:
        self.lineEvent.releaseKeyboard()
        self.valueEdit.releaseKeyboard()
        self.etimeline.releaseKeyboard()
        self.etypeComboBox.releaseKeyboard()
        self.eNumberSpinBox.releaseKeyboard()
        self.lineEvent.clearFocus()
        self.valueEdit.clearFocus()
        self.etimeline.clearFocus()
        self.etypeComboBox.clearFocus()
        self.eNumberSpinBox.clearFocus()
        self.buttonminiEvent.clearFocus()

    # this function respects the button visibility via self.qmc.buttonvisibility and if button.isDisabled()
    # button = 0:CHARGE, 1:DRY_END, 2:FC_START, 3:FC_END, 4:SC_START, 5:SC_END, 6:DROP, 7:COOL_END; 8:EVENT (EVENT is always enabled!)
    # buttons that trigger events and can be triggered only once
    def nextActiveButton(self, currentButtonIndex: int) -> int:
        if currentButtonIndex == 8:  # current: EVENT
            currentButtonIndex = -1  # next: CHARGE
        if currentButtonIndex == 7:  # current: COOL (last before EVENT)
            # check if the EVENT button is active, else move to the ON/OFF
            if self.eventsbuttonflag:
                return 8  # next: EVENT (always enabled)
            currentButtonIndex = -1  # next: CHARGE
        # we check if the next button is visible, else we recurse (the index of buttonvisibility starts from 0:CHARGE and leads to 7:COOL)
        if self.qmc.buttonvisibility[currentButtonIndex + 1] and self.keyboardButtonList[
            currentButtonIndex + 1].isEnabled():
            return currentButtonIndex + 1
        if not any(self.qmc.buttonvisibility):  # prevent infinite loop if all buttons are hidden
            return 7  # CHARGE
        return self.nextActiveButton(currentButtonIndex + 1)

    def previousActiveButton(self, currentButtonIndex: int) -> int:
        if currentButtonIndex == 0:  # current: CHARGE
            # check if the EVENT button is active, else move beyond
            if self.eventsbuttonflag:
                return 8  # next: EVENT
            currentButtonIndex = 8  # set to EVENT and move to previous non-flat button
        # we check if the previous button is visible, else we recurse (the index of buttonvisibility starts from 0:CHARGE and leads to 7:COOL)
        if self.qmc.buttonvisibility[currentButtonIndex - 1] and self.keyboardButtonList[
            currentButtonIndex - 1].isEnabled():
            return currentButtonIndex - 1
        if not any(self.qmc.buttonvisibility):  # prevent infinite loop if all buttons are hidden
            return 0  # CHARGE
        return self.previousActiveButton(currentButtonIndex - 1)

    def resetKeyboardButtonMarks(self) -> None:
        if self.qmc.flagon:
            if self.simulator:
                self.buttonONOFF.setStyleSheet(self.pushbuttonstyles_simulator['ON'])
            else:
                self.buttonONOFF.setStyleSheet(self.pushbuttonstyles['ON'])
        elif self.simulator:
            self.buttonONOFF.setStyleSheet(self.pushbuttonstyles_simulator['OFF'])
        else:
            self.buttonONOFF.setStyleSheet(self.pushbuttonstyles['OFF'])
        for b in [
            self.buttonCHARGE,  # CHARGE
            self.buttonDRY,  # DRY END
            self.buttonFCs,  # FCs
            self.buttonFCe,  # FCe
            self.buttonSCs,  # SCs
            self.buttonSCe,  # SCe
            self.buttonDROP,  # DROP
            self.buttonCOOL,  # COOL END
            self.buttonEVENT  # EVENT
        ]:
            b.setSelected(False)

    def ignoreFlatButtons(self, moveindex: int) -> int:
        # there is an offset between keyboardButtonList and self.buttonvisibilty of 1
        if (self.keyboardButtonList[moveindex].isFlat() or (
                moveindex < 7 and not self.qmc.buttonvisibility[moveindex]) and
                moveindex < 7):  # exclude the EVENT button that is not covered by self.qmc.buttonvisibility
            # we search forward for the next non-flat button
            m = moveindex + 1
            # we jump over invisible buttons
            while m < 8 and (not self.qmc.buttonvisibility[m] or self.keyboardButtonList[m].isFlat()):
                m = m + 1
            return m
        return moveindex

    # called after markCHARGE, markDROP,....
    # moves keyboard navigation to next button
    # and enables/disables buttons depending if undo is applicable
    def onMarkMoveToNext(self, button: EventPushButton) -> None:
        try:
            this_index = self.keyboardButtonList.index(button)
            if self.qmc.buttonvisibility[this_index]:
                if button.isFlat():
                    if self.keyboardmoveflag:
                        # keyboard navigation is active, button is flat (was just activated), and button is visible
                        # move to the right up to the button index
                        if self.keyboardmoveindex < this_index:
                            for _ in range(this_index - self.keyboardmoveindex):
                                self.moveKbutton('right')
                                if self.keyboardmoveindex == this_index:
                                    break
                        # if we found our button, move one more to the right
                        if this_index == self.keyboardmoveindex:
                            self.moveKbutton('right')  # now to the next
                    # disable all buttons before this_index until the previous registered event
                    for i in range(this_index - 1, -1, -1):
                        self.keyboardButtonList[i].setEnabled(False)
                        if self.qmc.timeindex[i] > 0:
                            # stop if already marked
                            break
                else:
                    # an undo action
                    # enable all buttons before this_index until the previous registered event
                    for i in range(this_index - 1, -1, -1):
                        self.keyboardButtonList[i].setEnabled(True)
                        if self.qmc.timeindex[i] > 0:
                            # stop if already marked
                            break
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot(str)
    def moveKbutton(self, kcommand: str, force: bool = False) -> None:
        # "Enter" toggles ON/OFF keyboard
        if kcommand == 'enter' and self.qmc.flagstart:
            if force or self.keyboardmoveflag == 0:
                # turn on
                self.keyboardmoveflag = 1
                # deactivate slider keyboard control
                self.setSliderFocusPolicy(Qt.FocusPolicy.NoFocus)
                self.sendmessage(QApplication.translate('Message', 'Keyboard moves turned ON'))
                self.keyboardmoveindex = self.ignoreFlatButtons(self.keyboardmoveindex) - 1
            elif self.keyboardmoveflag == 1:
                # turn off
                self.keyboardmoveflag = 0
                # activate slider keyboard control
                self.setSliderFocusPolicy(Qt.FocusPolicy.StrongFocus)
                # clear all
                self.sendmessage(QApplication.translate('Message', 'Keyboard moves turned OFF'))
                self.resetKeyboardButtonMarks()
        # if moves on
        if self.keyboardmoveflag:
            if kcommand == 'space':
                now = libtime.perf_counter()
                if self.lastkeyboardcmd == 0 or (
                        now > self.lastkeyboardcmd + 1):  # accept SPACE keyboard cmds only every 1sec.
                    self.keyboardmove[self.keyboardmoveindex]()  # apply button command
                    # behaviour rules after pressing a button
                    self.lastkeyboardcmd = now
                    self.releaseminieditor()
                else:  # we ignore this event
                    return
            else:
                if kcommand == 'left':
                    nextcmd = self.previousActiveButton(self.keyboardmoveindex)
                else:
                    nextcmd = self.nextActiveButton(self.keyboardmoveindex)
                # activate the button at index nextcmd
                self.keyboardButtonList[nextcmd].setSelected(True)
                self.keyboardButtonList[self.keyboardmoveindex].setSelected(False)
                # update self.keyboardmoveindex
                self.keyboardmoveindex = nextcmd
        # we enable keyboard event processing again

    # sound feedback when pressing a push button
    @pyqtSlot()
    def soundpop(self) -> None:
        if self.soundflag:
            QApplication.beep()

    #    @staticmethod
    #    def removeDisallowedFilenameChars(filename):
    #        import unicodedata # @UnresolvedImport
    #        cleanedFilename = s2a(unicodedata.normalize('NFKD', filename))
    #        import string as libstring
    #        validFilenameChars = f'-_.() {libstring.ascii_letters}{libstring.digits}'
    #        return ''.join(c for c in decodeLocal(cleanedFilename) if c in validFilenameChars)

    def generateFilename(self, prefix: str = '', previewmode: int = 0) -> str:
        filename = ''
        try:
            if prefix == '':
                title = None
                if self.qmc.title != '' and self.qmc.title != QApplication.translate('Scope Title', ''):
                    title = self.qmc.title
                filename = title if prefix == '' and title else prefix
                if filename != '':
                    filename += '_' + self.qmc.roastdate.toString('yy-MM-dd_hhmm')
                else:
                    filename += self.qmc.roastdate.toString('yy-MM-dd_hhmm')
            else:
                filename = self.parseAutosaveprefix(prefix, previewmode=previewmode)
            filename += '.alog'
            #            #clean name (disabled now since Artisan >2.6.0)
            #            filename = self.removeDisallowedFilenameChars(filename)
            filename = filename.strip()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        return filename

    # replace autosave delimited fields with the corresponding value
    # previewmode 0=not preview, 1=preview for while recording, 2=preview for while not recording
    def parseAutosaveprefix(self, fn: str = '', previewmode: int = 0) -> str:
        try:
            # single, leading delimiter for the fields
            fieldDelim = '~'  # note this value is hard coded in autosavefields
            # delimiter for ON only
            onDelim = "'"
            # delimiter for OFF only
            offDelim = '"'

            # when there are no tildes simply add the date for backward compatibility and return.
            if fieldDelim not in fn:
                return f"{fn}_{self.qmc.roastdate.toString('yy-MM-dd_hhmm')}"

            # create the autosave filename
            #  newlines can sneak in from cut and paste from help page
            fn = fn.replace('\n', '')

            # if flagon then the batchcounter has not yet been incremented so we do that here
            if (self.qmc.flagon or previewmode == 1) and self.qmc.batchcounter != -1:
                bnr = self.qmc.batchcounter + 1
            else:
                bnr = self.qmc.roastbatchnr

            # grab the first line of the beens field
            firstline = re.match(r'([^\n]*)', self.qmc.beans)
            beansline = firstline.group(0) if firstline else ''

            # grab the first line of the roasting notes field
            firstline = re.match(r'([^\n]*)', self.qmc.roastingnotes)
            roastingnotesline = firstline.group(0) if firstline else ''

            # grab the first line of the cupping notes field
            firstline = re.match(r'([^\n]*)', self.qmc.cuppingnotes)
            cuppingnotesline = firstline.group(0) if firstline else ''

            # pull in the compute profle data
            # note cp[] values of type float always have one decimal place
            cp = self.computedProfileInformation()

            # build *_long times
            if 'FCs_time' in cp:
                m, s = divmod(cp['FCs_time'], 60)
                fcstime_long = f'{int(m):02.0f}_{int(s):02.0f}'
            else:
                fcstime_long = '00_00'
            if 'DROP_time' in cp:
                m, s = divmod(cp['DROP_time'], 60)
                droptime_long = f'{int(m):02.0f}_{int(s):02.0f}'
            else:
                droptime_long = '00_00'

            # build dtr, devtime and devtime_long
            if 'DROP_time' in cp and 'FCs_time' in cp and cp['DROP_time'] > 0 and cp['DROP_time'] > cp['FCs_time']:
                devtime_int = int(cp['DROP_time'] - cp['FCs_time'])
                devtime = str(devtime_int)
                m, s = divmod(devtime_int, 60)
                devtime_long = f'{int(m):02.0f}_{int(s):02.0f}'
                dtr = f"{self.float2float(100 * (cp['DROP_time'] - cp['FCs_time']) / cp['DROP_time'], 1)}"
            else:
                devtime = '0'
                devtime_long = '00_00'
                dtr = '0.0'

            # calculate density loss
            if 'green_density' in cp and 'roasted_density' in cp:
                density_loss = f"{self.float2float(100 * (cp['green_density'] - cp['roasted_density']) / cp['green_density'], 1)}"
            else:
                density_loss = '0'

            # strips trailing zero decimals from floats
            # but keeps zeros without decimals
            def drop_trailing_zero(s: str) -> str:
                s = s.strip()
                r = s.rstrip('0').rstrip('.')
                if r == '':
                    return s
                return r

            # respect the Decimal Places setting (in Curves>> UI) for fields that are stored as float
            # trailing zeros stripped
            def setdecimal(rawvalue: float) -> str:
                return drop_trailing_zero(f'{rawvalue:.1f}' if self.qmc.LCDdecimalplaces else f'{rawvalue:.0f}')

            # note: fields are delimited only at the start, to avoid ambiguity the shortest similar field string
            #      must be last in the list.  Example, "date_time" must come before "date" in the list.
            fields: List[Tuple[str, str]]
            fields = [
                ('batch_long', f'{self.qmc.roastbatchprefix}{bnr} ({self.qmc.roastbatchpos})'),
                ('batchprefix', self.qmc.roastbatchprefix),
                ('batchcounter', f'{bnr}'),
                ('batchposition', f'{self.qmc.roastbatchpos}'),
                ('batch', f'{self.qmc.roastbatchprefix}{bnr}'),
                ('title', self.qmc.title),
                ('datetime_long', self.qmc.roastdate.toString('yyyy-MM-dd_hhmm')),
                ('datetime', self.qmc.roastdate.toString('yy-MM-dd_hhmm')),
                ('date_long', self.qmc.roastdate.toString('yyyy-MM-dd')),
                ('date', self.qmc.roastdate.toString('yy-MM-dd')),
                ('time', self.qmc.roastdate.toString('hhmm')),
                ('operator', self.qmc.operator),
                ('organization', self.qmc.organization),
                ('machine', self.qmc.roastertype),
                ('capacity', drop_trailing_zero(f'{self.qmc.roastersize}')),
                ('drumspeed', f'{self.qmc.drumspeed}'),
                ('mode', self.qmc.mode),
                ('test', setdecimal(cp['finish_phase_delta_temp']) if 'test' in cp else setdecimal(0.0)),
                ('weightloss', drop_trailing_zero(f"{cp['weight_loss']}") if 'weight_loss' in cp else '0'),
                ('volumegain', drop_trailing_zero(f"{cp['volume_gain']}") if 'volume_gain' in cp else '0'),
                ('densityloss', drop_trailing_zero(density_loss)),
                ('moistureloss', drop_trailing_zero(f"{cp['moisture_loss']}") if 'moisture_loss' in cp else '0'),
                ('weightunits', self.qmc.weight[2]),
                ('weight', drop_trailing_zero(f'{self.qmc.weight[0]}')),
                ('volumeunits', self.qmc.volume[2]),
                ('volume', drop_trailing_zero(f'{self.qmc.volume[0]}')),
                ('densityunits', f'{self.qmc.density[1]}_{self.qmc.density[3]}'),
                ('density', drop_trailing_zero(f'{self.qmc.density[0]}')),
                ('moisture', drop_trailing_zero(f'{self.qmc.moisture_greens}')),
                ('beans_line', beansline),
                ('beans_10', beansline[:10]),
                ('beans_15', beansline[:15]),
                ('beans_20', beansline[:20]),
                ('beans_25', beansline[:25]),
                ('beans_30', beansline[:30]),
                ('beans', beansline[:30]),
                # deprecated, undocumented, remains here for hidden backward compatibility with v2.4RC
                ('roastedweight', drop_trailing_zero(f'{self.float2float(float(self.qmc.weight[1]), 1)}')),
                ('roastedvolume', drop_trailing_zero(f'{self.float2float(float(self.qmc.volume[1]), 1)}')),
                ('roasteddensity', drop_trailing_zero(f'{self.float2float(float(self.qmc.density_roasted[0]), 1)}')),
                ('roastedmoisture', drop_trailing_zero(f'{self.float2float(float(self.qmc.moisture_roasted))}')),
                ('colorwhole', f'{self.qmc.whole_color}'),
                ('colorground', f'{self.qmc.ground_color}'),
                ('colorsystem', f'{self.qmc.color_systems[self.qmc.color_system_idx]}'),
                ('screenmax', f'{self.qmc.beansize_max}'),
                ('screenmin', f'{self.qmc.beansize_min}'),
                ('greenstemp', drop_trailing_zero(f'{self.float2float(float(self.qmc.greens_temp))}')),
                ('ambtemp', drop_trailing_zero(f"{cp['ambient_temperature']}") if 'ambient_temperature' in cp else '0'),
                ('ambhumidity', drop_trailing_zero(f"{cp['ambient_humidity']}") if 'ambient_humidity' in cp else '0'),
                ('ambpressure', drop_trailing_zero(f"{cp['ambient_pressure']}") if 'ambient_pressure' in cp else '0'),
                ('aucbase', drop_trailing_zero(f"{cp['AUCbase']}") if 'AUCbase' in cp else '0'),
                ('auc', drop_trailing_zero(f"{cp['AUC']}") if 'AUC' in cp else '0'),
                ('chargeet', setdecimal(cp['CHARGE_ET']) if 'CHARGE_ET' in cp else setdecimal(0.0)),
                ('chargebt', setdecimal(cp['CHARGE_BT']) if 'CHARGE_BT' in cp else setdecimal(0.0)),
                ('fcset', setdecimal(cp['FCs_ET']) if 'FCs_ET' in cp else setdecimal(0.0)),
                ('fcsbt', setdecimal(cp['FCs_BT']) if 'FCs_BT' in cp else setdecimal(0.0)),
                ('fcstime_long', fcstime_long),
                ('fcstime', f"{int(cp['FCs_time'])}" if 'FCs_time' in cp else '0'),
                ('dropet', setdecimal(cp['DROP_ET']) if 'DROP_ET' in cp else setdecimal(0.0)),
                ('dropbt', setdecimal(cp['DROP_BT']) if 'DROP_BT' in cp else setdecimal(0.0)),
                ('droptime_long', droptime_long),
                ('droptime', f"{int(cp['DROP_time'])}" if 'DROP_time' in cp else '0'),
                ('devtime_long', devtime_long),
                ('devtime', devtime),
                ('dtr', dtr),
                ('dryphasedeltatemp',
                 setdecimal(cp['dry_phase_delta_temp']) if 'dry_phase_delta_temp' in cp else setdecimal(0.0)),
                ('midphasedeltatemp',
                 setdecimal(cp['mid_phase_delta_temp']) if 'mid_phase_delta_temp' in cp else setdecimal(0.0)),
                ('finishphasedeltatemp',
                 setdecimal(cp['finish_phase_delta_temp']) if 'finish_phase_delta_temp' in cp else setdecimal(0.0)),
                ('roastingnotes_line', roastingnotesline),
                ('roastingnotes_10', roastingnotesline[:10]),
                ('roastingnotes_15', roastingnotesline[:15]),
                ('roastingnotes_20', roastingnotesline[:20]),
                ('roastingnotes_25', roastingnotesline[:25]),
                ('roastingnotes_30', roastingnotesline[:30]),
                #                ("roastingnotes",roastingnotesline[:30]),
                ('cuppingnotes_line', cuppingnotesline),
                ('cuppingnotes_10', cuppingnotesline[:10]),
                ('cuppingnotes_15', cuppingnotesline[:15]),
                ('cuppingnotes_20', cuppingnotesline[:20]),
                ('cuppingnotes_25', cuppingnotesline[:25]),
                ('cuppingnotes_30', cuppingnotesline[:30]),
                #                ("cuppingnotes",cuppingnotesline[:30]),
                ('roastweight', drop_trailing_zero(f'{self.float2float(float(self.qmc.weight[1]), 1)}')),
                # deprecated, undocumented
                ('roastvolume', drop_trailing_zero(f'{self.float2float(float(self.qmc.volume[1]), 1)}')),
                # deprecated, undocumented
                ('roastdensity', drop_trailing_zero(f'{self.float2float(float(self.qmc.density_roasted[0]), 1)}')),
                # deprecated, undocumented
                ('roastmoisture', drop_trailing_zero(f'{self.float2float(float(self.qmc.moisture_roasted))}')),
                # deprecated, undocumented
                ('yyyy', self.qmc.roastdate.toString('yyyy')),
                ('yy', self.qmc.roastdate.toString('yy')),
                ('mmm', f"{encodeLocal(self.qmc.roastdate.toString('MMM'))}"),
                ('mm', self.qmc.roastdate.toString('MM')),
                ('ddd', f"{encodeLocal(self.qmc.roastdate.toString('ddd'))}"),
                ('dd', self.qmc.roastdate.toString('dd')),
                ('hour', self.qmc.roastdate.toString('hh')),
                ('minute', self.qmc.roastdate.toString('mm')),
                ('currtime', QDateTime.currentDateTime().toString('yy-MM-dd_hhmmss')),
                #  Energy Use
                ('btubatch', f"{cp['BTU_batch']}" if 'BTU_batch' in cp else '0'),
                ('co2batch', f"{cp['CO2_batch']}" if 'CO2_batch' in cp else '0'),
                ('btupreheat', f"{cp['BTU_preheat']}" if 'BTU_preheat' in cp else '0'),
                ('co2preheat', f"{cp['CO2_preheat']}" if 'CO2_preheat' in cp else '0'),
                ('btubbp', f"{cp['BTU_bbp']}" if 'BTU_bbp' in cp else '0'),
                ('co2bbp', f"{cp['CO2_bbp']}" if 'CO2_bbp' in cp else '0'),
                # ("btucooling", f"{cp["BTU_cooling"]}" if "BTU_cooling" in cp else '0'),
                # ("co2cooling", f"{cp["CO2_cooling"]}" if "CO2_cooling" in cp else '0'),
                ('bturoast', f"{cp['BTU_roast']}" if 'BTU_roast' in cp else '0'),
                ('co2roast', f"{cp['CO2_roast']}" if 'CO2_roast' in cp else '0'),
                ('co2batchpergreenkg', f"{cp['CO2_batch_per_green_kg']}" if 'CO2_batch_per_green_kg' in cp else '0'),
                ('co2roastpergreenkg', f"{cp['CO2_roast_per_green_kg']}" if 'CO2_roast_per_green_kg' in cp else '0'),
                ('btubatchpergreenkg', f"{cp['BTU_batch_per_green_kg']}" if 'BTU_batch_per_green_kg' in cp else '0'),
                ('bturoastpergreenkg', f"{cp['BTU_roast_per_green_kg']}" if 'BTU_roast_per_green_kg' in cp else '0'),
                ('effbatch', f"{cp['KWH_batch_per_green_kg']}" if 'KWH_batch_per_green_kg' in cp else '0'),
                ('effroast', f"{cp['KWH_roast_per_green_kg']}" if 'KEH_roast_per_green_kg' in cp else '0'),
            ]

            _ignorecase = re.IGNORECASE  # @UndefinedVariable
            # text between single quotes ' will show only when recording or for preview recording
            fn = re.sub(fr'{onDelim}([^{onDelim}]+){onDelim}',
                        r'\1', fn) if (previewmode == 1 or (previewmode == 0 and self.qmc.flagon)) else re.sub(
                fr'{onDelim}([^{onDelim}]+){onDelim}', r'', fn)
            # text between double quotes " will show only when flagon is False
            fn = re.sub(fr'{offDelim}([^{offDelim}]+){offDelim}',
                        r'\1', fn) if (previewmode == 2 or (previewmode == 0 and not self.qmc.flagon)) else re.sub(
                fr'{offDelim}([^{offDelim}]+){offDelim}', r'', fn)
            # replace the fields with content
            for fi in fields:
                fn = re.sub(fr'{fieldDelim}{fi[0]}', fr'{str(fi[1])}', fn, count=0, flags=_ignorecase)

            # cleaning is performed in generateFilename()
            # fn = self.removeDisallowedFilenameChars(str(fn))
            # fn = fn.strip()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Error:') + ' parseAutosaveprefix() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))
        return fn

    # automatation of filename when saving a file through keyboard shortcut. Speeds things up for batch roasting.
    # returns filename on success, None otherwise
    def automaticsave(self, interactive: bool = True) -> Optional[str]:
        try:
            if self.qmc.autosavepath and self.qmc.autosaveflag:
                prefix = ''
                if self.qmc.autosaveprefix != '':
                    prefix = self.qmc.autosaveprefix
                elif self.qmc.batchcounter > -1 and self.qmc.roastbatchnr > 0:
                    prefix += self.qmc.batchprefix + str(self.qmc.roastbatchnr)
                elif self.qmc.batchprefix != '':
                    prefix += self.qmc.batchprefix
                filename = self.generateFilename(prefix=prefix)
                filename_path = os.path.join(self.qmc.autosavepath, filename)
                oldDir = str(QDir.current())
                res = QDir.setCurrent(self.qmc.autosavepath)
                if res:
                    # write
                    pf = self.getProfile()
                    sync_record_hash = plus.controller.updateSyncRecordHashAndSync()
                    if sync_record_hash is not None:
                        # we add the hash over the sync record to be able to detect offline changes
                        hash_encoded = encodeLocal(sync_record_hash)
                        if hash_encoded is not None:
                            pf['plus_sync_record_hash'] = hash_encoded
                    self.serialize(filename_path, cast(Dict[str, Any], pf))
                    self.sendmessage(QApplication.translate('Message', 'Profile {0} saved in: {1}').format(filename,
                                                                                                           self.qmc.autosavepath))
                    self.setCurrentFile(filename_path, self.qmc.autosaveaddtorecentfilesflag)
                    self.qmc.fileCleanSignal.emit()

                    if self.qmc.autosavealsopath != '':
                        other_filename_path = os.path.join(self.qmc.autosavealsopath, filename)
                    else:
                        other_filename_path = os.path.join(self.qmc.autosavepath, filename)

                    if self.qmc.autosaveimage and not self.qmc.flagon:
                        if other_filename_path.endswith('.alog'):
                            other_filename_path = other_filename_path[0:-5]
                        if self.qmc.autosaveimageformat == 'PDF':
                            self.saveVectorGraph(extension='.pdf', fname=other_filename_path)
                        elif self.qmc.autosaveimageformat == 'PDF Report' and self.QtWebEngineSupport:
                            self.roastReport(pdf_filename=other_filename_path + '.pdf')
                        elif self.qmc.autosaveimageformat == 'SVG':
                            self.saveVectorGraph(extension='.svg', fname=other_filename_path)
                        elif self.qmc.autosaveimageformat == 'CSV':
                            self.exportCSV(other_filename_path + '.csv')
                        elif self.qmc.autosaveimageformat == 'JSON':
                            self.exportJSON(other_filename_path + '.json')
                        else:
                            #                            self.resizeImg(0,1,self.qmc.autosaveimageformat,fname=other_filename_path)
                            self.resizeImgToSize(0, 0, self.qmc.autosaveimageformat, fname=other_filename_path)
                    # restore dirs
                    QDir.setCurrent(oldDir)
                    # file might be autosaved but not uploaded to plus yet (no DROP registered). This needs to be indicated by a red plus icon
                    try:
                        self.updatePlusStatus()
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)

                    return filename
                self.sendmessage(QApplication.translate('Message', 'Autosave path does not exist. Autosave failed.'))
                return None
            if interactive:
                self.sendmessage(QApplication.translate('Message', 'Empty path or box unchecked in Autosave'))
                self.autosaveconf()
                return None
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Error:') + ' automaticsave() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))
        return None

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewKshortcuts(self, _: bool = False) -> None:
        from help import keyboardshortcuts_help  # pylint: disable=no-name-in-module
        self.helpdialog = self.showHelpDialog(
            self,  # this dialog as parent
            self.helpdialog,  # the existing help dialog
            QApplication.translate('Form Caption', 'Keyboard Shortcuts Help'),
            keyboardshortcuts_help.content())

    @pyqtSlot(bool)
    def decrEventNumber(self, _: bool = False) -> None:
        self.eNumberSpinBox.stepBy(-1)

    @pyqtSlot(bool)
    def incrEventNumber(self, _: bool = False) -> None:
        self.eNumberSpinBox.stepBy(1)

    # moves events in minieditor
    @pyqtSlot(int)
    def changeEventNumber(self, _: int = 0) -> None:
        if self.qmc.designerflag:
            return
        # check
        lenevents = len(self.qmc.specialevents)
        currentevent = self.eNumberSpinBox.value()
        self.eNumberSpinBox.setDisabled(True)
        try:
            self.eventlabel.setText(f'{QApplication.translate("Form Caption", "Event")} #<b>{currentevent} </b>')

            if currentevent == 0:
                self.lineEvent.setText('')
                self.valueEdit.setText('')
                self.etypeComboBox.setCurrentIndex(0)
                self.etimeline.setText('')
                self.qmc.resetlines()
                if not self.qmc.flagstart:
                    self.qmc.fig.canvas.draw()
                return
            if currentevent > lenevents:
                self.eNumberSpinBox.setValue(int(lenevents))
                return
            self.lineEvent.setText(self.qmc.specialeventsStrings[currentevent - 1])
            if self.qmc.timeindex[0] > -1 and len(self.qmc.timex) > self.qmc.timeindex[0]:
                timez = stringfromseconds(
                    self.qmc.timex[self.qmc.specialevents[currentevent - 1]] - self.qmc.timex[self.qmc.timeindex[0]])
            else:
                timez = stringfromseconds(self.qmc.timex[self.qmc.specialevents[currentevent - 1]])
            self.etimeline.setText(timez)
            self.valueEdit.setText(self.qmc.eventsvalues(self.qmc.specialeventsvalue[currentevent - 1]))
            self.etypeComboBox.setCurrentIndex(self.qmc.specialeventstype[currentevent - 1])
            # plot little dot lines
            self.qmc.resetlines()  # clear old
            etimeindex = self.qmc.specialevents[currentevent - 1]
            if currentevent and self.qmc.ax is not None:
                x = [self.qmc.timex[etimeindex], self.qmc.timex[etimeindex], self.qmc.timex[etimeindex],
                     self.qmc.timex[etimeindex]]
                y = [(self.qmc.ylimit_min - 100), self.qmc.temp2[etimeindex], self.qmc.temp1[etimeindex],
                     (self.qmc.ylimit + 100)]
                self.qmc.ax.plot(x, y, marker='o', markersize=12, color='yellow', linestyle='-', linewidth=7, alpha=.4)
                if not self.qmc.flagstart:
                    self.qmc.fig.canvas.draw()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _a, _b, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' changeEventNumber() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            self.eNumberSpinBox.setDisabled(False)
            if self.EventsGroupLayout.isVisible():
                self.eNumberSpinBox.setFocus()

    # updates events from mini edtitor
    @pyqtSlot(bool)
    def miniEventRecord(self, _: bool) -> None:
        lenevents = self.eNumberSpinBox.value()
        if lenevents:
            if self.qmc.timeindex[0] > -1:
                newtime = self.qmc.time2index(
                    self.qmc.timex[self.qmc.timeindex[0]] + stringtoseconds(str(self.etimeline.text())))
            else:
                newtime = self.qmc.time2index(stringtoseconds(str(self.etimeline.text())))
            self.qmc.setEvent(lenevents - 1,
                              newtime,
                              self.etypeComboBox.currentIndex(),
                              self.lineEvent.text(),
                              self.qmc.str2eventsvalue(self.valueEdit.text()))
            self.lineEvent.clearFocus()
            self.eNumberSpinBox.clearFocus()
            self.etimeline.clearFocus()

            self.qmc.redraw(recomputeAllDeltas=False)

            if self.qmc.ax is not None:
                # plot highest ET or BT (sometimes only BT is plot (et is zero))
                etimeindex = self.qmc.specialevents[lenevents - 1]
                if self.qmc.temp1[etimeindex] > self.qmc.temp2[etimeindex]:
                    self.qmc.ax.plot(self.qmc.timex[etimeindex], self.qmc.temp1[etimeindex], 'o',
                                     color=self.qmc.palette['et'])
                else:
                    self.qmc.ax.plot(self.qmc.timex[etimeindex], self.qmc.temp2[etimeindex], 'o',
                                     color=self.qmc.palette['bt'])

            if not self.qmc.flagstart:
                self.qmc.fig.canvas.draw()
                self.qmc.fileDirtySignal.emit()

            string = ''
            if len(self.qmc.specialeventsStrings[lenevents - 1]) > 5:
                string += self.qmc.specialeventsStrings[lenevents - 1][0:5]
                string += '...'

            message = QApplication.translate('Message', 'Event #{0}:  {1} has been updated').format(str(lenevents),
                                                                                                    string)
            self.sendmessage(message)

    @staticmethod
    def strippedName(fullFileName: str) -> str:
        return str(QFileInfo(fullFileName).fileName())

    @staticmethod
    def strippedDir(fullFileName: str) -> str:
        return str(QFileInfo(fullFileName).dir().dirName())

    # fileNamePath holds the full path to the loaded profile
    def setCurrentFile(self, fileNamePath: Optional[str], addToRecent: bool = True) -> None:
        self.curFile = fileNamePath
        if self.curFile is not None:
            try:
                if addToRecent:
                    settings = QSettings()
                    files = toStringList(settings.value('recentFileList'))
                    try:
                        removeAll(files, self.curFile)
                    except ValueError:
                        pass
                    files.insert(0, self.curFile)
                    del files[self.MaxRecentFiles:]
                    settings.setValue('recentFileList', files)
                    for widget in QApplication.topLevelWidgets():
                        if isinstance(widget, ApplicationWindow):
                            widget.updateRecentFileActions()
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
        self.updateWindowTitle()

    def updateRecentFileActions(self) -> None:
        settings = QSettings()
        files = toStringList(settings.value('recentFileList'))
        strippedNames = list(map(self.strippedName, files))
        numRecentFiles = min(len(files), self.MaxRecentFiles)

        for i in range(numRecentFiles):
            strippedName = self.strippedName(files[i])
            if strippedNames.count(strippedName) > 1:
                text = f'&{strippedName} ({self.strippedDir(files[i])})'
            else:
                text = f'&{strippedName}'
            self.recentFileActs[i].setText(text)
            self.recentFileActs[i].setData(files[i])
            self.recentFileActs[i].setVisible(True)

        for j in range(numRecentFiles, self.MaxRecentFiles):
            self.recentFileActs[j].setVisible(False)

    @pyqtSlot(bool)
    def openRecentFile(self, _checked: bool = False) -> None:
        action = self.sender()
        if action and hasattr(action, 'data'):
            filename = toString(action.data())
            if self.comparator is not None:
                self.comparator.addProfiles([filename])
            else:
                self.loadFile(filename)

    def getDefaultPath(self) -> str:
        if not os.path.exists(self.userprofilepath):
            self.userprofilepath = self.profilepath
        return self.userprofilepath

    def setDefaultPath(self, f: Optional[str]) -> None:
        if f:
            filepath_dir = QDir()
            filepath_dir.setPath(f)
            filepath_elements = filepath_dir.absolutePath().split('/')[
                                :-1]  # directories as QStrings (without the filename)
            self.userprofilepath = str(freduce(lambda x, y: x + '/' + y, filepath_elements) + '/')

    def ArtisanOpenFilesDialog(self, msg: Optional[str] = None, ext: str = '*', path: Optional[str] = None) -> List[
        str]:
        if msg is None:
            msg = QApplication.translate('Message', 'Select')
        if path is None:
            path = self.getDefaultPath()
        res: List[str] = QFileDialog.getOpenFileNames(self, msg, path, ext)[0]
        if len(res) > 0:
            self.setDefaultPath(str(res[0]))
        return res

    # the central OpenFileDialog function that should always be called. Besides triggering the file dialog it
    # reads and sets the actual directory
    # if ext is given, the file selector allows only file with that extension to be selected for open
    # if ext_alt is given (not None), all files can be selected, but if a file was selected not having the ext_alt the empty string is returned (used in the background profile dialog)
    def ArtisanOpenFileDialog(self, msg: Optional[str] = None, ext: str = '*', ext_alt: Optional[str] = None,
                              path: Optional[str] = None) -> str:
        if msg is None:
            msg = QApplication.translate('Message', 'Open')
        if path is None:
            path = self.getDefaultPath()
        f: str = str(QFileDialog.getOpenFileName(self, caption=msg, directory=path, filter=ext)[0])
        if ext_alt is not None and not f.endswith(ext_alt):
            return ''
        self.setDefaultPath(f)
        return f

    def ArtisanOpenURLDialog(self, msg: Optional[str] = None) -> Optional[QUrl]:
        if msg is None:
            msg = QApplication.translate('Message', 'Open')
        res = None
        dlg = ArtisanInputDialog(self, self, msg, QApplication.translate('Message', 'URL'))
        if dlg.exec():
            res = dlg.url
        try:  # sip not supported on older PyQt versions (RPi!)
            sip.delete(dlg)
            # print(sip.isdeleted(dlg))
        except Exception:  # pylint: disable=broad-except
            pass
        if res is not None:
            url = QUrl(res.strip(), QUrl.ParsingMode.StrictMode)
            if url.isValid():
                return url
        return None

    # the central SaveFileDialog function that should always be called. Besides triggering the file dialog it
    # reads and sets the actual directory
    def ArtisanSaveFileDialog(self, msg: Optional[str] = None, ext: str = '*.alog', path: Optional[str] = None) -> str:
        if msg is None:
            msg = QApplication.translate('Message', 'Save')
            print(msg)
        if path is None:
            path = self.getDefaultPath()
        f = str(QFileDialog.getSaveFileName(self, msg, path, ext)[0])
        self.setDefaultPath(f)
        return f

    # the central ExistingDirectoryDialog function that should always be called. Besides triggering the file dialog it
    # reads and sets the actual directory
    def ArtisanExistingDirectoryDialog(self, msg: Optional[str] = None, path: Optional[str] = None,
                                       copy: bool = False) -> str:
        if msg is None:
            msg = QApplication.translate('Message', 'Select Directory')
        if path is None:
            path = self.getDefaultPath()
        f = str(QFileDialog.getExistingDirectory(self, msg, path))
        if not copy:
            self.setDefaultPath(f)
        return f

    @pyqtSlot()
    @pyqtSlot(bool)
    def newRoast(self, _: bool = False) -> bool:
        #####################################
        # IF there is an ongoing roast (if START):
        #   (this block allows batch processing using the autosave feature)
        #   if no CHARGE found:
        #       return
        #   if no DROP found:
        #       #use last data point as DROP (mark DROP)
        #       return
        #   stop recording
        #   if there is an autosave path (from autosafe config) AND the autosave flag is ON:
        #       create filename using the autosavepath and date+time
        #   else:
        #       start autosave Dialog to set the name path
        #       return (nothing saved. Cancel New)
        #   reset  (delete everything)
        #   start new roast (START)
        # ELSE (if recording is stopped - OFF):
        #   if no profile present (no data present or profile loaded):
        #       start new roast (START)
        #   else:
        #       reset (reset offers three options: Save,Continue,Cancel)
        #       START
        #########################################

        # turn keepOn temporary off
        tmpKeepON = self.qmc.flagKeepON
        self.qmc.flagKeepON = False

        if self.qmc.flagstart:
            if self.qmc.timeindex[0] == -1:
                self.sendmessage(QApplication.translate('Message',
                                                        'NEW ROAST canceled: incomplete profile lacking CHARGE and DROP found'))
                return False
            # mark drop if not yet done
            if self.qmc.timeindex[6] == 0:
                #                self.qmc.markDrop()
                self.sendmessage(
                    QApplication.translate('Message', 'NEW ROAST canceled: incomplete profile lacking DROP found'))
                return False
            # invoke "OFF"
            self.qmc.OffMonitor()

            filename = self.automaticsave(interactive=False)
            if self.qmc.reset():
                # start new roast
                self.qmc.ToggleRecorder()
                if filename is not None:
                    self.sendmessage(
                        QApplication.translate('Message', '{0} has been saved. New roast has started').format(filename))
        elif len(self.qmc.timex) > 1:
            self.qmc.ToggleRecorder()
        else:
            if self.qmc.flagon:
                self.qmc.OffMonitor()
            if self.qmc.reset():
                self.qmc.ToggleRecorder()
        self.qmc.flagKeepON = tmpKeepON
        return True

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileLoad(self, _: bool = False) -> None:
        try:
            fileName = self.ArtisanOpenFileDialog(ext='*.alog')
            if self.comparator is not None:
                self.comparator.addProfiles([fileName])
            elif fileName:
                self.loadFile(fileName)
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _a, _b, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' fileLoad() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot(str)
    def loadFileSlot(self, filename: str) -> None:
        self.loadFile(filename)

    # loads stored profiles. Called from file menu
    def loadFile(self, filename: str, quiet: bool = False) -> None:
        f = QFile(filename)
        try:
            if self.qmc.clearBgbeforeprofileload:
                self.deleteBackground()
            if not f.open(QFile.OpenModeFlag.ReadOnly):
                raise OSError(f.errorString())
            stream = QTextStream(f)
            firstChar = stream.read(1)
            f.close()
            if firstChar != '{':
                self.sendmessage(QApplication.translate('Message', 'Invalid artisan format'))
                return
            res = self.qmc.reset(redraw=False, soundOn=False)
            obj = cast('ProfileData', self.deserialize(filename))
            if 'extradevices' in obj:
                org_obj_extra_devs = obj['extradevices'][:]
            else:
                org_obj_extra_devs = []
            if res:
                # we avoid the reset within setProfile as we just did a reset and do not want to confuse the ExtraDeviceSettingsBackup
                res = self.setProfile(filename, obj, quiet=quiet, reset=False)
            if res:
                # update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                profile_changed = self.qmc.extradevices != org_obj_extra_devs
                self.setCurrentFile(filename)  # update recent file list
                if profile_changed:
                    # profiles was adjusted, ensure that it does not overwrite the original file on saving
                    self.qmc.fileDirtySignal.emit()
                    self.curFile = None
                else:
                    self.qmc.fileCleanSignal.emit()
                # clear LCDs as the number of decimals based on self.qmc.intChannel() might have changed
                self.qmc.clearLCDs()
                if self.qmc.backgroundprofile is not None:
                    self.qmc.timealign(redraw=False, recompute=False)
                if self.qmc.hideBgafterprofileload:
                    self.qmc.background = False
                    self.autoAdjustAxis()

                #                #####
                #                ##### START of autoCHARGE/autoDROP debug
                #                ##
                #                ## uncomment this section to run BTbreak() to re-calc CHARGE and DROP for debugging
                #                ##
                #                _log.info("PRINT #########")
                #                _log.info("PRINT autoCHARGE/autoDROP debug")
                #                chargetime = 0
                #                if self.qmc.timeindex[0] > -1:
                #                    chargetime = self.qmc.timex[self.qmc.timeindex[0]]
                #                    _log.info("PRINT CHARGE Idx: %s (%s@%s)",self.qmc.timeindex[0],stringfromseconds(self.qmc.timex[self.qmc.timeindex[0]]-chargetime),self.qmc.temp2[self.qmc.timeindex[0]])
                #                if self.qmc.timeindex[6]:
                #                    _log.info("PRINT DROP Idx: %s (%s@%s)",self.qmc.timeindex[6],stringfromseconds(self.qmc.timex[self.qmc.timeindex[6]]-chargetime),self.qmc.temp2[self.qmc.timeindex[6]])
                #                if self.qmc.mode == 'C':
                #                    o = 0.5
                #                else:
                #                    o = 0.5 * 1.8
                #                if self.qmc.mode == 'C':
                #                    oo = 0.2
                #                else:
                #                    oo = 0.2 * 1.8
                #                autoChargeIdx = 0
                #                autoDropIdx = 0
                #                for i in range(len(self.qmc.temp2)):
                #                    if i>=5 and self.qmc.temp2 is not None and self.qmc.temp2 != -1:
                #                        # autoCharge:
                #                        if not autoChargeIdx and ((self.qmc.mode == 'C' and self.qmc.temp2[i] > 77) or (self.qmc.mode == 'F' and self.qmc.temp2[-1] > 170)):
                #                            b = self.BTbreak(i,o)
                #                            if b > 0:
                #                                autoChargeIdx = i - b + 1
                #                                _log.info("PRINT autoChargeIdx: %s (%s@%s)",autoChargeIdx,stringfromseconds(self.qmc.timex[autoChargeIdx]-chargetime),self.qmc.temp2[autoChargeIdx])
                #                                # add event marker
                #                                self.qmc.specialevents.append(autoChargeIdx)
                #                                self.qmc.specialeventstype.append(4)
                #                                self.qmc.specialeventsStrings.append("CHARGE")
                #                                self.qmc.specialeventsvalue.append(0)
                #                        if autoChargeIdx and not autoDropIdx and ((self.qmc.timex[i] - chargetime) > 420) and ((self.qmc.mode == 'C' and self.qmc.temp2[i] > 160) or (self.qmc.mode == 'F' and self.qmc.temp2[i] > 320)):
                #                            b = self.BTbreak(i,oo)
                #                            if b > 0:
                #                                autoDropIdx = i - b + 1
                #                                _log.info("PRINT autoDropIdx: %s (%s@%s)",autoDropIdx,stringfromseconds(self.qmc.timex[autoDropIdx]-chargetime),self.qmc.temp2[autoDropIdx])
                #                                # add event marker
                #                                self.qmc.specialevents.append(autoDropIdx)
                #                                self.qmc.specialeventstype.append(4)
                #                                self.qmc.specialeventsStrings.append("DROP")
                #                                self.qmc.specialeventsvalue.append(0)
                #                ##### END of autoCHARGE/autoDROP debug

                # Plot everything
                self.qmc.redraw()
                self.updatePhasesLCDs()
                message = QApplication.translate('Message', '{0}  loaded ').format(filename)
                self.sendmessage(message)
                _log.info('profile loaded: %s', filename)

                # update plus data set modification date
                self.qmc.plus_file_last_modified = plus.util.getModificationDate(filename)
                self.updatePlusStatus()
                if self.plus_account is not None and plus.config.uuid_tag in obj:
                    QTimer.singleShot(100, plus.sync.sync)

                # check colors
                self.checkColors(self.getcolorPairsToCheck())

        except OSError as ex:
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' {0}: {1}').format(str(ex), str(filename)),
                getattr(exc_tb, 'tb_lineno', '?'))
            # remove file from the recent file list
            settings = QSettings()
            files = toStringList(settings.value('recentFileList'))
            try:
                removeAll(files, filename)
            except ValueError:
                pass
            settings.setValue('recentFileList', files)
            for widget in QApplication.topLevelWidgets():
                if isinstance(widget, ApplicationWindow):
                    widget.updateRecentFileActions()
        except ValueError as ex:
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Value Error:') + ' fileload() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' loadFile() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
        finally:
            if f:
                f.close()

    def loadAlarmsFromProfile(self, filename: str, profile: 'ProfileData') -> None:
        self.qmc.alarmsfile = filename
        self.qmc.alarmsetlabel = profile.get('alarmsetlabel', '')
        self.qmc.alarmflag = profile.get('alarmflag', [])
        if 'alarmguard' in profile:
            self.qmc.alarmguard = profile['alarmguard']
        else:
            self.qmc.alarmguard = [0] * len(self.qmc.alarmflag)
        if 'alarmnegguard' in profile:
            self.qmc.alarmnegguard = profile['alarmnegguard']
        else:
            self.qmc.alarmnegguard = [0] * len(self.qmc.alarmflag)
        if 'alarmtime' in profile:
            self.qmc.alarmtime = profile['alarmtime']
        else:
            self.qmc.alarmtime = [-1] * len(self.qmc.alarmflag)
        if 'alarmoffset' in profile:
            self.qmc.alarmoffset = profile['alarmoffset']
        else:
            self.qmc.alarmoffset = [0] * len(self.qmc.alarmflag)
        if 'alarmcond' in profile:
            self.qmc.alarmcond = profile['alarmcond']
        else:
            self.qmc.alarmcond = [1] * len(self.qmc.alarmflag)
        if 'alarmsource' in profile:
            self.qmc.alarmsource = profile['alarmsource']
        else:
            self.qmc.alarmsource = [1] * len(self.qmc.alarmflag)
        if 'alarmtemperature' in profile:
            self.qmc.alarmtemperature = profile['alarmtemperature']
        else:
            self.qmc.alarmtemperature = [500.] * len(self.qmc.alarmflag)
        if 'alarmaction' in profile:
            self.qmc.alarmaction = profile['alarmaction']
        else:
            self.qmc.alarmaction = [0] * len(self.qmc.alarmflag)
        if 'alarmbeep' in profile:
            self.qmc.alarmbeep = profile['alarmbeep']
        else:
            self.qmc.alarmbeep = [0] * len(self.qmc.alarmflag)
        if 'alarmstrings' in profile:
            self.qmc.alarmstrings = [decodeLocalStrict(x) for x in profile['alarmstrings']]
        else:
            self.qmc.alarmstrings = [''] * len(self.qmc.alarmflag)
        self.qmc.alarmstate = [-1] * len(self.qmc.alarmflag)  # -1 = not triggered; otherwise idx = triggered

    def loadRampSoakFromProfile(self, filename: str, profile: 'ProfileData') -> None:
        self.qmc.rsfile = filename
        if 'svLabel' in profile:
            self.pidcontrol.svLabel = str(profile['svLabel'])
        if 'svValues' in profile:
            self.pidcontrol.svValues = [int(x) for x in profile['svValues']]
        if 'svRamps' in profile:
            self.pidcontrol.svRamps = [int(x) for x in profile['svRamps']]
        if 'svSoaks' in profile:
            self.pidcontrol.svSoaks = [int(x) for x in profile['svSoaks']]
        if 'svActions' in profile:
            self.pidcontrol.svActions = [int(x) for x in profile['svActions']]
        if 'svBeeps' in profile:
            self.pidcontrol.svBeeps = [bool(x) for x in profile['svBeeps']]
        if 'svDescriptions' in profile:
            self.pidcontrol.svDescriptions = [str(x) for x in profile['svDescriptions']]

    def loadEnergyFromProfile(self, profile: 'ProfileData') -> None:
        if 'loadlabels' in profile:
            self.qmc.loadlabels = [str(x) for x in profile['loadlabels']]
        if 'loadratings' in profile:
            self.qmc.loadratings = [float(x) for x in profile['loadratings']]
        if 'ratingunits' in profile:
            self.qmc.ratingunits = [int(x) for x in profile['ratingunits']]
        if 'sourcetypes' in profile:
            self.qmc.sourcetypes = [int(x) for x in profile['sourcetypes']]
        if 'load_etypes' in profile:
            self.qmc.load_etypes = [int(x) for x in profile['load_etypes']]
        if 'presssure_percents' in profile:
            self.qmc.presssure_percents = [bool(x) for x in profile['presssure_percents']]
        if 'loadevent_zeropcts' in profile:
            self.qmc.loadevent_zeropcts = [int(x) for x in profile['loadevent_zeropcts']]
        if 'loadevent_hundpcts' in profile:
            self.qmc.loadevent_hundpcts = [int(x) for x in profile['loadevent_hundpcts']]
        if 'preheatDuration' in profile:
            self.qmc.preheatDuration = profile['preheatDuration']
        if 'preheatenergies' in profile:
            self.qmc.preheatenergies = [float(x) for x in profile['preheatenergies']]
        if 'betweenbatchDuration' in profile:
            self.qmc.betweenbatchDuration = profile['betweenbatchDuration']
        if 'betweenbatchenergies' in profile:
            self.qmc.betweenbatchenergies = [float(x) for x in profile['betweenbatchenergies']]
        if 'coolingDuration' in profile:
            self.qmc.coolingDuration = profile['coolingDuration']
        if 'coolingenergies' in profile:
            self.qmc.coolingenergies = [float(x) for x in profile['coolingenergies']]
        if 'betweenbatch_after_preheat' in profile:
            self.qmc.betweenbatch_after_preheat = profile['betweenbatch_after_preheat']
        if 'electricEnergyMix' in profile:
            self.qmc.electricEnergyMix = profile['electricEnergyMix']

    # returns True if data got updated, False otherwise
    def updateSymbolicETBT(self) -> bool:
        try:
            if len(self.qmc.timex) <= 0:
                self.sendmessage(QApplication.translate('Message', 'No profile data.  ET/BT not recalculated'))
                return False
            if not len(self.qmc.temp1) == len(self.qmc.temp2) == len(self.qmc.timex):
                self.sendmessage(
                    QApplication.translate('Message', 'Problem with the profile data.  ET/BT not recalculated'))
                return False

            # be sure there is an equation to process (already checked in devices.py, repeated here in case this is called from elsewhere)
            nonempty_ETfunction = self.qmc.ETfunction is not None and self.qmc.ETfunction.strip() != ''
            nonempty_BTfunction = self.qmc.BTfunction is not None and self.qmc.BTfunction.strip() != ''
            if (nonempty_ETfunction or nonempty_BTfunction):
                # set dirty
                self.qmc.fileDirtySignal.emit()
                self.curFile = None

                # update ET and BT
                newTemp1 = self.qmc.temp1.copy()
                newTemp2 = self.qmc.temp2.copy()
                for i, tx in enumerate(self.qmc.timex):
                    if nonempty_ETfunction:
                        newTemp1[i] = self.qmc.eval_math_expression(self.qmc.ETfunction, tx)
                    if nonempty_BTfunction:
                        newTemp2[i] = self.qmc.eval_math_expression(self.qmc.BTfunction, tx)
                self.qmc.temp1 = newTemp1.copy()
                self.qmc.temp2 = newTemp2.copy()

                # reset the annotation flags
                self.qmc.l_annotations_dict = {}
                self.qmc.l_event_flags_dict = {}
                return True
            return False
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + 'updateSymbolicETBT(): {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
        return False

    # returns True if data got updated, False otherwise
    def calcVirtualdevices(self, update: bool = False) -> bool:
        try:
            dirty = False
            for j, xd in enumerate(self.qmc.extradevices):
                if xd == 25:  # virtual device
                    if len(self.qmc.extratimex[j]) > 0 and not update:  # move on if the virtual device already has data
                        continue

                    if update and not len(self.qmc.extratimex[j]) > 0:
                        self.qmc.extratimex[j] = self.qmc.timex[:]
                        self.qmc.extratemp1[j] = [-1.] * len(self.qmc.timex)
                        self.qmc.extratemp2[j] = [-1.] * len(self.qmc.timex)
                        y_range1: List[float] = []
                        y_range2: List[float] = []

                    nonempty_mathexpression1 = bool(
                        self.qmc.extramathexpression1[j] is not None and len(self.qmc.extramathexpression1[j].strip()))
                    nonempty_mathexpression2 = bool(
                        self.qmc.extramathexpression2[j] is not None and len(self.qmc.extramathexpression2[j].strip()))

                    if nonempty_mathexpression1 or nonempty_mathexpression2:
                        self.qmc.extratimex[j] = self.qmc.timex[:]

                        # need two separate loops. without y2(x) cannot calculate a dependency on y1(x).

                        if nonempty_mathexpression1:
                            dirty = True
                            self.qmc.extratemp1[j] = [-1.0] * len(self.qmc.extratimex[j])
                            y_range1 = []
                            for i in range(len(self.qmc.extratimex[j])):
                                y_range1.append(self.qmc.eval_math_expression(self.qmc.extramathexpression1[j],
                                                                              self.qmc.extratimex[j][i]))
                            self.qmc.extratemp1[j] = y_range1[:]

                        if nonempty_mathexpression2:
                            dirty = True
                            self.qmc.extratemp2[j] = [-1.0] * len(self.qmc.extratimex[j])
                            y_range2 = []
                            for i in range(len(self.qmc.extratimex[j])):
                                y_range2.append(self.qmc.eval_math_expression(self.qmc.extramathexpression2[j],
                                                                              self.qmc.extratimex[j][i]))
                            self.qmc.extratemp2[j] = y_range2[:]

            if dirty:
                self.qmc.fileDirtySignal.emit()
                return True
            return False

        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' calcVirtualdevices() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
        return False

    # tries to load background from the given path, if that fails try to deref the given UUID
    # returns True on success, Fail otherwise
    def loadbackgroundUUID(self, filename: Optional[str], UUID: Optional[str]) -> bool:
        if filename is not None and filename != '' and os.path.isfile(filename):
            try:
                self.loadbackground(filename)
                return True
            except Exception:  # pylint: disable=broad-except
                return False
        elif UUID is not None:
            filepath = plus.register.getPath(UUID)
            if filepath is not None:
                try:
                    self.loadbackground(filepath)
                    return True
                except Exception:  # pylint: disable=broad-except
                    return False
            else:
                return False
        else:
            return False

    @pyqtSlot()
    def clearbackgroundRedraw(self) -> None:
        self.deleteBackground()
        self.autoAdjustAxis()
        self.qmc.redraw()

    @pyqtSlot(str)
    def loadbackgroundRedraw(self, filename: str) -> None:
        _log.info('loadbackgroundRedraw(%s)', filename)
        if filename is None or len(filename) == 0:
            return
        try:
            filename = os.path.expanduser(filename)  # expand users home directory abbreviation
        except Exception:  # pylint: disable=broad-except
            pass
        if os.path.isfile(filename):
            try:
                self.sendmessage(QApplication.translate('Message', 'Reading background profile...'))
                self.qmc.resetlinecountcaches()
                self.loadbackground(filename)
                self.qmc.background = not self.qmc.hideBgafterprofileload
                self.autoAdjustAxis()
                self.qmc.timealign(redraw=False)
                self.qmc.redraw()

            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
                self.deleteBackground()  # delete a loaded background if any
        else:
            QTimer.singleShot(500, lambda: self.sendmessage(f'file not found: {filename}'))

    # Loads background profile
    # NOTE: this does NOT set the self.qmc.background flag to make the loaded background visible.
    def loadbackground(self, filename: str) -> None:
        f = QFile(filename)
        try:
            if not f.open(QIODevice.OpenModeFlag.ReadOnly):
                raise OSError(f.errorString())
            stream = QTextStream(f)

            firstChar = stream.read(1)
            if firstChar == '{':
                f.close()
                profile = self.deserialize(filename)
                self.qmc.backgroundprofile = cast('ProfileData', profile)
                tb = profile['timex']
                t1 = profile['temp1']
                t2 = profile['temp2']
                t1x = profile['extratemp1']
                t2x = profile['extratemp2']

                # reset the movebackground cache:
                self.qmc.backgroundprofile_moved_x = 0
                self.qmc.backgroundprofile_moved_y = 0
                # delete background annotation positions
                self.qmc.deleteAnnoPositions(foreground=False, background=True)

                # remove the analysis results annotation if it exists
                self.qmc.analysisresultsstr = ''

                if 'mode' in profile:
                    m = str(profile['mode'])
                    # convert modes only if needed comparing the new uploaded mode to the old one.
                    # otherwise it would incorrectly convert the uploaded phases
                    if m == 'F' and self.qmc.mode == 'C':
                        # we have to convert all temperatures from F to C
                        t1 = [fromFtoCstrict(t) for t in t1]
                        t2 = [fromFtoCstrict(t) for t in t2]
                        for e, _ in enumerate(t1x):
                            t1x[e] = [fromFtoCstrict(t) for t in t1x[e]]
                            t2x[e] = [fromFtoCstrict(t) for t in t2x[e]]
                    if m == 'C' and self.qmc.mode == 'F':
                        # we have to convert all temperatures from C to F
                        t1 = [fromCtoFstrict(t) for t in t1]
                        t2 = [fromCtoFstrict(t) for t in t2]
                        for e, _ in enumerate(t1x):
                            t1x[e] = [fromCtoFstrict(t) for t in t1x[e]]
                            t2x[e] = [fromCtoFstrict(t) for t in t2x[e]]

                names1x = [decodeLocalStrict(x) for x in profile['extraname1']]
                names2x = [decodeLocalStrict(x) for x in profile['extraname2']]
                timex = profile['extratimex']
                self.qmc.temp1B, self.qmc.temp2B, self.qmc.timeB, self.qmc.temp1BX, self.qmc.temp2BX = t1, t2, tb, t1x, t2x
                self.qmc.abs_timeB = tb.copy()  # invariant copy of timeB
                self.qmc.extratimexB = timex

                if 'extraDelta1' in profile:
                    self.qmc.temp1Bdelta = profile['extraDelta1']
                else:
                    self.qmc.temp1Bdelta = [False] * len(names1x)
                if 'extraDelta2' in profile:
                    self.qmc.temp2Bdelta = profile['extraDelta2']
                else:
                    self.qmc.temp2Bdelta = [False] * len(names2x)

                # we fill_gaps for all background curves on load, not to have to re-compute those on most redraws
                if self.qmc.interpolateDropsflag:
                    t1 = fill_gaps(t1)  # pyright: ignore[reportGeneralTypeIssues]
                    t2 = fill_gaps(t2)  # pyright: ignore[reportGeneralTypeIssues]
                    for e, _ in enumerate(t1x):
                        t1x[e] = fill_gaps(t1x[e])
                        t2x[e] = fill_gaps(t2x[e])

                # we resample the temperatures to regular interval timestamps
                if tb is not None and tb:
                    tb_lin = numpy.linspace(tb[0], tb[-1], len(tb))
                else:
                    tb_lin = None
                decay_smoothing_p = not self.qmc.optimalSmoothing
                b1 = self.qmc.smooth_list(tb, t1, window_len=self.qmc.curvefilter, decay_smoothing=decay_smoothing_p,
                                          a_lin=tb_lin)
                b2 = self.qmc.smooth_list(tb, t2, window_len=self.qmc.curvefilter, decay_smoothing=decay_smoothing_p,
                                          a_lin=tb_lin)

                self.qmc.extraname1B, self.qmc.extraname2B = names1x, names2x
                b1x = []
                b2x = []
                idx3 = self.qmc.xtcurveidx - 1
                idx4 = self.qmc.ytcurveidx - 1
                n3 = idx3 // 2
                n4 = idx4 // 2

                for i in range(min(len(t1x), len(t2x), len(timex))):
                    # we smooth also that 3rd and 4th background courve only on redraw with the actual smoothing parameters
                    if (self.qmc.xtcurveidx > 0 and n3 == i) or (
                            self.qmc.ytcurveidx > 0 and n4 == i):  # this is the 3rd or 4th background curve to be drawn, we smooth it
                        tx = timex[i]
                        if tx is not None and tx:
                            tx_lin = numpy.linspace(tx[0], tx[-1], len(tx))
                        else:
                            tx_lin = None
                        if (self.qmc.xtcurveidx > 0 and n3 == i and self.qmc.xtcurveidx % 2) or (
                                self.qmc.ytcurveidx > 0 and n4 == i and self.qmc.ytcurveidx % 2):
                            b1x.append(self.qmc.smooth_list(tx, t1x[i], window_len=self.qmc.curvefilter,
                                                            decay_smoothing=decay_smoothing_p, a_lin=tx_lin))
                            b2x.append(numpy.array(t2x[i]))
                        else:
                            b1x.append(numpy.array(t1x[i]))
                            b2x.append(self.qmc.smooth_list(tx, t2x[i], window_len=self.qmc.curvefilter,
                                                            decay_smoothing=decay_smoothing_p, a_lin=tx_lin))
                    else:
                        b1x.append(numpy.array(t1x[i]))
                        b2x.append(numpy.array(t2x[i]))
                # NOTE: parallel assignment after time intensive smoothing is necessary to avoid redraw failure!
                self.qmc.stemp1B, self.qmc.stemp2B, self.qmc.stemp1BX, self.qmc.stemp2BX = b1, b2, b1x, b2x
                self.qmc.backgroundEvents = profile['specialevents']
                self.qmc.backgroundEtypes = profile['specialeventstype']
                self.qmc.backgroundEvalues = profile['specialeventsvalue']
                self.qmc.backgroundEStrings = [decodeLocalStrict(x) for x in profile['specialeventsStrings']]
                self.qmc.backgroundFlavors = profile['flavors']
                self.qmc.titleB = decodeLocalStrict(profile['title'])

                if 'roastbatchnr' in profile:
                    try:
                        self.qmc.roastbatchnrB = int(profile['roastbatchnr'])
                    except Exception:  # pylint: disable=broad-except
                        pass
                    self.qmc.roastbatchprefixB = profile['roastbatchprefix']
                    try:
                        self.qmc.roastbatchposB = profile['roastbatchpos']
                    except Exception:  # pylint: disable=broad-except
                        pass
                else:
                    self.qmc.roastbatchnrB = 0
                    self.qmc.roastbatchprefixB = ''
                    self.qmc.roastbatchposB = 1

                # on request we load alarms from backgrounds, but keep in mind as this would overload the one of the foreground profile that automatically loads this background
                if self.qmc.loadalarmsfrombackground:
                    self.loadAlarmsFromProfile(filename, self.qmc.backgroundprofile)

                # Ramp/Soak Profiles
                if self.pidcontrol.loadRampSoakFromBackground:
                    self.loadRampSoakFromProfile(filename, self.qmc.backgroundprofile)

                # if old format < 0.5.0 version  (identified by numbers less than 1.). convert
                if self.qmc.backgroundFlavors[0] < 1. and self.qmc.backgroundFlavors[-1] < 1.:
                    l = len(self.qmc.backgroundFlavors)
                    for i in range(l):
                        self.qmc.backgroundFlavors[i] *= 10.
                    self.qmc.backgroundFlavors = self.qmc.backgroundFlavors[:(l - 1)]
                if 'etypes' in profile:
                    self.qmc.Betypes = [decodeLocalStrict(x) for x in profile['etypes']]
                    if 'default_etypes' in profile:
                        default_etypes = profile['default_etypes']
                        for i, _ in enumerate(self.qmc.Betypes):
                            if default_etypes[i]:
                                self.qmc.Betypes[i] = self.qmc.etypesdefault[i]
                if 'timeindex' in profile:
                    self.qmc.timeindexB = [max(0, v) if i > 0 else max(-1, v) for i, v in enumerate(
                        profile['timeindex'])]  # if new profile found with variable timeindex
                    if self.qmc.phasesfromBackgroundflag:
                        # adjust phases by DryEnd and FCs events from background profile
                        if self.qmc.timeindexB[1] and len(self.qmc.timeindexB) > 1 and len(self.qmc.temp2B) > \
                                self.qmc.timeindexB[1]:
                            val = self.qmc.temp2B[self.qmc.timeindexB[1]]
                            if val is not None:
                                self.qmc.phases[1] = int(round(val))
                        if self.qmc.timeindexB[2] and len(self.qmc.timeindexB) > 2 and len(self.qmc.temp2B) > \
                                self.qmc.timeindexB[2]:
                            val = self.qmc.temp2B[self.qmc.timeindexB[2]]
                            if val is not None:
                                self.qmc.phases[2] = int(round(val))
                elif 'startend' in profile:
                    startendB = profile['startend']
                    varCB = profile['cracks']
                    dryendB = profile.get('dryend', [0, 0])
                    times = []
                    times.append(startendB[0])
                    times.append(dryendB[0])
                    times.append(varCB[0])
                    times.append(varCB[2])
                    times.append(varCB[4])
                    times.append(varCB[6])
                    times.append(startendB[2])
                    self.qmc.timebackgroundindexupdate(times[:])
                self.qmc.timeindexB = self.qmc.timeindexB + [0 for i in range(8 - len(self.qmc.timeindexB))]
                try:
                    self.qmc.background_profile_sampling_interval = profile['samplinginterval']
                except Exception:  # pylint: disable=broad-except
                    pass  # might not exist in older profiles
                try:
                    try:
                        self.qmc.TP_time_B_loaded = None
                        self.qmc.TP_time_B_loaded = profile['computed']['TP_time']
                        if self.qmc.TP_time_B_loaded is not None:
                            if self.qmc.timeindexB[0] > 0:
                                # CHARGE set
                                shift = self.qmc.timeB[self.qmc.timeindexB[0]]
                            else:
                                shift = 0
                            TP_index = self.qmc.backgroundtime2index(self.qmc.TP_time_B_loaded + shift)
                        else:
                            TP_index = None
                        _, _, auc, _ = self.ts(tp=TP_index, background=True)
                    except Exception:  # pylint: disable=broad-except
                        _, _, auc, _ = self.ts(tp=None, background=True)
                    self.qmc.AUCbackground = auc
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)

                if not self.curFile and len(self.qmc.timex) < 10:  # if no foreground is loaded, autoadjustAxis
                    self.autoAdjustAxis(True)

                message = QApplication.translate('Message', 'Background {0} loaded successfully {1}').format(filename,
                                                                                                             '')
                self.sendmessage(message)
                self.qmc.backgroundpath = str(filename)
                self.qmc.backgroundUUID = profile.get('roastUUID', None)
                _log.info('background profile loaded: %s', filename)
            else:
                self.sendmessage(QApplication.translate('Message', 'Invalid artisan format'))
        except OSError as e:
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' loadbackground() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return

        except ValueError as e:
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Value Error:') + ' loadbackground() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' loadbackground() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return
        finally:
            if f:
                f.close()

    @staticmethod
    def eventtime2string(time: float) -> str:
        if time == 0.0:
            return ''
        di, mo = divmod(time, 60)
        #        return '%02d:%02d'% divmod(time,60)
        return f'{di:02.0f}:{mo:02.0f}'

    # read Artisan CSV
    def importCSV(self, filename: str) -> None:
        import csv
        try:
            with open(filename, newline='', encoding='utf-8') as csvFile:
                data = csv.reader(csvFile, delimiter='\t')
                # read file header
                header = next(data)
                date = QDate.fromString(header[0].split('Date:')[1], "dd'.'MM'.'yyyy")
                if len(header) > 11:
                    try:
                        tm = QTime.fromString(header[11].split('Time:')[1])
                        self.qmc.roastdate = QDateTime(date, tm)
                    except Exception:  # pylint: disable=broad-except
                        self.qmc.roastdate = QDateTime(date, QTime())
                else:
                    self.qmc.roastdate = QDateTime(date, QTime())
                self.qmc.roastepoch = self.qmc.roastdate.toSecsSinceEpoch()
                self.qmc.roasttzoffset = 0
                unit = header[1].split('Unit:')[1]
                # set temperature mode
                if unit == 'F' and self.qmc.mode == 'C':
                    self.qmc.celsiusMode()
                if unit == 'C' and self.qmc.mode == 'F':
                    self.qmc.celsiusMode()
                # read column headers
                fields = next(data)
                extra_fields = fields[5:]  # columns after 'Event'
                # add devices if needed
                for _ in range(max(0, (len(extra_fields) // 2) - len(self.qmc.extradevices))):
                    self.addDevice()
                # set extra device names # NOTE: eventuelly we want to set/change the names only for devices that were just added in the line above!?
                for i, ef in enumerate(extra_fields):
                    if i % 2 == 1:
                        # odd
                        self.qmc.extraname2[int(i / 2)] = ef
                    else:
                        # even
                        self.qmc.extraname1[int(i / 2)] = ef
                # read data
                last_time: Optional[float] = None

                i = 0
                for row in data:
                    i = i + 1
                    items = list(zip(fields, row))
                    item = {}
                    for (name, value) in items:
                        item[name] = value.strip()
                    # add one measurement
                    timez = float(stringtoseconds(item['Time1']))
                    if not last_time or last_time < timez:
                        self.qmc.timex.append(timez)
                        self.qmc.temp1.append(float(item['ET']))
                        self.qmc.temp2.append(float(item['BT']))
                        for j, ef in enumerate(extra_fields):
                            if j % 2 == 1:
                                # odd
                                self.qmc.extratemp2[int(j / 2)].append(float(item[ef]))
                            else:
                                # even
                                self.qmc.extratimex[int(j / 2)].append(timez)
                                self.qmc.extratemp1[int(j / 2)].append(float(item[ef]))
                    last_time = timez
            # set events
            CHARGE_entry = header[2].split('CHARGE:')
            if len(CHARGE_entry) > 1:
                CHARGE = stringtoseconds(CHARGE_entry[1])
                if CHARGE >= 0:
                    self.qmc.timeindex[0] = max(-1, self.qmc.time2index(CHARGE))
                else:
                    self.qmc.timeindex[0] = -1
            else:
                self.qmc.timeindex[0] = -1
            DRYe = stringtoseconds(header[4].split('DRYe:')[1])
            if DRYe > 0:
                self.qmc.timeindex[1] = max(0, self.qmc.time2index(DRYe))
            FCs = stringtoseconds(header[5].split('FCs:')[1])
            if FCs > 0:
                self.qmc.timeindex[2] = max(0, self.qmc.time2index(FCs))
            FCe = stringtoseconds(header[6].split('FCe:')[1])
            if FCe > 0:
                self.qmc.timeindex[3] = max(0, self.qmc.time2index(FCe))
            SCs = stringtoseconds(header[7].split('SCs:')[1])
            if SCs > 0:
                self.qmc.timeindex[4] = max(0, self.qmc.time2index(SCs))
            SCe = stringtoseconds(header[8].split('SCe:')[1])
            if SCe > 0:
                self.qmc.timeindex[5] = max(0, self.qmc.time2index(SCe))
            DROP = stringtoseconds(header[9].split('DROP:')[1])
            if DROP > 0:
                self.qmc.timeindex[6] = max(0, self.qmc.time2index(DROP))
            COOL = stringtoseconds(header[10].split('COOL:')[1])
            if COOL > 0:
                self.qmc.timeindex[7] = max(0, self.qmc.time2index(COOL))
            self.qmc.endofx = self.qmc.timex[-1]
            self.sendmessage(QApplication.translate('Message', 'Artisan CSV file loaded successfully'))
            self.qmc.fileDirtySignal.emit()
            self.autoAdjustAxis()
            self.qmc.redraw()
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' importCSV() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

    def addSerialPort(self) -> None:
        n = len(self.qmc.extradevices) - 1
        self.extraser = self.extraser[:n]
        self.extraser.append(serialport(self))
        self.extracomport = self.extracomport[:n]
        self.extracomport.append('COM1')
        self.extrabaudrate = self.extrabaudrate[:n]
        self.extrabaudrate.append(9600)
        self.extrabytesize = self.extrabytesize[:n]
        self.extrabytesize.append(8)
        self.extraparity = self.extraparity[:n]
        self.extraparity.append('E')
        self.extrastopbits = self.extrastopbits[:n]
        self.extrastopbits.append(1)
        self.extratimeout = self.extratimeout[:n]
        self.extratimeout.append(0.4)

    def addDevice(self) -> None:
        try:
            self.qmc.extradevices.append(25)
            n = len(self.qmc.extradevices)
            self.qmc.extradevicecolor1 = self.qmc.extradevicecolor1[:n - 1]
            self.qmc.extradevicecolor1.append('#000000')  # init color to black
            self.qmc.extradevicecolor2 = self.qmc.extradevicecolor2[:n - 1]
            self.qmc.extradevicecolor2.append('#000000')
            self.qmc.extraname1 = self.qmc.extraname1[:n - 1]
            self.qmc.extraname1.append('Extra 1')
            self.qmc.extraname2 = self.qmc.extraname2[:n - 1]
            self.qmc.extraname2.append('Extra 2')
            self.qmc.extramathexpression1 = self.qmc.extramathexpression1[:n - 1]
            self.qmc.extramathexpression1.append('')
            self.qmc.extramathexpression2 = self.qmc.extramathexpression2[:n - 1]
            self.qmc.extramathexpression2.append('')

            # ensure that the curves and LCDs of the new device are visible:
            self.extraLCDvisibility1[n - 1] = True
            self.extraLCDvisibility2[n - 1] = True
            self.extraCurveVisibility1[n - 1] = True
            self.extraCurveVisibility2[n - 1] = True
            self.extraDelta1[n - 1] = False
            self.extraDelta2[n - 1] = False
            self.extraFill1[n - 1] = 0
            self.extraFill2[n - 1] = 0

            # create new serial port (but don't open it yet). Store initial settings
            self.addSerialPort()

            # add new line variables
            self.qmc.extratimex = self.qmc.extratimex[:n - 1]
            self.qmc.extratimex.append([])
            self.qmc.extratemp1 = self.qmc.extratemp1[:n - 1]
            self.qmc.extratemp1.append([])
            self.qmc.extratemp2 = self.qmc.extratemp2[:n - 1]
            self.qmc.extratemp2.append([])
            self.qmc.extrastemp1 = self.qmc.extrastemp1[:n - 1]
            self.qmc.extrastemp1.append([])
            self.qmc.extrastemp2 = self.qmc.extrastemp2[:n - 1]
            self.qmc.extrastemp2.append([])
            self.qmc.extractimex1 = self.qmc.extractimex1[:n - 1]
            self.qmc.extractimex1.append([])
            self.qmc.extractimex2 = self.qmc.extractimex2[:n - 1]
            self.qmc.extractimex2.append([])
            self.qmc.extractemp1 = self.qmc.extractemp1[:n - 1]
            self.qmc.extractemp1.append([])
            self.qmc.extractemp2 = self.qmc.extractemp2[:n - 1]
            self.qmc.extractemp2.append([])

            # add new style variables
            self.qmc.extralinestyles1 = self.qmc.extralinestyles1[:n - 1]
            self.qmc.extralinestyles1.append(self.qmc.linestyle_default)
            self.qmc.extralinestyles2 = self.qmc.extralinestyles2[:n - 1]
            self.qmc.extralinestyles2.append(self.qmc.linestyle_default)
            self.qmc.extradrawstyles1 = self.qmc.extradrawstyles1[:n - 1]
            self.qmc.extradrawstyles1.append(self.qmc.drawstyle_default)
            self.qmc.extradrawstyles2 = self.qmc.extradrawstyles2[:n - 1]
            self.qmc.extradrawstyles2.append(self.qmc.drawstyle_default)
            self.qmc.extralinewidths1 = self.qmc.extralinewidths1[:n - 1]
            self.qmc.extralinewidths1.append(self.qmc.extra_linewidth_default)
            self.qmc.extralinewidths2 = self.qmc.extralinewidths2[:n - 1]
            self.qmc.extralinewidths2.append(self.qmc.extra_linewidth_default)
            self.qmc.extramarkers1 = self.qmc.extramarkers1[:n - 1]
            self.qmc.extramarkers1.append(self.qmc.marker_default)
            self.qmc.extramarkers2 = self.qmc.extramarkers2[:n - 1]
            self.qmc.extramarkers2.append(self.qmc.marker_default)
            self.qmc.extramarkersizes1 = self.qmc.extramarkersizes1[:n - 1]
            self.qmc.extramarkersizes1.append(self.qmc.markersize_default)
            self.qmc.extramarkersizes2 = self.qmc.extramarkersizes2[:n - 1]
            self.qmc.extramarkersizes2.append(self.qmc.markersize_default)

            # add two extra lines in figure for extra ET and extra BT
            l = len(self.qmc.extradevices) - 1  # new line index
            if self.qmc.ax is not None:
                self.qmc.extratemp1lines.append(self.qmc.ax.plot(self.qmc.extratimex[l], self.qmc.extratemp1[l],
                                                                 color=self.qmc.extradevicecolor1[l],
                                                                 markersize=self.qmc.extramarkersizes1[l],
                                                                 marker=self.qmc.extramarkers1[l],
                                                                 linewidth=self.qmc.extralinewidths1[l],
                                                                 linestyle=self.qmc.extralinestyles1[l],
                                                                 drawstyle=self.qmc.extradrawstyles1[l],
                                                                 label=self.qmc.extraname1[l])[0])
                self.qmc.extratemp2lines.append(self.qmc.ax.plot(self.qmc.extratimex[l], self.qmc.extratemp2[l],
                                                                 color=self.qmc.extradevicecolor2[l],
                                                                 markersize=self.qmc.extramarkersizes2[l],
                                                                 marker=self.qmc.extramarkers2[l],
                                                                 linewidth=self.qmc.extralinewidths2[l],
                                                                 linestyle=self.qmc.extralinestyles2[l],
                                                                 drawstyle=self.qmc.extradrawstyles2[l],
                                                                 label=self.qmc.extraname2[l])[0])

            self.updateExtraLCDvisibility()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    # Write readings to Artisan JSON file
    def exportJSON(self, filename: str) -> bool:
        try:
            with open(filename, 'w', encoding='utf-8') as outfile:
                from json import dump as json_dump
                json_dump(self.getProfile(), outfile, ensure_ascii=True)
                outfile.write('\n')
            return True
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' exportJSON() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return False

    def indent(self, elem: 'XMLElement', level: int = 0) -> None:
        i = '\r\n' + level * '  '  # Windows line ending (as Pilot is only available on Windows)
        if len(elem):
            if not elem.text or not elem.text.strip():
                elem.text = i + '  '
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
            for e in elem:
                self.indent(e, level + 1)
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
        elif level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i

    def exportPilot(self, filename: str) -> bool:
        try:
            # warning popup if filename contains more than one _
            # only contain one _ followed by an index number like Name_0.xml
            s = filename.split('_')
            if (len(s) < 2 or len(s) > 2):
                QMessageBox.warning(self, QApplication.translate('Message', 'Warning'),
                                    QApplication.translate('Message',
                                                           'The Probat Shop Pilot Software expects files named <Name>_<Index>.xml like in Test_0.xml on import'))

            import xml.etree.ElementTree as ET
            tree = ET.Element('recipe')

            charge = ET.SubElement(tree, 'charge')
            charge.text = str(self.float2float(
                self.convertWeight(self.qmc.weight[0], self.qmc.weight_units.index(self.qmc.weight[2]), 1)))

            beans = ET.SubElement(tree, 'coffeetype')
            if self.qmc.beans and self.qmc.beans != '':
                beans.text = self.qmc.beans

            color = ET.SubElement(tree, 'coffeecolor')
            if self.qmc.ground_color:
                color.text = str(self.qmc.ground_color)

            endtemperature = ET.SubElement(tree, 'endtemperature')
            endtime = ET.SubElement(tree, 'endtime')
            cooling = ET.SubElement(tree, 'coolingtime')

            roaster = ET.SubElement(tree, 'roaster')
            if self.qmc.roastertype and self.qmc.roastertype != '':
                roaster.text = self.qmc.roastertype

            notes = ET.SubElement(tree, 'notes')
            if self.qmc.roastingnotes and self.qmc.roastingnotes != '':
                notes.text = self.qmc.roastingnotes

            roasttype = ET.SubElement(tree, 'roasttype')
            roasttype.text = '0'  # 0: global, 1: time, 2: temp

            recipedata = ET.SubElement(tree, 'recipedata_temp_unit')
            recipedata.text = self.qmc.mode

            diagrampoints = ET.SubElement(tree, 'diagrampoints')

            time_tag = 'sTime'
            temp_tag = 'nTemperature'
            burner_tag = 'nBurnercapacity'
            rising_tag = 'bRising'

            # if CHARGE is defined, only export from CHARGE
            # if DROP is defined only export until DROP
            end_temp = None
            end_time = None
            idx = 1
            for i, tx in enumerate(self.qmc.timex):
                if (self.qmc.timeindex[0] < 0 or i >= self.qmc.timeindex[0]) and (
                        self.qmc.timeindex[6] == 0 or i <= self.qmc.timeindex[6]):
                    data = ET.SubElement(diagrampoints, 'data', index=str(idx))
                    t = tx
                    if self.qmc.timeindex[0] > -1:
                        t = t - self.qmc.timex[self.qmc.timeindex[0]]
                    time = ET.SubElement(data, time_tag)
                    di, mo = divmod(t, 60)
                    time.text = f'{di:02.0f}:{mo:02.0f}'
                    end_time = time.text
                    temp = ET.SubElement(data, temp_tag)
                    temp.text = str(int(round(self.qmc.temp2[i])))
                    end_temp = temp.text
                    burner = ET.SubElement(data, burner_tag)
                    if len(self.qmc.extradevices) > 0:
                        burner.text = str(max(0, int(round(self.qmc.extratemp1[0][i]))))
                    else:
                        burner.text = '0'
                    rising = ET.SubElement(data, rising_tag)
                    delta2i = self.qmc.delta2[i]
                    if delta2i is not None and delta2i > 0:
                        rising.text = 'true'
                    else:
                        rising.text = 'false'
                    idx = idx + 1

            if end_temp:
                endtemperature.text = end_temp

            if end_temp:
                endtime.text = end_time

            # if self.qmc.timeindex[7]:
            #     t = self.qmc.timex[self.qmc.timeindex[7]] - self.qmc.timex[self.qmc.timeindex[6]]
            #     di, mo = divmod(t, 60)
            #     cooling.text = f'{di:02.0f}:{mo:02.0f}'
            # else:
            #     cooling.text = '00:00'

            switchpoints = ET.SubElement(tree, 'switchpoints')
            # take data from 2nd extra event type
            idx = 1
            for i, spe in enumerate(self.qmc.specialevents):
                if self.qmc.specialeventstype[i] == 3 and (
                        self.qmc.timeindex[0] < 0 or spe >= self.qmc.timeindex[0]) and (
                        self.qmc.timeindex[6] == 0 or spe <= self.qmc.timeindex[6]):
                    data = ET.SubElement(switchpoints, 'data', index=str(idx))
                    if self.qmc.timeindex[0] > -1 and len(self.qmc.timex) > self.qmc.timeindex[0]:
                        timez = stringfromseconds(self.qmc.timex[spe] - self.qmc.timex[self.qmc.timeindex[0]])
                    else:
                        timez = stringfromseconds(self.qmc.timex[spe])
                    t = spe
                    if self.qmc.timeindex[0] > -1:
                        t = t - self.qmc.timeindex[0]
                    time = ET.SubElement(data, time_tag)
                    time.text = timez
                    temp = ET.SubElement(data, temp_tag)
                    temp.text = str(int(round(self.qmc.temp2[spe])))
                    burner = ET.SubElement(data, burner_tag)
                    b = self.qmc.eventsInternal2ExternalValue(self.qmc.specialeventsvalue[i])
                    burner.text = str(int(round(b)))
                    rising = ET.SubElement(data, rising_tag)
                    delta2i = self.qmc.delta2[i]
                    if delta2i is not None and delta2i > 0:
                        rising.text = 'true'
                    else:
                        rising.text = 'false'
                    idx = idx + 1
            self.indent(tree)
            ET.ElementTree(tree).write(filename, encoding='utf-8', xml_declaration=True)
            return True
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' exportPilot() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return False

    # Write readings to RoastLogger CSV file
    def exportRoastLogger(self, filename: str) -> bool:
        import csv
        try:
            with open(filename, 'w', encoding='utf-8') as outfile:
                outfile.write('Log created at 09:00:00 ' + self.qmc.roastdate.date().toString("dd'/'MM'/'yyyy") + '\n')
                outfile.write('Use Options|Set template for new log to modify this template.\n')
                outfile.write('------------------------------------------------------\n')
                outfile.write('Bean/Blend name:\n')
                outfile.write('\n')
                outfile.write('Profile description:\n')
                outfile.write('\n')
                outfile.write('Roast notes:\n')
                outfile.write('\n')
                outfile.write('Cupping results:\n')
                outfile.write('\n')
                outfile.write('Roast Logger Copyright ? T. R. Coxon (GreenBean TMC).\n')
                outfile.write(
                    'Roast started at 09:00:00 ' + self.qmc.roastdate.date().toString("dd'/'MM'/'yyyy") + '\n')
                if len(self.qmc.timex) > 0:
                    CHARGE = self.qmc.timex[self.qmc.timeindex[0]]
                else:
                    CHARGE = 0
                writer = csv.writer(outfile, delimiter=',')
                writer.writerow(['Elapsed time ', ' T1 ', ' T2 ', ' Event type'])
                for i, _ in enumerate(self.qmc.timex):
                    if i == self.qmc.timeindex[0]:
                        kind = 'Beans loaded'
                    elif i != 0 and i == self.qmc.timeindex[2]:
                        kind = 'First crack start'
                    elif i != 0 and i == self.qmc.timeindex[3]:
                        kind = 'First crack end'
                    elif i != 0 and i == self.qmc.timeindex[4]:
                        kind = 'Second crack start'
                    elif i != 0 and i == self.qmc.timeindex[6]:
                        kind = 'Beans ejected'
                    else:
                        kind = 'timer'
                    writer.writerow([stringfromseconds(self.qmc.timex[i] - CHARGE), f'{self.qmc.temp2[i]:.1f}',
                                     f'{self.qmc.temp1[i]:.1f}', kind])
                outfile.write('\n')
                outfile.write('@actionT1Table\n')
                outfile.write('120|null|30\n')
                outfile.write('178|65|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('\n')
                outfile.write('@actionSecsFCTable\n')
                outfile.write('60|50|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('null|null|null\n')
                outfile.write('\n')
                outfile.write('@actionResetTable\n')
                outfile.write('100|0\n')
                outfile.write('\n')
                outfile.write('@loadBeansTable\n')
                outfile.write('146\n')
                outfile.write('\n')
            return True
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' exportRoastLogger() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return False

    def importJSON(self, filename: str) -> None:
        try:
            from json import load as json_load
            with open(filename, encoding='utf-8') as infile:
                obj = json_load(infile)
                res = self.setProfile(filename, obj)
            if res:
                # update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                self.qmc.fileDirtySignal.emit()
                self.autoAdjustAxis()
                self.qmc.redraw()
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' importJSON() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

    def importRoastLogger(self, filename: str) -> None:
        self.resetExtraDevices()
        # the RoastLogger file might be in utf-8 or latin1 encoding, we cannot know so let's test both
        try:
            try:
                self.importRoastLoggerEnc(filename, 'utf-8')
            except Exception:  # pylint: disable=broad-except
                self.importRoastLoggerEnc(filename, 'latin1')
            self.qmc.fileDirtySignal.emit()
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' importRoastLogger() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

    def resetExtraDevices(self) -> None:
        try:
            # delete extra devices
            self.qmc.extradevices = []
            # delete extra curves variables
            self.qmc.extratimex = []
            self.qmc.extradevicecolor1 = []
            self.qmc.extradevicecolor2 = []
            self.qmc.extratemp1, self.qmc.extratemp2 = [], []
            self.qmc.extrastemp1, self.qmc.extrastemp2 = [], []
            self.qmc.extractimex1, self.qmc.extractimex2 = [], []
            self.qmc.extractemp1, self.qmc.extractemp2 = [], []
            self.qmc.extratemp1lines, self.qmc.extratemp2lines = [], []
            self.qmc.extralinestyles1, self.qmc.extralinestyles2 = [], []
            self.qmc.extradrawstyles1, self.qmc.extradrawstyles2 = [], []
            self.qmc.extralinewidths1, self.qmc.extralinewidths2 = [], []
            self.qmc.extramarkers1, self.qmc.extramarkers2 = [], []
            self.qmc.extramarkersizes1, self.qmc.extramarkersizes2 = [], []
            self.qmc.extraname1, self.qmc.extraname2 = [], []
            self.qmc.extramathexpression1, self.qmc.extramathexpression2 = [], []
            self.extraLCDvisibility1, self.extraLCDvisibility2 = [False] * self.nLCDS, [False] * self.nLCDS
            self.extraCurveVisibility1, self.extraCurveVisibility2 = [True] * self.nLCDS, [True] * self.nLCDS
            self.extraDelta1, self.extraDelta2 = [False] * self.nLCDS, [False] * self.nLCDS
            self.extraFill1, self.extraFill2 = [0] * self.nLCDS, [0] * self.nLCDS
            for i in range(len(self.extraLCDlabel1)):
                self.extraLCDframe1[i].setVisible(False)
                self.extraLCDframe2[i].setVisible(False)
            # delete EXTRA COMM PORTS VARIABLES
            self.extraser = []
            self.extracomport, self.extrabaudrate, self.extrabytesize, self.extraparity, self.extrastopbits, self.extratimeout = [], [], [], [], [], []
            self.qmc.resetlinecountcaches()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' resetExtraDevices(): {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

    def importRoastLoggerEnc(self, filename: str, enc: str = 'utf-8') -> None:
        import csv
        roastlogger_action_section = ''
        # use io.open instead of open to have encoding support on Python 2
        with open(filename, encoding=enc) as infile:
            obj: 'ProfileData' = {}
            obj['mode'] = 'C'
            obj['title'] = str(QFileInfo(filename).fileName())
            roastdate_str = encodeLocal(QDate.currentDate().toString())
            if roastdate_str is not None:
                obj['roastdate'] = roastdate_str
            # read roastdate from file
            while True:
                l = infile.readline()
                if l.startswith('Roast started at '):
                    # extract roast date
                    roastdate = QDateTime(QDate.fromString(l.split(' ')[-1][0:10], "dd'/'MM'/'yyyy"), QTime())
                    if not roastdate.isNull():
                        roastdate_str = encodeLocal(roastdate.date().toString())
                        if roastdate_str is not None:
                            obj['roastdate'] = roastdate_str
                    break
                if l == '':
                    break
            timeindex = [-1, 0, 0, 0, 0, 0, 0, 0]
            timex = []
            temp1 = []
            temp2 = []
            data = csv.reader(infile, delimiter=',')
            # read file header
            next(data)  # we do not use the labels
            # header = list(map(lambda s:s.strip(),next(data)))
            while True:
                fields = next(data)
                if len(fields) == 0:
                    break
                timex.append(float(stringtoseconds(fields[0])))
                try:
                    t1 = float(fields[1])
                except Exception:  # pylint: disable=broad-except
                    t1 = -1
                temp1.append(t1)
                try:
                    t2 = float(fields[2])
                except Exception:  # pylint: disable=broad-except
                    t2 = -1
                temp2.append(t2)
                event = fields[3]
                if event == 'Beans loaded':
                    timeindex[0] = max(-1, len(timex) - 1)
                elif event == 'First crack start':
                    timeindex[2] = max(0, len(timex) - 1)
                elif event == 'First crack end':
                    timeindex[3] = max(0, len(timex) - 1)
                elif event == 'Second crack start':
                    timeindex[4] = max(0, len(timex) - 1)
                elif event == 'Beans ejected':
                    timeindex[6] = max(0, len(timex) - 1)
            obj['timeindex'] = timeindex
            obj['timex'] = timex
            obj['temp1'] = temp2
            obj['temp2'] = temp1

            if len(obj['timex']) > 2:
                obj['samplinginterval'] = (obj['timex'][-1] - obj['timex'][0]) / (len(obj['timex']) - 1)

            res = self.setProfile(filename, obj)

            error_msg: str = ''
            try:
                if self.qmc.loadalarmsfromprofile:
                    self.qmc.alarmsfile = filename
                    roastlogger_action_section = 'No actions loaded'

                    # Find sliders - exact names of the sliders must be defined
                    slider_power = -1
                    slider_fan = -1
                    try:
                        slider_power = self.qmc.etypes.index('Power')
                    except Exception:  # pylint: disable=broad-except
                        pass
                    try:
                        slider_fan = self.qmc.etypes.index('Fan')
                    except Exception:  # pylint: disable=broad-except
                        pass
                    # load only "Power" and "Fan" events
                    if slider_power != -1 and slider_fan != -1:
                        data_action = csv.reader(infile, delimiter='|')

                        self.qmc.alarmsetlabel = ''
                        self.qmc.alarmflag = []
                        self.qmc.alarmguard = []
                        self.qmc.alarmnegguard = []
                        self.qmc.alarmtime = []
                        self.qmc.alarmoffset = []
                        self.qmc.alarmcond = []
                        self.qmc.alarmstate = []
                        self.qmc.alarmsource = []
                        self.qmc.alarmtemperature = []
                        self.qmc.alarmaction = []
                        self.qmc.alarmbeep = []
                        self.qmc.alarmstrings = []

                        while True:
                            fields_action = next(data_action)
                            if len(fields_action) == 0:
                                pass
                            elif len(fields_action) == 1 and fields_action[0].startswith('@'):
                                roastlogger_action_section = fields_action[0]
                            # process items in the section
                            elif roastlogger_action_section.startswith('@actionT1Table'):
                                if len(fields_action) == 3 and fields_action[0] != 'null':
                                    # add temp alarm - POWER
                                    self.qmc.alarmflag.append(1)
                                    self.qmc.alarmguard.append(-1)
                                    self.qmc.alarmnegguard.append(-1)
                                    self.qmc.alarmtime.append(8)  # after TP
                                    self.qmc.alarmoffset.append(0)
                                    self.qmc.alarmcond.append(1)
                                    self.qmc.alarmstate.append(-1)
                                    self.qmc.alarmsource.append(1)  # BT
                                    self.qmc.alarmtemperature.append(float(fields_action[0]))
                                    self.qmc.alarmaction.append(3 + slider_power)  # SLIDER POWER
                                    self.qmc.alarmbeep.append(0)
                                    self.qmc.alarmstrings.append(QApplication.translate('Label', fields_action[1]))

                                    # add temp alarm - FAN
                                    self.qmc.alarmflag.append(1)
                                    self.qmc.alarmguard.append(-1)
                                    self.qmc.alarmnegguard.append(-1)
                                    self.qmc.alarmtime.append(8)  # after TP
                                    self.qmc.alarmoffset.append(0)
                                    self.qmc.alarmcond.append(1)
                                    self.qmc.alarmstate.append(-1)
                                    self.qmc.alarmsource.append(1)  # BT
                                    self.qmc.alarmtemperature.append(int(fields_action[0]))
                                    self.qmc.alarmaction.append(3 + slider_fan)  # SLIDER FAN
                                    self.qmc.alarmbeep.append(0)
                                    self.qmc.alarmstrings.append(QApplication.translate('Label', fields_action[2]))

                            elif roastlogger_action_section.startswith('@actionSecsFCTable'):
                                if len(fields_action) == 3 and fields_action[0] != 'null':
                                    # add time alarm - POWER
                                    self.qmc.alarmflag.append(1)
                                    self.qmc.alarmguard.append(-1)
                                    self.qmc.alarmnegguard.append(-1)
                                    self.qmc.alarmtime.append(2)  # after FC
                                    self.qmc.alarmoffset.append(int(fields_action[0]))
                                    self.qmc.alarmcond.append(1)
                                    self.qmc.alarmstate.append(-1)
                                    self.qmc.alarmsource.append(-3)  # no source - this is time alarm
                                    self.qmc.alarmtemperature.append(0)
                                    self.qmc.alarmaction.append(3 + slider_power)  # SLIDER POWER
                                    self.qmc.alarmbeep.append(0)
                                    self.qmc.alarmstrings.append(QApplication.translate('Label', fields_action[1]))

                                    # add time alarm - FAN
                                    self.qmc.alarmflag.append(1)
                                    self.qmc.alarmguard.append(-1)
                                    self.qmc.alarmnegguard.append(-1)
                                    self.qmc.alarmtime.append(2)  # after FC
                                    self.qmc.alarmoffset.append(int(fields_action[0]))
                                    self.qmc.alarmcond.append(1)
                                    self.qmc.alarmstate.append(-1)
                                    self.qmc.alarmsource.append(-3)  # no source - this is time alarm
                                    self.qmc.alarmtemperature.append(0)
                                    self.qmc.alarmaction.append(3 + slider_fan)  # SLIDER FAN
                                    self.qmc.alarmbeep.append(0)
                                    self.qmc.alarmstrings.append(QApplication.translate('Label', fields_action[2]))

                            elif roastlogger_action_section.startswith('@actionResetTable'):
                                if len(fields_action) == 2 and fields_action[0] != 'null':
                                    # add temp alarm - POWER
                                    self.qmc.alarmflag.insert(0, 1)
                                    self.qmc.alarmguard.insert(0, -1)
                                    self.qmc.alarmnegguard.insert(0, -1)
                                    self.qmc.alarmtime.insert(0, 9)  # after ON
                                    self.qmc.alarmoffset.insert(0, 0)
                                    self.qmc.alarmcond.insert(0, 1)
                                    self.qmc.alarmstate.insert(0, -1)
                                    self.qmc.alarmsource.insert(0, 1)  # BT
                                    self.qmc.alarmtemperature.insert(0, 0)
                                    self.qmc.alarmaction.insert(0, 3 + slider_power)  # SLIDER POWER
                                    self.qmc.alarmbeep.insert(0, 0)
                                    self.qmc.alarmstrings.insert(0, QApplication.translate('Label', fields_action[0]))

                                    # add temp alarm - FAN
                                    self.qmc.alarmflag.insert(0, 1)
                                    self.qmc.alarmguard.insert(0, -1)
                                    self.qmc.alarmnegguard.insert(0, -1)
                                    self.qmc.alarmtime.insert(0, 9)  # after ON
                                    self.qmc.alarmoffset.insert(0, 0)
                                    self.qmc.alarmcond.insert(0, 1)
                                    self.qmc.alarmstate.insert(0, -1)
                                    self.qmc.alarmsource.insert(0, 1)  # BT
                                    self.qmc.alarmtemperature.insert(0, 0)
                                    self.qmc.alarmaction.insert(0, 3 + slider_fan)  # SLIDER POWER
                                    self.qmc.alarmbeep.insert(0, 0)
                                    self.qmc.alarmstrings.insert(0, QApplication.translate('Label', fields_action[1]))

                            elif roastlogger_action_section.startswith('@loadBeansTable'):
                                if len(fields_action) == 1 and fields_action[0] != 'null':
                                    # add START TRIGGER - 10 DEG before charge temp
                                    self.qmc.alarmflag.insert(2, 1)
                                    self.qmc.alarmguard.insert(2, -1)
                                    self.qmc.alarmnegguard.insert(2, -1)
                                    self.qmc.alarmtime.insert(0, 9)  # after ON
                                    self.qmc.alarmoffset.insert(2, 0)
                                    self.qmc.alarmcond.insert(2, 1)
                                    self.qmc.alarmstate.insert(2, -1)
                                    self.qmc.alarmsource.insert(2, 1)  # BT
                                    self.qmc.alarmtemperature.insert(2, float(fields_action[0]) - 10)
                                    self.qmc.alarmaction.insert(2, 7)  # initiate 7 (START)
                                    self.qmc.alarmbeep.insert(2, 0)
                                    self.qmc.alarmstrings.insert(2, QApplication.translate('Label', 'Start recording'))

                                    # add CHARGE alarm
                                    self.qmc.alarmflag.insert(3, 1)
                                    self.qmc.alarmguard.insert(3, -1)
                                    self.qmc.alarmnegguard.insert(3, -1)
                                    self.qmc.alarmtime.insert(3, -1)  # after START
                                    self.qmc.alarmoffset.insert(3, 0)
                                    self.qmc.alarmcond.insert(3, 1)
                                    self.qmc.alarmstate.insert(3, -1)
                                    self.qmc.alarmsource.insert(3, 1)  # BT
                                    self.qmc.alarmtemperature.insert(3, float(fields_action[0]))
                                    self.qmc.alarmaction.insert(3, 0)  # POPUP
                                    self.qmc.alarmbeep.insert(3, 1)  # do beep for charge
                                    self.qmc.alarmstrings.insert(3, QApplication.translate('Label', 'Charge the beans'))
                                break
                    else:
                        if slider_power == -1:
                            error_msg += "Could not find slider named 'Power' "
                        if slider_fan == -1:
                            error_msg += "Could not find slider named 'Fan' "
                        error_msg += 'Please rename sliders in Config - Events menu'

            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
                if roastlogger_action_section == 'No actions loaded':
                    error_msg += 'Roastlogger file does not contain actions.  Alarms will not be loaded.'
                else:
                    error_msg += "Roastlogger actions are not complete. Last loaded section is '" + roastlogger_action_section + "'"

            finally:
                if res:
                    self.autoAdjustAxis()
                    self.qmc.redraw()

            if error_msg != '':
                self.qmc.adderror(
                    QApplication.translate('Error Message', 'Roastlogger log file exception: ' + error_msg))

    # Write readings to Artisan csv file
    def exportCSV(self, filename: str) -> bool:
        import csv
        try:
            if len(self.qmc.timex) > 0:
                # make timex zero based
                timex_zero = [tx - self.qmc.timex[0] for tx in self.qmc.timex]
                if self.qmc.timeindex[0] > -1:
                    CHARGE = timex_zero[self.qmc.timeindex[0]]
                else:
                    CHARGE = -1
                TP_index = self.findTP()
                TP = 0.
                if TP_index and TP_index < len(timex_zero):
                    TP = timex_zero[TP_index]
                dryEndIndex = self.findDryEnd(TP_index)
                if self.qmc.timeindex[1]:
                    # manual dryend available
                    DRYe = timex_zero[self.qmc.timeindex[1]]
                # we use the dryEndIndex respecting the dry phase
                elif dryEndIndex < len(timex_zero):
                    DRYe = timex_zero[dryEndIndex]
                else:
                    DRYe = 0.
                if self.qmc.timeindex[2]:
                    FCs = timex_zero[self.qmc.timeindex[2]]
                else:
                    FCs = 0
                if self.qmc.timeindex[3]:
                    FCe = timex_zero[self.qmc.timeindex[3]]
                else:
                    FCe = 0
                if self.qmc.timeindex[4]:
                    SCs = timex_zero[self.qmc.timeindex[4]]
                else:
                    SCs = 0
                if self.qmc.timeindex[5]:
                    SCe = timex_zero[self.qmc.timeindex[5]]
                else:
                    SCe = 0
                if self.qmc.timeindex[6]:
                    DROP = timex_zero[self.qmc.timeindex[6]]
                else:
                    DROP = 0
                if self.qmc.timeindex[7]:
                    COOL = timex_zero[self.qmc.timeindex[7]]
                else:
                    COOL = 0
                events = [
                    [CHARGE, 'CHARGE', False],
                    [TP, 'TP', False],
                    [DRYe, 'DRY End', False],
                    [FCs, 'FCs', False],
                    [FCe, 'FCe', False],
                    [SCs, 'SCs', False],
                    [SCe, 'SCe', False],
                    [DROP, 'DROP', False],
                    [COOL, 'COOL', False],
                ]
                with open(filename, 'w', newline='', encoding='utf8') as outfile:
                    writer = csv.writer(outfile, delimiter='\t')
                    writer.writerow([
                        'Date:' + self.qmc.roastdate.date().toString("dd'.'MM'.'yyyy"),
                        'Unit:' + self.qmc.mode,
                        'CHARGE:' + (self.eventtime2string(CHARGE) if CHARGE > 0 else ('' if CHARGE < 0 else '00:00')),
                        'TP:' + self.eventtime2string(TP),
                        'DRYe:' + self.eventtime2string(DRYe),
                        'FCs:' + self.eventtime2string(FCs),
                        'FCe:' + self.eventtime2string(FCe),
                        'SCs:' + self.eventtime2string(SCs),
                        'SCe:' + self.eventtime2string(SCe),
                        'DROP:' + self.eventtime2string(DROP),
                        'COOL:' + self.eventtime2string(COOL),
                        'Time:' + self.qmc.roastdate.time().toString()[:-3]])
                    headrow: List[str] = (['Time1', 'Time2', 'ET', 'BT', 'Event'] + freduce(
                        lambda x, y: x + [str(y[0]), str(y[1])], list(
                            zip(self.qmc.extraname1[0:len(self.qmc.extradevices)],
                                self.qmc.extraname2[0:len(self.qmc.extradevices)])), []))  # type: ignore
                    writer.writerow(headrow)
                    last_time: Optional[str] = None
                    for i, tx in enumerate(timex_zero):
                        if tx >= CHARGE >= 0:
                            di, mo = divmod(tx - CHARGE, 60)
                            time2 = f'{di:02.0f}:{mo:02.0f}'
                        else:
                            time2 = ''
                        event = ''
                        for ev in events:
                            if not ev[2] and (ev[0] != 0 or (ev[1] == 'CHARGE' and ev[0] != -1)) and int(
                                    round(tx)) == int(round(ev[0])):  # type: ignore
                                event = ev[
                                    1]  # type: ignore # Incompatible types in assignment (expression has type "object", variable has type "str")
                                ev[2] = True
                                break
                        di, mo = divmod(tx, 60)
                        time1 = f'{di:02.0f}:{mo:02.0f}'
                        if last_time is None or last_time != time1:
                            extratemps = []
                            for j in range(len(self.qmc.extradevices)):
                                if j < len(self.qmc.extratemp1) and i < len(self.qmc.extratemp1[j]):
                                    extratemps.append(str(self.qmc.extratemp1[j][i]))
                                else:
                                    extratemps.append('-1')
                                if j < len(self.qmc.extratemp2) and i < len(self.qmc.extratemp2[j]):
                                    extratemps.append(str(self.qmc.extratemp2[j][i]))
                                else:
                                    extratemps.append('-1')
                            writer.writerow([str(time1), str(time2), str(self.qmc.temp1[i]), str(self.qmc.temp2[i]),
                                             str(event)] + extratemps)
                        last_time = time1
                return True
            return False
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' exportCSV() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return False

    # Write readings to Artisan Excel file
    def exportExcel(self, filename: str) -> bool:
        try:
            if len(self.qmc.timex) > 0:
                CHARGE = self.qmc.timex[self.qmc.timeindex[0]]
                TP_index = self.findTP()
                TP = 0.
                if TP_index and TP_index < len(self.qmc.timex):
                    TP = self.qmc.timex[TP_index]
                dryEndIndex = self.findDryEnd(TP_index)
                if self.qmc.timeindex[1]:
                    # manual dryend available
                    DRYe = self.qmc.timex[self.qmc.timeindex[1]]
                # we use the dryEndIndex respecting the dry phase
                elif dryEndIndex < len(self.qmc.timex):
                    DRYe = self.qmc.timex[dryEndIndex]
                else:
                    DRYe = 0.
                if self.qmc.timeindex[2]:
                    FCs = self.qmc.timex[self.qmc.timeindex[2]]
                else:
                    FCs = 0.
                if self.qmc.timeindex[3]:
                    FCe = self.qmc.timex[self.qmc.timeindex[3]]
                else:
                    FCe = 0.
                if self.qmc.timeindex[4]:
                    SCs = self.qmc.timex[self.qmc.timeindex[4]]
                else:
                    SCs = 0.
                if self.qmc.timeindex[5]:
                    SCe = self.qmc.timex[self.qmc.timeindex[5]]
                else:
                    SCe = 0.
                if self.qmc.timeindex[6]:
                    DROP = self.qmc.timex[self.qmc.timeindex[6]]
                else:
                    DROP = 0.
                if self.qmc.timeindex[7]:
                    COOL = self.qmc.timex[self.qmc.timeindex[7]]
                else:
                    COOL = 0.
                events: List[List[Union[float, str, bool]]] = [
                    [CHARGE, 'Charge', False],
                    [TP, 'TP', False],
                    [DRYe, 'Dry End', False],
                    [FCs, 'FCs', False],
                    [FCe, 'FCe', False],
                    [SCs, 'SCs', False],
                    [SCe, 'SCe', False],
                    [DROP, 'Drop', False],
                    [COOL, 'COOL', False],
                ]

                from openpyxl import Workbook
                from openpyxl.styles import Font, Alignment  # , Fill # ML: not used

                wb = Workbook()
                ws: Optional[
                    Worksheet] = wb.active  # type: ignore # Incompatible types in assignment (expression has type "Optional[_WorkbookChild]", variable has type "Optional[Worksheet]")
                if ws is not None:
                    ws.title = QApplication.translate('HTML Report Template', 'Profile')

                    bf = Font(bold=True)

                    # summary section
                    fieldlist = [
                        ['Date', self.qmc.roastdate.date().toString("dd'.'MM'.'yyyy")],
                        ['Unit', self.qmc.mode],
                        ['CHARGE', self.eventtime2string(max(0, CHARGE - CHARGE))],
                        ['TP', self.eventtime2string(max(0, TP - CHARGE))],
                        ['DRYe', self.eventtime2string(max(0, DRYe - CHARGE))],
                        ['FCs', self.eventtime2string(max(0, FCs - CHARGE))],
                        ['FCe', self.eventtime2string(max(0, FCe - CHARGE))],
                        ['SCs', self.eventtime2string(max(0, SCs - CHARGE))],
                        ['SCe', self.eventtime2string(max(0, SCe - CHARGE))],
                        ['DROP', self.eventtime2string(max(0, DROP - CHARGE))],
                        ['COOL', self.eventtime2string(max(0, COOL - CHARGE))],
                        ['Time', self.qmc.roastdate.time().toString()[:-3]],
                    ]
                    for f, fe in enumerate(fieldlist):
                        ws.cell(row=1, column=f + 1).value = fe[0]
                        ws.cell(row=1, column=f + 1).font = bf
                        ws.cell(row=2, column=f + 1).value = fe[1]
                        ws.cell(row=1, column=f + 1).alignment = Alignment(horizontal='center')
                        ws.cell(row=2, column=f + 1).alignment = Alignment(horizontal='center')

                    # profile data
                    fieldlist = [
                        ['Time1', 'time1'],
                        ['Time2', 'time2'],
                        ['ET', 'self.qmc.temp1[i]'],
                        ['BT', 'self.qmc.temp2[i]'],
                        [deltaLabelUTF8 + 'BT', 'self.qmc.delta2[i]'],
                        ['Event', 'event'],
                    ]
                    extraslist = list(zip(self.qmc.extraname1[0:len(self.qmc.extradevices)],
                                          self.qmc.extraname2[0:len(self.qmc.extradevices)]))

                    r = 4  # starting row number
                    c = 0  # starting col number
                    for fe in fieldlist:
                        c += 1
                        ws.cell(row=r, column=c, value=fe[0])
                    for el in extraslist:
                        c += 1
                        ws.cell(row=r, column=c).value = el[0]
                        c += 1
                        ws.cell(row=r, column=c).value = el[1]

                    for i in range(ws.max_column):
                        ws.cell(row=r, column=i + 1).font = bf
                        ws.cell(row=r, column=i + 1).alignment = Alignment(horizontal='center')
                    r += 1

                    last_time: Optional[str] = None
                    for i, tx in enumerate(self.qmc.timex):
                        if tx >= CHARGE > 0:
                            di, mo = divmod(tx - CHARGE, 60)
                            time2 = f'{di:02.0f}:{mo:02.0f}'  # @UnusedVariable # pylint: disable=unused-variable # noqa: F841
                        else:
                            time2 = ''  # @UnusedVariable #@UnusedVariable # pylint: disable=unused-variable # noqa: F841
                        event: str = ''  # @UnusedVariable #@UnusedVariable # pylint: disable=unused-variable # noqa: F841
                        for ev in events:
                            if not ev[2] and int(round(tx)) == int(round(ev[0])):  # type: ignore
                                event = ev[
                                    1]  # type: ignore # #@UnusedVariable #@UnusedVariable # pylint: disable=unused-variable # noqa: F841
                                ev[2] = True
                                break
                        if i in self.qmc.specialevents:
                            for n, m in enumerate(self.qmc.specialevents):
                                if m == i:
                                    if len(event) > 0:
                                        event += ','
                                    # if self.qmc.specialeventstype[n] == 4:       # only export the event Description for -- type events
                                    if len(self.qmc.specialeventsStrings[
                                               n]) > 0:  # always export the event Description if it exist
                                        event += self.qmc.specialeventsStrings[n]
                                    else:
                                        event += self.qmc.etypesf(self.qmc.specialeventstype[n])[
                                                     0] + self.qmc.eventsvalues(self.qmc.specialeventsvalue[n])

                        di, mo = divmod(tx, 60)
                        time1 = f'{di:02.0f}:{mo:02.0f}'
                        if last_time is None or last_time != time1:
                            extratemps = []
                            for j in range(len(self.qmc.extradevices)):
                                if j < len(self.qmc.extratemp1) and i < len(self.qmc.extratemp1[j]):
                                    extratemps.append(self.qmc.extratemp1[j][i])
                                else:
                                    extratemps.append(-1)
                                if j < len(self.qmc.extratemp2) and i < len(self.qmc.extratemp2[j]):
                                    extratemps.append(self.qmc.extratemp2[j][i])
                                else:
                                    extratemps.append(-1)

                            for j in range(6):
                                try:
                                    ws.cell(row=r + i, column=j + 1).value = eval(
                                        fieldlist[j][1])  # pylint: disable=eval-used
                                except Exception:  # pylint: disable=broad-except
                                    pass

                            for j, etemp in enumerate(extratemps):
                                ws.cell(row=r + i, column=7 + j).value = etemp

                        last_time = time1

                wb.save(filename)
                return True
            return False
        except Exception as ex:
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            lineno = 0
            if exc_tb is not None:
                lineno = exc_tb.tb_lineno
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' exportExcel() {0}').format(str(ex)), lineno)
            return False

    # Write object to file
    @staticmethod
    def serialize(filename: str, obj: Dict[str, Any]) -> None:
        fn = str(filename)
        import codecs  # @Reimport
        with codecs.open(fn, 'w+', encoding='utf-8') as f:
            f.write(repr(obj))
        # PLUS
        # fill plus UUID register
        try:
            if obj is not None and plus.config.uuid_tag in obj:
                plus.register.addPath(obj[plus.config.uuid_tag], fn)
        except Exception:  # pylint: disable=broad-except
            pass

    # Read object from file
    def deserialize(self, filename: str) -> Dict[str, Any]:
        obj: Dict[str, Any] = {}
        try:
            fn = str(filename)
            if os.path.exists(fn):
                import codecs
                with codecs.open(fn, 'rb', encoding='utf-8') as f:
                    obj = ast.literal_eval(f.read())  # pylint: disable=eval-used
            # PLUS
            # fill plus UUID register
            try:
                if plus.config.uuid_tag in obj:
                    plus.register.addPath(obj[plus.config.uuid_tag], fn)
            except Exception:  # pylint: disable=broad-except
                pass

            return obj
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' deserialize() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return obj

    def ensureCorrectExtraDeviceListLength(self) -> None:
        self.qmc.extraname1 = self.qmc.extraname1[:len(self.qmc.extradevices)]
        self.qmc.extraname1 = self.qmc.extraname1 + ['Extra 1'] * max(0, len(self.qmc.extradevices) - len(
            self.qmc.extraname1))
        self.qmc.extraname2 = self.qmc.extraname2[:len(self.qmc.extradevices)]
        self.qmc.extraname2 = self.qmc.extraname2 + ['Extra 2'] * max(0, len(self.qmc.extradevices) - len(
            self.qmc.extraname2))
        self.qmc.extramathexpression1 = self.qmc.extramathexpression1[:len(self.qmc.extradevices)]
        self.qmc.extramathexpression1 = self.qmc.extramathexpression1 + [''] * max(0, len(self.qmc.extradevices) - len(
            self.qmc.extramathexpression1))
        self.qmc.extramathexpression2 = self.qmc.extramathexpression2[:len(self.qmc.extradevices)]
        self.qmc.extramathexpression2 = self.qmc.extramathexpression2 + [''] * max(0, len(self.qmc.extradevices) - len(
            self.qmc.extramathexpression2))
        self.qmc.extradevicecolor1 = self.qmc.extradevicecolor1[:len(self.qmc.extradevices)]
        self.qmc.extradevicecolor1 = self.qmc.extradevicecolor1 + ['#000000'] * max(0, len(self.qmc.extradevices) - len(
            self.qmc.extradevicecolor1))
        self.qmc.extradevicecolor2 = self.qmc.extradevicecolor2[:len(self.qmc.extradevices)]
        self.qmc.extradevicecolor2 = self.qmc.extradevicecolor2 + ['#000000'] * max(0, len(self.qmc.extradevices) - len(
            self.qmc.extradevicecolor2))

    def saveExtradeviceSettings(self) -> None:
        self.org_extradevicesettings = {
            'extradevices': self.qmc.extradevices,
            'extradevicecolor1': self.qmc.extradevicecolor1,
            'extradevicecolor2': self.qmc.extradevicecolor2,
            'extraname1': self.qmc.extraname1,
            'extraname2': self.qmc.extraname2,
            'extramathexpression1': self.qmc.extramathexpression1,
            'extramathexpression2': self.qmc.extramathexpression2,
            'extraLCDvisibility1': self.extraLCDvisibility1,
            'extraLCDvisibility2': self.extraLCDvisibility2,
            'extraCurveVisibility1': self.extraCurveVisibility1,
            'extraCurveVisibility2': self.extraCurveVisibility2,
            'extraDelta1': self.extraDelta1,
            'extraDelta2': self.extraDelta2,
            'extraFill1': self.extraFill1,
            'extraFill2': self.extraFill2,
            'extralinestyles1': self.qmc.extralinestyles1,
            'extralinestyles2': self.qmc.extralinestyles2,
            'extradrawstyles1': self.qmc.extradrawstyles1,
            'extradrawstyles2': self.qmc.extradrawstyles2,
            'extralinewidths1': self.qmc.extralinewidths1,
            'extralinewidths2': self.qmc.extralinewidths2,
            'extramarkers1': self.qmc.extramarkers1,
            'extramarkers2': self.qmc.extramarkers2,
            'extramarkersizes1': self.qmc.extramarkersizes1,
            'extramarkersizes2': self.qmc.extramarkersizes2,
            'etypes': self.qmc.etypes
        }

    def restoreExtradeviceSettings(self) -> None:
        if self.org_extradevicesettings is not None:
            self.qmc.extradevices = self.org_extradevicesettings['extradevices']
            self.qmc.extradevicecolor1 = self.org_extradevicesettings['extradevicecolor1']
            self.qmc.extradevicecolor2 = self.org_extradevicesettings['extradevicecolor2']
            self.qmc.extraname1 = self.org_extradevicesettings['extraname1']
            self.qmc.extraname2 = self.org_extradevicesettings['extraname2']
            self.qmc.extramathexpression1 = self.org_extradevicesettings['extramathexpression1']
            self.qmc.extramathexpression2 = self.org_extradevicesettings['extramathexpression2']
            self.extraLCDvisibility1 = self.org_extradevicesettings['extraLCDvisibility1']
            self.extraLCDvisibility2 = self.org_extradevicesettings['extraLCDvisibility2']
            self.extraCurveVisibility1 = self.org_extradevicesettings['extraCurveVisibility1']
            self.extraCurveVisibility2 = self.org_extradevicesettings['extraCurveVisibility2']
            self.extraDelta1 = self.org_extradevicesettings['extraDelta1']
            self.extraDelta2 = self.org_extradevicesettings['extraDelta2']
            self.extraFill1 = self.org_extradevicesettings['extraFill1']
            self.extraFill2 = self.org_extradevicesettings['extraFill2']
            self.qmc.extralinestyles1 = self.org_extradevicesettings['extralinestyles1']
            self.qmc.extralinestyles2 = self.org_extradevicesettings['extralinestyles2']
            self.qmc.extradrawstyles1 = self.org_extradevicesettings['extradrawstyles1']
            self.qmc.extradrawstyles2 = self.org_extradevicesettings['extradrawstyles2']
            self.qmc.extralinewidths1 = self.org_extradevicesettings['extralinewidths1']
            self.qmc.extralinewidths2 = self.org_extradevicesettings['extralinewidths2']
            self.qmc.extramarkers1 = self.org_extradevicesettings['extramarkers1']
            self.qmc.extramarkers2 = self.org_extradevicesettings['extramarkers2']
            self.qmc.extramarkersizes1 = self.org_extradevicesettings['extramarkersizes1']
            self.qmc.extramarkersizes2 = self.org_extradevicesettings['extramarkersizes2']
            self.qmc.etypes = self.org_extradevicesettings['etypes']
            self.updateExtradeviceSettings()

    def updateExtradeviceSettings(self) -> None:
        ndevices = len(self.qmc.extradevices)
        if ndevices != len(self.qmc.extralinestyles1) or \
                ndevices != len(self.qmc.extralinestyles2) or \
                ndevices != len(self.qmc.extradrawstyles1) or \
                ndevices != len(self.qmc.extradrawstyles2) or \
                ndevices != len(self.qmc.extralinewidths1) or \
                ndevices != len(self.qmc.extralinewidths2) or \
                ndevices != len(self.qmc.extramarkers1) or \
                ndevices != len(self.qmc.extramarkers2) or \
                ndevices != len(self.qmc.extramarkersizes1) or \
                ndevices != len(self.qmc.extramarkersizes2):
            self.qmc.extralinestyles1 = [self.qmc.linestyle_default] * ndevices
            self.qmc.extralinestyles2 = [self.qmc.linestyle_default] * ndevices
            self.qmc.extradrawstyles1 = [self.qmc.drawstyle_default] * ndevices
            self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default] * ndevices
            self.qmc.extralinewidths1 = [self.qmc.extra_linewidth_default] * ndevices
            self.qmc.extralinewidths2 = [self.qmc.extra_linewidth_default] * ndevices
            self.qmc.extramarkers1 = [self.qmc.marker_default] * ndevices
            self.qmc.extramarkers2 = [self.qmc.marker_default] * ndevices
            self.qmc.extramarkersizes1 = [self.qmc.markersize_default] * ndevices
            self.qmc.extramarkersizes2 = [self.qmc.markersize_default] * ndevices
        self.qmc.extratemp1 = []
        self.qmc.extratemp2 = []
        self.qmc.extratimex = []
        self.qmc.extrastemp1 = []
        self.qmc.extrastemp2 = []
        for _ in range(len(self.qmc.extradevices)):
            self.qmc.extratemp1.append([])
            self.qmc.extratemp2.append([])
            self.qmc.extratimex.append([])
            self.qmc.extrastemp1.append([])
            self.qmc.extrastemp2.append([])
            self.qmc.extractimex1.append([])
            self.qmc.extractimex2.append([])
            self.qmc.extractemp1.append([])
            self.qmc.extractemp2.append([])
        # extra LCDs and other LCDs visibility
        self.updateLCDproperties()
        # set extraLCD colors
        for i in range(len(self.qmc.extradevices)):
            self.setLabelColor(self.extraLCDlabel1[i], QColor(self.qmc.extradevicecolor1[i]))
            self.setLabelColor(self.extraLCDlabel2[i], QColor(self.qmc.extradevicecolor2[i]))

    def initializedMonitoringExtraDeviceStructures(self) -> None:
        self.qmc.on_timex = []
        self.qmc.on_temp1 = []
        self.qmc.on_temp2 = []
        self.qmc.on_ctimex1 = []
        self.qmc.on_ctemp1 = []
        self.qmc.on_ctimex2 = []
        self.qmc.on_ctemp2 = []
        self.qmc.on_tstemp1 = []
        self.qmc.on_tstemp2 = []
        self.qmc.on_unfiltereddelta1 = []
        self.qmc.on_unfiltereddelta2 = []
        self.qmc.on_delta1 = []
        self.qmc.on_delta2 = []
        # list of lists:
        self.qmc.on_extratemp1 = []
        self.qmc.on_extratemp2 = []
        self.qmc.on_extratimex = []
        self.qmc.on_extractimex1 = []
        self.qmc.on_extractemp1 = []
        self.qmc.on_extractimex2 = []
        self.qmc.on_extractemp2 = []
        for _ in range(len(self.qmc.extradevices)):
            self.qmc.on_extratemp1.append([])
            self.qmc.on_extratemp2.append([])
            self.qmc.on_extratimex.append([])
            self.qmc.on_extractimex1.append([])
            self.qmc.on_extractemp1.append([])
            self.qmc.on_extractimex2.append([])
            self.qmc.on_extractemp2.append([])

    def getExtraDeviceSettingsPath(self) -> Optional[str]:
        datadir = getDataDirectory()
        if datadir is None:
            return None
        if self.app.artisanviewerMode:
            return os.path.join(datadir, 'extra_devices_backup_viewer.aset')
        return os.path.join(datadir, 'extra_devices_backup.aset')

    def setExtraDeviceSettings(self, settings: QSettings, default_settings: Optional[Dict[str, Any]] = None,
                               read_defaults: bool = False) -> None:
        self.settingsSetValue(settings, default_settings, 'extradevices', self.qmc.extradevices, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extraname1', self.qmc.extraname1, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extraname2', self.qmc.extraname2, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extramathexpression1', self.qmc.extramathexpression1,
                              read_defaults)
        self.settingsSetValue(settings, default_settings, 'extramathexpression2', self.qmc.extramathexpression2,
                              read_defaults)
        self.settingsSetValue(settings, default_settings, 'extradevicecolor1', self.qmc.extradevicecolor1,
                              read_defaults)
        self.settingsSetValue(settings, default_settings, 'extradevicecolor2', self.qmc.extradevicecolor2,
                              read_defaults)
        self.settingsSetValue(settings, default_settings, 'extraLCDvisibility1', self.extraLCDvisibility1,
                              read_defaults)
        self.settingsSetValue(settings, default_settings, 'extraLCDvisibility2', self.extraLCDvisibility2,
                              read_defaults)
        self.settingsSetValue(settings, default_settings, 'extraCurveVisibility1', self.extraCurveVisibility1,
                              read_defaults)
        self.settingsSetValue(settings, default_settings, 'extraCurveVisibility2', self.extraCurveVisibility2,
                              read_defaults)
        self.settingsSetValue(settings, default_settings, 'extraDelta1', self.extraDelta1, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extraDelta2', self.extraDelta2, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extraFill1', self.extraFill1, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extraFill2', self.extraFill2, read_defaults)
        self.settingsSetValue(settings, default_settings, 'devicetablecolumnwidths', self.qmc.devicetablecolumnwidths,
                              read_defaults)

    def setExtraDeviceCurveStyles(self, settings: QSettings, default_settings: Optional[Dict[str, Any]] = None,
                                  read_defaults: bool = False) -> None:
        self.settingsSetValue(settings, default_settings, 'extralinestyles1', self.qmc.extralinestyles1, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extralinestyles2', self.qmc.extralinestyles2, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extradrawstyles1', self.qmc.extradrawstyles1, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extradrawstyles2', self.qmc.extradrawstyles2, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extralinewidths1', self.qmc.extralinewidths1, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extralinewidths2', self.qmc.extralinewidths2, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extramarkers1', self.qmc.extramarkers1, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extramarkers2', self.qmc.extramarkers2, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extramarkersizes1', self.qmc.extramarkersizes1,
                              read_defaults)
        self.settingsSetValue(settings, default_settings, 'extramarkersizes2', self.qmc.extramarkersizes2,
                              read_defaults)

    def setExtraDeviceCommSettings(self, settings: QSettings, default_settings: Optional[Dict[str, Any]] = None,
                                   read_defaults: bool = False) -> None:
        self.settingsSetValue(settings, default_settings, 'extracomport', self.extracomport, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extrabaudrate', self.extrabaudrate, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extrabytesize', self.extrabytesize, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extraparity', self.extraparity, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extrastopbits', self.extrastopbits, read_defaults)
        self.settingsSetValue(settings, default_settings, 'extratimeout', self.extratimeout, read_defaults)

    def createExtraDeviceSettingsBackup(self) -> None:
        _log.debug('createExtraDeviceSettingsBackup()')
        # if self.simulator is None:
        #     try:
        #         filename = self.getExtraDeviceSettingsPath()
        #         if filename is not None and not os.path.isfile(filename):
        #             # we only backup the extra device settings if there is not an older available
        #             settings = QSettings(filename, QSettings.Format.IniFormat)
        #
        #             settings.beginGroup('ExtraDev')
        #             self.setExtraDeviceSettings(settings)
        #             settings.endGroup()
        #
        #             settings.beginGroup('CurveStyles')
        #             self.setExtraDeviceCurveStyles(settings)
        #             settings.endGroup()
        #
        #             # save extra serial comm ports settings
        #             settings.beginGroup('ExtraComm')
        #             self.setExtraDeviceCommSettings(settings)
        #             settings.endGroup()
        #
        #             # save custom event names
        #             settings.beginGroup('events')
        #             settings.setValue('etypes', self.qmc.etypes)
        #             settings.endGroup()
        #     except Exception as e:  # pylint: disable=broad-except
        #         _log.exception(e)

    def clearExtraDeviceSettingsBackup(self, filename: Optional[str] = None) -> None:
        _log.debug('clearExtraDeviceSettingsBackup()')
        # if filename is None:
        #     filename = self.getExtraDeviceSettingsPath()
        # if filename is not None:
        #     try:
        #         os.unlink(filename)
        #     except Exception:  # pylint: disable=broad-except
        #         pass

    def getExtraDeviceSettings(self, settings: QSettings) -> None:
        self.qmc.extradevices = [toInt(x) for x in toList(settings.value('extradevices', self.qmc.extradevices))]
        self.qmc.extraname1 = list(map(str, list(toStringList(settings.value('extraname1', self.qmc.extraname1)))))
        self.qmc.extraname2 = list(map(str, list(toStringList(settings.value('extraname2', self.qmc.extraname2)))))
        self.qmc.extramathexpression1 = list(
            map(str, list(toStringList(settings.value('extramathexpression1', self.qmc.extramathexpression1)))))
        self.qmc.extramathexpression2 = list(
            map(str, list(toStringList(settings.value('extramathexpression2', self.qmc.extramathexpression2)))))
        self.qmc.extradevicecolor1 = list(
            map(str, list(toStringList(settings.value('extradevicecolor1', self.qmc.extradevicecolor1)))))
        self.qmc.extradevicecolor2 = list(
            map(str, list(toStringList(settings.value('extradevicecolor2', self.qmc.extradevicecolor2)))))
        if settings.contains('extraLCDvisibility1'):
            self.extraLCDvisibility1 = [toBool(x) for x in
                                        toList(settings.value('extraLCDvisibility1', self.extraLCDvisibility1))]
        if settings.contains('extraLCDvisibility2'):
            self.extraLCDvisibility2 = [toBool(x) for x in
                                        toList(settings.value('extraLCDvisibility2', self.extraLCDvisibility2))]
        if settings.contains('extraCurveVisibility1'):
            self.extraCurveVisibility1 = [toBool(x) for x in
                                          toList(settings.value('extraCurveVisibility1', self.extraCurveVisibility1))]
        if settings.contains('extraCurveVisibility2'):
            self.extraCurveVisibility2 = [toBool(x) for x in
                                          toList(settings.value('extraCurveVisibility2', self.extraCurveVisibility2))]
        if settings.contains('extraDelta1'):
            self.extraDelta1 = [toBool(x) for x in toList(settings.value('extraDelta1', self.extraDelta1))]
        if settings.contains('extraDelta2'):
            self.extraDelta2 = [toBool(x) for x in toList(settings.value('extraDelta2', self.extraDelta2))]
        if settings.contains('extraFill1'):
            self.extraFill1 = [toInt(x) for x in toList(settings.value('extraFill1', self.extraFill1))]
        if settings.contains('extraFill2'):
            self.extraFill2 = [toInt(x) for x in toList(settings.value('extraFill2', self.extraFill2))]
        if settings.contains('devicetablecolumnwidths'):
            self.qmc.devicetablecolumnwidths = [toInt(x) for x in toList(
                settings.value('devicetablecolumnwidths', self.qmc.devicetablecolumnwidths))]

    def getExtraDeviceCurveStyles(self, settings: QSettings) -> None:
        self.qmc.extralinestyles1 = list(
            map(str, list(toStringList(settings.value('extralinestyles1', self.qmc.extralinestyles1)))))
        self.qmc.extralinestyles2 = list(
            map(str, list(toStringList(settings.value('extralinestyles2', self.qmc.extralinestyles2)))))
        self.qmc.extradrawstyles1 = list(
            map(str, list(toStringList(settings.value('extradrawstyles1', self.qmc.extradrawstyles1)))))
        self.qmc.extradrawstyles1 = [self.qmc.drawstyle_default if s == '-' else s for s in self.qmc.extradrawstyles1]
        self.qmc.extradrawstyles2 = list(
            map(str, list(toStringList(settings.value('extradrawstyles2', self.qmc.extradrawstyles2)))))
        self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default if s == '-' else s for s in self.qmc.extradrawstyles2]
        self.qmc.extralinewidths1 = [max(self.qmc.linewidth_min, self.float2float(toFloat(x))) for x in
                                     toList(settings.value('extralinewidths1', self.qmc.extralinewidths1))]
        self.qmc.extralinewidths2 = [max(self.qmc.linewidth_min, self.float2float(toFloat(x))) for x in
                                     toList(settings.value('extralinewidths2', self.qmc.extralinewidths2))]
        self.qmc.extramarkers1 = list(
            map(str, list(toStringList(settings.value('extramarkers1', self.qmc.extramarkers1)))))
        self.qmc.extramarkers2 = list(
            map(str, list(toStringList(settings.value('extramarkers2', self.qmc.extramarkers2)))))
        self.qmc.extramarkersizes1 = [max(self.qmc.markersize_min, self.float2float(toFloat(x))) for x in
                                      toList(settings.value('extramarkersizes1', self.qmc.extramarkersizes1))]
        self.qmc.extramarkersizes2 = [max(self.qmc.markersize_min, self.float2float(toFloat(x))) for x in
                                      toList(settings.value('extramarkersizes2', self.qmc.extramarkersizes2))]

    def getExtraDeviceCommSettings(self, settings: QSettings) -> None:
        self.extracomport = list(map(str, list(toStringList(settings.value('extracomport', self.extracomport)))))
        self.extrabaudrate = [toInt(x) for x in toList(settings.value('extrabaudrate', self.extrabaudrate))]
        self.extrabytesize = [toInt(x) for x in toList(settings.value('extrabytesize', self.extrabytesize))]
        self.extraparity = list(map(str, list(toStringList(settings.value('extraparity', self.extraparity)))))
        self.extrastopbits = [toInt(x) for x in toList(settings.value('extrastopbits', self.extrastopbits))]
        self.extratimeout = [self.float2float(toFloat(x)) for x in
                             toList(settings.value('extratimeout', self.extratimeout))]
        lenextraports = len(self.extracomport)
        self.extraser = [serialport(self) for _ in range(lenextraports)]
        # populate self.extraser
        for i in range(lenextraports):
            self.extraser[i].comport = str(self.extracomport[i])
            self.extraser[i].baudrate = self.extrabaudrate[i]
            self.extraser[i].bytesize = self.extrabytesize[i]
            self.extraser[i].parity = str(self.extraparity[i])
            self.extraser[i].stopbits = self.extrastopbits[i]
            self.extraser[i].timeout = self.extratimeout[i]

    # this should only be called from reset()
    def restoreExtraDeviceSettingsBackup(self) -> None:
        print(000)
        # if self.simulator is None:
        #     try:
        #         filename = self.getExtraDeviceSettingsPath()
        #         if filename is not None and os.path.isfile(filename):
        #             _log.debug('restoreExtraDeviceSettingsBackup()')
        #             settings = QSettings(filename, QSettings.Format.IniFormat)
        #             settings.beginGroup('ExtraDev')
        #             self.getExtraDeviceSettings(settings)
        #             settings.endGroup()
        #
        #             settings.beginGroup('CurveStyles')
        #             self.getExtraDeviceCurveStyles(settings)
        #             settings.endGroup()
        #
        #             # ensure that extra list length are of the size of the extradevices:
        #             self.ensureCorrectExtraDeviceListLength()
        #             self.updateExtradeviceSettings()
        #
        #             settings.beginGroup('ExtraComm')
        #             self.getExtraDeviceCommSettings(settings)
        #             settings.endGroup()
        #
        #             settings.beginGroup('events')
        #             self.qmc.etypes = toStringList(settings.value('etypes', self.qmc.etypes))
        #             settings.endGroup()
        #             # now remove the settings file
        #             self.clearExtraDeviceSettingsBackup(filename)
        #
        #             # etypes might have been changed thus we need to update the slider labels
        #             self.updateSlidersProperties()
        #             # update extra device lcds which might use event types as part of their labels
        #             self.establish_etypes()
        #             # as well as the large extra LCDs
        #             if self.largeExtraLCDs_dialog is not None:
        #                 self.largeExtraLCDs_dialog.reLayout()
        #             # update extra event button which might use event types as part of their labels
        #             self.realignbuttons()
        #
        #     except Exception as e:  # pylint: disable=broad-except
        #         _log.exception(e)

    @staticmethod
    def makeListLength(l: List[Any], n: int, default_element: Any) -> List[Any]:
        """Returns list l extended by the given default elements to make it exactly of length n"""
        return l[:n] + [default_element] * max(0, n - len(l))

    def consolidateSpecialEvents(self) -> None:
        """ensures that the 4 lists holding the special events data () are of equal length"""
        special_events_length = len(self.qmc.specialevents)
        self.qmc.specialeventstype = self.makeListLength(self.qmc.specialeventstype, special_events_length, 4)
        self.qmc.specialeventsStrings = self.makeListLength(self.qmc.specialeventsStrings, special_events_length, '')
        self.qmc.specialeventsvalue = self.makeListLength(self.qmc.specialeventsvalue, special_events_length, 0)

    # called by fileLoad() and various import functions
    # we assume that before a reset action was issues and among others timeindex got initialized to its defaults
    # returns False if action was canceled, True otherwise
    def setProfile(self, profile: 'ProfileData', quiet: bool = False,
                   reset: bool = True) -> bool:  # pyright: ignore [reportGeneralTypeIssues] # Code is too complex to analyze; reduce complexity by refactoring into subroutines or reducing conditional code paths
        try:
            updateRender = False
            # if missing, current etypes are used. Empty entries are replaced by their defaults translated using the current locale
            profile_etypes = (
                [decodeLocalStrict(x) for x in profile['etypes']] if 'etypes' in profile else self.qmc.etypes)
            if 'default_etypes' in profile:
                default_etypes = profile['default_etypes']
                for i, _ in enumerate(profile_etypes):
                    if default_etypes[i]:
                        profile_etypes[i] = self.qmc.etypesdefault[i]
            # extra devices load and check
            if profile and 'extratimex' in profile:
                if 'extradevices' in profile:
                    updateRender = False
                    # check for difference in the Data values between the profile and current settings
                    settingdev = ''.join(
                        [str(self.qmc.extradevices), str([encodeLocal(n) for n in self.qmc.extraname1]),
                         str([encodeLocal(n) for n in self.qmc.extraname2]),
                         str([encodeLocal(x) for x in self.qmc.extramathexpression1]),
                         str([encodeLocal(x) for x in self.qmc.extramathexpression2]),
                         str([encodeLocal(x) for x in self.qmc.etypes[:4]])
                         ])
                    # fix missing extramathexpression arrays on import
                    if 'extramathexpression1' not in profile:
                        profile['extramathexpression1'] = [''] * len(profile['extraname1'])
                    if 'extramathexpression2' not in profile:
                        profile['extramathexpression2'] = [''] * len(profile['extraname2'])
                    try:
                        profiledev = ''.join(
                            [str(profile['extradevices']), str(profile['extraname1']), str(profile['extraname2']),
                             str(profile['extramathexpression1']), str(profile['extramathexpression2']),
                             str(profile_etypes[:4])
                             ])
                    except Exception:  # pylint: disable=broad-except
                        profiledev = ''
                    if settingdev != profiledev:
                        # we don't ask the user to adjust or not the extra device setup. Instead, now we backup the current settings via createExtraDeviceSettingsBackup() always and reset back to the original state
                        # on reset, thus we default to StandardButton.Yes instead of asking in the dialog:

                        if self.simulator is not None:
                            # loading files with different extra device settings will not alter those and not mess up an potentially already existing settings backup
                            reply = QMessageBox.StandardButton.No
                        else:
                            reply = QMessageBox.StandardButton.Yes

                        # Shift+Alt modifier allows to overwrite extra devices (as was default in v2.4.6)
                        if QApplication.queryKeyboardModifiers() == Qt.KeyboardModifier.AltModifier | Qt.KeyboardModifier.ShiftModifier:
                            string = QApplication.translate('Message',
                                                            'To fully load this profile the extra device configuration needs to be modified.\n\nOverwrite your extra device definitions using the values from the profile?\n\nIt is advisable to save your current settings beforehand via menu Help >> Save Settings.')
                            if quiet:
                                reply = QMessageBox.StandardButton.Yes
                            else:
                                reply = QMessageBox.question(self, QApplication.translate('Message',
                                                                                          'Found a different set of extra devices'),
                                                             string,
                                                             QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Cancel,
                                                             QMessageBox.StandardButton.No)

                        if reply == QMessageBox.StandardButton.Yes:
                            if not reset or self.qmc.reset(
                                    redraw=False):  # operation not canceled by the user in the save dirty state dialog
                                self.createExtraDeviceSettingsBackup()  # we make a backup of the core extra device settings before loading the profile, to be restored on next RESET
                                updateRender = True
                                self.qmc.resetlinecountcaches()
                                self.qmc.extradevices = profile['extradevices']
                            else:
                                return False
                        elif reply == QMessageBox.StandardButton.No:
                            pass
                        else:
                            return False

                        # we remove the extra device elements that do not fit
                        if reply == QMessageBox.StandardButton.No:
                            # if (len(self.qmc.extradevices) < len(profile["extradevices"])):
                            l = len(self.qmc.extradevices)
                            profile['extratimex'] = profile['extratimex'][:l]
                            profile['extratemp1'] = profile['extratemp1'][:l]
                            profile['extratemp2'] = profile['extratemp2'][:l]
                            profile['extradevices'] = self.qmc.extradevices
                            profile['extraname1'] = self.qmc.extraname1
                            profile['extraname2'] = self.qmc.extraname2
                            profile['extramathexpression1'] = self.qmc.extramathexpression1
                            profile['extramathexpression2'] = self.qmc.extramathexpression2
                            profile['extradevicecolor1'] = self.qmc.extradevicecolor1
                            profile['extradevicecolor2'] = self.qmc.extradevicecolor2
                            profile['extramarkersizes1'] = [max(self.qmc.markersize_min, ms) for ms in
                                                            self.qmc.extramarkersizes1]
                            profile['extramarkersizes2'] = [max(self.qmc.markersize_min, ms) for ms in
                                                            self.qmc.extramarkersizes2]
                            profile['extramarkers1'] = self.qmc.extramarkers1
                            profile['extramarkers2'] = self.qmc.extramarkers2
                            profile['extralinewidths1'] = [max(self.qmc.linewidth_min, lw) for lw in
                                                           self.qmc.extralinewidths1]
                            profile['extralinewidths2'] = [max(self.qmc.linewidth_min, lw) for lw in
                                                           self.qmc.extralinewidths2]
                            profile['extralinestyles1'] = self.qmc.extralinestyles1
                            profile['extralinestyles2'] = self.qmc.extralinestyles2
                            profile['extradrawstyles1'] = self.qmc.extradrawstyles1
                            profile['extradrawstyles2'] = self.qmc.extradrawstyles2
                            profile['extraLCDvisibility1'] = self.extraLCDvisibility1
                            profile['extraLCDvisibility2'] = self.extraLCDvisibility2
                            profile['extraCurveVisibility1'] = self.extraCurveVisibility1
                            profile['extraCurveVisibility2'] = self.extraCurveVisibility2
                            profile['extraDelta1'] = self.extraDelta1
                            profile['extraDelta2'] = self.extraDelta2
                            profile['extraFill1'] = self.extraFill1
                            profile['extraFill2'] = self.extraFill2

                # adjust extra serial device table
                # a) remove superfluous extra serial settings
                self.extraser = self.extraser[:len(self.qmc.extradevices)]
                self.extracomport = self.extracomport[:len(self.qmc.extradevices)]
                self.extrabaudrate = self.extrabaudrate[:len(self.qmc.extradevices)]
                self.extrabytesize = self.extrabytesize[:len(self.qmc.extradevices)]
                self.extraparity = self.extraparity[:len(self.qmc.extradevices)]
                self.extrastopbits = self.extrastopbits[:len(self.qmc.extradevices)]
                self.extratimeout = self.extratimeout[:len(self.qmc.extradevices)]
                # b) add missing extra serial settings
                for _ in range(len(self.qmc.extradevices) - len(self.extraser)):
                    self.addSerialPort()
                # c) set extra temp curves and prepare empty extra smoothed temp curves
                if 'extratimex' in profile:
                    self.qmc.extratimex = profile['extratimex'] + [[]] * (
                            len(self.qmc.extradevices) - len(profile['extratimex']))
                if 'extratemp1' in profile:
                    self.qmc.extratemp1 = profile['extratemp1'] + [[]] * (
                            len(self.qmc.extradevices) - len(profile['extratimex']))
                    self.qmc.extrastemp1 = [[]] * len(self.qmc.extratemp1)
                    self.qmc.extractemp1 = [[]] * len(self.qmc.extratemp1)
                    self.qmc.extractimex1 = [[]] * len(self.qmc.extratemp1)
                if 'extratemp2' in profile:
                    self.qmc.extratemp2 = profile['extratemp2'] + [[]] * (
                            len(self.qmc.extradevices) - len(profile['extratimex']))
                    self.qmc.extrastemp2 = [[]] * len(self.qmc.extratemp2)
                    self.qmc.extractemp2 = [[]] * len(self.qmc.extratemp2)
                    self.qmc.extractimex2 = [[]] * len(self.qmc.extratemp2)
                # d) set other extra curve attribute lists
                if 'extraname1' in profile:
                    self.qmc.extraname1 = [decodeLocalStrict(x) for x in profile['extraname1']]
                if 'extraname2' in profile:
                    self.qmc.extraname2 = [decodeLocalStrict(x) for x in profile['extraname2']]
                if 'extramathexpression1' in profile:
                    self.qmc.extramathexpression1 = [decodeLocalStrict(x) for x in profile['extramathexpression1']]
                if 'extramathexpression2' in profile:
                    self.qmc.extramathexpression2 = [decodeLocalStrict(x) for x in profile['extramathexpression2']]

                if updateRender:
                    if 'extradevicecolor1' in profile:
                        self.qmc.extradevicecolor1 = [decodeLocalStrict(x, '#000000') for x in
                                                      profile['extradevicecolor1']]
                    if 'extradevicecolor2' in profile:
                        self.qmc.extradevicecolor2 = [decodeLocalStrict(x, '#000000') for x in
                                                      profile['extradevicecolor2']]

                    if 'extraLCDvisibility1' in profile:
                        self.extraLCDvisibility1 = profile['extraLCDvisibility1']
                    else:
                        self.extraLCDvisibility1 = [False] * self.nLCDS
                    if 'extraLCDvisibility2' in profile:
                        self.extraLCDvisibility2 = profile['extraLCDvisibility2']
                    else:
                        self.extraLCDvisibility2 = [False] * self.nLCDS
                    if 'extraCurveVisibility1' in profile:
                        self.extraCurveVisibility1 = profile['extraCurveVisibility1']
                    else:
                        self.extraCurveVisibility1 = [False] * self.nLCDS
                    if 'extraCurveVisibility2' in profile:
                        self.extraCurveVisibility2 = profile['extraCurveVisibility2']
                    else:
                        self.extraCurveVisibility2 = [False] * self.nLCDS
                    if 'extraDelta1' in profile:
                        self.extraDelta1 = profile['extraDelta1']
                    else:
                        self.extraDelta1 = [False] * self.nLCDS
                    if 'extraDelta2' in profile:
                        self.extraDelta2 = profile['extraDelta2']
                    else:
                        self.extraDelta2 = [False] * self.nLCDS
                    if 'extraFill1' in profile:
                        self.extraFill1 = profile['extraFill1']
                    else:
                        self.extraFill1 = [0] * self.nLCDS
                    if 'extraFill2' in profile:
                        self.extraFill2 = profile['extraFill2']
                    else:
                        self.extraFill2 = [0] * self.nLCDS
                    if 'extramarkersizes1' in profile:
                        self.qmc.extramarkersizes1 = [max(self.qmc.markersize_min, float(ms)) for ms in
                                                      profile['extramarkersizes1']]
                    else:
                        self.qmc.extramarkersizes1 = [self.qmc.markersize_default] * len(self.qmc.extratemp1)
                    if 'extramarkersizes2' in profile:
                        self.qmc.extramarkersizes2 = [max(self.qmc.markersize_min, float(ms)) for ms in
                                                      profile['extramarkersizes2']]
                    else:
                        self.qmc.extramarkersizes2 = [self.qmc.markersize_default] * len(self.qmc.extratemp2)
                    if 'extramarkers1' in profile:
                        self.qmc.extramarkers1 = [decodeLocalStrict(x, self.qmc.marker_default) for x in
                                                  profile['extramarkers1']]
                    else:
                        self.qmc.extramarkers1 = [self.qmc.marker_default] * len(self.qmc.extratemp1)
                    if 'extramarkers2' in profile:
                        self.qmc.extramarkers2 = [decodeLocalStrict(x, self.qmc.marker_default) for x in
                                                  profile['extramarkers2']]
                    else:
                        self.qmc.extramarkers2 = [self.qmc.marker_default] * len(self.qmc.extratemp2)
                    if 'extralinewidths1' in profile:
                        self.qmc.extralinewidths1 = [max(self.qmc.linewidth_min, float(w)) for w in
                                                     profile['extralinewidths1']]
                    else:
                        self.qmc.extralinewidths1 = [self.qmc.extra_linewidth_default] * len(self.qmc.extratemp1)
                    if 'extralinewidths2' in profile:
                        self.qmc.extralinewidths2 = [max(self.qmc.linewidth_min, float(w)) for w in
                                                     profile['extralinewidths2']]
                    else:
                        self.qmc.extralinewidths2 = [self.qmc.extra_linewidth_default] * len(self.qmc.extratemp2)
                    if 'extralinestyles1' in profile:
                        self.qmc.extralinestyles1 = [decodeLocalStrict(x, self.qmc.linestyle_default) for x in
                                                     profile['extralinestyles1']]
                    else:
                        self.qmc.extralinestyles1 = [self.qmc.linestyle_default] * len(self.qmc.extratemp1)
                    if 'extralinestyles2' in profile:
                        self.qmc.extralinestyles2 = [decodeLocalStrict(x, self.qmc.linestyle_default) for x in
                                                     profile['extralinestyles2']]
                    else:
                        self.qmc.extralinestyles2 = [self.qmc.linestyle_default] * len(self.qmc.extratemp2)
                    if 'extradrawstyles1' in profile:
                        self.qmc.extradrawstyles1 = [decodeLocalStrict(x, self.qmc.drawstyle_default) for x in
                                                     profile['extradrawstyles1']]
                    else:
                        self.qmc.extradrawstyles1 = [self.qmc.drawstyle_default] * len(self.qmc.extratemp1)
                    if 'extradrawstyles2' in profile:
                        self.qmc.extradrawstyles2 = [decodeLocalStrict(x, self.qmc.drawstyle_default) for x in
                                                     profile['extradrawstyles2']]
                    else:
                        self.qmc.extradrawstyles2 = [self.qmc.drawstyle_default] * len(self.qmc.extratemp2)

                # ensure that extra list length are of the size of the extradevices:
                self.ensureCorrectExtraDeviceListLength()

            self.updateExtraLCDvisibility()

            self.recording_version = profile.get('recording_version', 'unknown')
            if 'recording_revision' in profile:
                self.recording_revision = profile['recording_revision']
            else:
                self.recording_revision = 'unknown'
            self.recording_build = profile.get('recording_build', 'unknown')

            # if auto-adjusted is ticked phases will automatically adjust to the set values in the profile
            # we better not load the phases from the profile not to change the user defined phases settings
            #            if "phases" in profile:
            #                self.qmc.phases = profile["phases"]
            if 'flavors' in profile:
                self.qmc.flavors = [max(0, min(10, float(fl))) for fl in profile['flavors']]
            if 'flavorlabels' in profile:
                self.qmc.flavorlabels = toStringList([decodeLocalStrict(x) for x in profile['flavorlabels']])
            if len(self.qmc.flavorlabels) > len(self.qmc.flavors):
                # fill with default 5. values
                self.qmc.flavors = self.qmc.flavors + [5.] * (len(self.qmc.flavorlabels) - len(self.qmc.flavors))
            elif len(self.qmc.flavorlabels) < len(self.qmc.flavors):
                # remove superfluous values
                self.qmc.flavors = self.qmc.flavors[:len(self.qmc.flavorlabels)]
            if 'flavorstartangle' in profile:
                self.qmc.flavorstartangle = int(profile['flavorstartangle'])
            if 'flavoraspect' in profile:
                self.qmc.flavoraspect = float(profile['flavoraspect'])
            else:
                self.qmc.flavoraspect = 1.
            if 'title' in profile:
                self.qmc.title = decodeLocalStrict(profile['title'], ' ')
            else:
                self.qmc.title = QApplication.translate('Scope Title', ' ')

            # PLUS
            if 'plus_store' in profile:
                self.qmc.plus_store = decodeLocalStrict(profile['plus_store'])
                if 'plus_store_label' in profile:
                    self.qmc.plus_store_label = decodeLocalStrict(profile['plus_store_label'])
                else:
                    self.qmc.plus_store_label = None
            else:
                self.qmc.plus_store = None
                self.qmc.plus_store_label = None
            if 'plus_coffee' in profile:
                self.qmc.plus_coffee = decodeLocalStrict(profile['plus_coffee'])
                if 'plus_coffee_label' in profile:
                    self.qmc.plus_coffee_label = decodeLocalStrict(profile['plus_coffee_label'])
                else:
                    self.qmc.plus_coffee_label = None
            else:
                self.qmc.plus_coffee = None
                self.qmc.plus_coffee_label = None
            if 'plus_blend_spec' in profile:
                # we convert the blend specification from its list to its internal dictionary representation
                self.qmc.plus_blend_spec = plus.stock.list2blend(profile['plus_blend_spec'])
                if 'plus_blend_label' in profile:
                    self.qmc.plus_blend_label = decodeLocalStrict(profile['plus_blend_label'])
                else:
                    self.qmc.plus_blend_label = None
                if 'plus_blend_spec_labels' in profile:
                    self.qmc.plus_blend_spec_labels = [decodeLocalStrict(l) for l in profile['plus_blend_spec_labels']]
                else:
                    self.qmc.plus_blend_spec_labels = None
            else:
                self.qmc.plus_blend_spec = None
                self.qmc.plus_blend_spec_labels = None
            if 'plus_sync_record_hash' in profile:
                self.qmc.plus_sync_record_hash = decodeLocal(profile['plus_sync_record_hash'])
            else:
                self.qmc.plus_sync_record_hash = None

            if 'beans' in profile:
                self.qmc.beans = decodeLocalStrict(profile['beans'])
            else:
                self.qmc.beans = ''
            if 'weight' in profile:
                weight = profile['weight']
                self.qmc.weight = (float(weight[0]), float(weight[1]), decodeLocalStrict(weight[2], 'g'))
            else:
                self.qmc.weight = (0, 0, 'g')
            if 'volume' in profile:
                volume = profile['volume']
                self.qmc.volume = (float(volume[0]), float(volume[1]), decodeLocalStrict(volume[2], 'l'))
            else:
                self.qmc.volume = (0, 0, 'l')
            if 'density' in profile:
                density = profile['density']
                self.qmc.density = (float(density[0]), decodeLocalStrict(density[1], 'g'), float(density[2]),
                                    decodeLocalStrict(density[3], 'l'))
            else:
                self.qmc.density = (0, 'g', 1, 'l')
            if 'density_roasted' in profile:
                density_roasted = profile['density_roasted']
                self.qmc.density_roasted = (
                    float(density_roasted[0]), decodeLocalStrict(density_roasted[1], 'g'), float(density_roasted[2]),
                    decodeLocalStrict(density_roasted[3], 'l'))
            else:
                self.qmc.density_roasted = (0, 'g', 1, 'l')
            if 'roastertype' in profile:
                self.qmc.roastertype = decodeLocalStrict(profile['roastertype'])
            else:
                self.qmc.roastertype = ''
            self.qmc.roastersize = profile.get('roastersize', 0)
            if 'roasterheating' in profile:
                self.qmc.roasterheating = profile['roasterheating']
            else:
                self.qmc.roastersize = 0
            if 'operator' in profile:
                self.qmc.operator = decodeLocalStrict(profile['operator'])
            else:
                self.qmc.operator = ''
            if 'organization' in profile:
                self.qmc.organization = decodeLocalStrict(profile['organization'])
            else:
                self.qmc.organization = ''
            if 'drumspeed' in profile:
                self.qmc.drumspeed = decodeLocalStrict(profile['drumspeed'])
            else:
                self.qmc.drumspeed = ''
            if 'beansize' in profile:
                # we map beansize in mm to beansize_max in 1/64"
                try:
                    self.qmc.beansize_max = int(round(float(profile['beansize']) * 0.0393701 * 61))
                except Exception:  # pylint: disable=broad-except
                    pass
            if 'beansize_min' in profile:
                self.qmc.beansize_min = int(round(
                    float(profile['beansize_min'])))  # compatible with legacy profiles holding beansize_min as floats
            else:
                self.qmc.beansize_min = 0
            if 'beansize_max' in profile:
                self.qmc.beansize_max = int(round(
                    float(profile['beansize_max'])))  # compatible with legacy profiles holding beansize_max as floats
            else:
                self.qmc.beansize_max = 0
            if 'heavyFC' in profile:
                self.qmc.heavyFC_flag = profile['heavyFC']
            if 'lowFC' in profile:
                self.qmc.lowFC_flag = profile['lowFC']
            if 'lightCut' in profile:
                self.qmc.lightCut_flag = profile['lightCut']
            if 'darkCut' in profile:
                self.qmc.darkCut_flag = profile['darkCut']
            if 'drops' in profile:
                self.qmc.drops_flag = profile['drops']
            if 'oily' in profile:
                self.qmc.oily_flag = profile['oily']
            if 'uneven' in profile:
                self.qmc.uneven_flag = profile['uneven']
            if 'tipping' in profile:
                self.qmc.tipping_flag = profile['tipping']
            if 'scorching' in profile:
                self.qmc.scorching_flag = profile['scorching']
            if 'divots' in profile:
                self.qmc.divots_flag = profile['divots']
            # color
            if 'whole_color' in profile:
                self.qmc.whole_color = profile['whole_color']
            if 'ground_color' in profile:
                self.qmc.ground_color = profile['ground_color']
            if 'color_system' in profile and profile['color_system'] in self.qmc.color_systems:
                self.qmc.color_system_idx = self.qmc.color_systems.index(profile['color_system'])
            if 'volumeCalcWeightIn' in profile:
                self.qmc.volumeCalcWeightInStr = profile['volumeCalcWeightIn']
            if 'volumeCalcWeightOut' in profile:
                self.qmc.volumeCalcWeightOutStr = profile['volumeCalcWeightOut']
            # for compatibility with older profiles:
            if 'roastdate' in profile:
                try:
                    date = QDate.fromString(decodeLocalStrict(profile['roastdate']))
                    if not date.isValid():
                        date = QDate.currentDate()
                    if 'roasttime' in profile:
                        try:
                            time = QTime.fromString(decodeLocalStrict(profile['roasttime']))
                            self.qmc.roastdate = QDateTime(date, time)
                        except Exception:  # pylint: disable=broad-except
                            self.qmc.roastdate = QDateTime(date, QTime())
                    else:
                        self.qmc.roastdate = QDateTime(date, QTime())
                except Exception:  # pylint: disable=broad-except
                    pass
            # the new dates have the locale independent isodate format:
            if 'roastisodate' in profile:
                try:
                    date = QDate.fromString(decodeLocalStrict(profile['roastisodate']), Qt.DateFormat.ISODate)
                    if not date.isValid():
                        date = QDate.currentDate()
                    if 'roasttime' in profile:
                        try:
                            time = QTime.fromString(decodeLocalStrict(profile['roasttime']))
                            if not time.isValid():
                                time = QTime().currentTime()
                            self.qmc.roastdate = QDateTime(date, time)
                        except Exception:  # pylint: disable=broad-except
                            self.qmc.roastdate = QDateTime(date, QTime())
                    else:
                        self.qmc.roastdate = QDateTime(date, QTime())
                except Exception:  # pylint: disable=broad-except
                    pass
            if 'roastepoch' in profile:
                try:
                    self.qmc.roastdate = QDateTime.fromSecsSinceEpoch(profile['roastepoch'])
                except Exception:  # pylint: disable=broad-except
                    pass
            if 'roastUUID' in profile:
                self.qmc.roastUUID = decodeLocal(profile['roastUUID'])
            else:
                import uuid
                self.qmc.roastUUID = uuid.uuid4().hex  # generate UUID
                self.qmc.fileDirtySignal.emit()
            if 'roastbatchnr' in profile:
                try:
                    self.qmc.roastbatchnr = int(profile['roastbatchnr'])
                except Exception:  # pylint: disable=broad-except
                    pass
                try:
                    self.qmc.roastbatchprefix = decodeLocalStrict(profile['roastbatchprefix'])
                except Exception:  # pylint: disable=broad-except
                    pass
                try:
                    self.qmc.roastbatchpos = int(profile['roastbatchpos'])
                except Exception:  # pylint: disable=broad-except
                    pass
            self.qmc.specialevents = profile.get('specialevents', [])
            self.qmc.specialeventstype = profile.get('specialeventstype', [])
            self.qmc.specialeventsvalue = profile.get('specialeventsvalue', [])
            if 'specialeventsStrings' in profile:
                self.qmc.specialeventsStrings = [decodeLocalStrict(x) for x in profile['specialeventsStrings']]
            else:
                self.qmc.specialeventsStrings = []
            self.consolidateSpecialEvents()  # we ensure that all 4 lists holding the special events are of equal length

            if 'etypes' in profile:
                self.qmc.etypes = profile_etypes

            if updateRender:
                # etypes might have been changed thus we need to update the slider labels
                self.updateSlidersProperties()
                # update extra device lcds which might use event types as part of their labels
                self.establish_etypes()
                # as well as the large extra LCDs
                if self.largeExtraLCDs_dialog is not None:
                    self.largeExtraLCDs_dialog.reLayout()
                # update extra event button which might use event types as part of their labels
                self.realignbuttons()

            if 'roastingnotes' in profile:
                self.qmc.roastingnotes = decodeLocalStrict(profile['roastingnotes'])
            else:
                self.qmc.roastingnotes = ''
            if 'cuppingnotes' in profile:
                self.qmc.cuppingnotes = decodeLocalStrict(profile['cuppingnotes'])
            else:
                self.qmc.cuppingnotes = ''
            if 'timex' in profile:
                self.qmc.timex = profile['timex']

            # ensure that extra timex and temp lists are as long as the main timex
            for i, _ in enumerate(self.qmc.extratimex):
                if not isinstance(self.qmc.extratimex[i], list) or len(self.qmc.extratimex[i]) != len(self.qmc.timex):
                    self.qmc.extratimex[i] = self.qmc.timex
                if not isinstance(self.qmc.extratemp1[i], list) or len(self.qmc.extratemp1[i]) != len(self.qmc.timex):
                    self.qmc.extratemp1[i] = [-1] * len(self.qmc.timex)
                if not isinstance(self.qmc.extratemp2[i], list) or len(self.qmc.extratemp2[i]) != len(self.qmc.timex):
                    self.qmc.extratemp2[i] = [-1] * len(self.qmc.timex)

            # alarms
            # if self.qmc.loadalarmsfromprofile and filename is not None:
            #     self.loadAlarmsFromProfile(filename, profile)

            self.qmc.extraNoneTempHint1 = profile.get('extraNoneTempHint1', [])
            self.qmc.extraNoneTempHint2 = profile.get('extraNoneTempHint2', [])

            m = str(profile['mode']) if 'mode' in profile else self.qmc.mode
            if 'temp1' in profile:
                self.qmc.temp1 = profile['temp1']
            if 'temp2' in profile:
                self.qmc.temp2 = profile['temp2']
            if 'ambientTemp' in profile:
                self.qmc.ambientTemp = profile['ambientTemp']
            self.qmc.greens_temp = profile.get('greens_temp', 0.0)

            if self.qmc.mode == 'C' and m == 'F':
                self.qmc.temp1 = [fromFtoCstrict(t) for t in self.qmc.temp1]
                self.qmc.temp2 = [fromFtoCstrict(t) for t in self.qmc.temp2]
                for e in range(len(self.qmc.extratimex)):
                    if self.extraDelta1[e]:
                        self.qmc.extratemp1[e] = [RoRfromFtoCstrict(t) for t in self.qmc.extratemp1[e]]
                    elif not (len(self.qmc.extraNoneTempHint1) > e and self.qmc.extraNoneTempHint1[e]):
                        self.qmc.extratemp1[e] = [fromFtoCstrict(t) for t in self.qmc.extratemp1[e]]
                    if self.extraDelta2[e]:
                        self.qmc.extratemp2[e] = [RoRfromFtoCstrict(t) for t in self.qmc.extratemp2[e]]
                    elif not (len(self.qmc.extraNoneTempHint2) > e and self.qmc.extraNoneTempHint2[e]):
                        self.qmc.extratemp2[e] = [fromFtoCstrict(t) for t in self.qmc.extratemp2[e]]
                try:
                    self.calcVirtualdevices(update=True)
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
                if self.qmc.ambientTemp != 0:
                    self.qmc.ambientTemp = fromFtoCstrict(self.qmc.ambientTemp)
                if self.qmc.loadalarmsfromprofile and 'alarmtemperature' in profile:
                    self.qmc.alarmtemperature = [(fromFtoCstrict(t) if t != 500 else t) for t in
                                                 self.qmc.alarmtemperature]
                if self.qmc.greens_temp != 0.:
                    self.qmc.greens_temp = fromFtoCstrict(self.qmc.greens_temp)
                self.qmc.fileDirtySignal.emit()
            elif self.qmc.mode == 'F' and m == 'C':
                self.qmc.temp1 = [fromCtoFstrict(t) for t in self.qmc.temp1]
                self.qmc.temp2 = [fromCtoFstrict(t) for t in self.qmc.temp2]
                for elem in range(len(self.qmc.extratimex)):
                    if self.extraDelta1[elem]:
                        self.qmc.extratemp1[elem] = [RoRfromCtoFstrict(t) for t in self.qmc.extratemp1[elem]]
                    elif not (len(self.qmc.extraNoneTempHint1) > elem and self.qmc.extraNoneTempHint1[elem]):
                        self.qmc.extratemp1[elem] = [fromCtoFstrict(t) for t in self.qmc.extratemp1[elem]]
                    if self.extraDelta2[elem]:
                        self.qmc.extratemp2[elem] = [RoRfromCtoFstrict(t) for t in self.qmc.extratemp2[elem]]
                    elif not (len(self.qmc.extraNoneTempHint2) > elem and self.qmc.extraNoneTempHint2[elem]):
                        self.qmc.extratemp2[elem] = [fromCtoFstrict(t) for t in self.qmc.extratemp2[elem]]
                try:
                    self.calcVirtualdevices(update=True)
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
                if self.qmc.ambientTemp != 0:
                    self.qmc.ambientTemp = fromCtoFstrict(self.qmc.ambientTemp)
                if self.qmc.loadalarmsfromprofile and 'alarmtemperature' in profile:
                    self.qmc.alarmtemperature = [fromCtoFstrict(t) for t in self.qmc.alarmtemperature]
                if self.qmc.greens_temp != 0.:
                    self.qmc.greens_temp = fromCtoFstrict(self.qmc.greens_temp)
                self.qmc.fileDirtySignal.emit()
            elif self.qmc.loadaxisfromprofile:
                # only if the temperature mode of the profile equals to our current mode, and loadfromprofile is ticked, we respect the temp/RoR axis limits
                if 'zmax' in profile:
                    self.qmc.zlimit = min(int(profile['zmax']), self.qmc.zlimit_max)
                if 'zmin' in profile:
                    self.qmc.zlimit_min = max(min(int(profile['zmin']), self.qmc.zlimit), self.qmc.zlimit_min_max)
                if 'ymax' in profile:
                    self.qmc.ylimit = min(int(profile['ymax']), self.qmc.ylimit_max)
                if 'ymin' in profile:
                    self.qmc.ylimit_min = max(min(int(profile['ymin']), self.qmc.ylimit), self.qmc.ylimit_min_max)
            if not self.qmc.locktimex and self.qmc.loadaxisfromprofile:
                # otherwise don't let the users y/z min/max axis limits be overwritten by loading a profile
                if 'xmin' in profile:
                    self.qmc.startofx = float(profile['xmin'])
                if 'xmax' in profile:
                    self.qmc.endofx = float(profile['xmax'])
                elif self.qmc.timex:
                    # Set the xlimits
                    self.qmc.endofx = self.qmc.timex[-1] + 40
            if 'ambient_humidity' in profile:
                self.qmc.ambient_humidity = profile['ambient_humidity']
            if 'ambient_pressure' in profile:
                self.qmc.ambient_pressure = profile['ambient_pressure']
            self.qmc.moisture_greens = profile.get('moisture_greens', 0.0)
            self.qmc.moisture_roasted = profile.get('moisture_roasted', 0.0)

            # only load annotations position if the temperature mode did not change
            if 'anno_positions' in profile and self.qmc.mode == m:
                self.qmc.setAnnoPositions(profile['anno_positions'])
            else:
                self.qmc.l_annotations_pos_dict = {}
            if 'flag_positions' in profile and self.qmc.mode == m:
                self.qmc.setFlagPositions(profile['flag_positions'])
            else:
                self.qmc.l_event_flags_pos_dict = {}
            if 'legendloc_pos' in profile and self.qmc.loadaxisfromprofile and self.qmc.ax is not None:
                try:
                    # first set the profiles axis limits to have the transformations right
                    self.qmc.ax.set_xlim(self.qmc.startofx, self.qmc.startofx + self.qmc.endofx)
                    self.qmc.ax.set_ylim(self.qmc.ylimit_min, self.qmc.ylimit)
                    # if available we transform the custom legend position back from data into axis coordinates
                    legendloc_pos_data = numpy.array(profile['legendloc_pos'])
                    axis_to_data = self.qmc.ax.transAxes + self.qmc.ax.transData.inverted()
                    data_to_axis = axis_to_data.inverted()
                    pos = data_to_axis.transform(legendloc_pos_data)
                    self.qmc.legendloc_pos = (pos[0], pos[1])
                    self.qmc.legend = None
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)

            # we load external programs only from app settings
            #            if "externalprogram" in profile:
            #                self.ser.externalprogram = decodeLocal(profile["externalprogram"])
            #            if "externaloutprogram" in profile:
            #                self.ser.externaloutprogram = decodeLocal(profile["externaloutprogram"])
            if 'samplinginterval' in profile:
                # derive self.qmc.deltaBTsamples from self.qmc.deltaBTspan and the sampling interval of the profile
                self.qmc.profile_sampling_interval = profile['samplinginterval']
            elif len(self.qmc.timex) > 2:
                self.qmc.profile_sampling_interval = (self.qmc.timex[-1] - self.qmc.timex[0]) / (
                        len(self.qmc.timex) - 1)
            self.qmc.updateDeltaSamples()
            # Ramp/Soak Profiles
            if self.pidcontrol.loadRampSoakFromProfile and filename is not None:
                self.loadRampSoakFromProfile(filename, profile)

            # Energy
            self.loadEnergyFromProfile(profile)

            if 'timeindex' in profile:
                self.qmc.timeindex = [max(0, v) if i > 0 else max(-1, v) for i, v in enumerate(profile['timeindex'])]
                if self.qmc.locktimex:
                    if self.qmc.timeindex[0] != -1:
                        self.qmc.startofx = self.qmc.timex[self.qmc.timeindex[0]] + self.qmc.locktimex_start
                    else:
                        self.qmc.startofx = self.qmc.locktimex_start
                elif not self.qmc.loadaxisfromprofile and self.qmc.timeindex[0] != -1:
                    # we still need to adjust startx as it depends on timeindex[0] to keep x-axis min limit as is
                    # we assume here that the previous reset did initialize timeindex[0] and adjusted startx correctly
                    self.qmc.startofx += self.qmc.timex[self.qmc.timeindex[0]]
            #            elif len(profile) > 0 and ('startend' in profile or 'dryend' in profile or 'cracks' in profile):
            #                ###########      OLD PROFILE FORMAT
            #                if 'startend' in profile:
            #                    startend = [float(fl) for fl in profile['startend']]
            #                else:
            #                    startend = [0.,0.,0.,0.]
            #                if 'dryend' in profile:
            #                    dryend = profile['dryend']
            #                else:
            #                    dryend = [0.,0.]
            #                if 'cracks' in profile:
            #                    varC = [float(fl) for fl in profile['cracks']]
            #                else:
            #                    varC = [0.,0.,0.,0.,0.,0.,0.,0.]
            #                times = []
            #                times.append(startend[0])
            #                times.append(dryend[0])
            #                times.append(varC[0])
            #                times.append(varC[2])
            #                times.append(varC[4])
            #                times.append(varC[6])
            #                times.append(startend[2])
            #                #convert to new profile
            #                self.qmc.timeindexupdate(times)
            #                ###########      END OLD PROFILE FORMAT
            # update phases if phases are set to auto adjusted
            if self.qmc.phasesbuttonflag:
                # adjust phases by DryEnd and FCs events
                if self.qmc.timeindex[1]:
                    self.qmc.phases[1] = int(round(self.qmc.temp2[self.qmc.timeindex[1]]))
                if self.qmc.timeindex[2]:
                    self.qmc.phases[2] = int(round(self.qmc.temp2[self.qmc.timeindex[2]]))
            # ensure that timeindex has the proper length
            self.qmc.timeindex = self.qmc.timeindex + [0 for _ in range(8 - len(self.qmc.timeindex))]
            # reset linecount caches
            self.qmc.resetlinecountcaches()
            # try to reload background profile
            if (not quiet) and 'backgroundpath' in profile and decodeLocal(profile['backgroundpath']) != '':
                self.qmc.backgroundpath = decodeLocalStrict(profile['backgroundpath'])
                if os.path.isfile(self.qmc.backgroundpath):
                    try:
                        background_hidden = self.qmc.backgroundprofile is not None and not self.qmc.background  # before loading this new profile, a background was loaded but hidden
                        self.loadbackground(self.qmc.backgroundpath)
                        self.qmc.background = not self.qmc.hideBgafterprofileload and not background_hidden  # if before the loaded background was hidden, we again hide the background on loading this profile
                        self.qmc.timealign(
                            redraw=False)  # there will be a later redraw triggered that also recomputes the deltas
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                        self.deleteBackground()  # delete a loaded background if any
                elif 'backgroundUUID' in profile and self.qmc.backgroundUUID != profile['backgroundUUID']:
                    # background file path moved, we try to resolve via the UUID cache
                    background_path = plus.register.getPath(profile['backgroundUUID'])
                    if background_path is not None and os.path.isfile(background_path):
                        try:
                            self.loadbackground(background_path)
                            self.qmc.background = not self.qmc.hideBgafterprofileload
                            self.qmc.timealign(
                                redraw=False)  # there will be a later redraw triggered that also recomputes the deltas
                            self.qmc.backgroundpath = background_path
                            self.qmc.fileDirtySignal.emit()  # as we updated the background path we force a profile save
                        except Exception as e:  # pylint: disable=broad-except
                            _log.exception(e)
                            self.deleteBackground()  # delete a loaded background if any
                    else:
                        self.deleteBackground()  # delete a loaded background if any
                else:
                    self.deleteBackground()  # delete a loaded background if any
            self.autoAdjustAxis()
            if 'devices' in profile:
                self.qmc.profile_meter = decodeLocalStrict(profile['devices'][0], 'Unknown')
            else:
                self.qmc.profile_meter = 'Unknown'
            if _log.isEnabledFor(logging.DEBUG):
                _log.debug(self.profileQuality(m, True))
            return True
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            # we don't report errors on settingsLoad
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self, QApplication.translate('Error Message', 'Exception:') + ' setProfile()',
                                    str(ex) + '@line ' + str(getattr(exc_tb, 'tb_lineno', '?')))
            return False

    def profileQuality(self, profileMode: str = '', checkDebugLevel: bool = False) -> str:
        # immediately return when not at debug log level
        if checkDebugLevel and not debugLogLevelActive():
            return ''
        try:
            if len(self.qmc.timex) > 0:
                bt = numpy.array(self.qmc.temp2)
                tx = numpy.array(self.qmc.timex)

                if self.qmc.profile_sampling_interval is None:
                    speed = self.qmc.timeclock.getBase() / 1000
                    profile_sampling_interval = speed * (self.qmc.delay / 1000)
                else:
                    profile_sampling_interval = self.qmc.profile_sampling_interval

                # Meter
                # The meter is added to setProfile() as it was not previously read.  It useful here for trending.
                #    The Meter device is written to the profile whenever it is saved, meaning that it can be changed
                #     in the profile without warning and may not reflect the actual meter used to record the profile.
                meter = self.qmc.profile_meter

                # Count the number of decimal places in a float
                def ndec(num: float) -> int:
                    return len(re.sub(r'(?:[{0}]+$)', '', str(num)).split('.')[1])

                # Total number of samples
                totalSamples = len(self.qmc.timex)

                # Calculate the average number of decimals in an array of floats
                ndec_arr = numpy.array([ndec(x) for x in bt])
                avgDecimal = numpy.average(ndec_arr)
                maxDecimal = numpy.amax(ndec_arr)

                # Calculate the resolution from the BT values
                # Sort the numbers in ascending order
                # Calculate the differences between successive numbers
                # Find the smallest non-zero difference
                # Exception if there are no non-zero differences
                try:
                    resolution = numpy.min(numpy.diff(numpy.sort(bt))[numpy.nonzero(numpy.diff(numpy.sort(bt)))])
                except Exception:  # pylint: disable=broad-except
                    resolution = float('nan')

                str_modeChanged = ''
                if profileMode in {'C', 'F'} and self.qmc.mode != profileMode:
                    str_modeChanged = '*Result not reliable, the temperature mode was changed'

                # Count the number of consecutive duplicates
                markdup = numpy.diff(bt).astype(bool)  # False (or 0) marks a duplicate
                dups = numpy.count_nonzero(markdup == 0)  # counts the 0s
                blank = numpy.count_nonzero(bt == -1)  # counts missing values

                # Count skipped samples (missing timex)
                tx_diff = numpy.diff(tx)
                avg_sample = float(numpy.average(tx_diff))
                longest_sample = numpy.max(tx_diff)
                shortest_sample = numpy.min(tx_diff)
                skipped_sample_time = 1.5 * avg_sample
                skipped = numpy.count_nonzero(tx_diff > skipped_sample_time)
                bins = [0, 1 * profile_sampling_interval, 1.5 * profile_sampling_interval,
                        4 * profile_sampling_interval, 9999]
                hist = numpy.histogram(tx_diff, bins=bins)
                std_sample = numpy.std(tx_diff)

                # Aperiodic sample ratio
                aperiodicRatio = avg_sample / profile_sampling_interval

                # Missing events
                missingEvents = 'Missing key events: '
                lenLabel = len(missingEvents)
                if self.qmc.timeindex[0] == -1:
                    missingEvents += 'CHARGE '
                if self.qmc.timeindex[2] == 0:
                    missingEvents += 'FCs '
                if self.qmc.timeindex[6] == 0:
                    missingEvents += 'DROP '
                if len(missingEvents) == lenLabel:
                    missingEvents += 'None '

                # Are Special Events in order?
                flag = 0
                i = 1
                while i < len(self.qmc.specialevents):
                    if self.qmc.specialevents[i] < self.qmc.specialevents[i - 1]:
                        flag = 1
                        break
                    i += 1
                if flag:
                    speventsSorted = 'Special Events: Out of order'
                else:
                    speventsSorted = 'Special Events: In sorted order'

                # Output string
                output = (
                    f'Profile quality metrics'
                    f'\n  Title: {self.qmc.title}'
                    f'\n  Meter: {meter}'
                    f'\n  Resolution: {resolution:.2E} {str_modeChanged}'
                    f'\n  Average decimals: {avgDecimal:.2f} {str_modeChanged}'
                    f'\n  Max decimals: {maxDecimal:.2f} {str_modeChanged}'
                    f'\n  Total Samples: {totalSamples}'
                    f'\n  Duplicate Samples: {dups}'
                    f'\n  Blank Samples: {blank}'
                    f'\n  Skipped Samples: {skipped}  (more than {skipped_sample_time:.2f} secs)'
                    f'\n  Histogram of Sample Times: {hist[0]}  Bins: <1x, 1x-1.5x, 1.5x-4x, >4x Profile Sampling Interval'
                    f'\n  Shortest Sample Interval: {shortest_sample:.2f}'
                    f'\n  Longest Sample Interval: {longest_sample:.2f}'
                    f'\n  Average Sample Time: {avg_sample:.2f}'
                    f'\n  Std Dev Sample Time: {std_sample:.2E}'
                    f'\n  Profile Sampling Interval: {profile_sampling_interval:.2f}'
                    f'\n  Aperiodic Samples Ratio: {aperiodicRatio:.2f}'
                    f'\n  {missingEvents}'
                    f'\n  {speventsSorted}'
                )
            else:
                output = 'Metrics not available: profile is zero length.'
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            output = 'Metrics not available: exception'
        return output

    @staticmethod
    def weightVolumeDigits(v: float) -> int:
        if v >= 1000:
            return 1
        if v >= 100:
            return 2
        if v >= 10:
            return 3
        return 4

    @staticmethod
    def float2floatWeightVolume(v: float) -> float:
        d = ApplicationWindow.weightVolumeDigits(v)
        return ApplicationWindow.float2float(v, d)

    # the int n specifies the number of digits
    @staticmethod
    def float2floatNone(f: Optional[float], n: int = 1) -> Optional[float]:
        if f is None:
            return None
        return ApplicationWindow.float2float(f, n)

    # the int n specifies the number of digits
    @staticmethod
    def float2float(f: float, n: int = 1) -> float:
        f = float(f)
        if n == 0:
            if math.isnan(f):
                return 0
            return int(round(f))
        res: float = float(f'%.{n}f' % f)
        if math.isnan(res):
            return 0.0
        return res

    # returns data that is computed by Artisan out of raw profile data using some formulas
    # and displayed to users e.g. as part of the Report to users and stored along profiles to be used by external programs
    # in case a value cannot be computed the corresponding entry is missing in the resulting dict
    def computedProfileInformation(self) -> 'ComputedProfileInformation':
        computedProfile: 'ComputedProfileInformation' = {}
        TP_time_idx = None
        DRY_time_idx = None
        TP_index = 0
        try:
            if self.qmc.timeindex[0] != -1:
                start = self.qmc.timex[self.qmc.timeindex[0]]
                computedProfile['CHARGE_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[0]])
                computedProfile['CHARGE_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[0]])
            else:
                start = 0
            ######### TP #########
            # calc TP_time_idx (index of TP; is None if unknown)
            TP_index = self.findTP()  # could return -1
            if TP_index > 0 and len(self.qmc.timex) > 0:
                TP_time_idx = TP_index
            elif len(self.qmc.timex) > 0:
                TP_time_idx = 0
            else:
                TP_time_idx = None
            if TP_time_idx:
                computedProfile['TP_idx'] = TP_time_idx
                computedProfile['TP_time'] = self.float2float(self.qmc.timex[TP_time_idx] - start)
                computedProfile['TP_ET'] = self.float2float(self.qmc.temp1[TP_time_idx])
                computedProfile['TP_BT'] = self.float2float(self.qmc.temp2[TP_time_idx])
                if self.qmc.timeindex[6]:
                    relevant_ETs = self.qmc.temp1[TP_time_idx:self.qmc.timeindex[6]]
                    if relevant_ETs:  # relevant_ETs might be the empty list!
                        computedProfile['MET'] = self.float2float(max(relevant_ETs))
            ######### DRY #########
            if self.qmc.timeindex[1]:
                computedProfile['DRY_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[1]] - start)
                computedProfile['DRY_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[1]])
                computedProfile['DRY_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[1]])
                DRY_time_idx = self.qmc.timeindex[1]
            ######### FC #########
            if self.qmc.timeindex[2]:
                computedProfile['FCs_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[2]] - start)
                computedProfile['FCs_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[2]])
                computedProfile['FCs_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[2]])
            if self.qmc.timeindex[3]:
                computedProfile['FCe_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[3]] - start)
                computedProfile['FCe_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[3]])
                computedProfile['FCe_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[3]])
            ######### SC #########
            if self.qmc.timeindex[4]:
                computedProfile['SCs_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[4]] - start)
                computedProfile['SCs_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[4]])
                computedProfile['SCs_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[4]])
            if self.qmc.timeindex[5]:
                computedProfile['SCe_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[5]] - start)
                computedProfile['SCe_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[5]])
                computedProfile['SCe_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[5]])
            ######### DROP #########
            if self.qmc.timeindex[6]:
                computedProfile['DROP_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[6]] - start)
                computedProfile['DROP_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[6]])
                computedProfile['DROP_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[6]])
            ######### COOL #########
            if self.qmc.timeindex[7]:
                computedProfile['COOL_time'] = self.float2float(self.qmc.timex[self.qmc.timeindex[7]] - start)
                computedProfile['COOL_ET'] = self.float2float(self.qmc.temp1[self.qmc.timeindex[7]])
                computedProfile['COOL_BT'] = self.float2float(self.qmc.temp2[self.qmc.timeindex[7]])
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' computedProfileInformation() {0}').format(
                    str(ex)), getattr(exc_tb, 'tb_lineno', '?'))
        ######### Phases #########
        try:
            # we calculate the statistics here as the profile might not have yet been rendered and thus the statistics are not yet computed
            _, statisticstimes = self.qmc.calcStatistics(TP_index)
            if statisticstimes[0]:
                computedProfile['totaltime'] = self.float2float(statisticstimes[0], 3)
            if statisticstimes[1]:
                computedProfile['dryphasetime'] = self.float2float(statisticstimes[1], 3)
            if statisticstimes[2]:
                computedProfile['midphasetime'] = self.float2float(statisticstimes[2], 3)
            if statisticstimes[3]:
                computedProfile['finishphasetime'] = self.float2float(statisticstimes[3], 3)
            if statisticstimes[4]:
                computedProfile['coolphasetime'] = self.float2float(statisticstimes[4], 3)
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' computedProfileInformation() {0}').format(
                    str(ex)), getattr(exc_tb, 'tb_lineno', '?'))
        ######### RoR #########
        try:
            if TP_time_idx and DRY_time_idx:
                ror = self.RoR(TP_time_idx, DRY_time_idx)
                computedProfile['dry_phase_ror'] = self.float2float(ror[0])
                computedProfile['mid_phase_ror'] = self.float2float(ror[1])
                computedProfile['finish_phase_ror'] = self.float2float(ror[2])
                if 'TP_BT' in computedProfile and 'TP_time' in computedProfile and 'DROP_BT' in computedProfile and 'DROP_time' in computedProfile and \
                        (computedProfile['DROP_time'] - computedProfile['TP_time']) != 0:
                    computedProfile['total_ror'] = self.float2float(((computedProfile['DROP_BT'] - computedProfile[
                        'TP_BT']) / (computedProfile['DROP_time'] - computedProfile['TP_time'])) * 60.)
                if self.qmc.timeindex[2] > 0 and self.qmc.delta2:
                    fcs_ror = self.qmc.delta2[self.qmc.timeindex[2]]
                    if fcs_ror is not None:
                        computedProfile['fcs_ror'] = self.float2float(fcs_ror)
                if ror[3] != -1:
                    computedProfile['dry_phase_delta_temp'] = self.float2float(ror[3])
                if ror[4] != -1:
                    computedProfile['mid_phase_delta_temp'] = self.float2float(ror[4])
                if ror[5] != -1:
                    computedProfile['finish_phase_delta_temp'] = self.float2float(ror[5])
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' computedProfileInformation() {0}').format(
                    str(ex)), getattr(exc_tb, 'tb_lineno', '?'))
        ######### ETBTarea #########
        try:
            ts, tse, tsb, _ = self.ts(self.qmc.timeindex[0], self.qmc.timeindex[6])
            computedProfile['total_ts'] = int(round(ts, 0))
            computedProfile['total_ts_ET'] = int(round(tse, 0))
            computedProfile['total_ts_BT'] = int(round(tsb, 0))
        except Exception:  # pylint: disable=broad-except
            pass
        ######### AUC area #########
        try:
            _, _, tsb, _ = self.ts()
            computedProfile['AUC'] = int(round(tsb, 0))
            computedProfile['AUCbegin'] = ''
            computedProfile['AUCbase'] = self.float2float(self.qmc.AUCbase, 0)
            computedProfile['AUCfromeventflag'] = int(self.qmc.AUCbaseFlag)
            if self.qmc.AUCbegin == 0:
                computedProfile['AUCbegin'] = 'CHARGE'
                if self.qmc.AUCbaseFlag and 'CHARGE_BT' in computedProfile:  # base AUC is taken from BT at AUCbegin event
                    computedProfile['AUCbase'] = computedProfile['CHARGE_BT']
            elif self.qmc.AUCbegin == 1:
                computedProfile['AUCbegin'] = 'TP'
                if self.qmc.AUCbaseFlag and 'TP_BT' in computedProfile:  # base AUC is taken from BT at AUCbegin event
                    computedProfile['AUCbase'] = computedProfile['TP_BT']
            elif self.qmc.AUCbegin == 2:
                computedProfile['AUCbegin'] = 'DE'
                if self.qmc.AUCbaseFlag and 'DRY_BT' in computedProfile:  # base AUC is taken from BT at AUCbegin event
                    computedProfile['AUCbase'] = computedProfile['DRY_BT']
            elif self.qmc.AUCbegin == 3:
                computedProfile['AUCbegin'] = 'FCs'
                if self.qmc.AUCbaseFlag and 'FCs_BT' in computedProfile:  # base AUC is taken from BT at AUCbegin event
                    computedProfile['AUCbase'] = computedProfile['FCs_BT']
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        try:
            _, _, ts1b, _ = self.ts(self.qmc.timeindex[0], DRY_time_idx)
            computedProfile['dry_phase_AUC'] = int(round(ts1b, 0))
        except Exception:  # pylint: disable=broad-except
            pass
        try:
            _, _, ts2b, _ = self.ts(DRY_time_idx, self.qmc.timeindex[2])
            computedProfile['mid_phase_AUC'] = int(round(ts2b, 0))
        except Exception:  # pylint: disable=broad-except
            pass
        try:
            _, _, ts3b, _ = self.ts(self.qmc.timeindex[2], self.qmc.timeindex[6])
            computedProfile['finish_phase_AUC'] = int(round(ts3b, 0))
        except Exception:  # pylint: disable=broad-except
            pass
        ######### Weight, Volume, Loss, Gain, Density #########
        try:
            volumein = self.qmc.volume[0]
            volumeout = self.qmc.volume[1]
            weightin = self.qmc.weight[0]
            weightout = self.qmc.weight[1]
            weight_loss = self.weight_loss(weightin, weightout)
            volume_gain = self.volume_increase(volumein, volumeout)
            if weight_loss:
                computedProfile['weight_loss'] = self.float2float(weight_loss)
            if volume_gain:
                computedProfile['volume_gain'] = self.float2float(volume_gain)
            if self.qmc.moisture_greens and self.qmc.moisture_roasted:
                moisture_loss = self.qmc.moisture_greens - self.qmc.moisture_roasted
                computedProfile['moisture_loss'] = self.float2float(moisture_loss)
                if weight_loss:
                    computedProfile['organic_loss'] = self.float2float(weight_loss - moisture_loss)
            din = dout = 0.
            # standardize unit of volume and weight to l and g
            if volumein != 0.0:
                volumein = self.float2float(
                    self.convertVolume(volumein, self.qmc.volume_units.index(self.qmc.volume[2]), 0), 4)  # in l
            if volumeout != 0.0:
                volumeout = self.float2float(
                    self.convertVolume(volumeout, self.qmc.volume_units.index(self.qmc.volume[2]), 0), 4)  # in l
            # store volume in l
            computedProfile['volumein'] = volumein
            computedProfile['volumeout'] = volumeout
            # store weight in kg
            if weightin != 0.0:
                weightin = self.float2float(
                    self.convertWeight(weightin, self.qmc.weight_units.index(self.qmc.weight[2]), 0), 1)  # in g
            if weightout != 0.0:
                weightout = self.float2float(
                    self.convertWeight(weightout, self.qmc.weight_units.index(self.qmc.weight[2]), 0), 1)  # in g
            computedProfile['weightin'] = weightin
            computedProfile['weightout'] = weightout
            if volumein != 0.0 and volumeout != 0.0 and weightin != 0.0 and weightout != 0.0:
                din = weightin / volumein
                dout = weightout / volumeout
            if din > 0.:
                computedProfile['green_density'] = self.float2float(din, 1)
            if dout > 0.:
                computedProfile['roasted_density'] = self.float2float(dout, 1)

            if (self.qmc.density[0] != 0.0 and self.qmc.density[2] != 0.0):
                setdensity = self.qmc.density[0] / self.qmc.density[2]
                setdensity = self.convertWeight(self.qmc.density[0], self.qmc.weight_units.index(self.qmc.density[1]),
                                                0) / self.convertVolume(self.qmc.density[2],
                                                                        self.qmc.volume_units.index(
                                                                            self.qmc.density[3]), 0)
                computedProfile['set_density'] = self.float2float(setdensity, 1)
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' computedProfileInformation() {0}').format(
                    str(ex)), getattr(exc_tb, 'tb_lineno', '?'))
        ######### Humidity / Pressure #########
        try:
            if self.qmc.moisture_greens != 0.0 and not math.isnan(self.qmc.moisture_greens):
                computedProfile['moisture_greens'] = self.float2float(self.qmc.moisture_greens)
            if self.qmc.moisture_roasted != 0.0 and not math.isnan(self.qmc.moisture_roasted):
                computedProfile['moisture_roasted'] = self.float2float(self.qmc.moisture_roasted)
            if self.qmc.ambient_humidity != 0.0 and not math.isnan(self.qmc.ambient_humidity):
                computedProfile['ambient_humidity'] = self.float2float(self.qmc.ambient_humidity)
            if self.qmc.ambient_pressure != 0.0 and not math.isnan(self.qmc.ambient_pressure):
                computedProfile['ambient_pressure'] = self.float2float(self.qmc.ambient_pressure)
            if self.qmc.ambientTemp != 0.0 and not math.isnan(self.qmc.ambientTemp):
                computedProfile['ambient_temperature'] = self.float2float(self.qmc.ambientTemp)
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' computedProfileInformation() {0}').format(
                    str(ex)), getattr(exc_tb, 'tb_lineno', '?'))
        ######### Similarity #########
        try:
            det, dbt = self.curveSimilarity()
            if det is not None and not math.isnan(det):
                computedProfile['det'] = det
            if dbt is not None and not math.isnan(dbt):
                computedProfile['dbt'] = dbt
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        ######### Energy Use #########
        try:
            energymetrics, _ = self.qmc.calcEnergyuse()
            if 'BTU_preheat' in energymetrics:
                computedProfile['BTU_preheat'] = self.float2float(energymetrics['BTU_preheat'], 1)
            if 'CO2_preheat' in energymetrics:
                computedProfile['CO2_preheat'] = self.float2float(energymetrics['CO2_preheat'], 1)
            if 'BTU_bbp' in energymetrics:
                computedProfile['BTU_bbp'] = self.float2float(energymetrics['BTU_bbp'], 1)
            if 'CO2_bbp' in energymetrics:
                computedProfile['CO2_bbp'] = self.float2float(energymetrics['CO2_bbp'], 1)
            if 'BTU_cooling' in energymetrics:
                computedProfile['BTU_cooling'] = self.float2float(energymetrics['BTU_cooling'], 1)
            if 'CO2_cooling' in energymetrics:
                computedProfile['CO2_cooling'] = self.float2float(energymetrics['CO2_cooling'], 1)
            if 'BTU_LPG' in energymetrics:
                computedProfile['BTU_LPG'] = self.float2float(energymetrics['BTU_LPG'], 1)
            if 'BTU_NG' in energymetrics:
                computedProfile['BTU_NG'] = self.float2float(energymetrics['BTU_NG'], 1)
            if 'BTU_ELEC' in energymetrics:
                computedProfile['BTU_ELEC'] = self.float2float(energymetrics['BTU_ELEC'], 1)
            if 'BTU_batch' in energymetrics:
                computedProfile['BTU_batch'] = self.float2float(energymetrics['BTU_batch'], 1)
            if 'BTU_batch_per_green_kg' in energymetrics:
                computedProfile['BTU_batch_per_green_kg'] = self.float2float(energymetrics['BTU_batch_per_green_kg'], 1)
            if 'BTU_roast' in energymetrics:
                computedProfile['BTU_roast'] = self.float2float(energymetrics['BTU_roast'], 1)
            if 'BTU_roast_per_green_kg' in energymetrics:
                computedProfile['BTU_roast_per_green_kg'] = self.float2float(energymetrics['BTU_roast_per_green_kg'], 1)
            if 'CO2_batch' in energymetrics:
                computedProfile['CO2_batch'] = self.float2float(energymetrics['CO2_batch'], 1)
            if 'CO2_batch_per_green_kg' in energymetrics:
                computedProfile['CO2_batch_per_green_kg'] = self.float2float(energymetrics['CO2_batch_per_green_kg'], 1)
            if 'CO2_roast' in energymetrics:
                computedProfile['CO2_roast'] = self.float2float(energymetrics['CO2_roast'], 1)
            if 'CO2_roast_per_green_kg' in energymetrics:
                computedProfile['CO2_roast_per_green_kg'] = self.float2float(energymetrics['CO2_roast_per_green_kg'], 1)
            if 'KWH_batch_per_green_kg' in energymetrics:
                computedProfile['KWH_batch_per_green_kg'] = self.float2float(energymetrics['KWH_batch_per_green_kg'], 1)
            if 'KWH_roast_per_green_kg' in energymetrics:
                computedProfile['KWH_roast_per_green_kg'] = self.float2float(energymetrics['KWH_roast_per_green_kg'], 1)

        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' computedProfileInformation() {0}').format(
                    str(ex)), getattr(exc_tb, 'tb_lineno', '?'))
        ######### RETURN #########
        return computedProfile

    # used by filesave()
    # wrap values in unicode(.) if and only if those are of type string
    def getProfile(self) -> 'ProfileData':
        try:
            profile: 'ProfileData' = {}
            profile['recording_version'] = self.recording_version
            profile['recording_revision'] = self.recording_revision
            profile['recording_build'] = self.recording_build
            profile['version'] = str(__version__)
            profile['revision'] = str(__revision__)
            profile['build'] = str(__build__)
            os_name, os_version, os_arch = self.get_os()
            profile['artisan_os'] = os_name
            profile['artisan_os_version'] = os_version
            profile['artisan_os_arch'] = os_arch
            profile['mode'] = self.qmc.mode
            profile['viewerMode'] = self.app.artisanviewerMode
            profile['timeindex'] = self.qmc.timeindex
            profile['flavors'] = self.qmc.flavors
            profile['flavorlabels'] = [encodeLocalStrict(fl) for fl in self.qmc.flavorlabels]
            profile['flavorstartangle'] = self.qmc.flavorstartangle
            profile['flavoraspect'] = self.qmc.flavoraspect
            profile['title'] = encodeLocalStrict(self.qmc.title)
            profile['locale'] = self.locale_str

            # PLUS
            if self.qmc.plus_store is not None:
                profile['plus_store'] = encodeLocalStrict(self.qmc.plus_store)
                if self.qmc.plus_store_label is not None:
                    profile['plus_store_label'] = encodeLocalStrict(self.qmc.plus_store_label)
            if self.qmc.plus_coffee is not None:
                profile['plus_coffee'] = encodeLocalStrict(self.qmc.plus_coffee)
                if self.qmc.plus_coffee_label is not None:
                    profile['plus_coffee_label'] = encodeLocalStrict(self.qmc.plus_coffee_label)
            if self.qmc.plus_blend_spec is not None:
                # we convert the internal blend dictionary specification to the external list specification
                blend_spec = plus.stock.blend2list(self.qmc.plus_blend_spec)
                if blend_spec is not None:
                    profile['plus_blend_spec'] = blend_spec
                profile['plus_blend_label'] = encodeLocalStrict(self.qmc.plus_blend_label)
                if self.qmc.plus_blend_spec_labels is not None:
                    profile['plus_blend_spec_labels'] = [encodeLocalStrict(l) for l in self.qmc.plus_blend_spec_labels]

            profile['beans'] = encodeLocalStrict(self.qmc.beans)
            profile['weight'] = [self.qmc.weight[0], self.qmc.weight[1], encodeLocalStrict(self.qmc.weight[2], 'g')]
            profile['volume'] = [self.qmc.volume[0], self.qmc.volume[1], encodeLocalStrict(self.qmc.volume[2], 'l')]
            profile['density'] = [self.qmc.density[0], encodeLocalStrict(self.qmc.density[1], 'g'), self.qmc.density[2],
                                  encodeLocalStrict(self.qmc.density[3], 'l')]
            profile['density_roasted'] = [self.qmc.density_roasted[0],
                                          encodeLocalStrict(self.qmc.density_roasted[1], 'g'),
                                          self.qmc.density_roasted[2],
                                          encodeLocalStrict(self.qmc.density_roasted[3], 'l')]
            profile['roastertype'] = encodeLocalStrict(self.qmc.roastertype)
            profile['roastersize'] = self.qmc.roastersize
            profile['roasterheating'] = self.qmc.roasterheating
            profile['machinesetup'] = encodeLocalStrict(self.qmc.machinesetup)
            profile['operator'] = encodeLocalStrict(self.qmc.operator)
            profile['organization'] = encodeLocalStrict(self.qmc.organization)
            profile['drumspeed'] = self.qmc.drumspeed
            profile['heavyFC'] = self.qmc.heavyFC_flag
            profile['lowFC'] = self.qmc.lowFC_flag
            profile['lightCut'] = self.qmc.lightCut_flag
            profile['darkCut'] = self.qmc.darkCut_flag
            profile['drops'] = self.qmc.drops_flag
            profile['oily'] = self.qmc.oily_flag
            profile['uneven'] = self.qmc.uneven_flag
            profile['tipping'] = self.qmc.tipping_flag
            profile['scorching'] = self.qmc.scorching_flag
            profile['divots'] = self.qmc.divots_flag
            profile['whole_color'] = self.qmc.whole_color
            profile['ground_color'] = self.qmc.ground_color
            profile['color_system'] = self.qmc.color_systems[self.qmc.color_system_idx]
            profile['volumeCalcWeightIn'] = str(self.qmc.volumeCalcWeightInStr)
            profile['volumeCalcWeightOut'] = str(self.qmc.volumeCalcWeightOutStr)
            # write roastdate that respects locale and potential cannot be read in under a different locale (just for compatibility to older versions)
            try:
                profile['roastdate'] = encodeLocalStrict(self.qmc.roastdate.date().toString())
            except Exception:  # pylint: disable=broad-except
                pass
            # write ISO roast date
            try:
                profile['roastisodate'] = encodeLocalStrict(self.qmc.roastdate.date().toString(Qt.DateFormat.ISODate))
            except Exception:  # pylint: disable=broad-except
                pass
            # write roast time
            try:
                profile['roasttime'] = encodeLocalStrict(self.qmc.roastdate.time().toString())
                profile['roastepoch'] = int(self.qmc.roastdate.toSecsSinceEpoch())
                profile['roasttzoffset'] = self.qmc.roasttzoffset
            except Exception:  # pylint: disable=broad-except
                pass
            profile['roastbatchnr'] = self.qmc.roastbatchnr
            profile['roastbatchprefix'] = encodeLocalStrict(self.qmc.roastbatchprefix)
            profile['roastbatchpos'] = self.qmc.roastbatchpos
            if self.qmc.roastUUID is None:
                import uuid
                self.qmc.roastUUID = uuid.uuid4().hex  # generate UUID
            profile['roastUUID'] = self.qmc.roastUUID
            #            profile['beansize'] = str(self.qmc.beansize) # legacy; not stored any longer
            profile['beansize_min'] = str(
                self.qmc.beansize_min)  # int in str (legacy profiles may contain floats in str)
            profile['beansize_max'] = str(
                self.qmc.beansize_max)  # int in str (legacy profiles may contain floats in str)
            self.consolidateSpecialEvents()  # we ensure that all 4 lists holding the special events are of equal length
            profile['specialevents'] = self.qmc.specialevents
            profile['specialeventstype'] = self.qmc.specialeventstype
            profile['specialeventsvalue'] = self.qmc.specialeventsvalue
            profile['specialeventsStrings'] = [encodeLocalStrict(ses) for ses in self.qmc.specialeventsStrings]
            profile['default_etypes'] = [item == self.qmc.etypesdefault[i] for i, item in enumerate(self.qmc.etypes)]
            profile['etypes'] = [encodeLocalStrict(et) for et in self.qmc.etypes[:]]
            profile['roastingnotes'] = encodeLocalStrict(self.qmc.roastingnotes)
            profile['cuppingnotes'] = encodeLocalStrict(self.qmc.cuppingnotes)
            profile['timex'] = [self.float2float(x, 10) for x in self.qmc.timex]
            profile['temp1'] = [self.float2float(x, 8) for x in self.qmc.temp1]
            profile['temp2'] = [self.float2float(x, 8) for x in self.qmc.temp2]
            profile['phases'] = self.qmc.phases
            profile['zmax'] = int(self.qmc.zlimit)
            profile['zmin'] = int(self.qmc.zlimit_min)
            profile['ymax'] = int(self.qmc.ylimit)
            profile['ymin'] = int(self.qmc.ylimit_min)
            profile['xmin'] = float(self.qmc.startofx)
            profile['xmax'] = float(self.qmc.endofx)
            profile['ambientTemp'] = self.qmc.ambientTemp
            profile['ambient_humidity'] = self.qmc.ambient_humidity
            profile['ambient_pressure'] = self.qmc.ambient_pressure
            profile['moisture_greens'] = self.qmc.moisture_greens
            profile['greens_temp'] = self.qmc.greens_temp
            profile['moisture_roasted'] = self.qmc.moisture_roasted
            profile['extradevices'] = self.qmc.extradevices
            profile['extraname1'] = [encodeLocalStrict(n, 'Extra 1') for n in self.qmc.extraname1]
            profile['extraname2'] = [encodeLocalStrict(n, 'Extra 2') for n in self.qmc.extraname2]
            profile['extratimex'] = [[self.float2float(t, 10) for t in x] for x in self.qmc.extratimex]
            profile['extratemp1'] = [[self.float2float(t, 8) for t in x] for x in self.qmc.extratemp1]
            profile['extratemp2'] = [[self.float2float(t, 8) for t in x] for x in self.qmc.extratemp2]
            profile['extramathexpression1'] = [encodeLocalStrict(x) for x in self.qmc.extramathexpression1]
            profile['extramathexpression2'] = [encodeLocalStrict(x) for x in self.qmc.extramathexpression2]
            profile['extradevicecolor1'] = [encodeLocalStrict(x, '#000000') for x in self.qmc.extradevicecolor1]
            profile['extradevicecolor2'] = [encodeLocalStrict(x, '#000000') for x in self.qmc.extradevicecolor2]
            profile['extraLCDvisibility1'] = self.extraLCDvisibility1
            profile['extraLCDvisibility2'] = self.extraLCDvisibility2
            profile['extraCurveVisibility1'] = self.extraCurveVisibility1
            profile['extraCurveVisibility2'] = self.extraCurveVisibility2
            profile['extraDelta1'] = self.extraDelta1
            profile['extraDelta2'] = self.extraDelta2
            profile['extraFill1'] = self.extraFill1
            profile['extraFill2'] = self.extraFill2
            profile['extramarkersizes1'] = self.qmc.extramarkersizes1
            profile['extramarkersizes2'] = self.qmc.extramarkersizes2
            profile['extramarkers1'] = [encodeLocalStrict(x, self.qmc.marker_default) for x in self.qmc.extramarkers1]
            profile['extramarkers2'] = [encodeLocalStrict(x, self.qmc.marker_default) for x in self.qmc.extramarkers2]
            profile['extralinewidths1'] = self.qmc.extralinewidths1
            profile['extralinewidths2'] = self.qmc.extralinewidths2
            profile['extralinestyles1'] = [encodeLocalStrict(x, self.qmc.linestyle_default) for x in
                                           self.qmc.extralinestyles1]
            profile['extralinestyles2'] = [encodeLocalStrict(x, self.qmc.linestyle_default) for x in
                                           self.qmc.extralinestyles2]
            profile['extradrawstyles1'] = [encodeLocalStrict(x, self.qmc.drawstyle_default) for x in
                                           self.qmc.extradrawstyles1]
            profile['extradrawstyles2'] = [encodeLocalStrict(x, self.qmc.drawstyle_default) for x in
                                           self.qmc.extradrawstyles2]
            profile['externalprogram'] = encodeLocalStrict(self.ser.externalprogram)
            profile['externaloutprogram'] = encodeLocalStrict(self.ser.externaloutprogram)
            profile['extraNoneTempHint1'] = self.qmc.extraNoneTempHint1
            profile['extraNoneTempHint2'] = self.qmc.extraNoneTempHint2
            # alarms
            profile['alarmsetlabel'] = self.qmc.alarmsetlabel
            profile['alarmflag'] = self.qmc.alarmflag
            profile['alarmguard'] = self.qmc.alarmguard
            profile['alarmnegguard'] = self.qmc.alarmnegguard
            profile['alarmtime'] = self.qmc.alarmtime
            profile['alarmoffset'] = self.qmc.alarmoffset
            profile['alarmcond'] = self.qmc.alarmcond
            profile['alarmsource'] = self.qmc.alarmsource
            profile['alarmtemperature'] = self.qmc.alarmtemperature
            profile['alarmaction'] = self.qmc.alarmaction
            profile['alarmbeep'] = self.qmc.alarmbeep
            profile['alarmstrings'] = [encodeLocalStrict(x) for x in self.qmc.alarmstrings]
            # remember background profile path and UUID
            bpp = encodeLocal(self.qmc.backgroundpath)
            if bpp is not None:
                profile['backgroundpath'] = bpp
            if self.qmc.backgroundUUID is not None:
                profile['backgroundUUID'] = self.qmc.backgroundUUID
            # write only:
            if self.qmc.profile_sampling_interval is not None:
                profile['samplinginterval'] = self.qmc.profile_sampling_interval
            profile['svLabel'] = self.pidcontrol.svLabel
            profile['svValues'] = self.pidcontrol.svValues
            profile['svRamps'] = self.pidcontrol.svRamps
            profile['svSoaks'] = self.pidcontrol.svSoaks
            profile['svActions'] = self.pidcontrol.svActions
            profile['svBeeps'] = self.pidcontrol.svBeeps
            profile['svDescriptions'] = self.pidcontrol.svDescriptions
            try:
                ds = list(self.qmc.extradevices)
                ds.insert(0, self.qmc.device)
                profile['devices'] = [('PID' if d == 0 else self.qmc.devices[d - 1]) for d in ds]
            except Exception:  # pylint: disable=broad-except
                pass
            profile['elevation'] = self.qmc.elevation
            profile['computed'] = self.computedProfileInformation()
            # add positions of main event annotations and custom event flags
            profile['anno_positions'] = self.qmc.getAnnoPositions()
            profile['flag_positions'] = self.qmc.getFlagPositions()
            if self.qmc.legend is not None and not isinstance(self.qmc.legend._loc,
                                                              int):  # type: ignore # "Legend" has no attribute "_loc" # pylint: disable=protected-access
                # if a legend is currently drawn and has a custom position we save its position in data coordinates
                try:
                    if self.qmc.ax is not None:
                        axis_to_data = self.qmc.ax.transAxes + self.qmc.ax.transData.inverted()
                        profile['legendloc_pos'] = axis_to_data.transform(
                            self.qmc.legend._loc).tolist()  # type: ignore # "Legend" has no attribute "_loc" # pylint: disable=protected-access
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)

            # Energy Settings
            try:
                profile['loadlabels'] = self.qmc.loadlabels
                profile['loadratings'] = self.qmc.loadratings
                profile['ratingunits'] = self.qmc.ratingunits
                profile['sourcetypes'] = self.qmc.sourcetypes
                profile['load_etypes'] = self.qmc.load_etypes
                profile['presssure_percents'] = self.qmc.presssure_percents
                profile['loadevent_zeropcts'] = self.qmc.loadevent_zeropcts
                profile['loadevent_hundpcts'] = self.qmc.loadevent_hundpcts
                profile['preheatDuration'] = self.qmc.preheatDuration
                profile['preheatenergies'] = self.qmc.preheatenergies
                profile['betweenbatchDuration'] = self.qmc.betweenbatchDuration
                profile['betweenbatchenergies'] = self.qmc.betweenbatchenergies
                profile['coolingDuration'] = self.qmc.coolingDuration
                profile['coolingenergies'] = self.qmc.coolingenergies
                profile['betweenbatch_after_preheat'] = self.qmc.betweenbatch_after_preheat
                profile['electricEnergyMix'] = self.qmc.electricEnergyMix
            except Exception as ex:  # pylint: disable=broad-except
                _log.exception(ex)
                _, _, exc_tb = sys.exc_info()
                self.qmc.adderror(
                    (QApplication.translate('Error Message', 'Exception:') + ' getProfile(): {0}').format(str(ex)),
                    getattr(exc_tb, 'tb_lineno', '?'))

            return profile
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' getProfile(): {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return {}

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileSave_current_action(self, _: bool = False) -> None:
        self.fileSave(self.curFile)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileSave_new_action(self, _: bool = False) -> None:
        self.fileSave(None)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileSave_copy_action(self, _: bool = False) -> None:
        self.fileSave(None, copy=True)

    # saves recorded profile in hard drive. Called from file menu
    # returns True if file was saved successfully
    # if copy is True, a new UUID is generated to be saved along the file
    def fileSave(self, fname: Optional[str], copy: bool = False) -> bool:
        try:
            filename = fname
            if not filename:
                path = QDir()
                path.setPath(self.getDefaultPath())
                if self.qmc.batchcounter > -1 and self.qmc.roastbatchnr > 0 and self.qmc.autosaveprefix == '':
                    prefix = self.qmc.batchprefix + str(self.qmc.roastbatchnr)
                elif self.qmc.roastbatchprefix != '' and self.qmc.autosaveprefix == '':
                    prefix = self.qmc.roastbatchprefix
                else:
                    prefix = self.qmc.autosaveprefix
                fname = path.absoluteFilePath(self.generateFilename(prefix=prefix))
                filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Profile'), path=fname)
            if filename:
                # write
                pf = self.getProfile()
                if pf:
                    # if the copy flag is set, we generate a new roastUUID
                    if copy:
                        import uuid
                        pf['roastUUID'] = uuid.uuid4().hex  # generate UUID

                    sync_record_hash = plus.controller.updateSyncRecordHashAndSync()
                    if sync_record_hash is not None:
                        # we add the hash over the sync record to be able to detect offline changes
                        srh = encodeLocal(sync_record_hash)
                        if srh is not None:
                            pf['plus_sync_record_hash'] = srh

                    # we save the file and set the filename
                    self.serialize(filename, cast(Dict[str, Any], pf))
                    self.sendmessage(QApplication.translate('Message', 'Profile saved'))
                    _log.info('profile saved: %s', filename)
                    if not copy:
                        self.setCurrentFile(filename)
                        self.curFile = filename
                        self.qmc.fileCleanSignal.emit()

                    # update plus data set modification date
                    self.qmc.plus_file_last_modified = plus.util.getModificationDate(filename)

                    if self.qmc.autosaveimage:
                        #
                        if QFileInfo(filename).suffix() == 'alog':
                            name_also = QFileInfo(filename).completeBaseName()
                        else:
                            name_also = QFileInfo(filename).fileName()
                        path_also = QDir()
                        if self.qmc.autosavealsopath != '':
                            path_also.setPath(self.qmc.autosavealsopath)
                        else:
                            path_also.setPath(QFileInfo(filename).path())
                        filename_also = path_also.absoluteFilePath(name_also)
                        if self.qmc.autosaveimageformat == 'PDF':
                            self.saveVectorGraph(extension='.pdf', fname=filename_also)
                        elif self.qmc.autosaveimageformat == 'SVG':
                            self.saveVectorGraph(extension='.svg', fname=filename_also)
                        elif self.qmc.autosaveimageformat == 'CSV':
                            self.exportCSV(filename_also + '.csv')
                        elif self.qmc.autosaveimageformat == 'JSON':
                            self.exportJSON(filename_also + '.json')
                        else:
                            self.resizeImgToSize(0, 0, self.qmc.autosaveimageformat, fname=filename_also)
                    return True
                self.sendmessage(QApplication.translate('Message', 'Cancelled'))
                return False
            self.sendmessage(QApplication.translate('Message', 'Cancelled'))
            return False
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' filesave(): {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return False

    def fileExport(self, msg: str, ext: str, dumper: Callable[[str], bool]) -> None:
        try:
            filename = self.ArtisanSaveFileDialog(msg=msg, ext=ext)
            if filename:
                res = dumper(filename)
                if res:
                    self.sendmessage(QApplication.translate('Message', 'Readings exported'))
            else:
                self.sendmessage(QApplication.translate('Message', 'Cancelled'))
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' fileExport(): {0}').format(str(ex)))
            return

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportExcel(self, _: bool = False) -> None:
        self.fileExport(QApplication.translate('Message', 'Export Excel'), '*.xlsx', self.exportExcel)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportCSV(self, _: bool = False) -> None:
        self.fileExport(QApplication.translate('Message', 'Export CSV'), '*.csv', self.exportCSV)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportJSON(self, _: bool = False) -> None:
        self.fileExport(QApplication.translate('Message', 'Export JSON'), '*.json', self.exportJSON)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportRoastLogger(self, _: bool = False) -> None:
        self.fileExport(QApplication.translate('Message', 'Export RoastLogger'), '*.csv', self.exportRoastLogger)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileExportPilot(self, _: bool = False) -> None:
        self.fileExport(QApplication.translate('Message', 'Export Probat Pilot'), '*.xml', self.exportPilot)

    def fileConvert(self, ext: str, dumper: Callable[[str], bool]) -> None:
        files = self.ArtisanOpenFilesDialog(ext='*.alog')
        if files and len(files) > 0:
            loaded_profile = self.curFile
            cont = self.qmc.reset(soundOn=False)
            if cont:
                self.saveExtradeviceSettings()
                outdir = self.ArtisanExistingDirectoryDialog()
                progress: QProgressDialog = QProgressDialog(QApplication.translate('Message', 'Converting...'), '', 0,
                                                            len(files), self)
                progress.setCancelButton(None)
                progress.setWindowModality(Qt.WindowModality.WindowModal)
                progress.setAutoClose(True)
                progress.show()
                i = 1
                flag_temp = self.qmc.roastpropertiesflag
                for f in files:
                    try:
                        progress.setValue(i)
                        QApplication.processEvents()
                        fname = str(QFileInfo(f).fileName())
                        fconv = str(QDir(outdir).filePath(fname + str(ext)))
                        if not os.path.exists(fconv):
                            self.qmc.reset(redraw=False, soundOn=False)
                            pd = cast('ProfileData', self.deserialize(f))
                            self.setProfile(f, pd, quiet=True)
                            self.qmc.redraw()  # we need to redraw to ensure populated delta lines
                            dumper(fconv)
                        else:
                            self.sendmessage(
                                QApplication.translate('Message', 'Target file {0} exists. {1} not converted.').format(
                                    fconv, fname + str(ext)))
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                    i += 1
                    self.qmc.fileCleanSignal.emit()
                    self.qmc.reset(soundOn=False)
                    self.restoreExtradeviceSettings()
                if loaded_profile:
                    self.loadFile(loaded_profile, quiet=True)
                self.qmc.roastpropertiesflag = flag_temp
                progress.cancel()
                del progress

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertExcel(self, _: bool = False) -> None:
        self.fileConvert('.xlsx', self.exportExcel)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertCSV(self, _: bool = False) -> None:
        self.fileConvert('.csv', self.exportCSV)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertJSON(self, _: bool = False) -> None:
        self.fileConvert('.json', self.exportJSON)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertRoastLogger(self, _: bool = False) -> None:
        self.fileConvert('.csv', self.exportRoastLogger)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertPilot(self, _: bool = False) -> None:
        self.fileConvert('.xml', self.exportPilot)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertPNG(self, _: bool = False) -> None:
        self.fileConvertBITMAP('PNG')

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertJPEG(self, _: bool = False) -> None:
        self.fileConvertBITMAP('JPEG')

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertBMP(self, _: bool = False) -> None:
        self.fileConvertBITMAP('BMP')

    def fileConvertBITMAP(self, filetype: str = 'PNG') -> None:
        files = self.ArtisanOpenFilesDialog(ext='*.alog')
        if files and len(files) > 0:
            loaded_profile = self.curFile
            cont = self.qmc.reset(soundOn=False)
            if cont:
                self.saveExtradeviceSettings()
                fileext = '.png'
                if filetype == 'JPEG':
                    fileext = '.jpg'
                elif filetype == 'BMP':
                    fileext = '.bmp'
                outdir = self.ArtisanExistingDirectoryDialog()
                progress: QProgressDialog = QProgressDialog(QApplication.translate('Message', 'Converting...'), '', 0,
                                                            len(files), self)
                progress.setCancelButton(None)
                progress.setWindowModality(Qt.WindowModality.WindowModal)
                progress.setAutoClose(True)
                progress.show()
                i = 1
                flag_temp = self.qmc.roastpropertiesflag
                for f in files:
                    try:
                        progress.setValue(i)
                        QApplication.processEvents()
                        fname = str(QFileInfo(f).fileName())
                        fconv = str(QDir(outdir).filePath(fname + str(fileext)))
                        if not os.path.exists(fconv):
                            self.qmc.reset(redraw=False, soundOn=False)
                            pd = cast('ProfileData', self.deserialize(f))
                            self.setProfile(f, pd, quiet=False)
                            self.qmc.redraw()
                            image = self.qmc.grab()
                            if filetype in {'JPEG', 'BMP', 'PNG'}:
                                # transparences are not supported by those file types and are rendered in black by default.
                                white_img = QPixmap(image.size())
                                white_img.fill()  # fills by default with Qt.GlobalColor.white
                                painter = QPainter(white_img)
                                painter.drawPixmap(0, 0, image.width(), image.height(), image)
                                image = white_img
                                painter.end()
                                del painter
                            image.save(fconv, filetype)
                        else:
                            self.sendmessage(
                                QApplication.translate('Message', 'Target file {0} exists. {1} not converted.').format(
                                    fconv, fname + str(fileext)))
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                    i += 1
                    self.qmc.fileCleanSignal.emit()
                    self.qmc.reset(soundOn=False)
                    self.restoreExtradeviceSettings()
                if loaded_profile:
                    self.loadFile(loaded_profile, quiet=True)
                self.qmc.roastpropertiesflag = flag_temp
                progress.cancel()
                del progress

    @pyqtSlot(bool)
    def fileConvertSVG(self, _: bool = False) -> None:
        self.fileConvertIMG('.svg')

    @pyqtSlot(bool)
    def fileConvertPDF(self, _: bool = False) -> None:
        self.fileConvertIMG('.pdf')

    @pyqtSlot(bool)
    def fileConvertReportPDF(self, _: bool = False) -> None:
        self.fileConvertReport('.pdf')

    def fileConvertReport(self, ext: str) -> None:
        files = self.ArtisanOpenFilesDialog(ext='*.alog')
        if files and len(files) > 0:
            loaded_profile = self.curFile
            self.saveExtradeviceSettings()
            outdir = self.ArtisanExistingDirectoryDialog()
            progress: QProgressDialog = QProgressDialog(QApplication.translate('Message', 'Converting...'), '', 0,
                                                        len(files), self)
            progress.setCancelButton(None)
            progress.setWindowModality(Qt.WindowModality.WindowModal)
            progress.setAutoClose(True)
            progress.show()
            i = 1
            flag_temp = self.qmc.roastpropertiesflag
            for f in files:
                try:
                    progress.setValue(i)
                    QApplication.processEvents()
                    fname = str(QFileInfo(f).fileName())
                    fconv = str(QDir(outdir).filePath(fname + str(ext)))
                    if not os.path.exists(fconv):
                        self.qmc.reset(redraw=False, soundOn=False)
                        pd = cast('ProfileData', self.deserialize(f))
                        self.setProfile(f, pd, quiet=True)
                        self.qmc.redraw()
                        self.roastReport(pdf_filename=fconv, batch_process=True)
                    else:
                        self.sendmessage(
                            QApplication.translate('Message', 'Target file {0} exists. {1} not converted.').format(
                                fconv, fname + str(ext)))
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
                i += 1
                self.qmc.fileCleanSignal.emit()
                self.qmc.reset(soundOn=False)
                self.restoreExtradeviceSettings()
            self.releaseQWebEngineView()
            if loaded_profile:
                self.loadFile(loaded_profile, quiet=True)
            self.qmc.roastpropertiesflag = flag_temp
            progress.cancel()
            del progress

    def fileConvertIMG(self, ext: str) -> None:
        files = self.ArtisanOpenFilesDialog(ext='*.alog')
        if files and len(files) > 0:
            loaded_profile = self.curFile
            self.saveExtradeviceSettings()
            outdir = self.ArtisanExistingDirectoryDialog()
            progress: QProgressDialog = QProgressDialog(QApplication.translate('Message', 'Converting...'), '', 0,
                                                        len(files), self)
            progress.setCancelButton(None)
            progress.setWindowModality(Qt.WindowModality.WindowModal)
            progress.setAutoClose(True)
            progress.show()
            i = 1
            flag_temp = self.qmc.roastpropertiesflag
            for f in files:
                try:
                    progress.setValue(i)
                    QApplication.processEvents()
                    fname = str(QFileInfo(f).fileName())
                    fconv = str(QDir(outdir).filePath(fname + str(ext)))
                    if not os.path.exists(fconv):
                        self.qmc.reset(redraw=False, soundOn=False)
                        pd = cast('ProfileData', self.deserialize(f))
                        self.setProfile(f, pd, quiet=True)
                        self.qmc.redraw()
                        self.qmc.fig.savefig(fconv, transparent=True, facecolor='none',
                                             edgecolor='none')  # transparent=True is need to get the delta curves and legend drawn
                    else:
                        self.sendmessage(
                            QApplication.translate('Message', 'Target file {0} exists. {1} not converted.').format(
                                fconv, fname + str(ext)))
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
                i += 1
                self.qmc.fileCleanSignal.emit()
                self.qmc.reset(soundOn=False)
                self.restoreExtradeviceSettings()
            if loaded_profile:
                self.loadFile(loaded_profile, quiet=True)
            self.qmc.roastpropertiesflag = flag_temp
            progress.cancel()
            del progress

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertToFahrenheit(self, _: bool = False) -> None:
        self.fileConverToTemp('F')

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileConvertToCelsius(self, _: bool = False) -> None:
        self.fileConverToTemp('C')

    def fileConverToTemp(self, t: str) -> None:
        files = self.ArtisanOpenFilesDialog(ext='*.alog')
        if files and len(files) > 0:
            self.saveExtradeviceSettings()
            loaded_profile = self.curFile
            cont = self.qmc.reset(soundOn=False)
            if cont:
                outdir = self.ArtisanExistingDirectoryDialog()
                progress: QProgressDialog = QProgressDialog(QApplication.translate('Message', 'Converting...'), '', 0,
                                                            len(files), self)
                progress.setCancelButton(None)
                progress.setWindowModality(Qt.WindowModality.WindowModal)
                progress.setAutoClose(True)
                progress.show()
                i = 1
                flag_temp = self.qmc.roastpropertiesflag
                for f in files:
                    try:
                        progress.setValue(i)
                        QApplication.processEvents()
                        fname = str(QFileInfo(f).fileName())
                        fconv = str(QDir(outdir).filePath(fname))
                        if not os.path.exists(fconv):
                            self.qmc.reset(redraw=False, soundOn=False)
                            pd = cast('ProfileData', self.deserialize(f))
                            self.setProfile(f, pd, quiet=True)
                            self.qmc.convertTemperature(t, True)
                            self.fileSave(fconv)
                        else:
                            self.sendmessage(
                                QApplication.translate('Message', 'Target file {0} exists. {1} not converted.').format(
                                    fconv, fname))
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                    i += 1
                    self.qmc.fileCleanSignal.emit()
                    self.qmc.reset(soundOn=False)
                    self.restoreExtradeviceSettings()
                if loaded_profile:
                    self.loadFile(loaded_profile, quiet=True)
                self.qmc.roastpropertiesflag = flag_temp
                progress.cancel()
                del progress

    def fileImport(self, msg: str, loader: Callable[[str], None], reset: bool = False, ext: str = '*') -> None:
        try:
            filename = self.ArtisanOpenFileDialog(msg=msg, ext=ext)
            if filename:
                res = self.qmc.reset(True, False) if reset else True
                if res:
                    loader(filename)
                    self.sendmessage(QApplication.translate('Message', 'Readings imported'))
                    return
            self.sendmessage(QApplication.translate('Message', 'Cancelled'))
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' fileImport(): {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

    @staticmethod
    def artisanURLextractor(url: QUrl, _aw: 'ApplicationWindow') -> Optional['ProfileData']:
        try:
            import requests
            r = requests.get(url.toString(),
                             allow_redirects=True,
                             timeout=(4, 15),
                             headers={'Accept-Encoding': 'gzip'},
                             #            verify=False
                             )
            return cast('ProfileData', ast.literal_eval(r.text))
        except Exception:  # pylint: disable=broad-except
            return None

    @pyqtSlot()
    @pyqtSlot(bool)
    def urlImport(self, _: bool = False) -> None:
        try:
            self.importExternalURL(self.artisanURLextractor, QApplication.translate('Message', 'Import Artisan URL'))
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileImportCSV(self, _: bool = False) -> None:
        self.fileImport(QApplication.translate('Message', 'Import CSV'), self.importCSV, True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileImportJSON(self, _: bool = False) -> None:
        self.fileImport(QApplication.translate('Message', 'Import JSON'), self.importJSON, True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileImportRoastLogger(self, _: bool = False) -> None:
        self.fileImport(QApplication.translate('Message', 'Import RoastLogger'), self.importRoastLogger, True)

    @pyqtSlot(bool)
    def notificationsSetEnabled(self, enabled: bool) -> None:
        if self.notificationsflag != enabled:
            _log.info('notifications: %s', self.notificationsflag)
        self.notificationsflag = enabled
        if self.notificationManager:
            if self.notificationsflag:
                self.notificationManager.showNotifications()
                self.notificationManager.enableNotifications()
            else:
                self.notificationManager.disableNotifications()
                self.notificationManager.hideNotifications()

    @pyqtSlot(bytes, int)
    def santokerSendMessage(self, target: bytes, value: int) -> None:
        if self.santoker is not None:
            self.santoker.send_msg(target, value)

    # kaleidoSendMessage() just sends out the message to the machine without waiting for a response
    @pyqtSlot(str, str)
    def kaleidoSendMessage(self, target: str, value: str) -> None:
        if self.kaleido is not None:
            self.kaleido.send_msg(target, value)

    # if record is True, an event is added during recording, otherwise only the slider is moved
    # if fire_slider_action is True, the slider action is fired
    # if force is True, process even if value is equal to the events lastvalue resp. the current slider value
    @pyqtSlot(int, int, bool, bool, bool)
    def addEventSlot(self, value: int, etype: int, record: bool, fire_slider_action: bool, force: bool) -> None:
        # limit value by slider limits
        if -1 < etype < 4:
            new_value = min(self.eventslidermax[etype], max(self.eventslidermin[etype], value))
            if force or (record and (
                    self.extraeventsactionslastvalue[etype] is None or new_value != self.extraeventsactionslastvalue[
                etype])) or self.sliderpos(etype) != value:
                # new value is different from the last recorded one or the slider position thus we register this one
                # reset quantification block
                self.block_quantification_sampling_ticks[etype] = self.sampling_ticks_to_block_quantifiction
                # remember the new value as the last value set for this event
                self.extraeventsactionslastvalue[etype] = new_value
                # move corresponding slider to new value:
                self.moveslider(etype, new_value)
                # optionally we fire the sider action
                if fire_slider_action:
                    self.fireslideractionSignal.emit(etype)
                # create a new event
                if record and self.qmc.flagstart:
                    nv: float = self.qmc.eventsExternal2InternalValue(new_value)
                    self.qmc.eventRecordActionSignal.emit(etype, nv, '', True)

    # kaleidoSendMessageAwait() sends out the message to the machine, awaits the reply and creates a corresponding event entry
    @pyqtSlot(str, str, int, int)
    def kaleidoSendMessageAwait(self, target: str, value: str, etype: int, lastbuttonpressed: int) -> None:
        if self.kaleido is not None:
            if etype == -1 and len(self.buttonlist) > lastbuttonpressed > -1:
                # we block all signals emitted from this button until we received a response
                self.buttonlist[lastbuttonpressed].blockSignals(True)
            try:
                res: Optional[str] = self.kaleido.send_request(target, value, timeout=self.kaleido.send_button_timeout)
                QApplication.processEvents()  # let's consume events received after blocking
                if res is not None:
                    try:
                        try:
                            self.lastIOResult = float(res)
                        except Exception:  # pylint: disable=broad-except
                            self.lastIOResult = None
                        if etype == -1:
                            if len(self.buttonlist) > lastbuttonpressed > -1:
                                # we got a valid lastbutton which triggered this action and we set its state according to our result
                                bv = toBool(res)
                                # block resetting style of last button
                                self.lastbuttonpressed = -1
                                self.buttonStates[lastbuttonpressed] = int(bv)
                                if bv:
                                    self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'pressed')
                                else:
                                    self.setExtraEventButtonStyleSignal.emit(lastbuttonpressed, 'normal')
                        elif etype > -1:
                            new_value = int(round(float(res)))
                            self.addEventSignal.emit(new_value, etype, True, False, False)
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
            finally:
                if etype == -1 and len(self.buttonlist) > lastbuttonpressed > -1:
                    # we unblock all signals emitted from this button until we received a response
                    self.buttonlist[lastbuttonpressed].blockSignals(False)

    # removes window geometry and splitter settings from the given settings
    @staticmethod
    def clearWindowGeometry(settings: QSettings) -> None:
        for s in ['Geometry', 'BlendGeometry', 'RoastGeometry', 'FlavorProperties', 'CalculatorGeometry',
                  'EventsGeometry', 'CompareGeometry',
                  'BackgroundGeometry', 'LCDGeometry', 'DeltaLCDGeometry', 'ExtraLCDGeometry', 'PhasesLCDGeometry',
                  'AlarmsGeometry',
                  'DeviceAssignmentGeometry', 'PortsGeometry', 'TransformatorPosition', 'CurvesPosition',
                  'StatisticsPosition',
                  'AxisPosition', 'PhasesPosition', 'BatchPosition', 'SamplingPosition', 'autosaveGeometry',
                  'PIDPosition',
                  'DesignerPosition', 'PIDLCDGeometry', 'ScaleLCDGeometry', 'MainSplitter']:
            settings.remove(s)

    # loads the settings at the start of application. See the oppposite closeEventSettings()
    def settingsLoad(self, filename: Optional[str] = None, theme: bool = False, machine: bool = False,
                     redraw: bool = True) -> bool:  # pyright: ignore [reportGeneralTypeIssues] # Code is too complex to analyze; reduce complexity by refactoring into subroutines or reducing
        res = False
        try:
            updateBatchCounter = True
            if filename is not None:
                settings = QSettings(filename, QSettings.Format.IniFormat)

                # a proper artisan-settings.aset file needs at least to contain a Mode tag
                if not (theme or machine) and not settings.contains('Mode'):
                    self.qmc.adderror(
                        QApplication.translate('Error Message', 'Exception: {} not a valid settings file').format(
                            str(filename)))
                    return False

                if self.qmc.neverUpdateBatchCounter or self.app.artisanviewerMode:
                    updateBatchCounter = False
                else:

                    # --- BEGIN GROUP Batch
                    settings.beginGroup('Batch')
                    if settings.contains('batchcounter'):
                        files_batchcounter = toInt(settings.value('batchcounter', self.qmc.batchcounter))
                        if files_batchcounter != self.qmc.batchcounter:
                            current_counter = str(self.qmc.batchcounter)
                            files_counter = str(files_batchcounter)
                            if self.qmc.batchcounter < 0:
                                string = QApplication.translate('Message',
                                                                'Your batch counter is currently turned off. Turn it on and set it to %s from the settings file to be imported?' % (
                                                                    files_counter))  # # pylint: disable=consider-using-f-string
                            elif files_batchcounter < 0:
                                string = QApplication.translate('Message',
                                                                'Your batch counter is set to %s. Turn it off as in the settings file to be imported?' % (
                                                                    current_counter))  # pylint: disable=consider-using-f-string
                            else:
                                string = QApplication.translate('Message',
                                                                'Overwrite your current batch counter %s by %s from the settings file to be imported?' % (
                                                                    current_counter,
                                                                    files_counter))  # noqa: UP031 # pylint: disable=consider-using-f-string
                            reply = QMessageBox.question(self, QApplication.translate('Message', 'Batch Counter'),
                                                         string,
                                                         QMessageBox.StandardButton.Cancel | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Yes)
                            if reply == QMessageBox.StandardButton.Cancel:
                                self.sendmessage(QApplication.translate('Message', 'Load Settings canceled'))
                                return False
                            if reply == QMessageBox.StandardButton.No:
                                updateBatchCounter = False
                            updateBatchCounter = True
                    settings.endGroup()
                # --- END GROUP Batch

                # on explicit settings load we remove the ExtraDeviceBackup to prevent later restoreExtraDeviceSettingsBackup()
                self.clearExtraDeviceSettingsBackup()
            else:
                settings = QSettings()
            if settings.contains('resetqsettings'):
                self.resetqsettings = toInt(settings.value('resetqsettings', self.resetqsettings))
            if self.resetqsettings or (filename is None and QApplication.queryKeyboardModifiers() == (
                    Qt.KeyboardModifier.AltModifier | Qt.KeyboardModifier.ShiftModifier)):
                self.resetqsettings = 0
                if 'canvas' in self.qmc.palette:
                    self.updateCanvasColors(checkColors=False)
                # remove window geometry and splitter settings
                self.clearWindowGeometry(settings)
                #
                self.setFonts()
                try:
                    self.updateNewMenuRecentRoasts()
                except Exception:  # pylint: disable=broad-except
                    pass
                _log.info('Factory reset')
                return True  # don't load any more settings. They could be bad (corrupted). Stop here.

            # we remember from which location we loaded the last settings file
            # to be able to update the batch counter in this file from qmc.incBatchCounter()/qmc.decBatchCounter()
            # but not for loading of settings fragments like themes or machines
            if filename:
                if updateBatchCounter:

                    # --- BEGIN GROUP Batch
                    settings.beginGroup('Batch')
                    if settings.contains('batchcounter'):
                        self.settingspath = filename
                    else:
                        self.settingspath = ''
                    settings.endGroup()
                # --- END GROUP Batch

                else:
                    self.settingspath = ''
            else:
                # the neverUpdateBatchCounter flag is never changed on loading a settings file!

                # --- BEGIN GROUP Batch
                settings.beginGroup('Batch')
                if settings.contains('neverUpdateBatchCounter'):
                    self.qmc.neverUpdateBatchCounter = toBool(
                        settings.value('neverUpdateBatchCounter', self.qmc.neverUpdateBatchCounter))
                settings.endGroup()
            # --- END GROUP Batch

            if filename is None:
                # don't load fullscreen or artisan.plus account from external settings file
                self.full_screen_mode_active = bool(toBool(settings.value('fullscreen', self.full_screen_mode_active)))
                self.plus_account = settings.value('plus_account', self.plus_account)
            self.plus_remember_credentials = bool(
                toBool(settings.value('plus_remember_credentials', self.plus_remember_credentials)))
            self.plus_email = settings.value('plus_email', self.plus_email)
            self.plus_language = settings.value('plus_language', self.plus_language)
            # remember swaplcds and swapdeltalcds
            old_swaplcds = self.qmc.swaplcds
            old_swapdeltalcds = self.qmc.swapdeltalcds
            # restore mode
            old_mode = self.qmc.mode
            self.qmc.mode = str(settings.value('Mode', self.qmc.mode))
            # convert modes only if needed comparing the new uploaded mode to the old one.
            # otherwise it would incorrectly convert the uploaded phases
            if self.qmc.mode == 'F' and old_mode == 'C':
                self.qmc.celsiusMode()
            if self.qmc.mode == 'C' and old_mode == 'F':
                self.qmc.celsiusMode()
            if settings.contains('DebugLogLevel'):
                try:
                    setDebugLogLevel(bool(toBool(settings.value('DebugLogLevel', False))))
                except Exception:  # pylint: disable=broad-except
                    pass
            # if screen setup changed (main screen size or pixel ratio or number of screens) we remove the
            # window geometry and splitter settings on load to prevent dialog open issues on different multiple screen setups
            # we use saved window positions only if we are sure that the screen setup did not change
            if (settings.contains('screens') and settings.contains('mainScreenPixelRatio') and
                    settings.contains('mainScreenWidth') and settings.contains('mainScreenHeight')):
                screens: int = toInt(settings.value('screens', 0))
                mainScreenPixelRatio: float = toFloat(settings.value('mainScreenPixelRatio', 0))
                mainScreenWidth: int = toInt(settings.value('mainScreenWidth', 0))
                mainScreenHeight: int = toInt(settings.value('mainScreenHeight', 0))
                mainScreen: Optional[QScreen] = self.app.primaryScreen()
                if mainScreen is not None and not ((screens == len(self.app.screens())) and
                                                   (mainScreenPixelRatio == mainScreen.devicePixelRatio()) and
                                                   (mainScreenWidth == mainScreen.size().width()) and
                                                   (mainScreenHeight == mainScreen.size().height())):
                    self.clearWindowGeometry(settings)
            elif filename is not None and not theme and not machine:
                # load a (old) settings file without proper screen setup information (not a theme or machine setup) we clear saved window positions
                # as well to be on the save side
                # NOTE: only the main window Geometry is exported to a settings file
                self.clearWindowGeometry(settings)

            # restore device

            # --- BEGIN GROUP Device
            settings.beginGroup('Device')
            if settings.contains('device_logging'):
                self.qmc.device_logging = bool(toBool(settings.value('device_logging', self.qmc.device_logging)))
                try:
                    setDeviceDebugLogLevel(self.qmc.device_logging)
                except Exception:  # pylint: disable=broad-except
                    pass
            self.qmc.device = toInt(settings.value('id', self.qmc.device))
            # Phidget configurations
            self.qmc.phidget1048_types = [toInt(x) for x in
                                          toList(settings.value('phidget1048_types', self.qmc.phidget1048_types))]
            self.qmc.phidget1048_async = [bool(toBool(x)) for x in
                                          toList(settings.value('phidget1048_async', self.qmc.phidget1048_async))]
            self.qmc.phidget1048_changeTriggers = [self.float2float(toFloat(x)) for x in toList(
                settings.value('phidget1048_changeTriggers', self.qmc.phidget1048_changeTriggers))]
            self.qmc.phidget1048_dataRate = toInt(settings.value('phidget1048_dataRate', self.qmc.phidget1048_dataRate))
            self.qmc.phidget1046_gain = [toInt(x) for x in
                                         toList(settings.value('phidget1046_gain', self.qmc.phidget1046_gain))]
            self.qmc.phidget1046_formula = [toInt(x) for x in
                                            toList(settings.value('phidget1046_formula', self.qmc.phidget1046_formula))]
            self.qmc.phidget1046_async = [bool(toBool(x)) for x in
                                          toList(settings.value('phidget1046_async', self.qmc.phidget1046_async))]
            self.qmc.phidget1046_dataRate = toInt(settings.value('phidget1046_dataRate', self.qmc.phidget1046_dataRate))
            self.qmc.phidget1045_async = bool(toBool(settings.value('phidget1045_async', self.qmc.phidget1045_async)))
            self.qmc.phidget1045_changeTrigger = self.float2float(
                toFloat(settings.value('phidget1045_changeTrigger', self.qmc.phidget1045_changeTrigger)))
            self.qmc.phidget1045_emissivity = toFloat(
                settings.value('phidget1045_emissivity', self.qmc.phidget1045_emissivity))
            self.qmc.phidget1045_dataRate = toInt(settings.value('phidget1045_dataRate', self.qmc.phidget1045_dataRate))
            self.qmc.phidget1200_formula = toInt(settings.value('phidget1200_formula', self.qmc.phidget1200_formula))
            self.qmc.phidget1200_wire = toInt(settings.value('phidget1200_wire', self.qmc.phidget1200_wire))
            self.qmc.phidget1200_async = bool(toBool(settings.value('phidget1200_async', self.qmc.phidget1200_async)))
            self.qmc.phidget1200_changeTrigger = self.float2float(
                toFloat(settings.value('phidget1200_changeTrigger', self.qmc.phidget1200_changeTrigger)))
            self.qmc.phidget1200_dataRate = toInt(settings.value('phidget1200_dataRate', self.qmc.phidget1200_dataRate))
            self.qmc.phidget1200_2_formula = toInt(
                settings.value('phidget1200_2_formula', self.qmc.phidget1200_2_formula))
            self.qmc.phidget1200_2_wire = toInt(settings.value('phidget1200_2_wire', self.qmc.phidget1200_2_wire))
            self.qmc.phidget1200_2_async = bool(
                toBool(settings.value('phidget1200_2_async', self.qmc.phidget1200_2_async)))
            self.qmc.phidget1200_2_changeTrigger = self.float2float(
                toFloat(settings.value('phidget1200_2_changeTrigger', self.qmc.phidget1200_2_changeTrigger)))
            self.qmc.phidget1200_2_dataRate = toInt(
                settings.value('phidget1200_2_dataRate', self.qmc.phidget1200_2_dataRate))
            self.qmc.phidgetDAQ1400_powerSupply = toInt(
                settings.value('phidgetDAQ1400_powerSupply', self.qmc.phidgetDAQ1400_powerSupply))
            self.qmc.phidgetDAQ1400_inputMode = toInt(
                settings.value('phidgetDAQ1400_inputMode', self.qmc.phidgetDAQ1400_inputMode))
            self.qmc.phidgetRemoteFlag = bool(toBool(settings.value('phidgetRemoteFlag', self.qmc.phidgetRemoteFlag)))
            self.qmc.phidgetServerID = toString(settings.value('phidgetServerID', self.qmc.phidgetServerID))
            self.qmc.phidgetPassword = toString(settings.value('phidgetPassword', self.qmc.phidgetPassword))
            self.qmc.phidgetPort = toInt(settings.value('phidgetPort', self.qmc.phidgetPort))
            self.qmc.phidgetRemoteOnlyFlag = bool(
                toBool(settings.value('phidgetRemoteOnlyFlag', self.qmc.phidgetRemoteOnlyFlag)))
            self.qmc.phidget1018_async = [bool(toBool(x)) for x in
                                          toList(settings.value('phidget1018_async', self.qmc.phidget1018_async))]
            self.qmc.phidget1018_dataRates = [toInt(x) for x in toList(
                settings.value('phidget1018_dataRates', self.qmc.phidget1018_dataRates))]
            self.qmc.phidget1018_changeTriggers = [toInt(x) for x in toList(
                settings.value('phidget1018_changeTriggers', self.qmc.phidget1018_changeTriggers))]
            self.qmc.phidget1018_ratio = [bool(toBool(x)) for x in
                                          toList(settings.value('phidget1018_ratio', self.qmc.phidget1018_ratio))]
            self.qmc.phidgetVCP100x_voltageRanges = [toInt(x) for x in toList(
                settings.value('phidgetVCP100x_voltageRanges', self.qmc.phidgetVCP100x_voltageRanges))]
            self.qmc.PIDbuttonflag = bool(toBool(settings.value('PIDbuttonflag', self.qmc.PIDbuttonflag)))
            self.qmc.Controlbuttonflag = bool(toBool(settings.value('Controlbuttonflag', self.qmc.Controlbuttonflag)))
            self.qmc.yoctoRemoteFlag = bool(toBool(settings.value('yoctoRemoteFlag', self.qmc.yoctoRemoteFlag)))
            self.qmc.yoctoServerID = toString(settings.value('yoctoServerID', self.qmc.yoctoServerID))
            self.qmc.YOCTO_emissivity = toFloat(settings.value('YOCTO_emissivity', self.qmc.YOCTO_emissivity))
            self.qmc.YOCTO_async = [bool(toBool(x)) for x in
                                    toList(settings.value('YOCTO_async', self.qmc.YOCTO_async))]
            self.qmc.YOCTO_dataRate = toInt(settings.value('YOCTO_dataRate', self.qmc.YOCTO_dataRate))
            self.qmc.ambient_temperature_device = toInt(
                settings.value('ambient_temperature_device', self.qmc.ambient_temperature_device))
            self.qmc.ambient_humidity_device = toInt(
                settings.value('ambient_humidity_device', self.qmc.ambient_humidity_device))
            self.qmc.ambient_pressure_device = toInt(
                settings.value('ambient_pressure_device', self.qmc.ambient_pressure_device))
            self.qmc.elevation = toInt(settings.value('elevation', self.qmc.elevation))
            self.santokerHost = toString(settings.value('santokerHost', self.santokerHost))
            self.santokerPort = toInt(settings.value('santokerPort', self.santokerPort))
            self.santokerSerial = bool(toBool(settings.value('santokerSerial', self.santokerSerial)))
            self.kaleidoHost = toString(settings.value('kaleidoHost', self.kaleidoHost))
            self.kaleidoPort = toInt(settings.value('kaleidoPort', self.kaleidoPort))
            self.kaleidoSerial = toBool(settings.value('kaleidoSerial', self.kaleidoSerial))
            self.kaleidoPID = bool(toBool(settings.value('kaleidoPID', self.kaleidoPID)))
            # activate CONTROL BUTTON
            # self.showControlButton()
            self.ser.controlETpid = [toInt(x) for x in toList(settings.value('controlETpid', self.ser.controlETpid))]
            self.ser.readBTpid = [toInt(x) for x in toList(settings.value('readBTpid', self.ser.readBTpid))]
            self.ser.arduinoETChannel = s2a(toString(settings.value('arduinoETChannel', self.ser.arduinoETChannel)))
            self.ser.arduinoBTChannel = s2a(toString(settings.value('arduinoBTChannel', self.ser.arduinoBTChannel)))
            self.ser.arduinoATChannel = s2a(toString(settings.value('arduinoATChannel', self.ser.arduinoATChannel)))
            self.ser.ArduinoFILT = [toInt(x) for x in toList(settings.value('ArduinoFILT', self.ser.ArduinoFILT))]
            self.ser.useModbusPort = bool(toBool(settings.value('useModbusPort', self.ser.useModbusPort)))
            self.ser.showFujiLCDs = bool(toBool(settings.value('showFujiLCDs', self.ser.showFujiLCDs)))
            settings.endGroup()
            # --- END GROUP Device

            # restore x,y formatting mode
            self.qmc.fmt_data_RoR = bool(toBool(settings.value('fmt_data_RoR', self.qmc.fmt_data_RoR)))
            self.qmc.fmt_data_ON = bool(toBool(settings.value('fmt_data_ON', self.qmc.fmt_data_ON)))
            self.qmc.fmt_data_curve = toInt(settings.value('fmt_data_curve', self.qmc.fmt_data_curve))
            # restore playback aid
            self.qmc.detectBackgroundEventTime = toInt(
                settings.value('detectBackgroundEventTime', self.qmc.detectBackgroundEventTime))
            self.qmc.backgroundReproduce = bool(
                toBool(settings.value('backgroundReproduce', self.qmc.backgroundReproduce)))
            self.qmc.backgroundReproduceBeep = bool(
                toBool(settings.value('backgroundReproduceBeep', self.qmc.backgroundReproduceBeep)))
            self.qmc.backgroundPlaybackEvents = bool(
                toBool(settings.value('backgroundPlaybackEvents', self.qmc.backgroundPlaybackEvents)))
            self.qmc.backgroundPlaybackDROP = bool(
                toBool(settings.value('backgroundPlaybackDROP', self.qmc.backgroundPlaybackDROP)))
            self.qmc.replayType = toInt(settings.value('replayType', self.qmc.replayType))
            self.qmc.specialeventplaybackaid = [toBool(x) for x in toList(
                settings.value('specialeventplaybackaid', self.qmc.specialeventplaybackaid))]
            self.qmc.specialeventplayback = [toBool(x) for x in toList(
                settings.value('specialeventplayback', self.qmc.specialeventplayback))]
            # restore phases
            self.qmc.phases = [toInt(x) for x in toList(settings.value('Phases', self.qmc.phases))]
            self.qmc.phasesbuttonflag = bool(toBool(settings.value('phasesbuttonflag', self.qmc.phasesbuttonflag)))
            self.qmc.phasesfromBackgroundflag = bool(
                toBool(settings.value('phasesfromBackgroundflag', self.qmc.phasesfromBackgroundflag)))
            self.qmc.watermarksflag = bool(toBool(settings.value('watermarks', self.qmc.watermarksflag)))
            self.qmc.phasesLCDflag = bool(toBool(settings.value('phasesLCDs', self.qmc.phasesLCDflag)))
            self.qmc.phasesLCDmode = toInt(settings.value('phasesLCDmode', self.qmc.phasesLCDmode))
            if settings.contains('step100temp'):
                try:
                    self.qmc.step100temp = int(settings.value('step100temp', self.qmc.step100temp))
                except Exception:  # pylint: disable=broad-except
                    self.qmc.step100temp = None
            # Important - this must come after the code that restores phasesLCDmode
            # Done this way with two variables to maintain forward and backward compatibility with settings since adding LCD mode by phase.
            if settings.contains('phasesLCDmode_l'):
                self.qmc.phasesLCDmode_l = [toInt(x) for x in
                                            toList(settings.value('phasesLCDmode_l', self.qmc.phasesLCDmode_l))]
            elif settings.contains('phasesLCDmode'):
                self.qmc.phasesLCDmode_l = [toInt(self.qmc.phasesLCDmode)] * 3
            self.qmc.phasesLCDmode_all = [bool(toBool(x)) for x in
                                          toList(settings.value('phasesLCDmode_all', self.qmc.phasesLCDmode_all))]
            self.qmc.autoDRYflag = bool(toBool(settings.value('autoDry', self.qmc.autoDRYflag)))
            self.qmc.autoFCsFlag = bool(toBool(settings.value('autoFCs', self.qmc.autoFCsFlag)))

            # --- BEGIN GROUP events
            # restore Events settings
            settings.beginGroup('events')
            self.eventsbuttonflag = toInt(settings.value('eventsbuttonflag', int(self.eventsbuttonflag)))
            self.minieventsflags = [toInt(x) for x in toList(settings.value('minieventsflags', self.minieventsflags))]
            self.qmc.eventsGraphflag = toInt(settings.value('eventsGraphflag', int(self.qmc.eventsGraphflag)))
            if settings.contains('etypes'):
                self.qmc.etypes = toStringList(settings.value('etypes', self.qmc.etypes))
                # etype specified as empty strings are replaced by their defaults to enable translations in partially customized etypes
                for i, name in enumerate(self.qmc.etypes):
                    if name == '':
                        self.qmc.etypes[i] = self.qmc.etypesdefault[i]
                # update minieditor event type ComboBox
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
            else:
                # etypes have not been saved in the setting to presever the translations, we have to reset those to their default
                self.qmc.etypes = self.qmc.etypesdefault[:]
            self.qmc.eventsshowflag = toInt(settings.value('eventsshowflag', int(self.qmc.eventsshowflag)))
            self.qmc.clampEvents = bool(toBool(settings.value('clampEvents', self.qmc.clampEvents)))
            self.qmc.renderEventsDescr = bool(toBool(settings.value('renderEventsDescr', self.qmc.renderEventsDescr)))
            self.qmc.eventslabelschars = toInt(settings.value('eventslabelschars', int(self.qmc.eventslabelschars)))
            self.qmc.annotationsflag = toInt(settings.value('annotationsflag', int(self.qmc.annotationsflag)))
            self.qmc.showeventsonbt = bool(toBool(settings.value('showeventsonbt', self.qmc.showeventsonbt)))
            self.qmc.showEtypes = [bool(toBool(x)) for x in toList(settings.value('showEtypes', self.qmc.showEtypes))]
            if settings.contains('autoChargeDrop'):
                self.qmc.autoChargeFlag = bool(toBool(settings.value('autoChargeDrop', False)))
                self.qmc.autoDropFlag = self.qmc.autoChargeFlag
            self.qmc.chargeTimerFlag = bool(toBool(settings.value('chargeTimer', self.qmc.chargeTimerFlag)))
            self.qmc.chargeTimerPeriod = toInt(settings.value('chargeTimerPeriod', int(self.qmc.chargeTimerPeriod)))
            self.qmc.autoChargeFlag = bool(toBool(settings.value('autoCharge', self.qmc.autoChargeFlag)))
            self.qmc.autoDropFlag = bool(toBool(settings.value('autoDrop', self.qmc.autoDropFlag)))
            self.qmc.autoChargeMode = toInt(settings.value('autoChargeMode', self.qmc.autoChargeMode))
            self.qmc.autoDropMode = toInt(settings.value('autoDropMode', self.qmc.autoDropMode))
            self.qmc.markTPflag = bool(toBool(settings.value('markTP', self.qmc.markTPflag)))
            if settings.contains('EvalueColor'):
                self.qmc.EvalueColor = list(
                    map(str, list(toStringList(settings.value('EvalueColor', self.qmc.EvalueColor)))))
                self.updateSliderColors()
            self.qmc.EvalueMarker = list(
                map(str, list(toStringList(settings.value('EvalueMarker', self.qmc.EvalueMarker)))))
            if settings.contains('EvalueTextColor'):
                self.qmc.EvalueTextColor = list(
                    map(str, list(toStringList(settings.value('EvalueTextColor', self.qmc.EvalueTextColor)))))
                self.updateSliderColors()
            self.qmc.Evaluelinethickness = [max(self.qmc.linewidth_min, toFloat(x)) for x in
                                            toList(settings.value('Evaluelinethickness', self.qmc.Evaluelinethickness))]
            self.qmc.Evaluealpha = [toFloat(x) for x in toList(settings.value('Evaluealpha', self.qmc.Evaluealpha))]
            self.qmc.EvalueMarkerSize = [max(self.qmc.markersize_min, toFloat(x)) for x in
                                         toList(settings.value('EvalueMarkerSize', self.qmc.EvalueMarkerSize))]
            self.qmc.specialeventannotations = list(map(str, list(
                toStringList(settings.value('specialeventannotations', self.qmc.specialeventannotations)))))
            self.qmc.specialeventannovisibilities = [toInt(x) for x in toList(
                settings.value('specialeventannovisibilities', self.qmc.specialeventannovisibilities))]
            self.qmc.overlappct = toInt(settings.value('overlappct', int(self.qmc.overlappct)))
            settings.endGroup()
            # --- END GROUP events

            # restore statistics
            if settings.contains('Statistics'):
                self.qmc.statisticsflags = [toInt(x) for x in
                                            toList(settings.value('Statistics', self.qmc.statisticsflags))]
                # extend statisticsflag len to the full size (for backward compatibility)
                for _ in range(7 - len(self.qmc.statisticsflags)):
                    self.qmc.statisticsflags.append(0)
            if settings.contains('AnalysisResultsLoc'):
                arl = toList(settings.value('AnalysisResultsLoc', self.qmc.analysisresultsloc))
                if len(arl) > 1:
                    self.qmc.analysisresultsloc = (toFloat(arl[0]), toFloat(arl[1]))
            if settings.contains('SegmentResultsLoc'):
                srl = toList(settings.value('SegmentResultsLoc', self.qmc.segmentresultsloc))
                if len(srl) > 1:
                    self.qmc.segmentresultsloc = (toFloat(srl[0]), toFloat(srl[1]))
            self.qmc.analysisstartchoice = toInt(
                settings.value('analysisstartchoice', int(self.qmc.analysisstartchoice)))
            self.qmc.analysisoffset = toInt(settings.value('analysisoffset', int(self.qmc.analysisoffset)))
            self.qmc.curvefitstartchoice = toInt(
                settings.value('curvefitstartchoice', int(self.qmc.curvefitstartchoice)))
            self.qmc.curvefitoffset = toInt(settings.value('curvefitoffset', int(self.qmc.curvefitoffset)))
            self.qmc.segmentsamplesthreshold = toInt(
                settings.value('segmentsamplesthreshold', int(self.qmc.segmentsamplesthreshold)))
            self.qmc.segmentdeltathreshold = self.float2float(
                toFloat(settings.value('segmentdeltathreshold', self.qmc.segmentdeltathreshold)), 4)
            if settings.contains('projectFlag'):  # deprecated flag controlling both projections
                self.qmc.ETprojectFlag = self.qmc.BTprojectFlag = bool(toBool(settings.value('projectFlag')))
            self.qmc.ETprojectFlag = bool(toBool(settings.value('ETprojectFlag', self.qmc.ETprojectFlag)))
            self.qmc.BTprojectFlag = bool(toBool(settings.value('BTprojectFlag', self.qmc.BTprojectFlag)))
            self.qmc.projectDeltaFlag = bool(toBool(settings.value('projectDeltaFlag', self.qmc.projectDeltaFlag)))
            self.qmc.projectionmode = toInt(settings.value('projectionmode', int(self.qmc.projectionmode)))
            self.qmc.AUCbegin = toInt(settings.value('AUCbegin', int(self.qmc.AUCbegin)))
            self.qmc.AUCbase = toInt(settings.value('AUCbase', int(self.qmc.AUCbase)))
            self.qmc.AUCbaseFlag = bool(toBool(settings.value('AUCbaseFlag', self.qmc.AUCbaseFlag)))
            self.qmc.AUCtarget = toInt(settings.value('AUCtarget', int(self.qmc.AUCtarget)))
            self.qmc.AUCtargetFlag = bool(toBool(settings.value('AUCtargetFlag', self.qmc.AUCtargetFlag)))
            self.qmc.AUCguideFlag = bool(toBool(settings.value('AUCguideFlag', self.qmc.AUCguideFlag)))
            self.qmc.AUClcdFlag = bool(toBool(settings.value('AUClcdFlag', self.qmc.AUClcdFlag)))
            self.qmc.AUCLCDmode = toInt(settings.value('AUCLCDmode', self.qmc.AUCLCDmode))
            self.qmc.AUCshowFlag = bool(toBool(settings.value('AUCshowFlag', self.qmc.AUCshowFlag)))
            self.keyboardmoveflag = toInt(settings.value('keyboardmoveflag', int(self.keyboardmoveflag)))
            self.qmc.ambientTempSource = toInt(settings.value('AmbientTempSource', int(self.qmc.ambientTempSource)))
            self.setSamplingRate(toInt(settings.value('Delay', int(self.qmc.delay))))
            self.qmc.flagKeepON = bool(toBool(settings.value('KeepON', self.qmc.flagKeepON)))
            self.qmc.flagOpenCompleted = bool(toBool(settings.value('flagOpenCompleted', self.qmc.flagOpenCompleted)))
            self.qmc.extra_event_sampling_delay = toInt(
                settings.value('ExtraEventSamplingDelay', int(self.qmc.extra_event_sampling_delay)))
            # restore colors
            if settings.contains('Colors'):
                for (k, v) in list(settings.value('Colors').items()):
                    self.qmc.palette[str(k)] = s2a(toString(v))
                if 'messages' in self.qmc.palette:
                    self.setLabelColor(self.messagelabel, QColor(self.qmc.palette['messages']))
                if 'et' in self.qmc.palette:
                    self.setLabelColor(self.label2, QColor(self.qmc.palette['et']))
                if 'bt' in self.qmc.palette:
                    self.setLabelColor(self.label3, QColor(self.qmc.palette['bt']))
                if 'deltaet' in self.qmc.palette:
                    self.setLabelColor(self.label4, QColor(self.qmc.palette['deltaet']))
                if 'deltabt' in self.qmc.palette:
                    self.setLabelColor(self.label5, QColor(self.qmc.palette['deltabt']))
                if 'canvas' in self.qmc.palette:
                    if len(self.qmc.palette[
                               'canvas']) == 0:  # revert the canvas element to default if it is blank in the settings.
                        self.qmc.palette['canvas'] = '#f8f8f8'
                else:
                    self.qmc.palette[
                        'canvas'] = '#f8f8f8'  # revert the canvas element to default if it does not exist in the settings.
                if 'canvas_alt' in self.qmc.palette:
                    self.qmc.palette.pop(
                        'canvas_alt')  # remove the canvas_alt element if it somehow snuck into the settings
            self.qmc.backgroundmetcolor = s2a(toString(settings.value('ETBColor', self.qmc.backgroundmetcolor)))
            self.qmc.backgroundbtcolor = s2a(toString(settings.value('BTBColor', self.qmc.backgroundbtcolor)))
            self.qmc.backgrounddeltaetcolor = s2a(
                toString(settings.value('ETBdeltaColor', self.qmc.backgrounddeltaetcolor)))
            self.qmc.backgrounddeltabtcolor = s2a(
                toString(settings.value('BTBdeltaColor', self.qmc.backgrounddeltabtcolor)))
            self.qmc.backgroundalpha = min(0.5, self.float2float(
                toFloat(settings.value('BackgroundAlpha', self.qmc.backgroundalpha))))
            if settings.contains('LCDColors'):
                for (k, v) in list(settings.value('LCDColors').items()):
                    self.lcdpaletteB[str(k)] = s2a(toString(v))
            if settings.contains('LEDColors'):
                for (k, v) in list(settings.value('LEDColors').items()):
                    self.lcdpaletteF[str(k)] = s2a(toString(v))
            if settings.contains('Alphas'):
                for (k, v) in list(settings.value('Alphas').items()):
                    self.qmc.alpha[str(k)] = v
            # restore colors
            self.lcd1.setStyleSheet(
                f"QLCDNumber {{ border-radius:4; color: {self.lcdpaletteF['timer']}; background: {self.lcdpaletteB['timer']};}}")
            self.lcd2.setStyleSheet(
                f"QLCDNumber {{ border-radius:4; color: {self.lcdpaletteF['et']}; background: {self.lcdpaletteB['et']};}}")
            self.lcd3.setStyleSheet(
                f"QLCDNumber {{ border-radius:4; color: {self.lcdpaletteF['bt']}; background: {self.lcdpaletteB['bt']};}}")
            self.lcd4.setStyleSheet(
                f"QLCDNumber {{ border-radius:4; color: {self.lcdpaletteF['deltaet']}; background: {self.lcdpaletteB['deltaet']};}}")
            self.lcd5.setStyleSheet(
                f"QLCDNumber {{ border-radius:4; color: {self.lcdpaletteF['deltabt']}; background: {self.lcdpaletteB['deltabt']};}}")
            self.lcd6.setStyleSheet(
                f"QLCDNumber {{ border-radius:4; color: {self.lcdpaletteF['sv']}; background: {self.lcdpaletteB['sv']};}}")
            self.lcd7.setStyleSheet(
                f"QLCDNumber {{ border-radius:4; color: {self.lcdpaletteF['sv']}; background: {self.lcdpaletteB['sv']};}}")
            self.readingslcdsflags = [toInt(x) for x in
                                      toList(settings.value('readingslcdsflags', self.readingslcdsflags))]
            # restore flavors
            self.qmc.flavorlabels = toStringList(settings.value('Flavors', self.qmc.flavorlabels))
            self.qmc.flavors = [5.] * len(self.qmc.flavorlabels)
            self.qmc.flavorstartangle = toInt(settings.value('flavorstartangle', int(self.qmc.flavorstartangle)))
            self.qmc.color_system_idx = toInt(settings.value('colorsystem', int(self.qmc.color_system_idx)))

            # --- BEGIN GROUP XT
            # restore extra background curve color and index
            settings.beginGroup('XT')
            self.qmc.backgroundxtcolor = s2a(toString(settings.value('color', self.qmc.backgroundxtcolor)))
            self.qmc.backgroundytcolor = s2a(toString(settings.value('color2', self.qmc.backgroundytcolor)))
            self.qmc.xtcurveidx = toInt(settings.value('index', int(self.qmc.xtcurveidx)))
            self.qmc.ytcurveidx = toInt(settings.value('index2', int(self.qmc.ytcurveidx)))
            settings.endGroup()
            # --- END GROUP XT

            # --- BEGIN GROUP Units
            # restore units
            settings.beginGroup('Units')
            self.qmc.weight = (
                self.qmc.weight[0], self.qmc.weight[1], s2a(toString(settings.value('weight', self.qmc.weight[2]))))
            self.qmc.volume = (
                self.qmc.volume[0], self.qmc.volume[1], s2a(toString(settings.value('volume', self.qmc.volume[2]))))
            # density units are now fixed to g/l
            #                self.qmc.density[1] = s2a(toString(settings.value("densityweight",self.qmc.density[1])))
            #                self.qmc.density[3] = s2a(toString(settings.value("densityvolume",self.qmc.density[3])))
            self.qmc.volumeCalcUnit = self.float2float(
                toFloat(settings.value('volumeCalcUnit', self.qmc.volumeCalcUnit)))
            settings.endGroup()
            # --- END GROUP Units

            # --- BEGIN GROUP Tare
            settings.beginGroup('Tare')
            self.qmc.container_names = list(
                map(str, list(toStringList(settings.value('names', self.qmc.container_names)))))
            self.qmc.container_weights = [toInt(x) for x in
                                          toList(settings.value('weights', self.qmc.container_weights))]
            self.qmc.container_idx = toInt(settings.value('idx', int(self.qmc.container_idx)))
            settings.endGroup()
            # --- END GROUP Tare

            # --- BEGIN GROUP SerialPort
            # restore serial port
            settings.beginGroup('SerialPort')
            self.ser.comport = s2a(toString(settings.value('comport', self.ser.comport)))
            self.ser.baudrate = toInt(settings.value('baudrate', int(self.ser.baudrate)))
            self.ser.bytesize = toInt(settings.value('bytesize', self.ser.bytesize))
            self.ser.stopbits = toInt(settings.value('stopbits', self.ser.stopbits))
            self.ser.parity = s2a(toString(settings.value('parity', self.ser.parity)))
            self.ser.timeout = self.float2float(toFloat(settings.value('timeout', self.ser.timeout)))
            settings.endGroup()
            # --- END GROUP SerialPort

            # --- BEGIN GROUP WebSocket
            # restorer WebSocket port
            settings.beginGroup('WebSocket')
            self.ws.host = toString(settings.value('host', self.ws.host))
            self.ws.port = toInt(settings.value('port', self.ws.port))
            self.ws.path = toString(settings.value('path', self.ws.path))
            self.ws.machineID = toInt(settings.value('machineID', self.ws.machineID))
            self.ws.connect_timeout = toFloat(settings.value('connect_timeout', self.ws.connect_timeout))
            self.ws.request_timeout = toFloat(settings.value('request_timeout', self.ws.request_timeout))
            self.ws.reconnect_interval = toFloat(settings.value('reconnect_interval', self.ws.reconnect_interval))
            self.ws.id_node = toString(settings.value('id_node', self.ws.id_node))
            self.ws.machine_node = toString(settings.value('machine_node', self.ws.machine_node))
            self.ws.command_node = toString(settings.value('command_node', self.ws.command_node))
            self.ws.data_node = toString(settings.value('data_node', self.ws.data_node))
            self.ws.pushMessage_node = toString(settings.value('pushMessage_node', self.ws.pushMessage_node))
            self.ws.request_data_command = toString(
                settings.value('request_data_command', self.ws.request_data_command))
            self.ws.charge_message = toString(settings.value('charge_message', self.ws.charge_message))
            self.ws.drop_message = toString(settings.value('drop_message', self.ws.drop_message))
            self.ws.STARTonCHARGE = bool(toBool(settings.value('STARTonCHARGE', self.ws.STARTonCHARGE)))
            self.ws.OFFonDROP = bool(toBool(settings.value('OFFonDROP', self.ws.OFFonDROP)))
            self.ws.addEvent_message = toString(settings.value('addEvent_message', self.ws.addEvent_message))
            self.ws.event_node = toString(settings.value('event_node', self.ws.event_node))
            self.ws.DRY_node = toString(settings.value('DRY_node', self.ws.DRY_node))
            self.ws.FCs_node = toString(settings.value('FCs_node', self.ws.FCs_node))
            self.ws.FCe_node = toString(settings.value('FCe_node', self.ws.FCe_node))
            self.ws.SCs_node = toString(settings.value('SCs_node', self.ws.SCs_node))
            self.ws.SCe_node = toString(settings.value('SCe_node', self.ws.SCe_node))
            self.ws.channel_requests = [toString(x) for x in
                                        toList(settings.value('channel_requests', self.ws.channel_requests))]
            self.ws.channel_requests = self.ws.channel_requests + [''] * (
                max(0, self.ws.channels - len(self.ws.channel_requests)))
            self.ws.channel_nodes = [toString(x) for x in
                                     toList(settings.value('channel_nodes', self.ws.channel_nodes))]
            self.ws.channel_nodes = self.ws.channel_nodes + [''] * (
                max(0, self.ws.channels - len(self.ws.channel_nodes)))
            self.ws.channel_modes = [toInt(x) for x in toList(settings.value('channel_modes', self.ws.channel_modes))]
            self.ws.channel_modes = self.ws.channel_modes + [0] * (
                max(0, self.ws.channels - len(self.ws.channel_modes)))
            settings.endGroup()
            # --- END GROUP WebSocket

            # --- BEGIN GROUP S7
            # restore s7 port
            settings.beginGroup('S7')
            self.s7.area = [toInt(x) for x in toList(settings.value('area', self.s7.area))]
            self.s7.area = self.s7.area + [0] * (max(0, self.s7.channels - len(self.s7.area)))
            self.s7.db_nr = [toInt(x) for x in toList(settings.value('db_nr', self.s7.db_nr))]
            self.s7.db_nr = self.s7.db_nr + [1] * (max(0, self.s7.channels - len(self.s7.db_nr)))
            self.s7.start = [toInt(x) for x in toList(settings.value('start', self.s7.start))]
            self.s7.start = self.s7.start + [0] * (max(0, self.s7.channels - len(self.s7.start)))
            self.s7.type = [toInt(x) for x in toList(settings.value('type', self.s7.type))]
            self.s7.type = self.s7.type + [0] * (max(0, self.s7.channels - len(self.s7.type)))
            self.s7.mode = [toInt(x) for x in toList(settings.value('mode', self.s7.mode))]
            self.s7.mode = self.s7.mode + [0] * (max(0, self.s7.channels - len(self.s7.mode)))
            self.s7.div = [toInt(x) for x in toList(settings.value('div', self.s7.div))]
            self.s7.div = self.s7.div + [0] * (max(0, self.s7.channels - len(self.s7.div)))
            self.s7.host = toString(settings.value('host', self.s7.host))
            self.s7.port = toInt(settings.value('port', self.s7.port))
            self.s7.rack = toInt(settings.value('rack', self.s7.rack))
            self.s7.slot = toInt(settings.value('slot', self.s7.slot))
            self.s7.PID_area = toInt(settings.value('PID_area', self.s7.PID_area))
            self.s7.PID_db_nr = toInt(settings.value('PID_db_nr', self.s7.PID_db_nr))
            self.s7.PID_SV_register = toInt(settings.value('PID_SV_register', self.s7.PID_SV_register))
            self.s7.PID_p_register = toInt(settings.value('PID_p_register', self.s7.PID_p_register))
            self.s7.PID_i_register = toInt(settings.value('PID_i_register', self.s7.PID_i_register))
            self.s7.PID_d_register = toInt(settings.value('PID_d_register', self.s7.PID_d_register))
            self.s7.PID_OFF_action = s2a(toString(settings.value('PID_OFF_action', self.s7.PID_OFF_action)))
            self.s7.PID_ON_action = s2a(toString(settings.value('PID_ON_action', self.s7.PID_ON_action)))
            self.s7.PIDmultiplier = toInt(settings.value('PIDmultiplier', self.s7.PIDmultiplier))
            self.s7.SVmultiplier = toInt(settings.value('SVmultiplier', self.s7.SVmultiplier))
            self.s7.SVtype = toInt(settings.value('SVtype', self.s7.SVtype))
            self.s7.optimizer = bool(toBool(settings.value('optimizer', self.s7.optimizer)))
            self.s7.fetch_max_blocks = bool(toBool(settings.value('fetch_max_blocks', self.s7.fetch_max_blocks)))
            settings.endGroup()
            # --- END GROUP S7

            # --- BEGIN GROUP Modbus
            # restore modbus port
            settings.beginGroup('Modbus')
            self.modbus.comport = s2a(toString(settings.value('comport', self.modbus.comport)))
            self.modbus.baudrate = toInt(settings.value('baudrate', int(self.modbus.baudrate)))
            self.modbus.bytesize = toInt(settings.value('bytesize', self.modbus.bytesize))
            self.modbus.stopbits = toInt(settings.value('stopbits', self.modbus.stopbits))
            self.modbus.parity = s2a(toString(settings.value('parity', self.modbus.parity)))
            self.modbus.timeout = max(0.3, self.float2float(
                toFloat(settings.value('timeout', self.modbus.timeout))))  # min serial MODBUS timeout is 300ms
            self.modbus.modbus_serial_extra_read_delay = toFloat(
                settings.value('modbus_serial_extra_read_delay', self.modbus.modbus_serial_extra_read_delay))
            self.modbus.serial_readRetries = toInt(settings.value('serial_readRetries', self.modbus.serial_readRetries))
            self.modbus.IP_timeout = self.float2float(toFloat(settings.value('IP_timeout', self.modbus.IP_timeout)))
            self.modbus.IP_retries = toInt(settings.value('IP_retries', self.modbus.IP_retries))
            for i in range(self.modbus.channels):
                self.modbus.inputSlaves[i] = toInt(settings.value(f'input{i + 1}slave', self.modbus.inputSlaves[i]))
                self.modbus.inputRegisters[i] = toInt(
                    settings.value(f'input{i + 1}register', self.modbus.inputRegisters[i]))
                self.modbus.inputFloats[i] = bool(
                    toBool(settings.value(f'input{i + 1}float', self.modbus.inputFloats[i])))
                self.modbus.inputBCDs[i] = bool(toBool(settings.value(f'input{i + 1}bcd', self.modbus.inputBCDs[i])))
                self.modbus.inputCodes[i] = toInt(settings.value(f'input{i + 1}code', self.modbus.inputCodes[i]))
                self.modbus.inputModes[i] = s2a(
                    toString(settings.value(f'input{i + 1}mode', self.modbus.inputModes[i])))
                self.modbus.inputDivs[i] = toInt(settings.value(f'input{i + 1}div', self.modbus.inputDivs[i]))
                self.modbus.inputFloatsAsInt[i] = bool(
                    toBool(settings.value(f'input{i + 1}FloatsAsInt', self.modbus.inputFloatsAsInt[i])))
                self.modbus.inputBCDsAsInt[i] = bool(
                    toBool(settings.value(f'input{i + 1}BCDsAsInt', self.modbus.inputBCDsAsInt[i])))
                self.modbus.inputSigned[i] = bool(
                    toBool(settings.value(f'input{i + 1}Signed', self.modbus.inputSigned[i])))
            self.modbus.byteorderLittle = bool(
                toBool(settings.value('littleEndianFloats', self.modbus.byteorderLittle)))
            self.modbus.wordorderLittle = bool(toBool(settings.value('wordorderLittle', self.modbus.wordorderLittle)))
            self.modbus.optimizer = bool(toBool(settings.value('optimizer', self.modbus.optimizer)))
            self.modbus.fetch_max_blocks = bool(
                toBool(settings.value('fetch_max_blocks', self.modbus.fetch_max_blocks)))
            self.modbus.PIDmultiplier = toInt(settings.value('PIDmultiplier', self.modbus.PIDmultiplier))
            self.modbus.SVmultiplier = toInt(settings.value('SVmultiplier', self.modbus.SVmultiplier))
            self.modbus.PID_slave_ID = toInt(settings.value('PID_slave_ID', self.modbus.PID_slave_ID))
            self.modbus.PID_SV_register = toInt(settings.value('PID_SV_register', self.modbus.PID_SV_register))
            self.modbus.PID_p_register = toInt(settings.value('PID_p_register', self.modbus.PID_p_register))
            self.modbus.PID_i_register = toInt(settings.value('PID_i_register', self.modbus.PID_i_register))
            self.modbus.PID_d_register = toInt(settings.value('PID_d_register', self.modbus.PID_d_register))
            self.modbus.PID_OFF_action = s2a(toString(settings.value('PID_OFF_action', self.modbus.PID_OFF_action)))
            self.modbus.PID_ON_action = s2a(toString(settings.value('PID_ON_action', self.modbus.PID_ON_action)))
            # restore MODBUS TCP/UDP settings
            self.modbus.type = toInt(settings.value('type', self.modbus.type))
            self.modbus.host = toString(settings.value('host', self.modbus.host))
            self.modbus.port = toInt(settings.value('port', self.modbus.port))
            self.modbus.reset_socket = bool(toBool(settings.value('reset_socket', self.modbus.reset_socket)))
            settings.endGroup()
            # --- END GROUP Modbus

            # --- BEGIN GROUP Scale
            # restore scale port
            settings.beginGroup('Scale')
            self.scale.device = settings.value('device', self.scale.device)
            self.scale.comport = s2a(toString(settings.value('comport', self.scale.comport)))
            self.scale.baudrate = toInt(settings.value('baudrate', int(self.scale.baudrate)))
            self.scale.bytesize = toInt(settings.value('bytesize', self.scale.bytesize))
            self.scale.stopbits = toInt(settings.value('stopbits', self.scale.stopbits))
            self.scale.parity = s2a(toString(settings.value('parity', self.scale.parity)))
            self.scale.timeout = self.float2float(toFloat(settings.value('timeout', self.scale.timeout)))
            settings.endGroup()
            # --- END GROUP Scale

            # --- BEGIN GROUP Color
            # restore color port
            settings.beginGroup('Color')
            self.color.device = settings.value('device', self.color.device)
            self.color.comport = s2a(toString(settings.value('comport', self.color.comport)))
            self.color.baudrate = toInt(settings.value('baudrate', int(self.color.baudrate)))
            self.color.bytesize = toInt(settings.value('bytesize', self.color.bytesize))
            self.color.stopbits = toInt(settings.value('stopbits', self.color.stopbits))
            self.color.parity = s2a(toString(settings.value('parity', self.color.parity)))
            self.color.timeout = self.float2float(toFloat(settings.value('timeout', self.color.timeout)))
            settings.endGroup()
            # --- END GROUP Color

            # --- BEGIN GROUP Alarms
            # restore alarms
            settings.beginGroup('Alarms')
            if settings.contains('alarmtime'):
                self.qmc.alarmflag = [toInt(x) for x in toList(settings.value('alarmflag', self.qmc.alarmflag))]
                if settings.contains('alarmsetlabel'):
                    self.qmc.alarmsetlabel = toString(settings.value('alarmsetlabel', self.qmc.alarmsetlabel))
                else:
                    self.qmc.alarmsetlabel = ''
                if settings.contains('alarmguard'):
                    self.qmc.alarmguard = [toInt(x) for x in toList(settings.value('alarmguard', self.qmc.alarmguard))]
                else:
                    self.qmc.alarmguard = [-1] * len(self.qmc.alarmflag)
                if settings.contains('alarmnegguard'):
                    self.qmc.alarmnegguard = [toInt(x) for x in
                                              toList(settings.value('alarmnegguard', self.qmc.alarmnegguard))]
                else:
                    self.qmc.alarmnegguard = [-1] * len(self.qmc.alarmflag)
                if settings.contains('alarmtime'):
                    self.qmc.alarmtime = [toInt(x) for x in toList(settings.value('alarmtime', self.qmc.alarmtime))]
                else:
                    self.qmc.alarmtime = [-1] * len(self.qmc.alarmflag)
                if settings.contains('alarmoffset'):
                    self.qmc.alarmoffset = [max(0, toInt(x)) for x in
                                            toList(settings.value('alarmoffset', self.qmc.alarmoffset))]
                else:
                    self.qmc.alarmoffset = [0] * len(self.qmc.alarmflag)
                if settings.contains('alarmcond'):
                    self.qmc.alarmcond = [toInt(x) for x in toList(settings.value('alarmcond', self.qmc.alarmcond))]
                else:
                    self.qmc.alarmcond = [1] * len(self.qmc.alarmflag)
                if settings.contains('alarmsource'):
                    self.qmc.alarmsource = [toInt(x) for x in
                                            toList(settings.value('alarmsource', self.qmc.alarmsource))]
                else:
                    self.qmc.alarmsource = [1] * len(self.qmc.alarmflag)
                if settings.contains('alarmtemperature'):
                    self.qmc.alarmtemperature = [toFloat(x) for x in
                                                 toList(settings.value('alarmtemperature', self.qmc.alarmtemperature))]
                else:
                    self.qmc.alarmtemperature = [500.] * len(self.qmc.alarmflag)
                if settings.contains('alarmaction'):
                    self.qmc.alarmaction = [toInt(x) for x in
                                            toList(settings.value('alarmaction', self.qmc.alarmaction))]
                else:
                    self.qmc.alarmaction = [0] * len(self.qmc.alarmflag)
                if settings.contains('alarmbeep'):
                    self.qmc.alarmbeep = [toInt(x) for x in toList(settings.value('alarmbeep', self.qmc.alarmbeep))]
                else:
                    self.qmc.alarmbeep = [0] * len(self.qmc.alarmflag)
                if settings.contains('alarmstrings'):
                    self.qmc.alarmstrings = list(toStringList(settings.value('alarmstrings', self.qmc.alarmstrings)))
                else:
                    self.qmc.alarmstrings = [''] * len(self.qmc.alarmflag)
                self.qmc.alarmstate = [-1] * len(self.qmc.alarmflag)
                self.qmc.loadalarmsfromprofile = bool(
                    toBool(settings.value('loadAlarmsFromProfile', self.qmc.loadalarmsfromprofile)))
                self.qmc.loadalarmsfrombackground = bool(
                    toBool(settings.value('loadAlarmsFromBackground', self.qmc.loadalarmsfrombackground)))
                self.qmc.alarmsfile = toString(settings.value('alarmsfile', self.qmc.alarmsfile))
                self.qmc.alarm_popup_timout = toInt(settings.value('alarm_popup_timout', self.qmc.alarm_popup_timout))
                self.qmc.alarmtablecolumnwidths = [toInt(x) for x in toList(
                    settings.value('alarmtablecolumnwidths', self.qmc.alarmtablecolumnwidths))]
                if settings.contains('alarmsets'):
                    aset_list = toList(settings.value('alarmsets'))
                    if len(aset_list) == self.qmc.ALARMSET_COUNT and all(
                            len(alist) == self.qmc.ALARMSET_ITEMS for alist in aset_list):
                        self.qmc.alarmsets = [self.qmc.lists2AlarmSet(alist) for alist in aset_list]
                self.qmc.alarmsetlabel = toString(settings.value('alarmsetlabel', self.qmc.alarmsetlabel))
            settings.endGroup()
            # --- END GROUP Alarms

            # --- BEGIN GROUP ArduinoPID
            # restore TC4/Arduino PID settings
            settings.beginGroup('ArduinoPID')
            self.pidcontrol.pidOnCHARGE = bool(toBool(settings.value('pidOnCHARGE', self.pidcontrol.pidOnCHARGE)))
            self.pidcontrol.createEvents = bool(toBool(settings.value('createEvents', self.pidcontrol.createEvents)))
            self.pidcontrol.loadRampSoakFromProfile = bool(
                toBool(settings.value('loadRampSoakFromProfile', self.pidcontrol.loadRampSoakFromProfile)))
            self.pidcontrol.svValues = [toInt(x) for x in toList(settings.value('svValues', self.pidcontrol.svValues))]
            self.pidcontrol.svRamps = [toInt(x) for x in toList(settings.value('svRamps', self.pidcontrol.svRamps))]
            self.pidcontrol.svSoaks = [toInt(x) for x in toList(settings.value('svSoaks', self.pidcontrol.svSoaks))]
            self.pidcontrol.svActions = [toInt(x) for x in
                                         toList(settings.value('svActions', self.pidcontrol.svActions))]
            self.pidcontrol.svBeeps = [bool(toBool(x)) for x in
                                       toList(settings.value('svBeeps', self.pidcontrol.svBeeps))]
            self.pidcontrol.svDescriptions = list(
                toStringList(settings.value('svDescriptions', self.pidcontrol.svDescriptions)))
            self.pidcontrol.svSlider = bool(toBool(settings.value('svSlider', self.pidcontrol.svSlider)))
            self.pidcontrol.svButtons = bool(toBool(settings.value('svButtons', self.pidcontrol.svButtons)))
            self.pidcontrol.svMode = toInt(settings.value('svMode', self.pidcontrol.svMode))
            self.pidcontrol.svLookahead = toInt(settings.value('svLookahead', self.pidcontrol.svLookahead))
            self.pidcontrol.dutySteps = toInt(settings.value('dutySteps', self.pidcontrol.dutySteps))
            self.pidcontrol.svSliderMin = toInt(settings.value('svSliderMin', self.pidcontrol.svSliderMin))
            self.pidcontrol.svSliderMax = toInt(settings.value('svSliderMax', self.pidcontrol.svSliderMax))
            self.pidcontrol.svValue = toInt(settings.value('svValue', self.pidcontrol.svValue))
            self.pidcontrol.loadRampSoakFromBackground = bool(
                toBool(settings.value('loadRampSoakFromBackground', self.pidcontrol.loadRampSoakFromBackground)))
            self.pidcontrol.svLabel = toString(settings.value('svLabel', self.pidcontrol.svLabel))
            self.pidcontrol.dutyMin = toInt(settings.value('dutyMin', self.pidcontrol.dutyMin))
            self.pidcontrol.dutyMax = toInt(settings.value('dutyMax', self.pidcontrol.dutyMax))
            self.pidcontrol.positiveTargetRangeLimit = bool(
                toBool(settings.value('positiveTargetRangeLimit', self.pidcontrol.positiveTargetRangeLimit)))
            self.pidcontrol.positiveTargetMin = toInt(
                settings.value('positiveTargetMin', self.pidcontrol.positiveTargetMin))
            self.pidcontrol.positiveTargetMax = toInt(
                settings.value('positiveTargetMax', self.pidcontrol.positiveTargetMax))
            self.pidcontrol.negativeTargetRangeLimit = bool(
                toBool(settings.value('negativeTargetRangeLimit', self.pidcontrol.negativeTargetRangeLimit)))
            self.pidcontrol.negativeTargetMin = toInt(
                settings.value('negativeTargetMin', self.pidcontrol.negativeTargetMin))
            self.pidcontrol.negativeTargetMax = toInt(
                settings.value('negativeTargetMax', self.pidcontrol.negativeTargetMax))
            self.pidcontrol.derivative_filter = toInt(
                settings.value('derivative_filter', self.pidcontrol.derivative_filter))
            # self.pidcontrol.activateSVSlider(self.pidcontrol.svSlider)
            self.pidcontrol.pidKp = toFloat(settings.value('pidKp', self.pidcontrol.pidKp))
            self.pidcontrol.pidKi = toFloat(settings.value('pidKi', self.pidcontrol.pidKi))
            self.pidcontrol.pidKd = toFloat(settings.value('pidKd', self.pidcontrol.pidKd))
            self.pidcontrol.pidSource = toInt(settings.value('pidSource', self.pidcontrol.pidSource))
            self.pidcontrol.pidCycle = toInt(settings.value('pidCycle', self.pidcontrol.pidCycle))
            self.pidcontrol.pidPositiveTarget = toInt(
                settings.value('pidPositiveTarget', self.pidcontrol.pidPositiveTarget))
            self.pidcontrol.pidNegativeTarget = toInt(
                settings.value('pidNegativeTarget', self.pidcontrol.pidNegativeTarget))
            self.pidcontrol.invertControl = bool(toBool(settings.value('invertControl', self.pidcontrol.invertControl)))
            self.pidcontrol.pOnE = bool(toBool(settings.value('pOnE', self.pidcontrol.pOnE)))

            for n in range(self.pidcontrol.RSLen):
                svLabelLabel = 'RS_svLabel' + str(n)
                self.pidcontrol.RS_svLabels[n] = toString(settings.value(svLabelLabel, self.pidcontrol.RS_svLabels[n]))
                svValuesLabel = 'RS_svValues' + str(n)
                self.pidcontrol.RS_svValues[n] = [toInt(x) for x in
                                                  toList(settings.value(svValuesLabel, self.pidcontrol.RS_svValues[n]))]
                svRampsLabel = 'RS_svRamps' + str(n)
                self.pidcontrol.RS_svRamps[n] = [toInt(x) for x in
                                                 toList(settings.value(svRampsLabel, self.pidcontrol.RS_svRamps[n]))]
                svSoaksLabel = 'RS_svSoaks' + str(n)
                self.pidcontrol.RS_svSoaks[n] = [toInt(x) for x in
                                                 toList(settings.value(svSoaksLabel, self.pidcontrol.RS_svSoaks[n]))]
                svActionsLabel = 'RS_svActions' + str(n)
                self.pidcontrol.RS_svActions[n] = [toInt(x) for x in toList(
                    settings.value(svActionsLabel, self.pidcontrol.RS_svActions[n]))]
                svBeepsLabel = 'RS_svBeeps' + str(n)
                self.pidcontrol.RS_svBeeps[n] = [bool(toBool(x)) for x in
                                                 toList(settings.value(svBeepsLabel, self.pidcontrol.RS_svBeeps[n]))]
                svDescriptionsLabel = 'RS_svDescriptions' + str(n)
                self.pidcontrol.RS_svDescriptions[n] = list(
                    toStringList(settings.value(svDescriptionsLabel, self.pidcontrol.RS_svDescriptions[n])))
            settings.endGroup()
            # --- END GROUP ArduinoPID

            # --- BEGIN GROUP PXR
            # restore pid settings
            settings.beginGroup('PXR')
            for k in list(self.fujipid.PXR.keys()):
                if isinstance(self.fujipid.PXR[k][0], float):
                    self.fujipid.PXR[k][0] = toFloat(settings.value(k, self.fujipid.PXR[k][0]))
                elif isinstance(self.fujipid.PXR[k][0], int):
                    self.fujipid.PXR[k][0] = toInt(settings.value(k, self.fujipid.PXR[k][0]))
            settings.endGroup()
            # --- END GROUP PXR

            # --- BEGIN GROUP PXG4
            settings.beginGroup('PXG4')
            for k in list(self.fujipid.PXG4.keys()):
                if isinstance(self.fujipid.PXG4[k][0], float):
                    self.fujipid.PXG4[k][0] = toFloat(settings.value(k, self.fujipid.PXG4[k][0]))
                elif isinstance(self.fujipid.PXG4[k][0], int):
                    self.fujipid.PXG4[k][0] = toInt(settings.value(k, self.fujipid.PXG4[k][0]))
            if self.fujipid.PXG4['selectsv'][0] < 1:
                self.fujipid.PXG4['selectsv'][0] = 1
            self.fujipid.followBackground = bool(
                toBool(settings.value('followBackground', self.fujipid.followBackground)))
            self.fujipid.lookahead = toInt(settings.value('lookahead', self.fujipid.lookahead))
            settings.endGroup()
            # --- END GROUP PXG4

            # --- BEGIN GROUP deltaDTA
            if settings.contains('deltaDTA'):
                settings.beginGroup('deltaDTA')
                for k in list(self.dtapid.dtamem.keys()):
                    if isinstance(self.dtapid.dtamem[k][0], float):
                        self.dtapid.dtamem[k][0] = toFloat(settings.value(k, self.dtapid.dtamem[k][0]))
                    elif isinstance(self.dtapid.dtamem[k][0], int):
                        self.dtapid.dtamem[k][0] = toInt(settings.value(k, self.dtapid.dtamem[k][0]))
                settings.endGroup()
            # --- END GROUP deltaDTA

            self.qmc.filterDropOuts = bool(toBool(settings.value('filterDropOuts', self.qmc.filterDropOuts)))
            self.qmc.dropSpikes = bool(toBool(settings.value('dropSpikes', self.qmc.dropSpikes)))
            self.qmc.dropDuplicates = bool(toBool(settings.value('dropDuplicates', self.qmc.dropDuplicates)))
            self.qmc.dropDuplicatesLimit = toFloat(settings.value('dropDuplicatesLimit', self.qmc.dropDuplicatesLimit))
            self.qmc.optimalSmoothing = bool(toBool(settings.value('optimalSmoothing', self.qmc.optimalSmoothing)))
            self.qmc.polyfitRoRcalc = bool(toBool(settings.value('polyfitRoRcalc', self.qmc.polyfitRoRcalc)))
            self.qmc.swapETBT = bool(toBool(settings.value('swapETBT', self.qmc.swapETBT)))
            self.qmc.minmaxLimits = bool(toBool(settings.value('minmaxLimits', self.qmc.minmaxLimits)))
            self.qmc.filterDropOut_tmin = toInt(settings.value('minLimit', self.qmc.filterDropOut_tmin))
            self.qmc.filterDropOut_tmax = toInt(settings.value('maxLimit', self.qmc.filterDropOut_tmax))
            self.qmc.foregroundShowFullflag = bool(
                toBool(settings.value('foregroundShowFullflag', self.qmc.foregroundShowFullflag)))
            self.qmc.interpolateDropsflag = bool(
                toBool(settings.value('interpolateDropsflag', self.qmc.interpolateDropsflag)))

            # --- BEGIN GROUP RoC
            settings.beginGroup('RoC')
            self.qmc.DeltaETflag = bool(toBool(settings.value('DeltaET', self.qmc.DeltaETflag)))
            self.qmc.DeltaBTflag = bool(toBool(settings.value('DeltaBT', self.qmc.DeltaBTflag)))
            self.qmc.deltaBTfilter = toInt(settings.value('deltafilter', self.qmc.deltaBTfilter))
            if settings.contains('deltaETfilter'):
                self.qmc.deltaETfilter = toInt(settings.value('deltaETfilter', self.qmc.deltaETfilter))
            else:
                self.qmc.deltaETfilter = self.qmc.deltaBTfilter
            self.qmc.deltaBTspan = toInt(settings.value('DeltaSpan', self.qmc.deltaBTspan))
            self.qmc.deltaETspan = toInt(settings.value('DeltaETspan', self.qmc.deltaETspan))
            self.qmc.LCDdecimalplaces = toInt(settings.value('LCDdecimalplaces', self.qmc.LCDdecimalplaces))
            self.qmc.statisticsmode = toInt(settings.value('statisticsmode', self.qmc.statisticsmode))
            self.qmc.DeltaETlcdflag = bool(toBool(settings.value('DeltaETlcd', self.qmc.DeltaETlcdflag)))
            self.qmc.DeltaBTlcdflag = bool(toBool(settings.value('DeltaBTlcd', self.qmc.DeltaBTlcdflag)))
            self.qmc.swapdeltalcds = bool(toBool(settings.value('swapdeltalcds', self.qmc.swapdeltalcds)))
            settings.endGroup()
            # --- END GROUP RoC

            self.qmc.curvefilter = toInt(settings.value('curvefilter', self.qmc.curvefilter))
            self.qmc.ETcurve = bool(toBool(settings.value('ETcurve', self.qmc.ETcurve)))
            self.qmc.BTcurve = bool(toBool(settings.value('BTcurve', self.qmc.BTcurve)))
            self.qmc.ETlcd = bool(toBool(settings.value('ETlcd', self.qmc.ETlcd)))
            self.qmc.BTlcd = bool(toBool(settings.value('BTlcd', self.qmc.BTlcd)))
            self.qmc.swaplcds = bool(toBool(settings.value('swaplcds', self.qmc.swaplcds)))

            # --- BEGIN GROUP DefaultButtons
            settings.beginGroup('DefaultButtons')
            self.qmc.buttonvisibility = [toBool(x) for x in
                                         toList(settings.value('buttonvisibility', self.qmc.buttonvisibility))]
            self.qmc.buttonactions = [toInt(x) for x in toList(settings.value('buttonactions', self.qmc.buttonactions))]
            self.qmc.buttonactionstrings = list(
                map(str, list(toStringList(settings.value('buttonactionstrings', self.qmc.buttonactionstrings)))))
            self.qmc.extrabuttonactions = [toInt(x) for x in
                                           toList(settings.value('extrabuttonactions', self.qmc.extrabuttonactions))]
            self.qmc.extrabuttonactionstrings = list(map(str, list(
                toStringList(settings.value('extrabuttonactionstrings', self.qmc.extrabuttonactionstrings)))))
            self.qmc.xextrabuttonactions = [toInt(x) for x in
                                            toList(settings.value('xextrabuttonactions', self.qmc.xextrabuttonactions))]
            self.qmc.xextrabuttonactionstrings = list(map(str, list(
                toStringList(settings.value('xextrabuttonactionstrings', self.qmc.xextrabuttonactionstrings)))))
            settings.endGroup()
            # --- END GROUP DefaultButtons

            self.qmc.transMappingMode = toInt(settings.value('transMappingMode', self.qmc.transMappingMode))

            # --- BEGIN GROUP Style
            settings.beginGroup('Style')
            self.qmc.patheffects = toInt(settings.value('patheffects', self.qmc.patheffects))
            self.qmc.glow = toInt(settings.value('glow', self.qmc.glow))
            self.qmc.graphstyle = toInt(settings.value('graphstyle', self.qmc.graphstyle))
            self.qmc.graphfont = toInt(settings.value('graphfont', self.qmc.graphfont))
            if settings.contains('ETname'):
                self.ETname = settings.value('ETname')
                self.label2.setText(f'<big><b>{self.ETname}</b></big>'.format(self.qmc.etypes[0], self.qmc.etypes[1],
                                                                              self.qmc.etypes[2], self.qmc.etypes[3]))
                # self.processInfoLabel.setText(f'<big><b>{self.ETname}</b></big>'.format(self.qmc.etypes[0],self.qmc.etypes[1],self.qmc.etypes[2],self.qmc.etypes[3]))
                self.label4.setText(
                    f'{deltaLabelBigPrefix}{self.ETname}</b></big>'.format(self.qmc.etypes[0], self.qmc.etypes[1],
                                                                           self.qmc.etypes[2], self.qmc.etypes[3]))
            else:
                self.ETname = QApplication.translate('Label', 'ET')
            if settings.contains('BTname'):
                self.BTname = settings.value('BTname')
                self.label3.setText(f'<big><b>{self.BTname}</b></big>'.format(self.qmc.etypes[0], self.qmc.etypes[1],
                                                                              self.qmc.etypes[2], self.qmc.etypes[3]))
                self.label5.setText(
                    f'{deltaLabelBigPrefix}{self.BTname}</b></big>'.format(self.qmc.etypes[0], self.qmc.etypes[1],
                                                                           self.qmc.etypes[2], self.qmc.etypes[3]))
            else:
                self.BTname = QApplication.translate('Label', 'BT')
            settings.endGroup()
            # --- END GROUP Style

            # --- BEGIN GROUP Sound
            settings.beginGroup('Sound')
            self.soundflag = toInt(settings.value('Beep', self.soundflag))
            settings.endGroup()
            # --- END GROUP Sound

            # --- BEGIN GROUP Notifications
            if filename is None:
                settings.beginGroup('Notifications')
                if self.notificationManager:
                    try:
                        # reconstruct Notification objects from component lists
                        titles = [toString(x) for x in toList(settings.value('titles', []))]
                        messages = [toString(x) for x in toList(settings.value('messages', []))]
                        types = [toInt(x) for x in toList(settings.value('types', []))]
                        created = [toFloat(x) for x in toList(settings.value('created', []))]
                        self.notificationManager.clearNotificationQueue()
                        for i, tl in enumerate(titles):
                            noti = Notification(
                                tl,
                                messages[i],
                                NotificationType(types[i]),
                                created[i])
                            self.notificationManager.addNotificationItem(noti)
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                notifications_enabled = toBool(settings.value('notificationsflag', self.notificationsflag))
                self.notificationsSetEnabledSignal.emit(notifications_enabled)
                settings.endGroup()
            # --- END GROUP Notifications

            # --- BEGIN GROUP Axis
            # loads max-min temp limits of graph
            settings.beginGroup('Axis')
            self.qmc.loadaxisfromprofile = bool(
                toBool(settings.value('loadAxisFromProfile', self.qmc.loadaxisfromprofile)))
            try:  # prevents some random exceptions in Windows!?
                self.qmc.startofx = toFloat(settings.value('xmin', self.qmc.startofx))
                self.qmc.endofx = toFloat(settings.value('xmax', self.qmc.endofx))
                # fixes Windows OS sometimes saving endofx as 0
                if self.qmc.endofx < 60 or self.qmc.endofx > 1800:
                    self.qmc.endofx = 60
            except Exception:  # pylint: disable=broad-except
                pass
            self.qmc.ylimit = min(toInt(settings.value('ymax', self.qmc.ylimit)), self.qmc.ylimit_max)
            self.qmc.ylimit_min = max(min(toInt(settings.value('ymin', self.qmc.ylimit_min)), self.qmc.ylimit),
                                      self.qmc.ylimit_min_max)
            self.qmc.zlimit = min(toInt(settings.value('zmax', self.qmc.zlimit)), self.qmc.zlimit_max)
            self.qmc.zlimit_min = max(min(toInt(settings.value('zmin', self.qmc.zlimit_min)), self.qmc.zlimit),
                                      self.qmc.zlimit_min_max)
            self.qmc.resetmaxtime = toInt(settings.value('resetmaxtime', self.qmc.resetmaxtime))
            self.qmc.fixmaxtime = bool(toBool(settings.value('lockmax', self.qmc.fixmaxtime)))
            self.qmc.locktimex = bool(toBool(settings.value('locktimex', self.qmc.locktimex)))
            self.qmc.autotimex = bool(toBool(settings.value('autotimex', self.qmc.autotimex)))
            self.qmc.autotimexMode = toInt(settings.value('autotimexMode', self.qmc.autotimexMode))
            self.qmc.autodeltaxET = bool(toBool(settings.value('autodeltaxET', self.qmc.autodeltaxET)))
            self.qmc.autodeltaxBT = bool(toBool(settings.value('autodeltaxBT', self.qmc.autodeltaxBT)))
            self.qmc.locktimex_start = toInt(settings.value('locktimex_start', self.qmc.locktimex_start))
            self.qmc.locktimex_end = toInt(settings.value('locktimex_end', self.qmc.locktimex_end))
            self.qmc.chargemintime = toInt(settings.value('chargemintime', self.qmc.chargemintime))
            self.qmc.legendloc = toInt(settings.value('legendloc', self.qmc.legendloc))
            self.qmc.temp_grid = bool(toBool(settings.value('temp_grid', self.qmc.temp_grid)))
            self.qmc.time_grid = bool(toBool(settings.value('time_grid', self.qmc.time_grid)))
            settings.endGroup()
            # --- END GROUP Axis

            # --- BEGIN GROUP MachineSetup
            # only set in (some) predefined machine setups:
            if filename and machine:
                settings.beginGroup('MachineSetup')
                self.qmc.roastersize_setup = toFloat(settings.value('capacity', self.qmc.roastersize_setup))
                self.qmc.roasterheating_setup = toInt(settings.value('heating_type', self.qmc.roasterheating_setup))
                settings.endGroup()
            # --- END GROUP MachineSetup

            self.qmc.organization_setup = toString(settings.value('organization_setup', self.qmc.organization_setup))
            self.qmc.operator_setup = toString(settings.value('operator_setup', self.qmc.operator_setup))
            self.qmc.roastertype_setup = toString(settings.value('roastertype_setup', self.qmc.roastertype_setup))
            self.qmc.roastersize_setup_default = toFloat(
                settings.value('roastersize_setup_default', self.qmc.roastersize_setup_default))
            self.qmc.roastersize_setup = toFloat(settings.value('roastersize_setup', self.qmc.roastersize_setup))
            self.qmc.last_batchsize = toFloat(settings.value('last_batchsize', self.qmc.last_batchsize))
            # we set the default in-weight from the given last_batchsize
            self.qmc.weight = (self.qmc.last_batchsize, self.qmc.weight[1], self.qmc.weight[2])
            self.qmc.roasterheating_setup = toInt(settings.value('roasterheating_setup', self.qmc.roasterheating_setup))
            self.qmc.roasterheating_setup_default = toInt(
                settings.value('roasterheating_setup_default', self.qmc.roasterheating_setup_default))
            self.qmc.drumspeed_setup = toString(settings.value('drumspeed_setup', self.qmc.drumspeed_setup))

            # --- BEGIN GROUP EnergyUse
            settings.beginGroup('EnergyUse')
            self.qmc.loadlabels_setup = [toString(x) for x in
                                         toList(settings.value('loadlabels_setup', self.qmc.loadlabels_setup))]
            self.qmc.loadratings_setup = [toFloat(x) for x in
                                          toList(settings.value('loadratings_setup', self.qmc.loadratings_setup))]
            self.qmc.ratingunits_setup = [toInt(x) for x in
                                          toList(settings.value('ratingunits_setup', self.qmc.ratingunits_setup))]
            self.qmc.sourcetypes_setup = [toInt(x) for x in
                                          toList(settings.value('sourcetypes_setup', self.qmc.sourcetypes_setup))]
            self.qmc.load_etypes_setup = [toInt(x) for x in
                                          toList(settings.value('load_etypes_setup', self.qmc.load_etypes_setup))]
            self.qmc.presssure_percents_setup = [bool(toBool(x)) for x in toList(
                settings.value('presssure_percents_setup', self.qmc.presssure_percents_setup))]
            self.qmc.loadevent_zeropcts_setup = [toInt(x) for x in toList(
                settings.value('loadevent_zeropcts_setup', self.qmc.loadevent_zeropcts_setup))]
            self.qmc.loadevent_hundpcts_setup = [toInt(x) for x in toList(
                settings.value('loadevent_hundpcts_setup', self.qmc.loadevent_hundpcts_setup))]
            self.qmc.preheatDuration_setup = toInt(
                settings.value('preheatDuration_setup', self.qmc.preheatDuration_setup))
            self.qmc.preheatenergies_setup = [toFloat(x) for x in toList(
                settings.value('preheatenergies_setup', self.qmc.preheatenergies_setup))]
            self.qmc.betweenbatchDuration_setup = toInt(
                settings.value('betweenbatchDuration_setup', self.qmc.betweenbatchDuration_setup))
            self.qmc.betweenbatchenergies_setup = [toFloat(x) for x in toList(
                settings.value('betweenbatchenergies_setup', self.qmc.betweenbatchenergies_setup))]
            self.qmc.coolingDuration_setup = toInt(
                settings.value('coolingDuration_setup', self.qmc.coolingDuration_setup))
            self.qmc.coolingenergies_setup = [toFloat(x) for x in toList(
                settings.value('coolingenergies_setup', self.qmc.coolingenergies_setup))]
            self.qmc.betweenbatch_after_preheat_setup = bool(
                toBool(settings.value('betweenbatch_after_preheat_setup', self.qmc.betweenbatch_after_preheat_setup)))
            self.qmc.electricEnergyMix_setup = toInt(
                settings.value('electricEnergyMix_setup', self.qmc.electricEnergyMix_setup))
            self.qmc.energyresultunit_setup = toInt(
                settings.value('energyresultunit_setup', self.qmc.energyresultunit_setup))
            #            self.qmc.energytablecolumnwidths = [toInt(x) for x in toList(settings.value("energytablecolumnwidths",self.qmc.energytablecolumnwidths))]
            settings.endGroup()
            self.qmc.restoreEnergyLoadDefaults()
            self.qmc.restoreEnergyProtocolDefaults()
            # --- END GROUP EnergyUse

            # --- BEGIN GROUP EnergyDefaults
            settings.beginGroup('EnergyDefaults')
            self.qmc.machinesetup_energy_ratings = settings.value('ratings', self.qmc.machinesetup_energy_ratings)
            settings.endGroup()
            # --- END GROUP EnergyDefaults

            # --- BEGIN GROUP RoastProperties
            settings.beginGroup('RoastProperties')
            # copy setup from pre v1.4.6 RoastProperties organization,operator,roastertype,roastersize
            if self.qmc.organization_setup == '' and settings.contains('organization'):
                self.qmc.organization_setup = toString(settings.value('organization', self.qmc.organization_setup))
            if self.qmc.operator_setup == '' and settings.contains('operator'):
                self.qmc.operator_setup = toString(settings.value('operator', self.qmc.operator_setup))
            if self.qmc.roastertype_setup == '' and settings.contains('roastertype'):
                self.qmc.roastertype_setup = toString(settings.value('roastertype', self.qmc.roastertype_setup))
            if self.qmc.roastersize_setup == 0 and settings.contains('roastersize'):
                self.qmc.roastersize_setup = toFloat(settings.value('roastersize', self.qmc.roastersize_setup))
            if self.qmc.drumspeed_setup == '' and settings.contains('drumspeed'):
                self.qmc.drumspeed_setup = toString(settings.value('drumspeed', self.qmc.drumspeed_setup))
            # initialize profile setup values
            self.qmc.organization = self.qmc.organization_setup
            self.qmc.operator = self.qmc.operator_setup
            self.qmc.roastertype = self.qmc.roastertype_setup
            self.qmc.roastersize = self.qmc.roastersize_setup
            self.qmc.roasterheating = self.qmc.roasterheating_setup
            self.qmc.drumspeed = self.qmc.drumspeed_setup
            #
            if settings.contains('machinesetup'):
                self.qmc.machinesetup = toString(settings.value('machinesetup', self.qmc.machinesetup))
            #            self.qmc.density[2] = toFloat(settings.value("densitySampleVolume",self.qmc.density[2])) # fixed to 1l now

            #            if settings.contains('beansize'):
            #                self.qmc.beansize = toFloat(settings.value('beansize',self.qmc.beansize)) # retired
            self.qmc.beansize_min = toInt(settings.value('beansize_min', self.qmc.beansize_min))
            self.qmc.beansize_max = toInt(settings.value('beansize_max', self.qmc.beansize_max))
            self.qmc.plus_default_store = settings.value('plus_default_store', self.qmc.plus_default_store)
            if filename is None and settings.contains('plus_custom_blend_name'):
                # we don't import plus custom blend data from external settings file as the custom blend is considered temporary
                plus_custom_blend_name = toString(settings.value('plus_custom_blend_name', ''))
                plus_custom_blend_coffees = [toString(x) for x in
                                             toList(settings.value('plus_custom_blend_coffees', []))]
                plus_custom_blend_ratios = [toFloat(x) for x in toList(settings.value('plus_custom_blend_ratios', []))]
                if plus_custom_blend_name != '' and len(plus_custom_blend_coffees) > 1 and len(
                        plus_custom_blend_ratios) == len(plus_custom_blend_coffees):
                    try:
                        plus_custom_blend_components = [plus.blend.Component(c, r) for (c, r) in
                                                        zip(plus_custom_blend_coffees, plus_custom_blend_ratios)]
                        self.qmc.plus_custom_blend = plus.blend.CustomBlend(
                            plus_custom_blend_name,
                            plus_custom_blend_components)
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                        self.qmc.plus_custom_blend = None
                else:
                    self.qmc.plus_custom_blend = None
            settings.endGroup()
            # --- END GROUP RoastProperties

            self.userprofilepath = toString(settings.value('profilepath', self.userprofilepath))
            self.settingspath = toString(settings.value('settingspath', self.settingspath))
            self.wheelpath = toString(settings.value('wheelpath', self.wheelpath))
            self.qmc.autosavepath = toString(settings.value('autosavepath', self.qmc.autosavepath))
            self.qmc.autosavealsopath = toString(settings.value('autosavealsopath', self.qmc.autosavealsopath))
            self.simulatorpath = toString(settings.value('simulatorpath', self.simulatorpath))
            self.ser.externalprogram = toString(settings.value('externalprogram', self.ser.externalprogram))
            self.ser.externaloutprogram = toString(settings.value('externaloutprogram', self.ser.externaloutprogram))
            self.ser.externaloutprogramFlag = bool(
                toBool(settings.value('externaloutprogramFlag', self.ser.externaloutprogramFlag)))
            if not theme:
                # --- BEGIN GROUP ExtraDev
                settings.beginGroup('ExtraDev')
                self.getExtraDeviceSettings(settings)
                settings.endGroup()
                # --- END GROUP ExtraDev
                # ensure that extra list length are of the size of the extradevices:
                self.ensureCorrectExtraDeviceListLength()
                self.updateExtradeviceSettings()

            try:
                _log.info('machine: %s (%s, %skg, %s)', self.qmc.machinesetup, self.qmc.roastertype_setup,
                          self.qmc.roastersize_setup, ([''] + self.qmc.sourcenames)[self.qmc.roasterheating_setup])
                _log.info('device: %s (%s extra devices)', (['Fuji PID'] + self.qmc.devices)[self.qmc.device],
                          len(self.qmc.extradevices))
                _log.info('serial: %s @%s', self.ser.comport, self.ser.baudrate)
                _log.info('MODBUS %s: %s, %s @%s',
                          ['Serial RTU', 'Serial ASCII', 'Serial Binary', 'TCP', 'UDP'][self.modbus.type],
                          self.modbus.host, self.modbus.comport, self.modbus.baudrate)
                _log.info('S7: %s', self.s7.host)
                _log.info('WebSocket: %s', self.ws.host)
            except Exception as e:  # pylint: disable=broad-except
                _log.error(e)

            # --- BEGIN GROUP CurveStyles
            # restore curve styles
            settings.beginGroup('CurveStyles')
            self.qmc.BTlinestyle = s2a(toString(settings.value('BTlinestyle', self.qmc.BTlinestyle)))
            self.qmc.BTdrawstyle = s2a(toString(settings.value('BTdrawstyle', self.qmc.BTdrawstyle)))
            if self.qmc.BTdrawstyle == '-':
                self.qmc.BTdrawstyle = self.qmc.drawstyle_default
            self.qmc.BTlinewidth = max(0.1,
                                       self.float2float(toFloat(settings.value('BTlinewidth', self.qmc.BTlinewidth))))
            self.qmc.BTmarker = s2a(toString(settings.value('BTmarker', self.qmc.BTmarker)))
            self.qmc.BTmarkersize = max(0.1, self.float2float(
                toFloat(settings.value('BTmarkersize', self.qmc.BTmarkersize))))
            self.qmc.ETlinestyle = s2a(toString(settings.value('ETlinestyle', self.qmc.ETlinestyle)))
            self.qmc.ETdrawstyle = s2a(toString(settings.value('ETdrawstyle', self.qmc.ETdrawstyle)))
            if self.qmc.ETdrawstyle == '-':
                self.qmc.ETdrawstyle = self.qmc.drawstyle_default
            self.qmc.ETlinewidth = max(0.1,
                                       self.float2float(toFloat(settings.value('ETlinewidth', self.qmc.ETlinewidth))))
            self.qmc.ETmarker = s2a(toString(settings.value('ETmarker', self.qmc.ETmarker)))
            self.qmc.ETmarkersize = max(0.1, self.float2float(
                toFloat(settings.value('ETmarkersize', self.qmc.ETmarkersize))))
            self.qmc.BTdeltalinestyle = s2a(toString(settings.value('BTdeltalinestyle', self.qmc.BTdeltalinestyle)))
            self.qmc.BTdeltadrawstyle = s2a(toString(settings.value('BTdeltadrawstyle', self.qmc.BTdeltadrawstyle)))
            if self.qmc.BTdeltadrawstyle == '-':
                self.qmc.BTdeltadrawstyle = self.qmc.drawstyle_default
            self.qmc.BTdeltalinewidth = max(0.1, self.float2float(
                toFloat(settings.value('BTdeltalinewidth', self.qmc.BTdeltalinewidth))))
            self.qmc.BTdeltamarker = s2a(toString(settings.value('BTdeltamarker', self.qmc.BTdeltamarker)))
            self.qmc.BTdeltamarkersize = max(0.1, self.float2float(
                toFloat(settings.value('BTdeltamarkersize', self.qmc.BTdeltamarkersize))))
            self.qmc.ETdeltalinestyle = s2a(toString(settings.value('ETdeltalinestyle', self.qmc.ETdeltalinestyle)))
            self.qmc.ETdeltadrawstyle = s2a(toString(settings.value('ETdeltadrawstyle', self.qmc.ETdeltadrawstyle)))
            if self.qmc.ETdeltadrawstyle == '-':
                self.qmc.ETdeltadrawstyle = self.qmc.drawstyle_default
            self.qmc.ETdeltalinewidth = max(0.1, self.float2float(
                toFloat(settings.value('ETdeltalinewidth', self.qmc.ETdeltalinewidth))))
            self.qmc.ETdeltamarker = s2a(toString(settings.value('ETdeltamarker', self.qmc.ETdeltamarker)))
            self.qmc.ETdeltamarkersize = max(0.1, self.float2float(
                toFloat(settings.value('ETdeltamarkersize', self.qmc.ETdeltamarkersize))))
            self.qmc.BTbacklinestyle = s2a(toString(settings.value('BTbacklinestyle', self.qmc.BTbacklinestyle)))
            self.qmc.BTbackdrawstyle = s2a(toString(settings.value('BTbackdrawstyle', self.qmc.BTbackdrawstyle)))
            if self.qmc.BTbackdrawstyle == '-':
                self.qmc.BTbackdrawstyle = self.qmc.drawstyle_default
            self.qmc.BTbacklinewidth = max(0.1, self.float2float(
                toFloat(settings.value('BTbacklinewidth', self.qmc.BTbacklinewidth))))
            self.qmc.BTbackmarker = s2a(toString(settings.value('BTbackmarker', self.qmc.BTbackmarker)))
            self.qmc.BTbackmarkersize = max(0.1, self.float2float(
                toFloat(settings.value('BTbackmarkersize', self.qmc.BTbackmarkersize))))
            self.qmc.ETbacklinestyle = s2a(toString(settings.value('ETbacklinestyle', self.qmc.ETbacklinestyle)))
            self.qmc.ETbackdrawstyle = s2a(toString(settings.value('ETbackdrawstyle', self.qmc.ETbackdrawstyle)))
            if self.qmc.ETbackdrawstyle == '-':
                self.qmc.ETbackdrawstyle = self.qmc.drawstyle_default
            self.qmc.ETbacklinewidth = max(0.1, self.float2float(
                toFloat(settings.value('ETbacklinewidth', self.qmc.ETbacklinewidth))))
            self.qmc.ETbackmarker = s2a(toString(settings.value('ETbackmarker', self.qmc.ETbackmarker)))
            self.qmc.ETbackmarkersize = max(0.1, self.float2float(
                toFloat(settings.value('ETbackmarkersize', self.qmc.ETbackmarkersize))))
            self.qmc.XTbacklinestyle = s2a(toString(settings.value('XTbacklinestyle', self.qmc.XTbacklinestyle)))
            self.qmc.XTbackdrawstyle = s2a(toString(settings.value('XTbackdrawstyle', self.qmc.XTbackdrawstyle)))
            if self.qmc.XTbackdrawstyle == '-':
                self.qmc.XTbackdrawstyle = self.qmc.drawstyle_default
            self.qmc.XTbacklinewidth = max(0.1, self.float2float(
                toFloat(settings.value('XTbacklinewidth', self.qmc.XTbacklinewidth))))
            self.qmc.XTbackmarker = s2a(toString(settings.value('XTbackmarker', self.qmc.XTbackmarker)))
            self.qmc.XTbackmarkersize = max(0.1, self.float2float(
                toFloat(settings.value('XTbackmarkersize', self.qmc.XTbackmarkersize))))
            self.qmc.YTbacklinestyle = s2a(toString(settings.value('YTbacklinestyle', self.qmc.XTbacklinestyle)))
            self.qmc.YTbackdrawstyle = s2a(toString(settings.value('YTbackdrawstyle', self.qmc.YTbackdrawstyle)))
            if self.qmc.YTbackdrawstyle == '-':
                self.qmc.YTbackdrawstyle = self.qmc.drawstyle_default
            self.qmc.YTbacklinewidth = max(0.1, self.float2float(
                toFloat(settings.value('YTbacklinewidth', self.qmc.YTbacklinewidth))))
            self.qmc.YTbackmarker = s2a(toString(settings.value('YTbackmarker', self.qmc.YTbackmarker)))
            self.qmc.YTbackmarkersize = max(0.1, self.float2float(
                toFloat(settings.value('YTbackmarkersize', self.qmc.YTbackmarkersize))))
            self.getExtraDeviceCurveStyles(settings)
            self.qmc.BTBdeltalinestyle = s2a(toString(settings.value('BTBdeltalinestyle', self.qmc.BTBdeltalinestyle)))
            self.qmc.BTBdeltadrawstyle = s2a(toString(settings.value('BTBdeltadrawstyle', self.qmc.BTBdeltadrawstyle)))
            self.qmc.BTBdeltalinewidth = max(0.1, self.float2float(
                toFloat(settings.value('BTBdeltalinewidth', self.qmc.BTBdeltalinewidth))))
            self.qmc.BTBdeltamarker = s2a(toString(settings.value('BTBdeltamarker', self.qmc.BTBdeltamarker)))
            self.qmc.BTBdeltamarkersize = max(0.1, self.float2float(
                toFloat(settings.value('BTBdeltamarkersize', self.qmc.BTBdeltamarkersize))))
            self.qmc.ETBdeltalinestyle = s2a(toString(settings.value('ETBdeltalinestyle', self.qmc.ETBdeltalinestyle)))
            self.qmc.ETBdeltadrawstyle = s2a(toString(settings.value('ETBdeltadrawstyle', self.qmc.ETBdeltadrawstyle)))
            self.qmc.ETBdeltalinewidth = max(0.1, self.float2float(
                toFloat(settings.value('ETBdeltalinewidth', self.qmc.ETBdeltalinewidth))))
            self.qmc.ETBdeltamarker = s2a(toString(settings.value('ETBdeltamarker', self.qmc.ETBdeltamarker)))
            self.qmc.ETBdeltamarkersize = max(0.1, self.float2float(
                toFloat(settings.value('ETBdeltamarkersize', self.qmc.ETBdeltamarkersize))))
            settings.endGroup()
            # --- END GROUP CurveStyles

            # --- BEGIN GROUP ExtraComm
            # Extra com ports
            settings.beginGroup('ExtraComm')
            self.getExtraDeviceCommSettings(settings)
            settings.endGroup()
            # --- END GROUP ExtraComm

            self.channel_tare_values = [toFloat(x) for x in
                                        toList(settings.value('ChannelTares', self.channel_tare_values))]
            self.qmc.BTfunction = s2a(toString(settings.value('BTfunction', self.qmc.BTfunction)))
            self.qmc.ETfunction = s2a(toString(settings.value('ETfunction', self.qmc.ETfunction)))
            self.qmc.DeltaBTfunction = s2a(toString(settings.value('DeltaBTfunction', self.qmc.DeltaBTfunction)))
            self.qmc.DeltaETfunction = s2a(toString(settings.value('DeltaETfunction', self.qmc.DeltaETfunction)))
            self.qmc.plotcurves = list(toStringList(settings.value('plotcurves', self.qmc.plotcurves)))
            self.qmc.plotcurvecolor = list(toStringList(settings.value('plotcurvecolor', self.qmc.plotcurvecolor)))
            # convert to 9
            if len(self.qmc.plotcurves) == 6:
                self.qmc.plotcurves += ['', '', '']
                self.qmc.plotcurvecolor += ['#000000', '#000000', '#000000']

            # --- BEGIN GROUP RoRlimits
            settings.beginGroup('RoRlimits')
            self.qmc.RoRlimitFlag = bool(toBool(settings.value('RoRlimitFlag', self.qmc.RoRlimitFlag)))
            self.qmc.RoRlimit = toInt(settings.value('RoRlimit', self.qmc.RoRlimit))
            self.qmc.RoRlimitm = toInt(settings.value('RoRlimitm', self.qmc.RoRlimitm))
            settings.endGroup()
            # --- END GROUP RoRlimits

            # --- BEGIN GROUP grid
            settings.beginGroup('grid')
            self.qmc.xgrid = toInt(settings.value('xgrid', self.qmc.xgrid))
            self.qmc.ygrid = max(0, toInt(settings.value('ygrid', self.qmc.ygrid)))
            self.qmc.zgrid = max(0, toInt(settings.value('zgrid', self.qmc.zgrid)))
            self.qmc.gridthickness = toInt(settings.value('gridthickness', self.qmc.gridthickness))
            self.qmc.gridlinestyle = toInt(settings.value('gridlinestyle', self.qmc.gridlinestyle))
            self.qmc.gridalpha = toFloat(settings.value('gridalpha', self.qmc.gridalpha))
            settings.endGroup()
            # --- END GROUP grid

            self.qmc.title_show_always = bool(toBool(settings.value('titleshowalways', self.qmc.title_show_always)))
            self.qmc.roastpropertiesflag = toInt(settings.value('roastpropertiesflag', self.qmc.roastpropertiesflag))
            self.qmc.roastpropertiesAutoOpenFlag = toInt(
                settings.value('roastpropertiesAutoOpenFlag', self.qmc.roastpropertiesAutoOpenFlag))
            self.qmc.roastpropertiesAutoOpenDropFlag = toInt(
                settings.value('roastpropertiesAutoOpenDropFlag', self.qmc.roastpropertiesAutoOpenDropFlag))
            self.qmc.customflavorlabels = list(
                map(str, list(toStringList(settings.value('customflavorlabels', self.qmc.customflavorlabels)))))

            # --- BEGIN GROUP Sliders
            # restore sliders
            settings.beginGroup('Sliders')
            eventslidervisibilities = list(
                map(toInt, toList(settings.value('slidervisibilities', self.eventslidervisibilities))))
            if len(eventslidervisibilities) == self.eventsliders:
                self.eventslidervisibilities = eventslidervisibilities
            eventslideractions = list(map(toInt, toList(settings.value('slideractions', self.eventslideractions))))
            if len(eventslideractions) == self.eventsliders:
                self.eventslideractions = eventslideractions
            eventslidercommands = list(
                map(str, list(toStringList(settings.value('slidercommands', self.eventslidercommands)))))
            if len(eventslidercommands) == self.eventsliders:
                self.eventslidercommands = eventslidercommands
            eventslideroffsets = list(map(toFloat, toList(settings.value('slideroffsets', self.eventslideroffsets))))
            if len(eventslideroffsets) == self.eventsliders:
                self.eventslideroffsets = eventslideroffsets
            eventsliderfactors = list(map(toFloat, toList(settings.value('sliderfactors', self.eventsliderfactors))))
            if len(eventsliderfactors) == self.eventsliders:
                self.eventsliderfactors = eventsliderfactors
            self.eventsliderKeyboardControl = bool(
                toBool(settings.value('eventsliderKeyboardControl', self.eventsliderKeyboardControl)))
            if settings.contains('eventsliderAlternativeLayout'):
                new_eventsliderAlternativeLayout = bool(
                    toBool(settings.value('eventsliderAlternativeLayout', self.eventsliderAlternativeLayout)))
                self.updateSliderLayout(new_eventsliderAlternativeLayout)
            eventslidermin = [toInt(x) for x in toList(settings.value('slidermin', self.eventslidermin))]
            if len(eventslidermin) == self.eventsliders:
                self.eventslidermin = eventslidermin
            eventslidermax = [toInt(x) for x in toList(settings.value('slidermax', self.eventslidermax))]
            if len(eventslidermax) == self.eventsliders:
                self.eventslidermax = eventslidermax
            self.updateSliderMinMax()
            eventslidersflags = [toInt(x) for x in toList(settings.value('eventslidersflags', self.eventslidersflags))]
            if len(eventslidersflags) == 3:
                self.eventslidersflags = eventslidersflags
            eventsliderBernoulli = [toInt(x) for x in
                                    toList(settings.value('eventsliderBernoulli', self.eventsliderBernoulli))]
            if len(eventsliderBernoulli) == self.eventsliders:
                self.eventsliderBernoulli = eventsliderBernoulli
            eventslidercoarse = [toInt(x) for x in toList(settings.value('eventslidercoarse', self.eventslidercoarse))]
            if len(eventslidercoarse) == self.eventsliders:
                self.eventslidercoarse = eventslidercoarse
            eventslidertemp = [toInt(x) for x in toList(settings.value('eventslidertemp', self.eventslidertemp))]
            if len(eventslidertemp) == self.eventsliders:
                self.eventslidertemp = eventslidertemp
            eventsliderunits = list(
                map(str, list(toStringList(settings.value('eventsliderunits', self.eventsliderunits)))))
            if len(eventsliderunits) == self.eventsliders:
                self.eventsliderunits = eventsliderunits
            self.qmc.mode_tempsliders = str(settings.value('ModeTempSliders', self.qmc.mode_tempsliders))
            settings.endGroup()
            self.qmc.adjustTempSliders()  # adjust min/max slider limits of temperature sliders to correspond to the current temp mode
            # self.slidersAction.setEnabled(any(self.eventslidervisibilities) or self.pidcontrol.svSlider)
            # if self.app.artisanviewerMode:
            #     self.slidersAction.setEnabled(False)
            # --- END GROUP Sliders

            # --- BEGIN GROUP Quantifiers
            # restore quantifier
            settings.beginGroup('Quantifiers')
            if settings.contains('quantifieractive'):
                activequantifiers = [toInt(x) for x in
                                     toList(settings.value('quantifieractive', self.eventquantifieractive))]
                if len(activequantifiers) == self.eventsliders:
                    self.eventquantifieractive = activequantifiers
                quantifiersource = [toInt(x) for x in
                                    toList(settings.value('quantifiersource', self.eventquantifiersource))]
                if len(quantifiersource) == self.eventsliders:
                    self.eventquantifiersource = quantifiersource
                quantifiersmin = [toInt(x) for x in toList(settings.value('quantifiermin', self.eventquantifiermin))]
                if len(quantifiersmin) == self.eventsliders:
                    self.eventquantifiermin = quantifiersmin
                quantifiersmax = [toInt(x) for x in toList(settings.value('quantifiermax', self.eventquantifiermax))]
                if len(quantifiersmax) == self.eventsliders:
                    self.eventquantifiermax = quantifiersmax
                eventquantifiercoarse = [toInt(x) for x in
                                         toList(settings.value('quantifiercoarse', self.eventquantifiercoarse))]
                if len(eventquantifiercoarse) == self.eventsliders:
                    self.eventquantifiercoarse = eventquantifiercoarse
                self.clusterEventsFlag = bool(toBool(settings.value('clusterEventsFlag', self.clusterEventsFlag)))
                eventquantifieraction = [toInt(x) for x in
                                         toList(settings.value('eventquantifieraction', self.eventquantifieraction))]
                if len(eventquantifieraction) == self.eventsliders:
                    self.eventquantifieraction = eventquantifieraction
                eventquantifierSV = [toInt(x) for x in
                                     toList(settings.value('eventquantifierSV', self.eventquantifierSV))]
                if len(eventquantifierSV) == self.eventsliders:
                    self.eventquantifierSV = eventquantifierSV
            settings.endGroup()
            # --- END GROUP Quantifiers

            # --- BEGIN GROUP Batch
            settings.beginGroup('Batch')
            if updateBatchCounter:
                self.qmc.batchcounter = toInt(settings.value('batchcounter', self.qmc.batchcounter))
            self.qmc.batchprefix = toString(settings.value('batchprefix', self.qmc.batchprefix))
            if filename is None:
                # we do not load those two from setting files!
                self.qmc.batchsequence = toInt(settings.value('batchsequence', self.qmc.batchsequence))
                self.qmc.lastroastepoch = toInt(settings.value('lastroastepoch', self.qmc.lastroastepoch))
            settings.endGroup()
            # --- END GROUP Batch

            self.computeLinespaces()
            self.updateSlidersProperties()

            # --- BEGIN GROUP background
            # restore background profile settings
            settings.beginGroup('background')
            self.qmc.backgroundDetails = bool(toBool(settings.value('backgrounddetails', self.qmc.backgroundDetails)))
            self.qmc.backgroundeventsflag = bool(
                toBool(settings.value('backgroundevents', self.qmc.backgroundeventsflag)))
            self.qmc.DeltaETBflag = bool(toBool(settings.value('DeltaETB', self.qmc.DeltaETBflag)))
            self.qmc.DeltaBTBflag = bool(toBool(settings.value('DeltaBTB', self.qmc.DeltaBTBflag)))
            self.qmc.alignEvent = toInt(settings.value('alignEvent', self.qmc.alignEvent))
            self.qmc.backgroundmovespeed = toInt(settings.value('movespeed', self.qmc.backgroundmovespeed))
            self.qmc.backgroundETcurve = bool(toBool(settings.value('ETBflag', self.qmc.backgroundETcurve)))
            self.qmc.backgroundBTcurve = bool(toBool(settings.value('BTBflag', self.qmc.backgroundBTcurve)))
            self.qmc.backgroundShowFullflag = bool(
                toBool(settings.value('backgroundShowFullflag', self.qmc.backgroundShowFullflag)))
            self.qmc.backgroundKeyboardControlFlag = bool(
                toBool(settings.value('backgroundKeyboardControlFlag', self.qmc.backgroundKeyboardControlFlag)))
            self.qmc.clearBgbeforeprofileload = bool(
                toBool(settings.value('clearBgbeforeprofileload', self.qmc.clearBgbeforeprofileload)))
            self.qmc.hideBgafterprofileload = bool(
                toBool(settings.value('hideBgafterprofileload', self.qmc.hideBgafterprofileload)))
            settings.endGroup()
            # --- END GROUP background

            self.qmc.compareAlignEvent = toInt(settings.value('compareAlignEvent', self.qmc.compareAlignEvent))
            self.qmc.compareEvents = toInt(settings.value('compareEvents', self.qmc.compareEvents))
            self.qmc.compareET = bool(toBool(settings.value('compareET', self.qmc.compareET)))
            self.qmc.compareBT = bool(toBool(settings.value('compareBT', self.qmc.compareBT)))
            self.qmc.compareDeltaET = bool(toBool(settings.value('compareDeltaET', self.qmc.compareDeltaET)))
            self.qmc.compareDeltaBT = bool(toBool(settings.value('compareDeltaBT', self.qmc.compareDeltaBT)))
            self.qmc.compareMainEvents = bool(toBool(settings.value('compareMainEvents', self.qmc.compareMainEvents)))
            self.qmc.compareExtraCurves1 = [toBool(x) for x in
                                            toList(settings.value('compareExtraCurves1', self.qmc.compareExtraCurves1))]
            self.qmc.compareExtraCurves2 = [toBool(x) for x in
                                            toList(settings.value('compareExtraCurves2', self.qmc.compareExtraCurves2))]
            self.qmc.compareBBP = bool(toBool(settings.value('compareBBP', self.qmc.compareBBP)))
            self.qmc.compareRoast = bool(toBool(settings.value('compareRoast', self.qmc.compareRoast)))
            self.qmc.autosaveflag = toInt(settings.value('autosaveflag', self.qmc.autosaveflag))
            self.qmc.autosaveaddtorecentfilesflag = bool(
                toBool(settings.value('autosaveaddtorecentfilesflag', self.qmc.autosaveaddtorecentfilesflag)))
            self.qmc.autosaveimage = bool(toBool(settings.value('autosavepdf', self.qmc.autosaveimage)))
            self.qmc.autosaveimageformat = toString(settings.value('autosaveimageformat', self.qmc.autosaveimageformat))
            self.qmc.autosaveprefix = toString(settings.value('autosaveprefix', self.qmc.autosaveprefix))

            # --- BEGIN GROUP WebLCDs
            # WebLCDs
            settings.beginGroup('WebLCDs')
            self.WebLCDs = bool(toBool(settings.value('active', self.WebLCDs)))
            self.WebLCDsPort = toInt(settings.value('port', self.WebLCDsPort))
            self.WebLCDsAlerts = bool(toBool(settings.value('alerts', self.WebLCDsAlerts)))
            settings.endGroup()
            # --- END GROUP WebLCDs

            self.LargeLCDsFlag = toBool(settings.value('LargeLCDs', self.LargeLCDsFlag))
            if self.LargeLCDsFlag:
                self.largeLCDs()
            self.LargeDeltaLCDsFlag = toBool(settings.value('LargeDeltaLCDs', self.LargeDeltaLCDsFlag))
            if self.LargeDeltaLCDsFlag:
                self.largeDeltaLCDs()
            self.LargePIDLCDsFlag = toBool(settings.value('LargePIDLCDs', self.LargePIDLCDsFlag))
            if self.LargePIDLCDsFlag:
                self.largePIDLCDs()
            self.LargeScaleLCDsFlag = toBool(settings.value('LargeScaleLCDs', self.LargeScaleLCDsFlag))
            if self.LargeScaleLCDsFlag:
                self.largeScaleLCDs()
            self.LargeExtraLCDsFlag = toBool(settings.value('LargeExtraLCDs', self.LargeExtraLCDsFlag))
            if self.LargeExtraLCDsFlag:
                self.largeExtraLCDs()
            self.LargePhasesLCDsFlag = toBool(settings.value('LargePhasesLCDs', self.LargePhasesLCDsFlag))
            if self.LargePhasesLCDsFlag:
                self.largePhasesLCDs()
            # start server if needed
            if self.WebLCDs:
                QTimer.singleShot(5000, self.startWebLCDsforced)

            # --- BEGIN GROUP ExtraEventButtons
            # restore buttons
            settings.beginGroup('ExtraEventButtons')
            self.buttonlistmaxlen = toInt(settings.value('buttonlistmaxlen', self.buttonlistmaxlen))
            self.extraeventsbuttonsflags = [toInt(x) for x in toList(
                settings.value('extraeventsbuttonsflags', self.extraeventsbuttonsflags))]
            extraeventstypes = [toInt(x) for x in toList(settings.value('extraeventstypes', self.extraeventstypes))]
            extraeventsvalues = [toFloat(x) for x in
                                 toList(settings.value('extraeventsvalues', self.extraeventsvalues))]
            extraeventsactions = [toInt(x) for x in
                                  toList(settings.value('extraeventsactions', self.extraeventsactions))]
            extraeventsvisibility = [toInt(x) for x in
                                     toList(settings.value('extraeventsvisibility', self.extraeventsvisibility))]
            extraeventsactionstrings = list(
                toStringList(settings.value('extraeventsactionstrings', self.extraeventsactionstrings)))
            extraeventslabels = list(toStringList(settings.value('extraeventslabels', self.extraeventslabels)))
            extraeventsdescriptions = list(
                toStringList(settings.value('extraeventsdescriptions', self.extraeventsdescriptions)))
            if settings.contains('extraeventbuttoncolor'):
                extraeventbuttoncolor = list(
                    toStringList(settings.value('extraeventbuttoncolor', self.extraeventbuttoncolor)))
            else:
                extraeventbuttoncolor = ['yellow'] * len(extraeventstypes)
            if settings.contains('extraeventbuttontextcolor'):
                extraeventbuttontextcolor = list(
                    toStringList(settings.value('extraeventbuttontextcolor', self.extraeventbuttontextcolor)))
            else:
                extraeventbuttontextcolor = ['#000000'] * len(extraeventstypes)
            if len(extraeventstypes) == len(extraeventsvalues) == len(extraeventsactions) == len(
                    extraeventsvisibility) == \
                    len(extraeventsactionstrings) == len(extraeventslabels) == len(extraeventsdescriptions) == \
                    len(extraeventbuttoncolor) == len(extraeventbuttontextcolor):
                self.extraeventstypes = extraeventstypes
                self.extraeventsvalues = extraeventsvalues
                self.extraeventsactions = extraeventsactions
                self.extraeventsvisibility = extraeventsvisibility
                self.extraeventsactionstrings = extraeventsactionstrings
                self.extraeventslabels = extraeventslabels
                self.extraeventsdescriptions = extraeventsdescriptions
                self.extraeventbuttoncolor = extraeventbuttoncolor
                self.extraeventbuttontextcolor = extraeventbuttontextcolor
            self.buttonpalettemaxlen = [min(30, max(6, toInt(x))) for x in
                                        toList(settings.value('buttonpalettemaxlen', self.buttonpalettemaxlen))]
            bp = toList(settings.value('buttonpalette', self.buttonpalette))
            self.buttonpalette = []
            if not bp:
                self.buttonpalette = [self.makePalette() for _ in range(10)]  # initialize empty palettes
            else:
                for p in bp[:self.max_palettes]:
                    if p is None or len(p) > self.palette_entries:
                        # we generate a new default palette
                        self.buttonpalette.append(self.makePalette())
                    elif len(p) == self.palette_entries:
                        # we convert the list into a Palette tuple
                        if self.paletteValid(p):
                            tp = cast('Palette', tuple(p))
                            self.buttonpalette.append(tp)
                        else:
                            self.buttonpalette.append(self.makePalette())
                    else:
                        # to be compatible to older Artisan versions with smaller palettes we fill the list from the defaults and convert it into a Palette
                        tp = cast('Palette', tuple(p + list(self.makePalette(empty=False))[len(p):]))
                        self.buttonpalette.append(tp)
            self.buttonpalette_shortcuts = bool(
                toBool(settings.value('buttonpalette_shortcuts', self.buttonpalette_shortcuts)))
            self.eventbuttontablecolumnwidths = [toInt(x) for x in toList(
                settings.value('eventbuttontablecolumnwidths', self.eventbuttontablecolumnwidths))]
            self.buttonsize = toInt(settings.value('buttonsize', self.buttonsize))
            self.mark_last_button_pressed = bool(
                toBool(settings.value('marklastbuttonpressed', self.mark_last_button_pressed)))
            self.show_extrabutton_tooltips = bool(
                toBool(settings.value('showextrabuttontooltips', self.show_extrabutton_tooltips)))
            self.buttonpalette_label = toString(settings.value('buttonpalette_label', self.buttonpalette_label))
            settings.endGroup()
            # --- END GROUP ExtraEventButtons

            # --- BEGIN GROUP ExtrasMoreInfo
            # Extras more info
            settings.beginGroup('ExtrasMoreInfo')
            self.qmc.showmet = bool(toBool(settings.value('showmet', self.qmc.showmet)))
            if settings.contains('statssummary'):
                self.qmc.statssummary = bool(toBool(settings.value('statssummary')))
                if self.qmc.statssummary:
                    self.savestatisticsAction.setEnabled(True)
                else:
                    self.savestatisticsAction.setEnabled(False)
            self.qmc.statsmaxchrperline = int(settings.value('statsmaxchrperline', self.qmc.statsmaxchrperline))
            self.qmc.showtimeguide = bool(toBool(settings.value('showtimeguide', self.qmc.showtimeguide)))
            settings.endGroup()
            # --- END GROUP ExtrasMoreInfo

            # recent roasts
            if settings.contains('recentRoasts'):
                try:
                    rr = settings.value('recentRoasts', self.recentRoasts)
                    if rr is not None:
                        self.recentRoasts = rr
                    else:
                        self.recentRoasts = []
                except Exception:  # pylint: disable=broad-except
                    pass
            try:
                self.updateNewMenuRecentRoasts()
            except Exception:  # pylint: disable=broad-except
                pass

            # used on startup to reload previous loaded profiles
            if settings.contains('lastLoadedProfile'):
                self.lastLoadedProfile = toString(settings.value('lastLoadedProfile', self.curFile))
            if settings.contains('lastLoadedBackground'):
                self.lastLoadedBackground = toString(settings.value('lastLoadedBackground', self.qmc.backgroundpath))

            # watermark image
            self.logoimgalpha = toFloat(settings.value('logoimgalpha', self.logoimgalpha))
            self.logoimgflag = bool(toBool(settings.value('logoimgflag', self.logoimgflag)))
            self.logofilename = toString(settings.value('logofilename', self.logofilename))

            res = True

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            res = False
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self, QApplication.translate('Error Message', 'Error'),
                                    QApplication.translate('Error Message',
                                                           'Exception:') + '  settingsLoad()  @line ' + str(
                                        getattr(exc_tb, 'tb_lineno', '?')))

        # --------------------------------
        try:
            self.setFonts(redraw=redraw)  # this one triggers a redraw by default to establish the correct fonts
            # only after this the correct aspect ratio of the qmc canvas is set

            if len(self.logofilename) > 0:
                self.qmc.logoloadfile(self.logofilename)

            # set window appearances (style)
            if settings.contains('appearance'):
                try:
                    # on Windows/Linux we use the Fusion style per default which supports the dark mode
                    if not sys.platform.startswith('darwin') and settings.value('appearance') == '':
                        settings.setValue('appearance', 'fusion')
                    available = list(map(str, list(QStyleFactory.keys())))
                    i = [x.lower() for x in available].index(toString(settings.value('appearance')))
                    self.app.setStyle(available[i])
                    self.appearance = available[i].lower()
                except Exception:  # pylint: disable=broad-except
                    pass  # appearance not in list of available once on this platform

            # set dpi
            if filename is not None and settings.contains('dpi'):
                # if filename is None (ie. setting is not explicitly loaded from file, but from default location on app start),
                # the dpi is set on creating the FigureCanvas
                try:
                    if self.dpi != toInt(settings.value('dpi', self.dpi)):
                        self.setdpi(max(40, toInt(settings.value('dpi', self.dpi))), moveWindow=True)
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
            # restore geometry
            if settings.contains('Geometry'):
                self.restoreGeometry(settings.value('Geometry'))
            if not filename:  # only if an external settings file is loaded
                FigureCanvas.updateGeometry(self.qmc)  # @UndefinedVariable

            # update visibility of main event button, extra event buttons and
            self.applyStandardButtonVisibility()

            # self.updateExtraButtonsVisibility()

            # update individual visibility of each buttons
            # self.realignbuttons()

            # swap BT/ET lcds if needed
            if self.qmc.swaplcds != old_swaplcds:
                tmp = QWidget()
                tmp.setLayout(self.LCD2frame.layout())
                self.LCD2frame.setLayout(self.LCD3frame.layout())
                self.LCD3frame.setLayout(tmp.layout())
                if self.largeLCDs_dialog is not None:
                    self.largeLCDs_dialog.reLayout()
            # swap DeltaBT/ET lcds if needed
            if self.qmc.swapdeltalcds != old_swapdeltalcds:
                tmp = QWidget()
                tmp.setLayout(self.LCD4frame.layout())
                self.LCD4frame.setLayout(self.LCD5frame.layout())
                self.LCD5frame.setLayout(tmp.layout())

            self.qmc.clearLCDs()

            # self.updateSlidersVisibility() # update visibility of sliders based on the users preference
            # self.update_minieventline_visibility()
            # self.updateReadingsLCDsVisibility() # update visibility of reading LCD based on the users preference

            if filename is None and self.full_screen_mode_active:
                self.showFullScreen()
                if not (platform.system() == 'Darwin' and self.qmc.locale_str == 'en'):
                    self.fullscreenAction.setChecked(True)

            if filename is None and self.plus_account is not None:
                try:
                    plus.controller.start(self)
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)

            # this one has done here, if it is done on start of the section the slider title colors are not set correctly on Linux and macOS
            # if 'canvas' in self.qmc.palette:
            #     self.updateCanvasColors(checkColors=False)

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            res = False
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self, QApplication.translate('Error Message', 'Error'),
                                    QApplication.translate('Error Message',
                                                           'Exception:') + ' settingsLoad()  @line ' + str(
                                        getattr(exc_tb, 'tb_lineno', '?')))

        return res

    @pyqtSlot()
    def startWebLCDsforced(self) -> None:
        self.startWebLCDs(force=True)

    def startWebLCDs(self, force: bool = False) -> bool:
        try:
            if not self.app.artisanviewerMode and not self.WebLCDs or force:
                from artisanlib.weblcds import WebLCDs
                self.weblcds_server = WebLCDs(
                    self.WebLCDsPort,
                    str(getResourcePath()),
                    ('&nbsp;&nbsp;-.-' if self.qmc.LCDdecimalplaces else '&nbsp;--'),
                    self.lcdpaletteF['timer'],
                    self.lcdpaletteB['timer'],
                    self.lcdpaletteF['bt'],
                    self.lcdpaletteB['bt'],
                    self.lcdpaletteF['et'],
                    self.lcdpaletteB['et'],
                    self.qmc.ETlcd,
                    self.qmc.BTlcd)
                res = self.weblcds_server.startWeb()
                if res:
                    self.WebLCDs = True
                    return True
                self.stopWebLCDs()
                self.WebLCDs = False
                return False
            return False
        except ModuleNotFoundError:
            self.qmc.adderror(QApplication.translate('Error Message', 'Exception: WebLCDs not supported by this build'))
            self.stopWebLCDs()
            self.WebLCDs = False
            return False
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            self.qmc.adderror(
                QApplication.translate('Error Message', 'Could not start WebLCDs. Selected port might be busy.'))
            self.stopWebLCDs()
            self.WebLCDs = False
            return False

    def stopWebLCDs(self) -> None:
        try:
            if self.weblcds_server is not None:
                self.weblcds_server.stopWeb()
            self.weblcds_server = None
            self.WebLCDs = False
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    def applyStandardButtonVisibility(self) -> None:
        if self.eventsbuttonflag:
            self.buttonEVENT.setVisible(True)
        else:
            self.buttonEVENT.setVisible(False)
        # set default button visibility
        for i in range(8):
            self.keyboardButtonList[i].setVisible(bool(self.qmc.buttonvisibility[i]))
            self.keyboardButtonList[i].setSelected(False)

    @staticmethod
    def getColor(line: Any) -> Any:
        c = line.get_color()
        if isinstance(c, (str, tuple)):
            return mpl.colors.rgb2hex(c,
                                      keep_alpha=True)  # pyright:ignore[reportAttributeAccessIssue] # tuple items expected to be of type float
        return c

    def fetchCurveStyles(self) -> None:
        try:
            if self.qmc.l_temp1 is not None:
                ls = self.qmc.l_temp1.get_linestyle()
                if isinstance(ls, str):
                    self.qmc.ETlinestyle = ls
                # hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                # otherwise the drawingstyle cannot be set back to default!
                if self.qmc.ETlinestyle == self.qmc.linestyle_default:
                    self.qmc.ETdrawstyle = self.qmc.l_temp1.get_drawstyle()
                else:
                    self.qmc.ETdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETlinewidth = max(self.qmc.linewidth_min, self.qmc.l_temp1.get_linewidth())
                m = self.qmc.l_temp1.get_marker()
                if isinstance(m, str):
                    self.qmc.ETmarker = m
                self.qmc.ETmarkersize = max(self.qmc.markersize_min, self.qmc.l_temp1.get_markersize())
                self.qmc.palette['et'] = self.getColor(self.qmc.l_temp1)
            if self.qmc.l_temp2 is not None:
                ls = self.qmc.l_temp2.get_linestyle()
                if isinstance(ls, str):
                    self.qmc.BTlinestyle = ls
                # hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTlinestyle == self.qmc.linestyle_default:
                    self.qmc.BTdrawstyle = self.qmc.l_temp2.get_drawstyle()
                else:
                    self.qmc.BTdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTlinewidth = max(self.qmc.linewidth_min, self.qmc.l_temp2.get_linewidth())
                m = self.qmc.l_temp2.get_marker()
                if isinstance(m, str):
                    self.qmc.BTmarker = m
                self.qmc.BTmarkersize = max(self.qmc.markersize_min, self.qmc.l_temp2.get_markersize())
                self.qmc.palette['bt'] = self.getColor(self.qmc.l_temp2)
            if self.qmc.l_delta1 is not None:
                ls = self.qmc.l_delta1.get_linestyle()
                if isinstance(ls, str):
                    self.qmc.ETdeltalinestyle = ls
                # hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.ETdeltadrawstyle = self.qmc.l_delta1.get_drawstyle()
                else:
                    self.qmc.ETdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.ETdeltalinewidth = max(self.qmc.linewidth_min, self.qmc.l_delta1.get_linewidth())
                m = self.qmc.l_delta1.get_marker()
                if isinstance(m, str):
                    self.qmc.ETdeltamarker = m
                self.qmc.ETdeltamarkersize = max(self.qmc.markersize_min, self.qmc.l_delta1.get_markersize())
                self.qmc.palette['deltaet'] = self.getColor(self.qmc.l_delta1)
            if self.qmc.l_delta2 is not None:
                ls = self.qmc.l_delta2.get_linestyle()
                if isinstance(ls, str):
                    self.qmc.BTdeltalinestyle = ls
                # hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.BTdeltadrawstyle = self.qmc.l_delta2.get_drawstyle()
                else:
                    self.qmc.BTdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.BTdeltalinewidth = max(self.qmc.linewidth_min, self.qmc.l_delta2.get_linewidth())
                m = self.qmc.l_delta2.get_marker()
                if isinstance(m, str):
                    self.qmc.BTdeltamarker = m
                self.qmc.BTdeltamarkersize = max(self.qmc.markersize_min, self.qmc.l_delta2.get_markersize())
                self.qmc.palette['deltabt'] = self.getColor(self.qmc.l_delta2)
            if self.qmc.l_back1 is not None:
                ls = self.qmc.l_back1.get_linestyle()
                if isinstance(ls, str):
                    self.qmc.ETbacklinestyle = ls
                # hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.ETbackdrawstyle = self.qmc.l_back1.get_drawstyle()
                else:
                    self.qmc.ETbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.ETbacklinewidth = max(self.qmc.linewidth_min, self.qmc.l_back1.get_linewidth())
                m = self.qmc.l_back1.get_marker()
                if isinstance(m, str):
                    self.qmc.ETbackmarker = m
                self.qmc.ETbackmarkersize = max(self.qmc.markersize_min, self.qmc.l_back1.get_markersize())
                self.qmc.backgroundmetcolor = self.getColor(self.qmc.l_back1)
            if self.qmc.l_back2 is not None:
                ls = self.qmc.l_back2.get_linestyle()
                if isinstance(ls, str):
                    self.qmc.BTbacklinestyle = ls
                # hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.BTbackdrawstyle = self.qmc.l_back2.get_drawstyle()
                else:
                    self.qmc.BTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.BTbacklinewidth = max(self.qmc.linewidth_min, self.qmc.l_back2.get_linewidth())
                m = self.qmc.l_back2.get_marker()
                if isinstance(m, str):
                    self.qmc.BTbackmarker = m
                self.qmc.BTbackmarkersize = max(self.qmc.markersize_min, self.qmc.l_back2.get_markersize())
                self.qmc.backgroundbtcolor = self.getColor(self.qmc.l_back2)
            if self.qmc.l_back3 is not None:
                ls = self.qmc.l_back3.get_linestyle()
                if isinstance(ls, str):
                    self.qmc.XTbacklinestyle = ls
                # hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.XTbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.XTbackdrawstyle = self.qmc.l_back3.get_drawstyle()
                else:
                    self.qmc.XTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.XTbacklinewidth = max(self.qmc.linewidth_min, self.qmc.l_back3.get_linewidth())
                m = self.qmc.l_back3.get_marker()
                if isinstance(m, str):
                    self.qmc.XTbackmarker = m
                self.qmc.XTbackmarkersize = max(self.qmc.markersize_min, self.qmc.l_back3.get_markersize())
                self.qmc.backgroundxtcolor = self.getColor(self.qmc.l_back3)
            if self.qmc.l_back4 is not None:
                ls = self.qmc.l_back4.get_linestyle()
                if isinstance(ls, str):
                    self.qmc.YTbacklinestyle = ls
                # hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.YTbacklinestyle == self.qmc.linestyle_default:
                    self.qmc.YTbackdrawstyle = self.qmc.l_back4.get_drawstyle()
                else:
                    self.qmc.YTbackdrawstyle = self.qmc.drawstyle_default
                self.qmc.YTbacklinewidth = max(self.qmc.linewidth_min, self.qmc.l_back4.get_linewidth())
                m = self.qmc.l_back4.get_marker()
                if isinstance(m, str):
                    self.qmc.YTbackmarker = m
                self.qmc.YTbackmarkersize = max(self.qmc.markersize_min, self.qmc.l_back4.get_markersize())
                self.qmc.backgroundytcolor = self.getColor(self.qmc.l_back4)
            if self.qmc.l_delta1B is not None:
                ls = self.qmc.l_delta1B.get_linestyle()
                if isinstance(ls, str):
                    self.qmc.ETBdeltalinestyle = ls
                # hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.ETBdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.ETBdeltadrawstyle = self.qmc.l_delta1B.get_drawstyle()
                else:
                    self.qmc.ETBdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.ETBdeltalinewidth = max(self.qmc.linewidth_min, self.qmc.l_delta1B.get_linewidth())
                m = self.qmc.l_delta1B.get_marker()
                if isinstance(m, str):
                    self.qmc.ETBdeltamarker = m
                self.qmc.ETBdeltamarkersize = max(self.qmc.markersize_min, self.qmc.l_delta1B.get_markersize())
                self.qmc.backgrounddeltaetcolor = self.getColor(self.qmc.l_delta1B)
            if self.qmc.l_delta2B is not None:
                ls = self.qmc.l_delta2B.get_linestyle()
                if isinstance(ls, str):
                    self.qmc.BTBdeltalinestyle = ls
                # hack: set all drawing styles to default as those can not be edited by the user directly (only via "steps")
                if self.qmc.BTBdeltalinestyle == self.qmc.linestyle_default:
                    self.qmc.BTBdeltadrawstyle = self.qmc.l_delta2B.get_drawstyle()
                else:
                    self.qmc.BTBdeltadrawstyle = self.qmc.drawstyle_default
                self.qmc.BTBdeltalinewidth = max(self.qmc.linewidth_min, self.qmc.l_delta2B.get_linewidth())
                m = self.qmc.l_delta2B.get_marker()
                if isinstance(m, str):
                    self.qmc.BTBdeltamarker = m
                self.qmc.BTBdeltamarkersize = max(self.qmc.markersize_min, self.qmc.l_delta2B.get_markersize())
                self.qmc.backgrounddeltabtcolor = self.getColor(self.qmc.l_delta2B)
            x1 = x2 = 0
            for i in range(len(self.qmc.extradevices)):
                if len(self.extraCurveVisibility1) > i and self.extraCurveVisibility1[i] and len(
                        self.qmc.extratemp1lines) > x1:
                    l1 = self.qmc.extratemp1lines[x1]
                    ls = l1.get_linestyle()
                    if isinstance(ls, str):
                        self.qmc.extralinestyles1[i] = ls
                    if self.qmc.extralinestyles1[i] == self.qmc.linestyle_default:
                        self.qmc.extradrawstyles1[i] = l1.get_drawstyle()
                    else:
                        self.qmc.extradrawstyles1[i] = self.qmc.drawstyle_default
                    self.qmc.extralinewidths1[i] = max(self.qmc.linewidth_min, float(l1.get_linewidth()))
                    m = l1.get_marker()
                    if isinstance(m, str):
                        self.qmc.extramarkers1[i] = m
                    self.qmc.extramarkersizes1[i] = max(self.qmc.markersize_min, l1.get_markersize())
                    self.qmc.extradevicecolor1[i] = self.getColor(l1)
                    self.setLabelColor(self.extraLCDlabel1[i], QColor(self.qmc.extradevicecolor1[i]))
                    self.qmc.extraname1[i] = str(l1.get_label())
                    x1 = x1 + 1
                if len(self.extraCurveVisibility2) > i and self.extraCurveVisibility2[i] and len(
                        self.qmc.extratemp2lines) > x2:
                    l2 = self.qmc.extratemp2lines[x2]
                    ls = l2.get_linestyle()
                    if isinstance(ls, str):
                        self.qmc.extralinestyles2[i] = ls
                    if self.qmc.extralinestyles2[i] == self.qmc.linestyle_default:
                        self.qmc.extradrawstyles2[i] = l2.get_drawstyle()
                    else:
                        self.qmc.extradrawstyles2[i] = self.qmc.drawstyle_default
                    self.qmc.extralinewidths2[i] = max(self.qmc.linewidth_min, float(l2.get_linewidth()))
                    m = l2.get_marker()
                    if isinstance(m, str):
                        self.qmc.extramarkers2[i] = m
                    self.qmc.extramarkersizes2[i] = max(self.qmc.markersize_min, l2.get_markersize())
                    self.qmc.extradevicecolor2[i] = self.getColor(l2)
                    self.setLabelColor(self.extraLCDlabel2[i], QColor(self.qmc.extradevicecolor2[i]))
                    self.qmc.extraname2[i] = str(l2.get_label())
                    x2 = x2 + 1
            if self.qmc.eventsGraphflag in {2, 3, 4}:
                if self.qmc.l_eventtype1dots is not None:
                    m = self.qmc.l_eventtype1dots.get_marker()
                    if isinstance(m, str):
                        self.qmc.EvalueMarker[0] = m
                    self.qmc.EvalueMarkerSize[0] = max(self.qmc.markersize_min,
                                                       self.qmc.l_eventtype1dots.get_markersize())
                    self.qmc.EvalueColor[0] = self.getColor(self.qmc.l_eventtype1dots)
                    self.qmc.Evaluelinethickness[0] = max(self.qmc.linewidth_min,
                                                          self.qmc.l_eventtype1dots.get_linewidth())
                    self.qmc.etypes[0] = str(self.qmc.l_eventtype1dots.get_label())
                if self.qmc.l_eventtype2dots is not None:
                    m = self.qmc.l_eventtype2dots.get_marker()
                    if isinstance(m, str):
                        self.qmc.EvalueMarker[1] = m
                    self.qmc.EvalueMarkerSize[1] = max(self.qmc.markersize_min,
                                                       self.qmc.l_eventtype2dots.get_markersize())
                    self.qmc.EvalueColor[1] = self.getColor(self.qmc.l_eventtype2dots)
                    self.qmc.Evaluelinethickness[1] = max(self.qmc.linewidth_min,
                                                          self.qmc.l_eventtype2dots.get_linewidth())
                    self.qmc.etypes[1] = str(self.qmc.l_eventtype2dots.get_label())
                if self.qmc.l_eventtype3dots is not None:
                    m = self.qmc.l_eventtype3dots.get_marker()
                    if isinstance(m, str):
                        self.qmc.EvalueMarker[2] = m
                    self.qmc.EvalueMarkerSize[2] = max(self.qmc.markersize_min,
                                                       self.qmc.l_eventtype3dots.get_markersize())
                    self.qmc.EvalueColor[2] = self.getColor(self.qmc.l_eventtype3dots)
                    self.qmc.Evaluelinethickness[2] = max(self.qmc.linewidth_min,
                                                          self.qmc.l_eventtype3dots.get_linewidth())
                    self.qmc.etypes[2] = str(self.qmc.l_eventtype3dots.get_label())
                if self.qmc.l_eventtype4dots is not None:
                    m = self.qmc.l_eventtype4dots.get_marker()
                    if isinstance(m, str):
                        self.qmc.EvalueMarker[3] = m
                    self.qmc.EvalueMarkerSize[3] = max(self.qmc.markersize_min,
                                                       self.qmc.l_eventtype4dots.get_markersize())
                    self.qmc.EvalueColor[3] = self.getColor(self.qmc.l_eventtype4dots)
                    self.qmc.Evaluelinethickness[3] = max(self.qmc.linewidth_min,
                                                          self.qmc.l_eventtype4dots.get_linewidth())
                    self.qmc.etypes[3] = str(self.qmc.l_eventtype4dots.get_label())
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' fetchCurveStyles() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

    # Saves the settings when closing application. See the oppposite settingsLoad()
    @pyqtSlot('QCloseEvent')
    def closeEvent(self, event: Optional['QCloseEvent'] = None) -> None:
        if event is not None:
            res = self.closeApp()
            if res:
                event.accept()
            else:
                event.ignore()

    # returns OS name, version and architecture as strings
    # ex: "macOS", "11.6",
    @staticmethod
    @functools.lru_cache(
        maxsize=None)  # we cache the result to avoid re-compuation #for Python >=3.9 can use @functools.cache
    def get_os() -> Tuple[str, str, str]:
        # subprocess above below is problematic in signed builds on macOS 14 especially on AppleSilicon
        #        def get_macOS_version():
        #            # platform.mac_ver() returns 10.16-style version info on BigSur
        #            # and is likely to do so until Python is compiled with the macOS 11 SDK
        #            # which may not happen for a while. And Apple's odd tricks mean that even
        #            # reading /System/Library/CoreServices/SystemVersion.plist is unreliable.
        #            import subprocess
        #            try:
        #                os_version_tuple = subprocess.check_output(
        #                    ('/usr/bin/sw_vers', '-productVersion'),
        #                    env={'SYSTEM_VERSION_COMPAT': '0'}
        #                ).decode('UTF-8').rstrip().split('.')
        #            except subprocess.CalledProcessError:
        #                os_version_tuple = platform.mac_ver()[0].split('.')
        #            os_version_tuple = platform.mac_ver()[0].split('.')
        #            os_version_tuple = os_version_tuple[0:2]
        #            return '.'.join(os_version_tuple)
        # cpuinfo.get_cpu_info().get('brand_raw') hangs on macOS 14 if app is signed (not cpuinfo needs multiprocessing.freeze_support() !)
        #        def get_macOS_arch():
        #            # platform.machine() returns x86_64 on M1 macs running Artisan under Rossetta2
        #            try:
        #                import cpuinfo # type: ignore
        #                manufacturer = cpuinfo.get_cpu_info().get('brand_raw')
        #                return 'm1' if 'm1' in manufacturer.lower() else 'x86_64'
        #            except Exception as e: # pylint: disable=broad-except
        #                return platform.machine()
        try:
            if platform.system().startswith('Darwin'):
                #                return 'macOS', get_macOS_version(), get_macOS_arch()
                return 'macOS', platform.mac_ver()[
                    0], platform.machine()  # reports wrong version on macOS 12 on older Python versions
            if platform.system().startswith('Windows'):
                return 'Windows', platform.release(), platform.machine()
            # we assume Linux
            if os.uname()[4][
               :3] == 'arm':  # type:ignore[unused-ignore,attr-defined] # pylint: disable=no-member # not available on Windows
                return 'RPi', platform.release(), os.uname()[
                    4]  # type:ignore[unused-ignore,attr-defined] # pylint: disable=no-member # not available on Windows
            try:
                lib, version = platform.libc_ver()
                return 'Linux', f'{lib} {version}', platform.machine()
            except Exception:  # pylint: disable=broad-except
                return '', '', ''
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            return '', '', ''

    # settingsSetValue() avoids writing settings unmodified w.r.t. their defaults and is to be used on saving settings on appQuit
    # if read_defaults=False the name/value pair is added in case the name is not in defaults or the value for name in defaults is different
    # else the defaultSettings dictionary is filled if given
    @staticmethod
    def settingsSetValue(settings: QSettings, default_settings: Optional[Dict[str, Any]], name: str, value: Any,
                         read_defaults: bool) -> None:
        item = f'{settings.group()}/{name}'
        if read_defaults:
            # we fill the default_settings dict with the current values
            if default_settings is not None:
                if item in default_settings:
                    _log.error('internal error in settingsSetValue: duplicate settings name: %s', item)
                else:
                    # as value could be a list of lists or a deeply structured dict where just items change,
                    # we need to add a deep copy to our cache here to be able to detect those changes
                    default_settings[item] = copyd.deepcopy(value)
        else:
            # we fill the settings with the current values
            if default_settings is None or item not in default_settings or default_settings[item] != value:
                settings.setValue(name, value)
            if default_settings is not None and settings.contains(name) and item in default_settings and \
                    default_settings[item] == value:
                settings.remove(name)

    # returns True on success and False otherwise
    def closeEventSettings(self, filename: Optional[str] = None) -> bool:
        # save window geometry and position. See QSettings documentation.
        # This information is often stored in the system registry on Windows,
        # and in XML preferences files on Mac OS X. On Unix systems, in the absence of a standard,
        # many applications (including the KDE applications) use INI text files

        if filename is not None and filename:
            # we set the default_settings to None here to force the saving of all settings not only those different to the defaults
            _log.info('export settings to %s', filename)
            return self.saveAllSettings(QSettings(filename, QSettings.Format.IniFormat), None, filename)
        # we hand over the defaultSettings to have only those settings saved that are different from their defaults
        return self.saveAllSettings(QSettings(), self.defaultSettings)

    # if settings are None, the default_settings dict is filled with current values (the default values if called directly after start)
    # if settings are given all values are filled if default_settings are not given or different to the corresponding value in default_settings
    # see the definition of the method settingsSetValue() above
    # returns True on success and False otherwise
    def saveAllSettings(self, settings: QSettings, default_settings: Optional[Dict[str, Any]],
                        filename: Optional[str] = None,
                        read_defaults: bool = False) -> bool:  # pyright:ignore[reportGeneralTypeIssues]
        start_time = libtime.process_time()
        try:
            if filename is None:
                self.settingsSetValue(settings, default_settings, 'fullscreen',
                                      self.full_screen_mode_active or self.isFullScreen(), read_defaults)
                self.settingsSetValue(settings, default_settings, 'plus_account', self.plus_account, read_defaults)
                self.settingsSetValue(settings, default_settings, 'plus_remember_credentials',
                                      self.plus_remember_credentials, read_defaults)
                self.settingsSetValue(settings, default_settings, 'plus_email', self.plus_email, read_defaults)
                self.settingsSetValue(settings, default_settings, 'plus_language', self.plus_language, read_defaults)

            if not read_defaults:  # we don't add those to the cache forcing those settings to be saved always
                # save window geometry if not in fullscreen mode
                if filename is None or not (self.full_screen_mode_active or self.isFullScreen()):
                    self.settingsSetValue(settings, default_settings, 'Geometry', self.saveGeometry(), read_defaults)

                # save screens fingerprint to decide if dialog positions should be remembered on startup
                if not read_defaults:
                    # we always write those settings to the settings file and never cache it
                    self.settingsSetValue(settings, default_settings, 'screens', len(self.app.screens()),
                                          read_defaults)  # number of connected screens (int)
                    mainScreen: Optional[QScreen] = self.app.primaryScreen()
                    if mainScreen is not None:
                        self.settingsSetValue(settings, default_settings, 'mainScreenPixelRatio',
                                              mainScreen.devicePixelRatio(),
                                              read_defaults)  # main screen pixel ratio (float)
                        self.settingsSetValue(settings, default_settings, 'mainScreenWidth', mainScreen.size().width(),
                                              read_defaults)  # main screen width (int)
                        self.settingsSetValue(settings, default_settings, 'mainScreenHeight',
                                              mainScreen.size().height(), read_defaults)  # main screen height (int)

                try:
                    self.settingsSetValue(settings, default_settings, 'DebugLogLevel', debugLogLevelActive(),
                                          read_defaults)
                except Exception:  # pylint: disable=broad-except
                    pass

            # save mode
            if not read_defaults:
                settings.setValue('Mode',
                                  self.qmc.mode)  # 'Mode' is always stored as it is used to discriminate the ViewerSettings (see _settingsCopied)

            if filename is not None and not read_defaults:
                # only add those on exporting settings (those are never read by Artisan)
                # --- BEGIN GROUP System
                settings.beginGroup('System')
                settings.setValue('artisan_version', __version__)
                settings.setValue('artisan_revision', __revision__)
                settings.setValue('artisan_build', __build__)
                os_name, os_version, os_arch = self.get_os()
                settings.setValue('artisan_os', os_name)
                settings.setValue('artisan_os_version', os_version)
                settings.setValue('artisan_os_arch', os_arch)
                settings.endGroup()
            # --- END GROUP System

            # --- BEGIN GROUP Device
            # save device
            settings.beginGroup('Device')
            self.settingsSetValue(settings, default_settings, 'device_logging', self.qmc.device_logging, read_defaults)
            self.settingsSetValue(settings, default_settings, 'id', self.qmc.device, read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1048_types', self.qmc.phidget1048_types,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1048_async', self.qmc.phidget1048_async,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1048_changeTriggers',
                                  self.qmc.phidget1048_changeTriggers, read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1048_dataRate', self.qmc.phidget1048_dataRate,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1046_async', self.qmc.phidget1046_async,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1046_gain', self.qmc.phidget1046_gain,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1046_formula', self.qmc.phidget1046_formula,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1046_dataRate', self.qmc.phidget1046_dataRate,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1045_async', self.qmc.phidget1045_async,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1045_changeTrigger',
                                  self.qmc.phidget1045_changeTrigger, read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1045_emissivity', self.qmc.phidget1045_emissivity,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1045_dataRate', self.qmc.phidget1045_dataRate,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1200_formula', self.qmc.phidget1200_formula,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1200_wire', self.qmc.phidget1200_wire,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1200_async', self.qmc.phidget1200_async,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1200_changeTrigger',
                                  self.qmc.phidget1200_changeTrigger, read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1200_dataRate', self.qmc.phidget1200_dataRate,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1200_2_formula', self.qmc.phidget1200_2_formula,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1200_2_wire', self.qmc.phidget1200_2_wire,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1200_2_async', self.qmc.phidget1200_2_async,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1200_2_changeTrigger',
                                  self.qmc.phidget1200_2_changeTrigger, read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1200_2_dataRate', self.qmc.phidget1200_2_dataRate,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidgetDAQ1400_powerSupply',
                                  self.qmc.phidgetDAQ1400_powerSupply, read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidgetDAQ1400_inputMode',
                                  self.qmc.phidgetDAQ1400_inputMode, read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidgetRemoteFlag', self.qmc.phidgetRemoteFlag,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidgetServerID', self.qmc.phidgetServerID,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidgetPassword', self.qmc.phidgetPassword,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidgetPort', self.qmc.phidgetPort, read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidgetRemoteOnlyFlag', self.qmc.phidgetRemoteOnlyFlag,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1018_async', self.qmc.phidget1018_async,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1018_ratio', self.qmc.phidget1018_ratio,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1018_dataRates', self.qmc.phidget1018_dataRates,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidget1018_changeTriggers',
                                  self.qmc.phidget1018_changeTriggers, read_defaults)
            self.settingsSetValue(settings, default_settings, 'phidgetVCP100x_voltageRanges',
                                  self.qmc.phidgetVCP100x_voltageRanges, read_defaults)
            self.settingsSetValue(settings, default_settings, 'controlETpid', self.ser.controlETpid, read_defaults)
            self.settingsSetValue(settings, default_settings, 'readBTpid', self.ser.readBTpid, read_defaults)
            self.settingsSetValue(settings, default_settings, 'arduinoETChannel', self.ser.arduinoETChannel,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'arduinoBTChannel', self.ser.arduinoBTChannel,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'arduinoATChannel', self.ser.arduinoATChannel,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ArduinoFILT', self.ser.ArduinoFILT, read_defaults)
            self.settingsSetValue(settings, default_settings, 'useModbusPort', self.ser.useModbusPort, read_defaults)
            self.settingsSetValue(settings, default_settings, 'showFujiLCDs', self.ser.showFujiLCDs, read_defaults)
            self.settingsSetValue(settings, default_settings, 'PIDbuttonflag', self.qmc.PIDbuttonflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'Controlbuttonflag', self.qmc.Controlbuttonflag,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'yoctoRemoteFlag', self.qmc.yoctoRemoteFlag,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'yoctoServerID', self.qmc.yoctoServerID, read_defaults)
            self.settingsSetValue(settings, default_settings, 'YOCTO_emissivity', self.qmc.YOCTO_emissivity,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'YOCTO_async', self.qmc.YOCTO_async, read_defaults)
            self.settingsSetValue(settings, default_settings, 'YOCTO_dataRate', self.qmc.YOCTO_dataRate, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ambient_temperature_device',
                                  self.qmc.ambient_temperature_device, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ambient_humidity_device',
                                  self.qmc.ambient_humidity_device, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ambient_pressure_device',
                                  self.qmc.ambient_pressure_device, read_defaults)
            self.settingsSetValue(settings, default_settings, 'elevation', self.qmc.elevation, read_defaults)
            self.settingsSetValue(settings, default_settings, 'santokerHost', self.santokerHost, read_defaults)
            self.settingsSetValue(settings, default_settings, 'santokerPort', self.santokerPort, read_defaults)
            self.settingsSetValue(settings, default_settings, 'santokerSerial', self.santokerSerial, read_defaults)
            self.settingsSetValue(settings, default_settings, 'kaleidoHost', self.kaleidoHost, read_defaults)
            self.settingsSetValue(settings, default_settings, 'kaleidoPort', self.kaleidoPort, read_defaults)
            self.settingsSetValue(settings, default_settings, 'kaleidoSerial', self.kaleidoSerial, read_defaults)
            self.settingsSetValue(settings, default_settings, 'kaleidoPID', self.kaleidoPID, read_defaults)
            settings.endGroup()
            # --- END GROUP System

            self.settingsSetValue(settings, default_settings, 'fmt_data_RoR', self.qmc.fmt_data_RoR, read_defaults)
            self.settingsSetValue(settings, default_settings, 'fmt_data_ON', self.qmc.fmt_data_ON, read_defaults)
            self.settingsSetValue(settings, default_settings, 'fmt_data_curve', self.qmc.fmt_data_curve, read_defaults)
            self.settingsSetValue(settings, default_settings, 'detectBackgroundEventTime',
                                  self.qmc.detectBackgroundEventTime, read_defaults)
            self.settingsSetValue(settings, default_settings, 'backgroundReproduce', self.qmc.backgroundReproduce,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'backgroundReproduceBeep',
                                  self.qmc.backgroundReproduceBeep, read_defaults)
            self.settingsSetValue(settings, default_settings, 'backgroundPlaybackEvents',
                                  self.qmc.backgroundPlaybackEvents, read_defaults)
            self.settingsSetValue(settings, default_settings, 'backgroundPlaybackDROP', self.qmc.backgroundPlaybackDROP,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'replayType', self.qmc.replayType, read_defaults)
            self.settingsSetValue(settings, default_settings, 'specialeventplaybackaid',
                                  self.qmc.specialeventplaybackaid, read_defaults)
            self.settingsSetValue(settings, default_settings, 'specialeventplayback', self.qmc.specialeventplayback,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'Phases', self.qmc.phases, read_defaults)
            # save phasesbuttonflag
            self.settingsSetValue(settings, default_settings, 'phasesbuttonflag', self.qmc.phasesbuttonflag,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phasesfromBackgroundflag',
                                  self.qmc.phasesfromBackgroundflag, read_defaults)
            # save phases watermarks flag
            self.settingsSetValue(settings, default_settings, 'watermarks', self.qmc.watermarksflag, read_defaults)
            # save phases LCDs on recording flag
            self.settingsSetValue(settings, default_settings, 'phasesLCDs', self.qmc.phasesLCDflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'phasesLCDmode', self.qmc.phasesLCDmode, read_defaults)
            self.settingsSetValue(settings, default_settings, 'phasesLCDmode_l', self.qmc.phasesLCDmode_l,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'phasesLCDmode_all', self.qmc.phasesLCDmode_all,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'step100temp', self.qmc.step100temp, read_defaults)
            # phase triggered DRY and FCs
            self.settingsSetValue(settings, default_settings, 'autoDry', self.qmc.autoDRYflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autoFCs', self.qmc.autoFCsFlag, read_defaults)
            # save statistics
            self.settingsSetValue(settings, default_settings, 'Statistics', self.qmc.statisticsflags, read_defaults)
            self.settingsSetValue(settings, default_settings, 'AnalysisResultsLoc', list(self.qmc.analysisresultsloc),
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'SegmentResultsLoc', list(self.qmc.segmentresultsloc),
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'analysisstartchoice', self.qmc.analysisstartchoice,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'analysisoffset', self.qmc.analysisoffset, read_defaults)
            self.settingsSetValue(settings, default_settings, 'curvefitstartchoice', self.qmc.curvefitstartchoice,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'curvefitoffset', self.qmc.curvefitoffset, read_defaults)
            self.settingsSetValue(settings, default_settings, 'segmentsamplesthreshold',
                                  self.qmc.segmentsamplesthreshold, read_defaults)
            self.settingsSetValue(settings, default_settings, 'segmentdeltathreshold', self.qmc.segmentdeltathreshold,
                                  read_defaults)
            # projection
            self.settingsSetValue(settings, default_settings, 'ETprojectFlag', self.qmc.ETprojectFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTprojectFlag', self.qmc.BTprojectFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'projectDeltaFlag', self.qmc.projectDeltaFlag,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'projectionmode', self.qmc.projectionmode, read_defaults)
            # save AUC
            self.settingsSetValue(settings, default_settings, 'AUCbegin', self.qmc.AUCbegin, read_defaults)
            self.settingsSetValue(settings, default_settings, 'AUCbase', self.qmc.AUCbase, read_defaults)
            self.settingsSetValue(settings, default_settings, 'AUCbaseFlag', self.qmc.AUCbaseFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'AUCtarget', self.qmc.AUCtarget, read_defaults)
            self.settingsSetValue(settings, default_settings, 'AUCtargetFlag', self.qmc.AUCtargetFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'AUCguideFlag', self.qmc.AUCguideFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'AUClcdFlag', self.qmc.AUClcdFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'AUCLCDmode', self.qmc.AUCLCDmode, read_defaults)
            self.settingsSetValue(settings, default_settings, 'AUCshowFlag', self.qmc.AUCshowFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'keyboardmoveflag', self.keyboardmoveflag, read_defaults)

            # --- BEGIN GROUP events
            # save Events settings
            settings.beginGroup('events')
            self.settingsSetValue(settings, default_settings, 'eventsbuttonflag', self.eventsbuttonflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'minieventsflags', self.minieventsflags, read_defaults)
            self.settingsSetValue(settings, default_settings, 'eventsGraphflag', self.qmc.eventsGraphflag,
                                  read_defaults)
            # we only store etype names if they have been modified by the user to allow automatic translations otherwise
            if (read_defaults or (self.qmc.etypes[0] != self.qmc.etypesdefault[0]) or
                    (self.qmc.etypes[1] != self.qmc.etypesdefault[1]) or
                    (self.qmc.etypes[2] != self.qmc.etypesdefault[2]) or
                    (self.qmc.etypes[3] != self.qmc.etypesdefault[3])):
                etypes = self.qmc.etypes[:]
                if not read_defaults:
                    for i, _ in enumerate(self.qmc.etypes):
                        if self.qmc.etypes[i] == self.qmc.etypesdefault[i]:
                            etypes[
                                i] = ''  # we save empty strings for default event type names to ensure correct translation on re-loading those settings
                self.settingsSetValue(settings, default_settings, 'etypes', etypes, read_defaults)
            else:
                settings.remove('etypes')
            self.settingsSetValue(settings, default_settings, 'eventsshowflag', self.qmc.eventsshowflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'clampEvents', self.qmc.clampEvents, read_defaults)
            self.settingsSetValue(settings, default_settings, 'renderEventsDescr', self.qmc.renderEventsDescr,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'eventslabelschars', self.qmc.eventslabelschars,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'annotationsflag', self.qmc.annotationsflag,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'showeventsonbt', self.qmc.showeventsonbt, read_defaults)
            self.settingsSetValue(settings, default_settings, 'showEtypes', self.qmc.showEtypes, read_defaults)
            self.settingsSetValue(settings, default_settings, 'chargeTimer', self.qmc.chargeTimerFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'chargeTimerPeriod', self.qmc.chargeTimerPeriod,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'autoCharge', self.qmc.autoChargeFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autoDrop', self.qmc.autoDropFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autoChargeMode', self.qmc.autoChargeMode, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autoDropMode', self.qmc.autoDropMode, read_defaults)
            self.settingsSetValue(settings, default_settings, 'markTP', self.qmc.markTPflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'EvalueColor', self.qmc.EvalueColor, read_defaults)
            self.settingsSetValue(settings, default_settings, 'EvalueTextColor', self.qmc.EvalueTextColor,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'EvalueMarker', self.qmc.EvalueMarker, read_defaults)
            self.settingsSetValue(settings, default_settings, 'Evaluelinethickness', self.qmc.Evaluelinethickness,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'EvalueMarkerSize', self.qmc.EvalueMarkerSize,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'Evaluealpha', self.qmc.Evaluealpha, read_defaults)
            self.settingsSetValue(settings, default_settings, 'specialeventannotations',
                                  self.qmc.specialeventannotations, read_defaults)
            self.settingsSetValue(settings, default_settings, 'specialeventannovisibilities',
                                  self.qmc.specialeventannovisibilities, read_defaults)
            self.settingsSetValue(settings, default_settings, 'overlappct', self.qmc.overlappct, read_defaults)
            settings.endGroup()
            # --- END GROUP events

            # save ambient temperature source
            self.settingsSetValue(settings, default_settings, 'AmbientTempSource', self.qmc.ambientTempSource,
                                  read_defaults)
            # save delay (sampling interval)
            self.settingsSetValue(settings, default_settings, 'Delay', self.qmc.delay, read_defaults)
            # save keepON flag
            self.settingsSetValue(settings, default_settings, 'KeepON', self.qmc.flagKeepON, read_defaults)
            self.settingsSetValue(settings, default_settings, 'flagOpenCompleted', self.qmc.flagOpenCompleted,
                                  read_defaults)
            # save extra event sampling interval
            self.settingsSetValue(settings, default_settings, 'ExtraEventSamplingDelay',
                                  self.qmc.extra_event_sampling_delay, read_defaults)
            # save colors
            self.settingsSetValue(settings, default_settings, 'Colors', self.qmc.palette, read_defaults)
            self.settingsSetValue(settings, default_settings, 'Alphas', self.qmc.alpha, read_defaults)
            self.settingsSetValue(settings, default_settings, 'LCDColors', self.lcdpaletteB, read_defaults)
            self.settingsSetValue(settings, default_settings, 'LEDColors', self.lcdpaletteF, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETBColor', self.qmc.backgroundmetcolor, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTBColor', self.qmc.backgroundbtcolor, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETBdeltaColor', self.qmc.backgrounddeltaetcolor,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTBdeltaColor', self.qmc.backgrounddeltabtcolor,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BackgroundAlpha', self.qmc.backgroundalpha,
                                  read_defaults)
            # save readings LCDs status flags
            self.settingsSetValue(settings, default_settings, 'readingslcdsflags', self.readingslcdsflags,
                                  read_defaults)
            # save flavors
            self.settingsSetValue(settings, default_settings, 'Flavors', self.qmc.flavorlabels, read_defaults)
            self.settingsSetValue(settings, default_settings, 'flavorstartangle', self.qmc.flavorstartangle,
                                  read_defaults)
            # save roast color system
            self.settingsSetValue(settings, default_settings, 'colorsystem', self.qmc.color_system_idx, read_defaults)
            # watermark image

            self.settingsSetValue(settings, default_settings, 'logofilename', self.logofilename, read_defaults)
            self.settingsSetValue(settings, default_settings, 'logoimgalpha', self.logoimgalpha, read_defaults)
            self.settingsSetValue(settings, default_settings, 'logoimgflag', self.logoimgflag, read_defaults)

            # --- BEGIN GROUP Tare
            settings.beginGroup('Tare')
            self.settingsSetValue(settings, default_settings, 'names', self.qmc.container_names, read_defaults)
            self.settingsSetValue(settings, default_settings, 'weights', self.qmc.container_weights, read_defaults)
            self.settingsSetValue(settings, default_settings, 'idx', self.qmc.container_idx, read_defaults)
            settings.endGroup()
            # --- END GROUP Tare

            # --- BEGIN GROUP SerialPort
            # save serial port
            settings.beginGroup('SerialPort')
            self.settingsSetValue(settings, default_settings, 'comport', self.ser.comport, read_defaults)
            self.settingsSetValue(settings, default_settings, 'baudrate', self.ser.baudrate, read_defaults)
            self.settingsSetValue(settings, default_settings, 'bytesize', self.ser.bytesize, read_defaults)
            self.settingsSetValue(settings, default_settings, 'stopbits', self.ser.stopbits, read_defaults)
            self.settingsSetValue(settings, default_settings, 'parity', self.ser.parity, read_defaults)
            self.settingsSetValue(settings, default_settings, 'timeout', self.ser.timeout, read_defaults)
            settings.endGroup()
            # --- END GROUP SerialPort

            # --- BEGIN GROUP WebSocket
            # save WebSocket port
            settings.beginGroup('WebSocket')
            self.settingsSetValue(settings, default_settings, 'host', self.ws.host, read_defaults)
            self.settingsSetValue(settings, default_settings, 'port', self.ws.port, read_defaults)
            self.settingsSetValue(settings, default_settings, 'path', self.ws.path, read_defaults)
            self.settingsSetValue(settings, default_settings, 'machineID', self.ws.machineID, read_defaults)
            self.settingsSetValue(settings, default_settings, 'connect_timeout', self.ws.connect_timeout, read_defaults)
            self.settingsSetValue(settings, default_settings, 'request_timeout', self.ws.request_timeout, read_defaults)
            self.settingsSetValue(settings, default_settings, 'reconnect_interval', self.ws.reconnect_interval,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'id_node', self.ws.id_node, read_defaults)
            self.settingsSetValue(settings, default_settings, 'machine_node', self.ws.machine_node, read_defaults)
            self.settingsSetValue(settings, default_settings, 'command_node', self.ws.command_node, read_defaults)
            self.settingsSetValue(settings, default_settings, 'data_node', self.ws.data_node, read_defaults)
            self.settingsSetValue(settings, default_settings, 'pushMessage_node', self.ws.pushMessage_node,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'request_data_command', self.ws.request_data_command,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'charge_message', self.ws.charge_message, read_defaults)
            self.settingsSetValue(settings, default_settings, 'drop_message', self.ws.drop_message, read_defaults)
            self.settingsSetValue(settings, default_settings, 'STARTonCHARGE', self.ws.STARTonCHARGE, read_defaults)
            self.settingsSetValue(settings, default_settings, 'OFFonDROP', self.ws.OFFonDROP, read_defaults)
            self.settingsSetValue(settings, default_settings, 'addEvent_message', self.ws.addEvent_message,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'event_node', self.ws.event_node, read_defaults)
            self.settingsSetValue(settings, default_settings, 'DRY_node', self.ws.DRY_node, read_defaults)
            self.settingsSetValue(settings, default_settings, 'FCs_node', self.ws.FCs_node, read_defaults)
            self.settingsSetValue(settings, default_settings, 'FCe_node', self.ws.FCe_node, read_defaults)
            self.settingsSetValue(settings, default_settings, 'SCs_node', self.ws.SCs_node, read_defaults)
            self.settingsSetValue(settings, default_settings, 'SCe_node', self.ws.SCe_node, read_defaults)
            self.settingsSetValue(settings, default_settings, 'channel_requests', self.ws.channel_requests,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'channel_nodes', self.ws.channel_nodes, read_defaults)
            self.settingsSetValue(settings, default_settings, 'channel_modes', self.ws.channel_modes, read_defaults)
            settings.endGroup()
            # --- END GROUP WebSocket

            # --- BEGIN GROUP S7
            # save s7 port
            settings.beginGroup('S7')
            self.settingsSetValue(settings, default_settings, 'area', self.s7.area, read_defaults)
            self.settingsSetValue(settings, default_settings, 'db_nr', self.s7.db_nr, read_defaults)
            self.settingsSetValue(settings, default_settings, 'start', self.s7.start, read_defaults)
            self.settingsSetValue(settings, default_settings, 'type', self.s7.type, read_defaults)
            self.settingsSetValue(settings, default_settings, 'mode', self.s7.mode, read_defaults)
            self.settingsSetValue(settings, default_settings, 'div', self.s7.div, read_defaults)
            self.settingsSetValue(settings, default_settings, 'host', self.s7.host, read_defaults)
            self.settingsSetValue(settings, default_settings, 'port', self.s7.port, read_defaults)
            self.settingsSetValue(settings, default_settings, 'rack', self.s7.rack, read_defaults)
            self.settingsSetValue(settings, default_settings, 'slot', self.s7.slot, read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_area', self.s7.PID_area, read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_db_nr', self.s7.PID_db_nr, read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_SV_register', self.s7.PID_SV_register, read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_p_register', self.s7.PID_p_register, read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_i_register', self.s7.PID_i_register, read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_d_register', self.s7.PID_d_register, read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_OFF_action', self.s7.PID_OFF_action, read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_ON_action', self.s7.PID_ON_action, read_defaults)
            self.settingsSetValue(settings, default_settings, 'PIDmultiplier', self.s7.PIDmultiplier, read_defaults)
            self.settingsSetValue(settings, default_settings, 'SVtype', self.s7.SVtype, read_defaults)
            self.settingsSetValue(settings, default_settings, 'SVmultiplier', self.s7.SVmultiplier, read_defaults)
            self.settingsSetValue(settings, default_settings, 'optimizer', self.s7.optimizer, read_defaults)
            self.settingsSetValue(settings, default_settings, 'fetch_max_blocks', self.s7.fetch_max_blocks,
                                  read_defaults)
            settings.endGroup()
            # --- END GROUP S7

            # --- BEGIN GROUP Modbus
            # save modbus port
            settings.beginGroup('Modbus')
            self.settingsSetValue(settings, default_settings, 'comport', self.modbus.comport, read_defaults)
            self.settingsSetValue(settings, default_settings, 'baudrate', self.modbus.baudrate, read_defaults)
            self.settingsSetValue(settings, default_settings, 'bytesize', self.modbus.bytesize, read_defaults)
            self.settingsSetValue(settings, default_settings, 'stopbits', self.modbus.stopbits, read_defaults)
            self.settingsSetValue(settings, default_settings, 'parity', self.modbus.parity, read_defaults)
            self.settingsSetValue(settings, default_settings, 'timeout', self.modbus.timeout, read_defaults)
            self.settingsSetValue(settings, default_settings, 'modbus_serial_extra_read_delay',
                                  self.modbus.modbus_serial_extra_read_delay, read_defaults)
            self.settingsSetValue(settings, default_settings, 'serial_readRetries', self.modbus.serial_readRetries,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'IP_timeout', self.modbus.IP_timeout, read_defaults)
            self.settingsSetValue(settings, default_settings, 'IP_retries', self.modbus.IP_retries, read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_slave_ID', self.modbus.PID_slave_ID, read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_SV_register', self.modbus.PID_SV_register,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_p_register', self.modbus.PID_p_register,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_i_register', self.modbus.PID_i_register,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_d_register', self.modbus.PID_d_register,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_OFF_action', self.modbus.PID_OFF_action,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'PID_ON_action', self.modbus.PID_ON_action, read_defaults)
            for i in range(self.modbus.channels):
                self.settingsSetValue(settings, default_settings, f'input{i + 1}slave', self.modbus.inputSlaves[i],
                                      read_defaults)
                self.settingsSetValue(settings, default_settings, f'input{i + 1}register',
                                      self.modbus.inputRegisters[i], read_defaults)
                self.settingsSetValue(settings, default_settings, f'input{i + 1}float', self.modbus.inputFloats[i],
                                      read_defaults)
                self.settingsSetValue(settings, default_settings, f'input{i + 1}bcd', self.modbus.inputBCDs[i],
                                      read_defaults)
                self.settingsSetValue(settings, default_settings, f'input{i + 1}code', self.modbus.inputCodes[i],
                                      read_defaults)
                self.settingsSetValue(settings, default_settings, f'input{i + 1}div', self.modbus.inputDivs[i],
                                      read_defaults)
                self.settingsSetValue(settings, default_settings, f'input{i + 1}mode', self.modbus.inputModes[i],
                                      read_defaults)
                self.settingsSetValue(settings, default_settings, f'input{i + 1}FloatsAsInt',
                                      self.modbus.inputFloatsAsInt[i], read_defaults)
                self.settingsSetValue(settings, default_settings, f'input{i + 1}BCDsAsInt',
                                      self.modbus.inputBCDsAsInt[i], read_defaults)
                self.settingsSetValue(settings, default_settings, f'input{i + 1}Signed', self.modbus.inputSigned[i],
                                      read_defaults)
            self.settingsSetValue(settings, default_settings, 'PIDmultiplier', self.modbus.PIDmultiplier, read_defaults)
            self.settingsSetValue(settings, default_settings, 'SVmultiplier', self.modbus.SVmultiplier, read_defaults)
            self.settingsSetValue(settings, default_settings, 'littleEndianFloats', self.modbus.byteorderLittle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'wordorderLittle', self.modbus.wordorderLittle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'optimizer', self.modbus.optimizer, read_defaults)
            self.settingsSetValue(settings, default_settings, 'fetch_max_blocks', self.modbus.fetch_max_blocks,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'type', self.modbus.type, read_defaults)
            self.settingsSetValue(settings, default_settings, 'host', self.modbus.host, read_defaults)
            self.settingsSetValue(settings, default_settings, 'port', self.modbus.port, read_defaults)
            self.settingsSetValue(settings, default_settings, 'reset_socket', self.modbus.reset_socket, read_defaults)
            settings.endGroup()
            # --- END GROUP Modbus

            # --- BEGIN GROUP Scale
            # save scale port
            settings.beginGroup('Scale')
            self.settingsSetValue(settings, default_settings, 'device', self.scale.device, read_defaults)
            self.settingsSetValue(settings, default_settings, 'comport', self.scale.comport, read_defaults)
            self.settingsSetValue(settings, default_settings, 'baudrate', self.scale.baudrate, read_defaults)
            self.settingsSetValue(settings, default_settings, 'bytesize', self.scale.bytesize, read_defaults)
            self.settingsSetValue(settings, default_settings, 'stopbits', self.scale.stopbits, read_defaults)
            self.settingsSetValue(settings, default_settings, 'parity', self.scale.parity, read_defaults)
            self.settingsSetValue(settings, default_settings, 'timeout', self.scale.timeout, read_defaults)
            settings.endGroup()
            # --- END GROUP Scale

            # --- BEGIN GROUP Color
            # save color port
            settings.beginGroup('Color')
            self.settingsSetValue(settings, default_settings, 'device', self.color.device, read_defaults)
            self.settingsSetValue(settings, default_settings, 'comport', self.color.comport, read_defaults)
            self.settingsSetValue(settings, default_settings, 'baudrate', self.color.baudrate, read_defaults)
            self.settingsSetValue(settings, default_settings, 'bytesize', self.color.bytesize, read_defaults)
            self.settingsSetValue(settings, default_settings, 'stopbits', self.color.stopbits, read_defaults)
            self.settingsSetValue(settings, default_settings, 'parity', self.color.parity, read_defaults)
            self.settingsSetValue(settings, default_settings, 'timeout', self.color.timeout, read_defaults)
            settings.endGroup()
            # --- END GROUP Color

            # --- BEGIN GROUP ArduinoPID
            # save pid settings (only key and value[0])
            settings.beginGroup('ArduinoPID')
            self.settingsSetValue(settings, default_settings, 'pidOnCHARGE', self.pidcontrol.pidOnCHARGE, read_defaults)
            self.settingsSetValue(settings, default_settings, 'createEvents', self.pidcontrol.createEvents,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'loadRampSoakFromProfile',
                                  self.pidcontrol.loadRampSoakFromProfile, read_defaults)
            self.settingsSetValue(settings, default_settings, 'loadRampSoakFromBackground',
                                  self.pidcontrol.loadRampSoakFromBackground, read_defaults)
            self.settingsSetValue(settings, default_settings, 'svLabel', self.pidcontrol.svLabel, read_defaults)
            self.settingsSetValue(settings, default_settings, 'svValues', self.pidcontrol.svValues, read_defaults)
            self.settingsSetValue(settings, default_settings, 'svRamps', self.pidcontrol.svRamps, read_defaults)
            self.settingsSetValue(settings, default_settings, 'svSoaks', self.pidcontrol.svSoaks, read_defaults)
            self.settingsSetValue(settings, default_settings, 'svActions', self.pidcontrol.svActions, read_defaults)
            self.settingsSetValue(settings, default_settings, 'svBeeps', self.pidcontrol.svBeeps, read_defaults)
            self.settingsSetValue(settings, default_settings, 'svDescriptions', self.pidcontrol.svDescriptions,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'svSlider', self.pidcontrol.svSlider, read_defaults)
            self.settingsSetValue(settings, default_settings, 'svButtons', self.pidcontrol.svButtons, read_defaults)
            self.settingsSetValue(settings, default_settings, 'svMode', self.pidcontrol.svMode, read_defaults)
            self.settingsSetValue(settings, default_settings, 'svLookahead', self.pidcontrol.svLookahead, read_defaults)
            self.settingsSetValue(settings, default_settings, 'dutySteps', self.pidcontrol.dutySteps, read_defaults)
            self.settingsSetValue(settings, default_settings, 'svSliderMin', self.pidcontrol.svSliderMin, read_defaults)
            self.settingsSetValue(settings, default_settings, 'svSliderMax', self.pidcontrol.svSliderMax, read_defaults)
            sv = max(min(self.pidcontrol.svValue, self.pidcontrol.svSliderMax), self.pidcontrol.svSliderMin)
            self.settingsSetValue(settings, default_settings, 'svValue', sv, read_defaults)
            self.settingsSetValue(settings, default_settings, 'dutyMin', self.pidcontrol.dutyMin, read_defaults)
            self.settingsSetValue(settings, default_settings, 'dutyMax', self.pidcontrol.dutyMax, read_defaults)
            self.settingsSetValue(settings, default_settings, 'positiveTargetRangeLimit',
                                  self.pidcontrol.positiveTargetRangeLimit, read_defaults)
            self.settingsSetValue(settings, default_settings, 'positiveTargetMin', self.pidcontrol.positiveTargetMin,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'positiveTargetMax', self.pidcontrol.positiveTargetMax,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'negativeTargetRangeLimit',
                                  self.pidcontrol.negativeTargetRangeLimit, read_defaults)
            self.settingsSetValue(settings, default_settings, 'negativeTargetMin', self.pidcontrol.negativeTargetMin,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'negativeTargetMax', self.pidcontrol.negativeTargetMax,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'derivative_filter', self.pidcontrol.derivative_filter,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'pidKp', self.pidcontrol.pidKp, read_defaults)
            self.settingsSetValue(settings, default_settings, 'pidKi', self.pidcontrol.pidKi, read_defaults)
            self.settingsSetValue(settings, default_settings, 'pidKd', self.pidcontrol.pidKd, read_defaults)
            self.settingsSetValue(settings, default_settings, 'pidSource', self.pidcontrol.pidSource, read_defaults)
            self.settingsSetValue(settings, default_settings, 'pidCycle', self.pidcontrol.pidCycle, read_defaults)
            self.settingsSetValue(settings, default_settings, 'pidPositiveTarget', self.pidcontrol.pidPositiveTarget,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'pidNegativeTarget', self.pidcontrol.pidNegativeTarget,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'invertControl', self.pidcontrol.invertControl,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'pOnE', self.pidcontrol.pOnE, read_defaults)
            for n in range(self.pidcontrol.RSLen):
                self.settingsSetValue(settings, default_settings, 'RS_svLabel' + str(n), self.pidcontrol.RS_svLabels[n],
                                      read_defaults)
                self.settingsSetValue(settings, default_settings, 'RS_svValues' + str(n),
                                      self.pidcontrol.RS_svValues[n], read_defaults)
                self.settingsSetValue(settings, default_settings, 'RS_svRamps' + str(n), self.pidcontrol.RS_svRamps[n],
                                      read_defaults)
                self.settingsSetValue(settings, default_settings, 'RS_svSoaks' + str(n), self.pidcontrol.RS_svSoaks[n],
                                      read_defaults)
                self.settingsSetValue(settings, default_settings, 'RS_svActions' + str(n),
                                      self.pidcontrol.RS_svActions[n], read_defaults)
                self.settingsSetValue(settings, default_settings, 'RS_svBeeps' + str(n), self.pidcontrol.RS_svBeeps[n],
                                      read_defaults)
                self.settingsSetValue(settings, default_settings, 'RS_svDescriptions' + str(n),
                                      self.pidcontrol.RS_svDescriptions[n], read_defaults)
            settings.endGroup()
            # --- END GROUP ArduinoPID

            # --- BEGIN GROUP PXR
            settings.beginGroup('PXR')
            for k in list(self.fujipid.PXR.keys()):
                self.settingsSetValue(settings, default_settings, k, self.fujipid.PXR[k][0], read_defaults)
            settings.endGroup()
            # --- END GROUP PXR

            # --- BEGIN GROUP PXG4
            settings.beginGroup('PXG4')
            for k in list(self.fujipid.PXG4.keys()):
                self.settingsSetValue(settings, default_settings, k, self.fujipid.PXG4[k][0], read_defaults)
            self.settingsSetValue(settings, default_settings, 'followBackground', self.fujipid.followBackground,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'lookahead', self.fujipid.lookahead, read_defaults)
            settings.endGroup()
            # --- END GROUP PXG4

            # --- BEGIN GROUP deltaDTA
            settings.beginGroup('deltaDTA')
            for k in list(self.dtapid.dtamem.keys()):
                self.settingsSetValue(settings, default_settings, k, self.dtapid.dtamem[k][0], read_defaults)
            settings.endGroup()
            # --- END GROUP deltaDTA

            self.settingsSetValue(settings, default_settings, 'filterDropOuts', self.qmc.filterDropOuts, read_defaults)
            self.settingsSetValue(settings, default_settings, 'dropSpikes', self.qmc.dropSpikes, read_defaults)
            self.settingsSetValue(settings, default_settings, 'dropDuplicates', self.qmc.dropDuplicates, read_defaults)
            self.settingsSetValue(settings, default_settings, 'dropDuplicatesLimit', self.qmc.dropDuplicatesLimit,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'optimalSmoothing', self.qmc.optimalSmoothing,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'polyfitRoRcalc', self.qmc.polyfitRoRcalc, read_defaults)
            self.settingsSetValue(settings, default_settings, 'swapETBT', self.qmc.swapETBT, read_defaults)
            self.settingsSetValue(settings, default_settings, 'minmaxLimits', self.qmc.minmaxLimits, read_defaults)
            self.settingsSetValue(settings, default_settings, 'minLimit', self.qmc.filterDropOut_tmin, read_defaults)
            self.settingsSetValue(settings, default_settings, 'maxLimit', self.qmc.filterDropOut_tmax, read_defaults)
            self.settingsSetValue(settings, default_settings, 'foregroundShowFullflag', self.qmc.foregroundShowFullflag,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'interpolateDropsflag', self.qmc.interpolateDropsflag,
                                  read_defaults)

            # --- BEGIN GROUP RoC
            settings.beginGroup('RoC')
            self.settingsSetValue(settings, default_settings, 'DeltaET', self.qmc.DeltaETflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'DeltaBT', self.qmc.DeltaBTflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'DeltaETlcd', self.qmc.DeltaETlcdflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'DeltaBTlcd', self.qmc.DeltaBTlcdflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'deltaETfilter', self.qmc.deltaETfilter, read_defaults)
            self.settingsSetValue(settings, default_settings, 'deltafilter', self.qmc.deltaBTfilter, read_defaults)
            self.settingsSetValue(settings, default_settings, 'DeltaETspan', self.qmc.deltaETspan, read_defaults)
            self.settingsSetValue(settings, default_settings, 'DeltaSpan', self.qmc.deltaBTspan, read_defaults)
            self.settingsSetValue(settings, default_settings, 'LCDdecimalplaces', self.qmc.LCDdecimalplaces,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'statisticsmode', self.qmc.statisticsmode, read_defaults)
            self.settingsSetValue(settings, default_settings, 'swapdeltalcds', self.qmc.swapdeltalcds, read_defaults)
            settings.endGroup()
            # --- END GROUP RoC

            self.settingsSetValue(settings, default_settings, 'curvefilter', self.qmc.curvefilter, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETcurve', self.qmc.ETcurve, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTcurve', self.qmc.BTcurve, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETlcd', self.qmc.ETlcd, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTlcd', self.qmc.BTlcd, read_defaults)
            self.settingsSetValue(settings, default_settings, 'swaplcds', self.qmc.swaplcds, read_defaults)

            # --- BEGIN GROUP DefaultButtons
            settings.beginGroup('DefaultButtons')
            self.settingsSetValue(settings, default_settings, 'buttonvisibility', self.qmc.buttonvisibility,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'buttonactions', self.qmc.buttonactions, read_defaults)
            self.settingsSetValue(settings, default_settings, 'buttonactionstrings', self.qmc.buttonactionstrings,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'extrabuttonactions', self.qmc.extrabuttonactions,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'extrabuttonactionstrings',
                                  self.qmc.extrabuttonactionstrings, read_defaults)
            self.settingsSetValue(settings, default_settings, 'xextrabuttonactions', self.qmc.xextrabuttonactions,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'xextrabuttonactionstrings',
                                  self.qmc.xextrabuttonactionstrings, read_defaults)
            settings.endGroup()
            # --- END GROUP DefaultButtons

            self.settingsSetValue(settings, default_settings, 'transMappingMode', self.qmc.transMappingMode,
                                  read_defaults)

            # --- BEGIN GROUP Style
            settings.beginGroup('Style')
            self.settingsSetValue(settings, default_settings, 'patheffects', self.qmc.patheffects, read_defaults)
            self.settingsSetValue(settings, default_settings, 'glow', self.qmc.glow, read_defaults)
            self.settingsSetValue(settings, default_settings, 'graphstyle', self.qmc.graphstyle, read_defaults)
            self.settingsSetValue(settings, default_settings, 'graphfont', self.qmc.graphfont, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETname', self.ETname, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTname', self.BTname, read_defaults)
            settings.endGroup()
            # --- END GROUP Style

            # --- BEGIN GROUP Sound
            settings.beginGroup('Sound')
            self.settingsSetValue(settings, default_settings, 'Beep', self.soundflag, read_defaults)
            settings.endGroup()
            # --- END GROUP Sound

            # --- BEGIN GROUP Notifications
            settings.beginGroup('Notifications')
            if self.notificationManager:
                try:
                    titles = []
                    messages = []
                    types = []
                    created = []
                    for noti in self.notificationManager.getNotificationItems():
                        titles.append(noti.title)
                        messages.append(noti.message)
                        types.append(noti.type.value)
                        created.append(noti.created)
                    self.settingsSetValue(settings, default_settings, 'titles', titles, read_defaults)
                    self.settingsSetValue(settings, default_settings, 'messages', messages, read_defaults)
                    self.settingsSetValue(settings, default_settings, 'types', types, read_defaults)
                    self.settingsSetValue(settings, default_settings, 'created', created, read_defaults)
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
            self.settingsSetValue(settings, default_settings, 'notificationsflag', self.notificationsflag,
                                  read_defaults)
            settings.endGroup()
            # --- END GROUP Notifications

            # --- BEGIN GROUP Axis
            settings.beginGroup('Axis')
            self.settingsSetValue(settings, default_settings, 'loadAxisFromProfile', self.qmc.loadaxisfromprofile,
                                  read_defaults)
            xmin = self.qmc.startofx
            if self.qmc.timeindex[0] != -1:
                xmin -= self.qmc.timex[self.qmc.timeindex[0]]
            self.settingsSetValue(settings, default_settings, 'xmin', xmin, read_defaults)
            self.settingsSetValue(settings, default_settings, 'xmax', self.qmc.endofx, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ymax', self.qmc.ylimit, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ymin', self.qmc.ylimit_min, read_defaults)
            self.settingsSetValue(settings, default_settings, 'zmax', self.qmc.zlimit, read_defaults)
            self.settingsSetValue(settings, default_settings, 'zmin', self.qmc.zlimit_min, read_defaults)
            self.settingsSetValue(settings, default_settings, 'resetmaxtime', self.qmc.resetmaxtime, read_defaults)
            self.settingsSetValue(settings, default_settings, 'lockmax', self.qmc.fixmaxtime, read_defaults)
            self.settingsSetValue(settings, default_settings, 'locktimex', self.qmc.locktimex, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autotimex', self.qmc.autotimex, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autotimexMode', self.qmc.autotimexMode, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autodeltaxET', self.qmc.autodeltaxET, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autodeltaxBT', self.qmc.autodeltaxBT, read_defaults)
            self.settingsSetValue(settings, default_settings, 'locktimex_start', self.qmc.locktimex_start,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'locktimex_end', self.qmc.locktimex_end, read_defaults)
            self.settingsSetValue(settings, default_settings, 'legendloc', self.qmc.legendloc, read_defaults)
            self.settingsSetValue(settings, default_settings, 'chargemintime', self.qmc.chargemintime, read_defaults)
            self.settingsSetValue(settings, default_settings, 'temp_grid', self.qmc.temp_grid, read_defaults)
            self.settingsSetValue(settings, default_settings, 'time_grid', self.qmc.time_grid, read_defaults)
            settings.endGroup()
            # --- END GROUP Axis

            self.settingsSetValue(settings, default_settings, 'organization_setup', self.qmc.organization_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'operator_setup', self.qmc.operator_setup, read_defaults)
            self.settingsSetValue(settings, default_settings, 'roastertype_setup', self.qmc.roastertype_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'roastersize_setup', self.qmc.roastersize_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'roasterheating_setup', self.qmc.roasterheating_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'drumspeed_setup', self.qmc.drumspeed_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'last_batchsize', self.qmc.last_batchsize, read_defaults)

            # --- BEGIN GROUP EnergyUse
            settings.beginGroup('EnergyUse')
            self.settingsSetValue(settings, default_settings, 'loadlabels_setup', self.qmc.loadlabels_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'loadratings_setup', self.qmc.loadratings_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ratingunits_setup', self.qmc.ratingunits_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'sourcetypes_setup', self.qmc.sourcetypes_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'load_etypes_setup', self.qmc.load_etypes_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'presssure_percents_setup',
                                  self.qmc.presssure_percents_setup, read_defaults)
            self.settingsSetValue(settings, default_settings, 'loadevent_zeropcts_setup',
                                  self.qmc.loadevent_zeropcts_setup, read_defaults)
            self.settingsSetValue(settings, default_settings, 'loadevent_hundpcts_setup',
                                  self.qmc.loadevent_hundpcts_setup, read_defaults)
            self.settingsSetValue(settings, default_settings, 'preheatDuration_setup', self.qmc.preheatDuration_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'preheatenergies_setup', self.qmc.preheatenergies_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'betweenbatchDuration_setup',
                                  self.qmc.betweenbatchDuration_setup, read_defaults)
            self.settingsSetValue(settings, default_settings, 'betweenbatchenergies_setup',
                                  self.qmc.betweenbatchenergies_setup, read_defaults)
            self.settingsSetValue(settings, default_settings, 'coolingDuration_setup', self.qmc.coolingDuration_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'coolingenergies_setup', self.qmc.coolingenergies_setup,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'betweenbatch_after_preheat_setup',
                                  self.qmc.betweenbatch_after_preheat_setup, read_defaults)
            self.settingsSetValue(settings, default_settings, 'electricEnergyMix_setup',
                                  self.qmc.electricEnergyMix_setup, read_defaults)
            self.settingsSetValue(settings, default_settings, 'energyresultunit_setup', self.qmc.energyresultunit_setup,
                                  read_defaults)
            settings.endGroup()
            # --- END GROUP EnergyUse

            # --- BEGIN GROUP RoastProperties
            settings.beginGroup('RoastProperties')

            self.settingsSetValue(settings, default_settings, 'machinesetup', self.qmc.machinesetup, read_defaults)
            self.settingsSetValue(settings, default_settings, 'beansize_min', self.qmc.beansize_min, read_defaults)
            self.settingsSetValue(settings, default_settings, 'beansize_max', self.qmc.beansize_max, read_defaults)
            if filename is None:
                # we don't export plus default store and custom blend data to external settings file as the custom blend is considered temporary
                self.settingsSetValue(settings, default_settings, 'plus_default_store', self.qmc.plus_default_store,
                                      read_defaults)
                if self.qmc.plus_custom_blend is not None:
                    self.settingsSetValue(settings, default_settings, 'plus_custom_blend_name',
                                          self.qmc.plus_custom_blend.name, read_defaults)
                    self.settingsSetValue(settings, default_settings, 'plus_custom_blend_coffees',
                                          [c.coffee for c in self.qmc.plus_custom_blend.components], read_defaults)
                    self.settingsSetValue(settings, default_settings, 'plus_custom_blend_ratios',
                                          [c.ratio for c in self.qmc.plus_custom_blend.components], read_defaults)
            # remove pre v2.0 settings no longer used
            try:
                if settings.contains('organization'):
                    settings.remove('organization')
                if settings.contains('operator'):
                    settings.remove('operator')
                if settings.contains('roastertype'):
                    settings.remove('roastertype')
                if settings.contains('roastersize'):
                    settings.remove('roastersize')
                if settings.contains('drumspeed'):
                    settings.remove('drumspeed')
                if settings.contains('beansize'):
                    settings.remove('beansize')
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
            settings.endGroup()
            # --- END GROUP RoastProperties

            # --- BEGIN GROUP XT
            settings.beginGroup('XT')
            self.settingsSetValue(settings, default_settings, 'color', self.qmc.backgroundxtcolor, read_defaults)
            self.settingsSetValue(settings, default_settings, 'color2', self.qmc.backgroundytcolor, read_defaults)
            self.settingsSetValue(settings, default_settings, 'index', self.qmc.xtcurveidx, read_defaults)
            self.settingsSetValue(settings, default_settings, 'index2', self.qmc.ytcurveidx, read_defaults)
            settings.endGroup()
            # --- END GROUP XT

            # --- BEGIN GROUP Units
            settings.beginGroup('Units')
            self.settingsSetValue(settings, default_settings, 'weight', self.qmc.weight[2], read_defaults)
            self.settingsSetValue(settings, default_settings, 'volume', self.qmc.volume[2], read_defaults)
            self.settingsSetValue(settings, default_settings, 'densityweight', self.qmc.density[1], read_defaults)
            self.settingsSetValue(settings, default_settings, 'densityvolume', self.qmc.density[3], read_defaults)
            self.settingsSetValue(settings, default_settings, 'volumeCalcUnit', self.qmc.volumeCalcUnit, read_defaults)
            settings.endGroup()
            # --- END GROUP Units

            # --- BEGIN GROUP Alarms
            # save alarms
            settings.beginGroup('Alarms')
            self.settingsSetValue(settings, default_settings, 'alarmsetlabel', self.qmc.alarmsetlabel, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmflag', self.qmc.alarmflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmguard', self.qmc.alarmguard, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmnegguard', self.qmc.alarmnegguard, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmtime', self.qmc.alarmtime, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmoffset', self.qmc.alarmoffset, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmcond', self.qmc.alarmcond, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmsource', self.qmc.alarmsource, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmtemperature', self.qmc.alarmtemperature,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmaction', self.qmc.alarmaction, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmbeep', self.qmc.alarmbeep, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmstrings', self.qmc.alarmstrings, read_defaults)
            self.settingsSetValue(settings, default_settings, 'loadAlarmsFromProfile', self.qmc.loadalarmsfromprofile,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'loadAlarmsFromBackground',
                                  self.qmc.loadalarmsfrombackground, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmsfile', self.qmc.alarmsfile, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarm_popup_timout', self.qmc.alarm_popup_timout,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmtablecolumnwidths', self.qmc.alarmtablecolumnwidths,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'alarmsets',
                                  [self.qmc.alarmSet2Lists(aset) for aset in self.qmc.alarmsets], read_defaults)
            settings.endGroup()
            # --- END GROUP Alarms

            self.settingsSetValue(settings, default_settings, 'profilepath', self.userprofilepath, read_defaults)
            self.settingsSetValue(settings, default_settings, 'settingspath', self.settingspath, read_defaults)
            self.settingsSetValue(settings, default_settings, 'wheelpath', self.wheelpath, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autosavepath', self.qmc.autosavepath, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autosavealsopath', self.qmc.autosavealsopath,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'simulatorpath', self.simulatorpath, read_defaults)
            self.settingsSetValue(settings, default_settings, 'externalprogram', self.ser.externalprogram,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'externaloutprogram', self.ser.externaloutprogram,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'externaloutprogramFlag', self.ser.externaloutprogramFlag,
                                  read_defaults)

            # --- BEGIN GROUP ExtraDev
            # save extra devices
            settings.beginGroup('ExtraDev')
            self.setExtraDeviceSettings(settings, default_settings, read_defaults)
            settings.endGroup()
            # --- END GROUP ExtraDev

            # --- BEGIN GROUP ExtraComm
            # save extra serial comm ports settings
            settings.beginGroup('ExtraComm')
            self.setExtraDeviceCommSettings(settings, default_settings, read_defaults)
            settings.endGroup()
            # --- END GROUP ExtraComm

            self.settingsSetValue(settings, default_settings, 'ChannelTares', self.channel_tare_values, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTfunction', self.qmc.BTfunction, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETfunction', self.qmc.ETfunction, read_defaults)
            self.settingsSetValue(settings, default_settings, 'DeltaBTfunction', self.qmc.DeltaBTfunction,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'DeltaETfunction', self.qmc.DeltaETfunction,
                                  read_defaults)
            if not read_defaults:
                settings.setValue('resetqsettings',
                                  self.resetqsettings)  # no defaults cache used here to ensure that this one is always written
            self.settingsSetValue(settings, default_settings, 'plotcurves', self.qmc.plotcurves, read_defaults)
            self.settingsSetValue(settings, default_settings, 'plotcurvecolor', self.qmc.plotcurvecolor, read_defaults)

            # --- BEGIN GROUP CurveStyles
            # curve styles
            settings.beginGroup('CurveStyles')
            self.settingsSetValue(settings, default_settings, 'BTlinestyle', self.qmc.BTlinestyle, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTdrawstyle', self.qmc.BTdrawstyle, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTlinewidth', self.qmc.BTlinewidth, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTmarker', self.qmc.BTmarker, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTmarkersize', self.qmc.BTmarkersize, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETlinestyle', self.qmc.ETlinestyle, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETdrawstyle', self.qmc.ETdrawstyle, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETlinewidth', self.qmc.ETlinewidth, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETmarker', self.qmc.ETmarker, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETmarkersize', self.qmc.ETmarkersize, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTdeltalinestyle', self.qmc.BTdeltalinestyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTdeltadrawstyle', self.qmc.BTdeltadrawstyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTdeltalinewidth', self.qmc.BTdeltalinewidth,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTdeltamarker', self.qmc.BTdeltamarker, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTdeltamarkersize', self.qmc.BTdeltamarkersize,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETdeltalinestyle', self.qmc.ETdeltalinestyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETdeltadrawstyle', self.qmc.ETdeltadrawstyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETdeltalinewidth', self.qmc.ETdeltalinewidth,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETdeltamarker', self.qmc.ETdeltamarker, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETdeltamarkersize', self.qmc.ETdeltamarkersize,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTbacklinestyle', self.qmc.BTbacklinestyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTbackdrawstyle', self.qmc.BTbackdrawstyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTbacklinewidth', self.qmc.BTbacklinewidth,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTbackmarker', self.qmc.BTbackmarker, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTbackmarkersize', self.qmc.BTbackmarkersize,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETbacklinestyle', self.qmc.ETbacklinestyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETbackdrawstyle', self.qmc.ETbackdrawstyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETbacklinewidth', self.qmc.ETbacklinewidth,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETbackmarker', self.qmc.ETbackmarker, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETbackmarkersize', self.qmc.ETbackmarkersize,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'XTbacklinestyle', self.qmc.XTbacklinestyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'XTbackdrawstyle', self.qmc.XTbackdrawstyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'XTbacklinewidth', self.qmc.XTbacklinewidth,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'XTbackmarker', self.qmc.XTbackmarker, read_defaults)
            self.settingsSetValue(settings, default_settings, 'XTbackmarkersize', self.qmc.XTbackmarkersize,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'YTbacklinestyle', self.qmc.YTbacklinestyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'YTbackdrawstyle', self.qmc.YTbackdrawstyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'YTbacklinewidth', self.qmc.YTbacklinewidth,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'YTbackmarker', self.qmc.YTbackmarker, read_defaults)
            self.settingsSetValue(settings, default_settings, 'YTbackmarkersize', self.qmc.YTbackmarkersize,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTBdeltalinestyle', self.qmc.BTBdeltalinestyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTBdeltadrawstyle', self.qmc.BTBdeltadrawstyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTBdeltalinewidth', self.qmc.BTBdeltalinewidth,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTBdeltamarker', self.qmc.BTBdeltamarker, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTBdeltamarkersize', self.qmc.BTBdeltamarkersize,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETBdeltalinestyle', self.qmc.ETBdeltalinestyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETBdeltadrawstyle', self.qmc.ETBdeltadrawstyle,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETBdeltalinewidth', self.qmc.ETBdeltalinewidth,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETBdeltamarker', self.qmc.ETBdeltamarker, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETBdeltamarkersize', self.qmc.ETBdeltamarkersize,
                                  read_defaults)
            self.setExtraDeviceCurveStyles(settings, default_settings, read_defaults)
            settings.endGroup()
            # --- END GROUP CurveStyles

            # --- BEGIN GROUP background
            # background settings
            settings.beginGroup('background')
            self.settingsSetValue(settings, default_settings, 'backgrounddetails', self.qmc.backgroundDetails,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'backgroundevents', self.qmc.backgroundeventsflag,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'movespeed', self.qmc.backgroundmovespeed, read_defaults)
            self.settingsSetValue(settings, default_settings, 'DeltaETB', self.qmc.DeltaETBflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'DeltaBTB', self.qmc.DeltaBTBflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alignEvent', self.qmc.alignEvent, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ETBflag', self.qmc.backgroundETcurve, read_defaults)
            self.settingsSetValue(settings, default_settings, 'BTBflag', self.qmc.backgroundBTcurve, read_defaults)
            self.settingsSetValue(settings, default_settings, 'backgroundShowFullflag', self.qmc.backgroundShowFullflag,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'backgroundKeyboardControlFlag',
                                  self.qmc.backgroundKeyboardControlFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'clearBgbeforeprofileload',
                                  self.qmc.clearBgbeforeprofileload, read_defaults)
            self.settingsSetValue(settings, default_settings, 'hideBgafterprofileload', self.qmc.hideBgafterprofileload,
                                  read_defaults)
            settings.endGroup()
            # --- END GROUP background

            self.settingsSetValue(settings, default_settings, 'compareAlignEvent', self.qmc.compareAlignEvent,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'compareEvents', self.qmc.compareEvents, read_defaults)
            self.settingsSetValue(settings, default_settings, 'compareET', self.qmc.compareET, read_defaults)
            self.settingsSetValue(settings, default_settings, 'compareBT', self.qmc.compareBT, read_defaults)
            self.settingsSetValue(settings, default_settings, 'compareDeltaET', self.qmc.compareDeltaET, read_defaults)
            self.settingsSetValue(settings, default_settings, 'compareDeltaBT', self.qmc.compareDeltaBT, read_defaults)
            self.settingsSetValue(settings, default_settings, 'compareMainEvents', self.qmc.compareMainEvents,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'compareExtraCurves1', self.qmc.compareExtraCurves1,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'compareExtraCurves2', self.qmc.compareExtraCurves2,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'compareBBP', self.qmc.compareBBP, read_defaults)
            self.settingsSetValue(settings, default_settings, 'compareRoast', self.qmc.compareRoast, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autosaveflag', self.qmc.autosaveflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autosaveaddtorecentfilesflag',
                                  self.qmc.autosaveaddtorecentfilesflag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autosavepdf', self.qmc.autosaveimage, read_defaults)
            self.settingsSetValue(settings, default_settings, 'autosaveimageformat', self.qmc.autosaveimageformat,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'autosaveprefix', self.qmc.autosaveprefix, read_defaults)

            # --- BEGIN GROUP WebLCDs
            settings.beginGroup('WebLCDs')
            self.settingsSetValue(settings, default_settings, 'active', self.WebLCDs, read_defaults)
            self.settingsSetValue(settings, default_settings, 'port', self.WebLCDsPort, read_defaults)
            self.settingsSetValue(settings, default_settings, 'alerts', self.WebLCDsAlerts, read_defaults)
            settings.endGroup()
            # --- END GROUP WebLCDs

            self.settingsSetValue(settings, default_settings, 'LargeLCDs', self.LargeLCDsFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'LargeDeltaLCDs', self.LargeDeltaLCDsFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'LargePIDLCDs', self.LargePIDLCDsFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'LargeScaleLCDs', self.LargeScaleLCDsFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'LargeExtraLCDs', self.LargeExtraLCDsFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'LargePhasesLCDs', self.LargePhasesLCDsFlag,
                                  read_defaults)

            # --- BEGIN GROUP ExtraEventButtons
            # custom event buttons
            settings.beginGroup('ExtraEventButtons')
            self.settingsSetValue(settings, default_settings, 'buttonlistmaxlen', self.buttonlistmaxlen, read_defaults)
            self.settingsSetValue(settings, default_settings, 'extraeventstypes', self.extraeventstypes, read_defaults)
            self.settingsSetValue(settings, default_settings, 'extraeventsvalues', self.extraeventsvalues,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'extraeventsactionstrings', self.extraeventsactionstrings,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'extraeventsactions', self.extraeventsactions,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'extraeventsdescriptions', self.extraeventsdescriptions,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'extraeventsvisibility', self.extraeventsvisibility,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'extraeventslabels', self.extraeventslabels,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'extraeventbuttoncolor', self.extraeventbuttoncolor,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'extraeventbuttontextcolor',
                                  self.extraeventbuttontextcolor, read_defaults)
            self.settingsSetValue(settings, default_settings, 'extraeventsbuttonsflags', self.extraeventsbuttonsflags,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'buttonpalette', [list(bp) for bp in self.buttonpalette],
                                  read_defaults)  # externally we store lists of lists, internally we hold a list of tuples of lists (Palettes)
            self.settingsSetValue(settings, default_settings, 'buttonpalettemaxlen', self.buttonpalettemaxlen,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'buttonpalette_shortcuts', self.buttonpalette_shortcuts,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'eventbuttontablecolumnwidths',
                                  self.eventbuttontablecolumnwidths, read_defaults)
            self.settingsSetValue(settings, default_settings, 'buttonsize', self.buttonsize, read_defaults)
            self.settingsSetValue(settings, default_settings, 'marklastbuttonpressed', self.mark_last_button_pressed,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'showextrabuttontooltips', self.show_extrabutton_tooltips,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'buttonpalette_label', self.buttonpalette_label,
                                  read_defaults)
            settings.endGroup()
            # --- END GROUP ExtraEventButtons

            # --- BEGIN GROUP RoRlimits
            settings.beginGroup('RoRlimits')
            self.settingsSetValue(settings, default_settings, 'RoRlimitFlag', self.qmc.RoRlimitFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'RoRlimit', self.qmc.RoRlimit, read_defaults)
            self.settingsSetValue(settings, default_settings, 'RoRlimitm', self.qmc.RoRlimitm, read_defaults)
            settings.endGroup()
            # --- END GROUP RoRlimits

            # --- BEGIN GROUP grid
            settings.beginGroup('grid')
            self.settingsSetValue(settings, default_settings, 'xgrid', self.qmc.xgrid, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ygrid', self.qmc.ygrid, read_defaults)
            self.settingsSetValue(settings, default_settings, 'zgrid', self.qmc.zgrid, read_defaults)
            self.settingsSetValue(settings, default_settings, 'gridlinestyle', self.qmc.gridlinestyle, read_defaults)
            self.settingsSetValue(settings, default_settings, 'gridthickness', self.qmc.gridthickness, read_defaults)
            self.settingsSetValue(settings, default_settings, 'gridalpha', self.qmc.gridalpha, read_defaults)
            settings.endGroup()
            # --- END GROUP grid

            # --- BEGIN GROUP Sliders
            settings.beginGroup('Sliders')
            self.settingsSetValue(settings, default_settings, 'slidervisibilities', self.eventslidervisibilities,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'eventsliderKeyboardControl',
                                  self.eventsliderKeyboardControl, read_defaults)
            self.settingsSetValue(settings, default_settings, 'eventsliderAlternativeLayout',
                                  self.eventsliderAlternativeLayout, read_defaults)
            self.settingsSetValue(settings, default_settings, 'slideractions', self.eventslideractions, read_defaults)
            self.settingsSetValue(settings, default_settings, 'slidercommands', self.eventslidercommands, read_defaults)
            self.settingsSetValue(settings, default_settings, 'slideroffsets', self.eventslideroffsets, read_defaults)
            self.settingsSetValue(settings, default_settings, 'sliderfactors', self.eventsliderfactors, read_defaults)
            self.settingsSetValue(settings, default_settings, 'slidermin', self.eventslidermin, read_defaults)
            self.settingsSetValue(settings, default_settings, 'slidermax', self.eventslidermax, read_defaults)
            self.settingsSetValue(settings, default_settings, 'eventslidersflags', self.eventslidersflags,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'eventsliderBernoulli', self.eventsliderBernoulli,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'eventslidercoarse', self.eventslidercoarse,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'eventslidertemp', self.eventslidertemp, read_defaults)
            self.settingsSetValue(settings, default_settings, 'eventsliderunits', self.eventsliderunits, read_defaults)
            self.settingsSetValue(settings, default_settings, 'ModeTempSliders', self.qmc.mode_tempsliders,
                                  read_defaults)
            settings.endGroup()
            # --- END GROUP Sliders

            # --- BEGIN GROUP Quantifiers
            settings.beginGroup('Quantifiers')
            self.settingsSetValue(settings, default_settings, 'quantifieractive', self.eventquantifieractive,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'quantifiersource', self.eventquantifiersource,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'eventquantifierSV', self.eventquantifierSV,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'quantifiermin', self.eventquantifiermin, read_defaults)
            self.settingsSetValue(settings, default_settings, 'quantifiermax', self.eventquantifiermax, read_defaults)
            self.settingsSetValue(settings, default_settings, 'quantifiercoarse', self.eventquantifiercoarse,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'eventquantifieraction', self.eventquantifieraction,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'clusterEventsFlag', self.clusterEventsFlag,
                                  read_defaults)
            settings.endGroup()
            # --- END GROUP Quantifiers

            self.settingsSetValue(settings, default_settings, 'titleshowalways', self.qmc.title_show_always,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'roastpropertiesflag', self.qmc.roastpropertiesflag,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'roastpropertiesAutoOpenFlag',
                                  self.qmc.roastpropertiesAutoOpenFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'roastpropertiesAutoOpenDropFlag',
                                  self.qmc.roastpropertiesAutoOpenDropFlag, read_defaults)
            self.settingsSetValue(settings, default_settings, 'customflavorlabels', self.qmc.customflavorlabels,
                                  read_defaults)

            # --- BEGIN GROUP Batch
            settings.beginGroup('Batch')
            self.settingsSetValue(settings, default_settings, 'batchcounter', self.qmc.batchcounter, read_defaults)
            self.settingsSetValue(settings, default_settings, 'batchsequence', self.qmc.batchsequence, read_defaults)
            self.settingsSetValue(settings, default_settings, 'batchprefix', self.qmc.batchprefix, read_defaults)
            if not read_defaults:
                # store always
                self.settingsSetValue(settings, default_settings, 'lastroastepoch', self.qmc.lastroastepoch,
                                      read_defaults)
            self.settingsSetValue(settings, default_settings, 'neverUpdateBatchCounter',
                                  self.qmc.neverUpdateBatchCounter, read_defaults)
            settings.endGroup()
            # --- END GROUP Batch

            # --- BEGIN GROUP ExtrasMoreInfo
            settings.beginGroup('ExtrasMoreInfo')
            self.settingsSetValue(settings, default_settings, 'showmet', self.qmc.showmet, read_defaults)
            self.settingsSetValue(settings, default_settings, 'statssummary', self.qmc.statssummary, read_defaults)
            self.settingsSetValue(settings, default_settings, 'statsmaxchrperline', self.qmc.statsmaxchrperline,
                                  read_defaults)
            self.settingsSetValue(settings, default_settings, 'showtimeguide', self.qmc.showtimeguide, read_defaults)
            settings.endGroup()
            # --- END GROUP ExtrasMoreInfo

            try:
                self.settingsSetValue(settings, default_settings, 'appearance', self.appearance, read_defaults)
            except Exception:  # pylint: disable=broad-except
                pass

            if not read_defaults:
                settings.setValue('dpi', self.dpi)  # no defaults cache used here to ensure that this one is always writ

            self.settingsSetValue(settings, default_settings, 'recentRoasts', self.recentRoasts, read_defaults)

            if self.curFile and filename is None:
                self.settingsSetValue(settings, default_settings, 'lastLoadedProfile', self.curFile, read_defaults)
            else:
                self.settingsSetValue(settings, default_settings, 'lastLoadedProfile', '', read_defaults)
            if self.qmc.backgroundpath and filename is None:
                self.settingsSetValue(settings, default_settings, 'lastLoadedBackground', self.qmc.backgroundpath,
                                      read_defaults)
            else:
                self.settingsSetValue(settings, default_settings, 'lastLoadedBackground', '', read_defaults)
            # on exported settings we add the current timestamp
            if filename:
                self.settingsSetValue(settings, default_settings, 'timestamp',
                                      QDateTime.currentDateTime().toString('yyyy-MM-ddThh:mm:ss'), read_defaults)

            if not read_defaults:
                settings.sync()

            if settings.status() != QSettings.Status.NoError:
                _log.error('Failed to save settings')
                QMessageBox.information(self, QApplication.translate('Error Message', 'Error', None),
                                        QApplication.translate('Error Message', 'Failed to save settings'))
                return False
            if not read_defaults:
                _log.info('wrote %s settings in %.2fs', len(settings.allKeys()), libtime.process_time() - start_time)
            return True

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self, QApplication.translate('Error Message', 'Error', None),
                                    QApplication.translate('Error Message',
                                                           'Exception:') + ' saveAllSettings()  @line ' + str(
                                        getattr(exc_tb, 'tb_lineno', '?')))
        return False

    def closeEventSettings_theme(self, filename: Optional[str] = None) -> None:
        try:
            if filename:
                settings = QSettings(filename, QSettings.Format.IniFormat)
            else:
                settings = QSettings()
            # save Events settings
            settings.beginGroup('events')
            settings.setValue('EvalueColor', self.qmc.EvalueColor)
            settings.setValue('EvalueTextColor', self.qmc.EvalueTextColor)
            settings.setValue('EvalueMarker', self.qmc.EvalueMarker)
            settings.setValue('Evaluelinethickness', self.qmc.Evaluelinethickness)
            settings.setValue('EvalueMarkerSize', self.qmc.EvalueMarkerSize)
            settings.setValue('Evaluealpha', self.qmc.Evaluealpha)
            settings.endGroup()
            # save phases watermarks flag
            settings.setValue('watermarks', self.qmc.watermarksflag)
            # save colors
            settings.setValue('Colors', self.qmc.palette)
            settings.setValue('Alphas', self.qmc.alpha)
            settings.setValue('LCDColors', self.lcdpaletteB)
            settings.setValue('LEDColors', self.lcdpaletteF)
            settings.setValue('ETBColor', self.qmc.backgroundmetcolor)
            settings.setValue('BTBColor', self.qmc.backgroundbtcolor)
            settings.setValue('ETBdeltaColor', self.qmc.backgrounddeltaetcolor)
            settings.setValue('BTBdeltaColor', self.qmc.backgrounddeltabtcolor)
            settings.setValue('BackgroundAlpha', self.qmc.backgroundalpha)
            settings.beginGroup('XT')
            settings.setValue('color', self.qmc.backgroundxtcolor)
            settings.setValue('color2', self.qmc.backgroundytcolor)
            settings.setValue('index', self.qmc.xtcurveidx)
            settings.setValue('index2', self.qmc.ytcurveidx)
            settings.endGroup()
            settings.beginGroup('grid')
            settings.setValue('gridalpha', self.qmc.gridalpha)
            settings.endGroup()

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            QMessageBox.information(self, QApplication.translate('Error Message', 'Error', None),
                                    QApplication.translate('Error Message',
                                                           'Exception:') + ' closeEventSettings_theme()  @line ' + str(
                                        getattr(exc_tb, 'tb_lineno', '?')))

    def updateExtraLCDvisibility(self) -> None:
        n = len(self.qmc.extradevices)
        for i in range(n):
            if i < self.nLCDS:
                if self.extraLCDvisibility1[i]:
                    if i < len(self.qmc.extraname1):
                        l1 = '<b>' + self.qmc.extraname1[i] + '</b>'
                        try:
                            l1 = l1.format(self.qmc.etypes[0], self.qmc.etypes[1], self.qmc.etypes[2],
                                           self.qmc.etypes[3])
                        except Exception:  # pylint: disable=broad-except
                            # substitution might fail if the label contains brackets like in "t{FCS}"
                            pass
                        self.extraLCDlabel1[i].setText(l1)
                        self.setLabelColor(self.extraLCDlabel1[i], QColor(self.qmc.extradevicecolor1[i]))
                    self.extraLCDframe1[i].setVisible(True)
                    self.extraLCD1[i].setStyleSheet(
                        f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['sv']}; background-color: {self.lcdpaletteB['sv']};}}")
                else:
                    self.extraLCDframe1[i].setVisible(False)
                if self.extraLCDvisibility2[i]:
                    if i < len(self.qmc.extraname2):
                        l2 = '<b>' + self.qmc.extraname2[i] + '</b>'
                        try:
                            l2 = l2.format(self.qmc.etypes[0], self.qmc.etypes[1], self.qmc.etypes[2],
                                           self.qmc.etypes[3])
                        except Exception:  # pylint: disable=broad-except
                            # substitution might fail if the label contains brackets like in "t{FCS}"
                            pass
                        self.extraLCDlabel2[i].setText(l2)
                        self.setLabelColor(self.extraLCDlabel2[i], QColor(self.qmc.extradevicecolor2[i]))
                    self.extraLCDframe2[i].setVisible(True)
                    self.extraLCD2[i].setStyleSheet(
                        f"QLCDNumber {{ border-radius: 4; color: {self.lcdpaletteF['sv']}; background-color: {self.lcdpaletteB['sv']};}}")
                else:
                    self.extraLCDframe2[i].setVisible(False)
        # hide the rest (just in case)
        for i in range(n, self.nLCDS):
            self.extraLCDframe1[i].setVisible(False)
            self.extraLCDframe2[i].setVisible(False)

    def stopActivities(self) -> None:
        if self.full_screen_mode_active:
            if not (platform.system() == 'Darwin' and self.qmc.locale_str == 'en'):
                self.fullscreenAction.setChecked(False)
            self.showNormal()
        if self.simulator is None:
            if self.qmc.device == 53 and self.hottop is not None:
                # disconnect HOTTOP
                self.hottop.stop()
                self.hottop = None
            elif self.qmc.device == 134 and self.santoker is not None:
                # disconnect Santoker
                self.santoker.stop()
                self.santoker = None
            elif self.qmc.device == 138 and self.kaleido is not None:
                # disconnect Santoker
                self.kaleido.stop()
                self.kaleido = None
        if self.qmc.flagon:
            self.qmc.ToggleMonitor()
        if self.WebLCDs:
            self.stopWebLCDs()
            self.WebLCDs = True  # to ensure they are started again on restart
        if self.LargeLCDsFlag and self.largeLCDs_dialog:
            tmp_LargeLCDs = self.LargeLCDsFlag  # we keep the state to properly store it in the settings
            self.largeLCDs_dialog.close()
            self.LargeLCDsFlag = tmp_LargeLCDs
        if self.LargeDeltaLCDsFlag and self.largeDeltaLCDs_dialog:
            tmp_LargeLCDs = self.LargeDeltaLCDsFlag  # we keep the state to properly store it in the settings
            self.largeDeltaLCDs_dialog.close()
            self.LargeDeltaLCDsFlag = tmp_LargeLCDs
        if self.LargePIDLCDsFlag and self.largePIDLCDs_dialog:
            tmp_LargeLCDs = self.LargePIDLCDsFlag  # we keep the state to properly store it in the settings
            self.largePIDLCDs_dialog.close()
            self.LargePIDLCDsFlag = tmp_LargeLCDs
        if self.LargeScaleLCDsFlag and self.largeScaleLCDs_dialog:
            tmp_LargeLCDs = self.LargeScaleLCDsFlag  # we keep the state to properly store it in the settings
            self.largeScaleLCDs_dialog.close()
            self.LargeScaleLCDsFlag = tmp_LargeLCDs
        if self.LargeExtraLCDsFlag and self.largeExtraLCDs_dialog:
            tmp_LargeLCDs = self.LargeExtraLCDsFlag  # we keep the state to properly store it in the settings
            self.largeExtraLCDs_dialog.close()
            self.LargeExtraLCDsFlag = tmp_LargeLCDs
        if self.LargePhasesLCDsFlag and self.largePhasesLCDs_dialog:
            tmp_LargeLCDs = self.LargePhasesLCDsFlag  # we keep the state to properly store it in the settings
            self.largePhasesLCDs_dialog.close()
            self.LargePhasesLCDsFlag = tmp_LargeLCDs
        if self.comparator:
            self.comparator.close()
        # now wait until the current sampling thread is terminated
        while self.qmc.flagsamplingthreadrunning:
            QApplication.processEvents()
            libtime.sleep(.01)
        if self.ser.R1 is not None:
            self.ser.R1 = None
        try:
            self.closeserialports()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        if self.qmc.phidgetManager is not None:
            try:
                self.qmc.closePhidgetOUTPUTs()
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
            try:
                self.qmc.closePhidgetAMBIENTs()
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
            self.qmc.stopPhidgetManager()

    # returns True if confirmed, False if canceled by the user
    def closeApp(self) -> bool:
        # self.quitAction.setEnabled(False)
        try:
            unsaved_changes = self.qmc.safesaveflag
            if self.qmc.checkSaved():  # if not canceled
                _log.info('MODE: QUIT')
                flagKeepON = self.qmc.flagKeepON
                self.qmc.flagKeepON = False  # temporarily turn keepOn off
                self.stopActivities()
                if unsaved_changes:
                    self.qmc.safesaveflag = False
                    # in case we have unsaved changes and the user decided to discard those, we first reset to have the correct settings (like axis limits) saved
                    self.qmc.reset(redraw=False, soundOn=False, keepProperties=False, fireResetAction=False)
                self.qmc.flagKeepON = flagKeepON
                if QApplication.queryKeyboardModifiers() != (
                        Qt.KeyboardModifier.AltModifier | Qt.KeyboardModifier.ShiftModifier):
                    self.closeEventSettings()  # it takes quite some time to write the >1000 setting items
                #                gc.collect() # this takes quite some time
                QApplication.exit()
                return True
            # self.quitAction.setEnabled(True)
            return False
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            # self.quitAction.setEnabled(True)
            return False

    def closeserialports(self) -> None:
        # close main instrument port
        self.ser.closeport()
        # close extra device ports
        for exser in self.extraser:
            try:
                if exser.SP.is_open:
                    exser.SP.close()
                    libtime.sleep(0.7)  # on OS X opening a serial port too fast after closing the port gets disabled
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
        # close modbus port
        self.modbus.disconnect()
        # close s7 port
        self.s7.disconnect()
        # close scale port
        try:
            if self.scale:
                self.scale.closeport()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        # close color meter port
        try:
            if self.color:
                self.color.closeport()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def fileQuit(self, _: bool = False) -> None:
        self.closeApp()

    @pyqtSlot()
    @pyqtSlot(bool)
    def filePrint(self, _: bool = False) -> None:
        image = self.qmc.grab().toImage()  # a QImage on macOS
        if image.isNull():
            return
        if self.printer is None:
            self.printer = QPrinter(QPrinter.PrinterMode.HighResolution)  # (QPrinter.PrinterMode.PrinterResolution)
        if self.printer is not None:
            self.printer.setCreator(application_name)
            #            self.printer.setResolution(300)
            form = QPrintDialog(self.printer, self)
            if form.exec():
                # painter coordinates
                painter = QPainter(self.printer)
                rect = painter.viewport()
                # image coordinates
                size = image.size()
                rect_size = rect.size()
                graph_height = size.height()
                rect_size.setHeight(int(round(rect_size.height() * self.devicePixelRatio())))
                rect_size.setWidth(int(round(rect_size.width() * self.devicePixelRatio())))
                size.scale(rect_size, Qt.AspectRatioMode.KeepAspectRatio)
                painter.setViewport(rect.x(), rect.y(), size.width(), size.height())  # sets device coordinate system
                image_rect = image.rect()
                #            image_rect.setHeight(int(round(image_rect.height()/self.devicePixelRatio())))
                #            image_rect.setWidth(int(round(image_rect.width()/self.devicePixelRatio())))
                painter.setWindow(image_rect)  # scale to fit page # sets logical coordinate system
                if isinstance(image, QPixmap):
                    painter.drawPixmap(0, 0, image)
                else:
                    painter.drawImage(0, 0, image)
                if self.comparator is not None and self.qpc and len(self.splitter.sizes()) > 1 and \
                        self.splitter.sizes()[1] > 0:
                    phases_image = self.qpc.grab().toImage()  # a QImage on macOS
                    if not phases_image.isNull():
                        if self.printer.pageLayout().orientation() == QPageLayout.Orientation.Landscape:
                            self.printer.newPage()
                            offset = 0
                        else:
                            offset = int(round(
                                graph_height / self.devicePixelRatio()))  # put the phases graph below the profile graph
                        size = phases_image.size()
                        rect_size = rect.size()
                        rect_size.setHeight(int(round(rect_size.height() * self.devicePixelRatio())))
                        rect_size.setWidth(int(round(rect_size.width() * self.devicePixelRatio())))
                        size.scale(rect_size, Qt.AspectRatioMode.KeepAspectRatio)
                        painter.setViewport(rect.x(), rect.y(), size.width(),
                                            size.height())  # sets device coordinate system
                        image_rect = phases_image.rect()
                        #            image_rect.setHeight(int(round(image_rect.height()/self.devicePixelRatio())))
                        #            image_rect.setWidth(int(round(image_rect.width()/self.devicePixelRatio())))
                        painter.setWindow(image_rect)  # scale to fit page # sets logical coordinate system
                        if isinstance(phases_image, QPixmap):
                            painter.drawPixmap(0, 0, phases_image)
                        else:
                            painter.drawImage(0, offset, phases_image)
                painter.end()
                del painter

    # takes a production data generated by profileProductionData(profile) and extracts the following as keyed (mostly) string values in a dict:
    #  . "id"
    #  . "nr"
    #  . "time" (as string, rendered with data and time separated by a space)
    #  . "datetime" (epoch, not a string!)
    #  . "date"
    #  . "time"
    #  . "title"
    #  . "beans"
    #  . "weight_in"
    #  . "weight_out"
    #  . "weight_loss"
    #  . "weight_in_num" (numeric in g)
    #  . "weight_out_num" (numeric in g)
    #  . "weight_loss_num" (numeric in %)
    #  . "whole_color"
    #  . "ground_color"
    #  . "color_system"
    #  . "roastertype"
    #  . "roastersize"
    #  . "beansize_min"
    #  . "beansize_max"
    #  . "roastingnotes"
    #  . "cuppingnotes"
    def productionData2string(self, data: 'ProductionData', units: bool = True) -> 'ProductionDataStr':
        data_roastdate = QDateTime(QDate.currentDate(), QTime())  # we just take the local time
        time = ''
        if 'roastdate' in data and data['roastdate'] is not None:
            data_roastdate = data['roastdate']
        data_date = data_roastdate.date()
        data_time = data_roastdate.time()
        if data_date is not None:
            time = data_date.toString('yy-MM-dd')  # Qt.DateFormat.SystemLocaleShortDate, Qt.DateFormat.ISODate
            if data_time is not None:
                time += time + data_time.toString('HH:mm')  # Qt.DateFormat.SystemLocaleShortDate, Qt.DateFormat.ISODate
        # weight
        weight_in = ''
        weight_out = ''
        weight_loss = ''
        weight_in_num = 0.
        weight_out_num = 0.
        weight_loss_num = 0.
        if 'weight' in data and data['weight'] is not None:
            w = data['weight']
            unit = self.qmc.weight[2]
            wi = self.convertWeight(w[0], self.qmc.weight_units.index(w[2]), self.qmc.weight_units.index(unit))
            wo = self.convertWeight(w[1], self.qmc.weight_units.index(w[2]), self.qmc.weight_units.index(unit))
            if unit in {'Kg', 'lb', 'oz'}:
                weight_in = f'{wi:.3f}'
                weight_out = f'{wo:.3f}'
            else:
                weight_in = f'{wi:.0f}'
                weight_out = f'{wo:.0f}'
            un = self.qmc.weight[2].lower()
            loss = self.weight_loss(w[0], w[1])
            weight_loss = f'{loss:.1f}' if 0 < loss < 100 else ''
            weight_in_num = self.convertWeight(w[0], self.qmc.weight_units.index(w[2]),
                                               self.qmc.weight_units.index('g'))
            weight_out_num = self.convertWeight(w[1], self.qmc.weight_units.index(w[2]),
                                                self.qmc.weight_units.index('g'))
            weight_loss_num = loss
            if units:
                if wi > 0:
                    weight_in += un
                if wo > 0:
                    weight_out += un
                if 0 < loss < 100:
                    weight_loss += '%'

        res: 'ProductionDataStr' = {
            # id (prefix+nr)
            'nr': str(data.get('batchnr', '')),
            'id': (
                (data.get('batchprefix', '') + str(data.get('batchnr', ''))) if (data.get('batchnr', 0) != 0) else ''),
            # title
            'title': data.get('title', ''),
            # date and time
            'datetime': data_roastdate.toPyDateTime(),  # not a string but a datetime object
            'time': time,
            # beans
            'beans': data.get('beans', ''),
            # weight
            'weight_in': weight_in,
            'weight_out': weight_out,
            'weight_loss': weight_loss,
            'weight_in_num': weight_in_num,
            'weight_out_num': weight_out_num,
            'weight_loss_num': weight_loss_num,
            'whole_color': data.get('whole_color', 0),
            'ground_color': data.get('ground_color', 0),
            'color_system': data.get('color_system', ''),
            'roastertype': data.get('roastertype', ''),
            'roastersize': data.get('roastersize', 0),
            'beansize_min': data.get('beansize_min', 0),
            'beansize_max': data.get('beansize_max', 0),
            'roastingnotes': data.get('roastingnotes', ''),
            'cuppingnotes': data.get('cuppingnotes', '')
        }
        return res

    def productionData2htmlentry(self, data: 'ProductionData') -> str:
        import string as libstring
        HTML_REPORT_TEMPLATE = """<tr>
<td sorttable_customkey=\"$batch_num\">$batch</td>
<td>$time</td>
<td>$title</td>
<td>$beans</td>
<td sorttable_customkey=\"$in_num\">$weightin</td>
<td sorttable_customkey=\"$out_num\">$weightout</td>
<td sorttable_customkey=\"$loss_num\">$weightloss</td>
</tr>"""
        ds: 'ProductionDataStr' = self.productionData2string(data, units=False)
        batch_html = ds['id']
        time_html = ds['time']
        title_html = ds['title']
        beans_html = ds['beans']
        try:
            if 'roastUUID' in data and data['roastUUID'] is not None and data['roastUUID'] != '':
                roast_uuid = data['roastUUID']
                #                if plus.register.getPath(roast_uuid):
                #                    title_html = f'<a href="artisan://roast/{roast_uuid}">{title_html}</a>'
                title_html = f'<a href="artisan://roast/{roast_uuid}">{title_html}</a>'
                if bool(plus.sync.getSync(roast_uuid)):
                    time_html = f'<a href="{plus.util.roastLink(roast_uuid)}" target="_blank">{time_html}</a>'
                if 'plus_coffee' in data and data['plus_coffee'] is not None and data['plus_coffee'] != '':
                    beans_html = f'<a href="{plus.util.coffeeLink(data["plus_coffee"])}" target="_blank">{beans_html}</a>'
        except Exception:  # pylint: disable=broad-except
            pass
        return libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
            batch_num=ds['nr'],
            batch=batch_html,
            time=time_html,
            title=title_html,
            beans=beans_html,
            weightin=ds['weight_in'],
            weightout=ds['weight_out'],
            weightloss=ds['weight_loss'],
            in_num=f"{ds['weight_in_num']:.0f}",
            out_num=f"{ds['weight_out_num']:.0f}",
            loss_num=f"{ds['weight_loss_num']:.2f}",
        )

    # extracts the following from a give profile dict in a new dict:
    #  . "batchprefix": string
    #  . "batchnr": int
    #  . "title": string
    #  . "roastdate": QDateTime
    #  . "beans": string
    #  . "weight": [<weight-in>:float,<weight-out>:float,<units>: string] or None
    @staticmethod
    def profileProductionData(profile: Dict[str, Any]) -> 'ProductionData':
        res: ProductionData = {}
        # id ("prefix+nr (sequence)")
        if 'roastbatchprefix' in profile:
            batchprefix_str = decodeLocal(profile['roastbatchprefix'])
            if batchprefix_str is not None:
                res['batchprefix'] = batchprefix_str
            else:
                res['batchprefix'] = ''
        else:
            res['batchprefix'] = ''
        # batch number
        if 'roastbatchnr' in profile:
            res['batchnr'] = int(profile['roastbatchnr'])
        else:
            res['batchnr'] = 0
        # UUID
        if 'roastUUID' in profile:
            res['roastUUID'] = profile['roastUUID']
        # plus_coffee
        if 'plus_coffee' in profile:
            res['plus_coffee'] = profile['plus_coffee']
        # title
        if 'title' in profile:
            title_str = decodeLocal(profile['title'])
            if title_str is not None:
                res['title'] = title_str
            else:
                res['title'] = ''
        else:
            res['title'] = ''
        # date and time
        res['roastdate'] = None
        if 'roastdate' in profile:
            try:
                date_str = decodeLocal(profile['roastdate'])
                if date_str is not None:
                    date = QDate.fromString(date_str)
                    if 'roasttime' in profile:
                        try:
                            time_str = decodeLocal(profile['roasttime'])
                            if time_str is not None:
                                time = QTime.fromString(time_str)
                                res['roastdate'] = QDateTime(date, time)
                            else:
                                res['roastdate'] = QDateTime(date, QTime())
                        except Exception:  # pylint: disable=broad-except
                            res['roastdate'] = QDateTime(date, QTime())
                    else:
                        res['roastdate'] = QDateTime(date, QTime())
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
        if 'roastisodate' in profile:
            try:
                date_str = decodeLocal(profile['roastisodate'])
                if date_str is not None:
                    date = QDate.fromString(date_str, Qt.DateFormat.ISODate)
                    if 'roasttime' in profile:
                        try:
                            time_str = decodeLocal(profile['roasttime'])
                            if time_str is not None:
                                time = QTime.fromString(time_str)
                                res['roastdate'] = QDateTime(date, time)
                            else:
                                res['roastdate'] = QDateTime(date, QTime())
                        except Exception:  # pylint: disable=broad-except
                            res['roastdate'] = QDateTime(date, QTime())
                    else:
                        res['roastdate'] = QDateTime(date, QTime())
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
        # beans
        if 'beans' in profile:
            beans = decodeLocal(profile['beans'])
            if beans is not None:
                res['beans'] = beans
            else:
                res['beans'] = ''
        else:
            res['beans'] = ''
        # weight
        if 'weight' in profile:
            weight = profile['weight']
            if weight is not None:
                res['weight'] = (weight[0], weight[1], decodeLocalStrict(weight[2], 'g'))
        if 'whole_color' in profile:
            res['whole_color'] = profile['whole_color']
        if 'ground_color' in profile:
            res['ground_color'] = profile['ground_color']
        if 'color_system' in profile:
            res['color_system'] = profile['color_system']
        if 'roastertype' in profile:
            res['roastertype'] = profile['roastertype']
        if 'roastersize' in profile:
            res['roastersize'] = profile['roastersize']
        if 'beansize_min' in profile:
            res['beansize_min'] = profile['beansize_min']
        if 'beansize_max' in profile:
            res['beansize_max'] = profile['beansize_max']
        if 'roastingnotes' in profile:
            res['roastingnotes'] = profile['roastingnotes']
        if 'cuppingnotes' in profile:
            res['whole_color'] = profile['whole_color']
        return res

    @pyqtSlot()
    @pyqtSlot(bool)
    def productionPDFReport(self, _: bool = False) -> None:
        self.productionReport(pdf=True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def productionHTMLReport(self, _: bool = False) -> None:
        self.productionReport()

    def productionReport(self, pdf: bool = False) -> None:
        import string as libstring
        # get profile filenames
        files = self.reportFiles()
        try:
            if files and len(files) > 0:
                profiles = [self.deserialize(f) for f in files]
                # let's sort by isodate
                profiles = sorted(profiles,
                                  key=lambda p: (QDateTime(QDate.fromString(p['roastisodate'], Qt.DateFormat.ISODate),
                                                           QTime.fromString(p['roasttime'])).toMSecsSinceEpoch()
                                                 if p is not None and 'roastisodate' in p and 'roasttime' in p else 0))
                with open(getResourcePath() + 'report-template.htm', encoding='utf-8') as myfile:
                    HTML_REPORT_TEMPLATE = myfile.read()
                entries = ''
                total_in = 0.
                total_out = 0.
                unit = self.qmc.weight[2]
                # collect data
                for p in profiles:
                    d = self.profileProductionData(p)
                    weight = d['weight']
                    last_unit = (weight[2] if weight is not None else 'kg')
                    total_in += (self.convertWeight(weight[0], self.qmc.weight_units.index(last_unit),
                                                    self.qmc.weight_units.index(unit)) if weight is not None else 0)
                    total_out += (self.convertWeight(weight[1], self.qmc.weight_units.index(last_unit),
                                                     self.qmc.weight_units.index(unit)) if weight is not None else 0)
                    entries += self.productionData2htmlentry(d) + '\n'

                html = libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
                    title=QApplication.translate('HTML Report Template', 'Roast Batches'),
                    entries=entries,
                    total_in=(f'{total_in:.2f}' if unit in {'Kg', 'lb', 'oz'} else f'{total_in:.0f}'),
                    total_out=(f'{total_out:.2f}' if unit in {'Kg', 'lb', 'oz'} else f'{total_out:.0f}'),
                    total_loss=f'{self.weight_loss(total_in, total_out):.1f}',
                    resources=str(getResourcePath()),
                    batch=QApplication.translate('HTML Report Template', 'Batch'),
                    time=QApplication.translate('HTML Report Template', 'Date'),
                    profile=QApplication.translate('Label', 'Title'),
                    beans=QApplication.translate('HTML Report Template', 'Beans'),
                    weightin=QApplication.translate('HTML Report Template', 'In'),
                    weightout=QApplication.translate('HTML Report Template', 'Out'),
                    loss=QApplication.translate('HTML Report Template', 'Loss'),
                    sum=QApplication.translate('HTML Report Template', 'SUM'),
                    unit=unit.lower()
                )

                f = None
                try:
                    tmpdir = str(QDir.tempPath() + '/')
                    filename = str(QDir(tmpdir).filePath('ProductionReport.html'))
                    try:
                        os.remove(filename)
                    except OSError:
                        pass
                    import codecs
                    with codecs.open(filename, 'w', encoding='utf-8') as f:
                        for ht in html:
                            f.write(ht)
                    if platform.system() == 'Darwin':
                        full_path = 'file://' + filename  # Safari refuses to load the javascript lib (sorttable) otherwise
                    else:
                        full_path = 'file:///' + filename  # Explorer refuses to start otherwise
                    if pdf:
                        # select file
                        filename = self.ArtisanSaveFileDialog(msg='Export PDF', ext='*.pdf')
                        if filename:
                            self.html2pdf(full_path, filename, landscape=True)
                    else:
                        QDesktopServices.openUrl(QUrl(full_path, QUrl.ParsingMode.TolerantMode))

                except OSError as e:
                    self.qmc.adderror(
                        (QApplication.translate('Error Message', 'IO Error:') + ' productionReport() {0}').format(
                            str(e)))
                finally:
                    if f:
                        f.close()
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' productionReport() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def saveStatistics(self, _: bool = False) -> None:
        if self.qmc.ax is None:
            return
        try:
            self.qmc.redraw()
            QApplication.processEvents()
            # 0. MPL coordinate systems & transformations:
            #   https://matplotlib.org/3.1.1/tutorials/advanced/transforms_tutorial.html
            # 1.get bounding box in axis coordinates
            if self.qmc.stats_summary_rect is not None:
                try:
                    rect_extents = self.qmc.stats_summary_rect.get_bbox()
                except Exception:  # pylint: disable=broad-except
                    self.sendmessage(QApplication.translate('Message', 'No statistics found'))
                    return
            else:
                return
            # 2. convert those to display coordinates
            rect_extents_display = self.qmc.ax.transData.transform(rect_extents)
            # 3. convert display coordinates to figure-inches
            rect_extents_bbox_inches = self.qmc.fig.dpi_scale_trans.inverted().transform(rect_extents_display)
            # 4. generate
            rect_bbox_inches = Bbox.from_extents(*list(rect_extents_bbox_inches))
            # 5. fig.save
            # MPL 3.1.1 does not properly handle saving pdf on Windows when figure dpi not 72.  Maybe fixed in a future version.
            # ref: https://github.com/matplotlib/matplotlib/issues/15497#issuecomment-548072609
            ext = '*.png' if platform.system() == 'Windows' else '*.pdf'
            filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Statistics'), ext=ext)
            if filename:
                self.qmc.fig.set_layout_engine('none')
                self.qmc.fig.savefig(filename, bbox_inches=rect_bbox_inches, pad_inches=0)
                self.qmc.fig.set_layout_engine('tight', **self.qmc.tight_layout_params)
                self.sendmessage(QApplication.translate('Message', 'Statistics Saved'))

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _a, _b, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' saveStatistics() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def productionCSVReport(self, _: bool = False) -> None:
        import csv
        # get profile filenames
        profiles = self.reportFiles()
        if profiles and len(profiles) > 0:
            # select file
            filename = self.ArtisanSaveFileDialog(msg='Export CSV', ext='*.csv')
            if filename:
                try:
                    # write header
                    with open(filename, 'w', newline='', encoding='utf-8') as outfile:
                        writer = csv.writer(outfile, delimiter='\t')
                        writer.writerow(
                            ['batch', 'time', 'profile', 'beans', 'in (g)', 'out (g)', 'loss (%)', 'date', 'time',
                             f'in ({self.qmc.weight[2].lower()})', f'out ({self.qmc.weight[2].lower()})',
                             'whole color', 'ground color', 'color system', 'machine', 'capacity (kg)', 'beansize min',
                             'beansize max', 'roasting notes', 'cupping notes'])
                        # write data
                        #                        c = 1
                        short_date_format = QLocale().dateFormat(QLocale.FormatType.ShortFormat)
                        for p in profiles:
                            try:
                                d = self.productionData2string(self.profileProductionData(self.deserialize(p)),
                                                               units=False)
                                dt = QDateTime.fromMSecsSinceEpoch(int(round(d['datetime'].timestamp() * 1000)))
                                writer.writerow([
                                    s2a(d['id']),
                                    s2a(d['time']),
                                    s2a(d['title']),
                                    s2a(d['beans']),
                                    f"{d['weight_in_num']:.0f}",
                                    f"{d['weight_out_num']:.0f}",
                                    f"{d['weight_loss_num']:.1f}",
                                    s2a(dt.date().toString(short_date_format)),
                                    s2a(dt.time().toString(short_date_format)),
                                    s2a(d['weight_in']),
                                    s2a(d['weight_out']),
                                    d['whole_color'],
                                    d['ground_color'],
                                    s2a(d['color_system']),
                                    s2a(d['roastertype']),
                                    d['roastersize'],
                                    d['beansize_min'],
                                    d['beansize_max'],
                                    s2a(d['roastingnotes']),
                                    s2a(d['cuppingnotes']),
                                ])
                            #                                c += 1
                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)

    #    @staticmethod
    #    def excel_date(date_time) -> float:
    #        delta = date_time - datetime.datetime(1899, 12, 30, tzinfo=datetime.timezone.utc)
    #        return float(delta.days  - 1462) + (float(delta.seconds) / 86400)

    @pyqtSlot()
    @pyqtSlot(bool)
    def productionExcelReport(self, _: bool = False) -> None:
        # get profile filenames
        profiles = self.reportFiles()
        if profiles and len(profiles) > 0:
            # select file
            filename = self.ArtisanSaveFileDialog(msg='Export Excel', ext='*.xlsx')
            if filename:
                try:
                    # open file
                    from openpyxl import Workbook  # pylint: disable=unused-import
                    from openpyxl.utils.cell import \
                        get_column_letter  # @UnusedImport # pylint: disable=unused-import # noqa: F401
                    from openpyxl.styles import Font, Fill  # @UnusedImport # pylint: disable=unused-import # noqa: F401
                    wb = Workbook()
                    ws: Optional[
                        Worksheet] = wb.active  # type: ignore # Incompatible types in assignment (expression has type "Optional[_WorkbookChild]", variable has type "Optional[Worksheet]")

                    if ws is not None:
                        ws.title = QApplication.translate('HTML Report Template', 'Production Report')

                        bf = Font(bold=True)
                        unit = self.qmc.weight[2]

                        # write header
                        ws['A1'] = QApplication.translate('HTML Report Template', 'Batch')
                        ws['A1'].font = bf
                        ws['B1'] = QApplication.translate('HTML Report Template', 'Time')
                        ws['B1'].font = bf
                        ws.column_dimensions['B'].width = 18
                        ws['C1'] = QApplication.translate('HTML Report Template', 'Profile')
                        ws['C1'].font = bf
                        ws.column_dimensions['C'].width = 25
                        ws['D1'] = QApplication.translate('HTML Report Template', 'Beans')
                        ws['D1'].font = bf
                        ws.column_dimensions['D'].width = 25
                        ws['E1'] = QApplication.translate('HTML Report Template', 'In') + ' (' + str(unit.lower()) + ')'
                        ws['E1'].font = bf
                        ws['F1'] = QApplication.translate('HTML Report Template', 'Out') + ' (' + str(
                            unit.lower()) + ')'
                        ws['F1'].font = bf
                        ws['G1'] = QApplication.translate('HTML Report Template', 'Loss')
                        ws['G1'].font = bf

                        def avgFormat(c: int, r1: str, r2: str) -> str:
                            e1 = f'{r1}{c}'
                            e2 = f'{r2}{c}'
                            return '=IF(' + e1 + '=0,0,(' + e1 + ' - ' + e2 + ') / ' + e1 + ')'

                        # write data
                        if unit in {'Kg', 'lb', 'oz'}:
                            num_format = '0.00'
                        else:
                            num_format = '0'
                        c = 1
                        for p in profiles:
                            try:
                                raw_data = self.profileProductionData(self.deserialize(p))
                                c += 1
                                d = self.productionData2string(raw_data, units=False)
                                ws[f'A{c}'] = d['id']
                                ws[f'B{c}'] = QDateTime(d[
                                                            'datetime']).toPyDateTime()  # type: ignore # Incompatible types in assignment (expression has type "datetime", target has type "str")
                                ws[f'B{c}'].number_format = 'YYYY-MM-DD HH:MM'
                                ws[f'C{c}'] = d['title']
                                ws[f'D{c}'] = d['beans']
                                weight = raw_data['weight']
                                w_in = (self.convertWeight(weight[0], self.qmc.weight_units.index(weight[2]),
                                                           self.qmc.weight_units.index(
                                                               unit)) if weight is not None else 0)
                                w_out = (self.convertWeight(weight[1], self.qmc.weight_units.index(weight[2]),
                                                            self.qmc.weight_units.index(
                                                                unit)) if weight is not None else 0)
                                ws[
                                    f'E{c}'] = w_in  # type: ignore # Incompatible types in assignment (expression has type "float", target has type "str")
                                ws[f'E{c}'].number_format = num_format
                                ws[
                                    f'F{c}'] = w_out  # type: ignore # Incompatible types in assignment (expression has type "float", target has type "str")
                                ws[f'F{c}'].number_format = num_format
                                ws[f'G{c}'] = avgFormat(c, 'E', 'F')
                                ws[f'G{c}'].number_format = '0.0%'
                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                        # write trailer
                        if c > 1:
                            ws[f'A{c + 1}'] = QApplication.translate('HTML Report Template', 'SUM')
                            ws[f'A{c + 1}'].font = bf
                            ws[f'E{c + 1}'] = f'=SUM(E2:E{c})'
                            ws[f'E{c + 1}'].font = bf
                            ws[f'E{c + 1}'].number_format = num_format
                            ws[f'F{c + 1}'] = f'=SUM(F2:F{c})'
                            ws[f'F{c + 1}'].font = bf
                            ws[f'F{c + 1}'].number_format = num_format
                            ws[f'G{c + 1}'] = avgFormat(c + 1, 'E', 'F')
                            ws[f'G{c + 1}'].font = bf
                            ws[f'G{c + 1}'].number_format = '0.0%'
                    wb.save(filename)
                    self.sendmessage(
                        QApplication.translate('Message', 'Excel Production Report exported to {0}').format(filename))
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
                    _a, _b, exc_tb = sys.exc_info()
                    self.qmc.adderror(
                        (QApplication.translate('Error Message', 'Exception:') + ' productionExcelReport() {0}').format(
                            str(e)), getattr(exc_tb, 'tb_lineno', '?'))

    # extracts the following from a give profile dict in a new dict:
    #  . "temp_unit": string (temperature unit, F or C)
    #  . "timex" : [] array of sample times
    #  . "temp2" : [] array of temperatures
    #  . "charge_temp": int
    #  . "FCs_time": int (in seconds)
    #  . "FCs_temp": string
    #  . "DROP_time": int (in seconds)
    #  . "DROP_temp": string
    #  . "DRY_percent": float (first phase percentage)
    #  . "MAI_percent": float (second phase percentage)
    #  . "DEV_percent": float (third phase percentage)
    #  . "DRY_time": int (in seconds)
    #  . "MAI_time": int (in seconds)
    #  . "DEV_time": int (in seconds)
    #  . "AUC": int
    #  . "color": int
    #  . "cup": int
    #  . "energy": float in kWh
    #  . "co2": float in g
    #  . "co2kg": float in g
    def profileRankingData(self, profile: Dict[str, Any]) -> Dict[str, Any]:
        res: Dict[str, Any] = {}
        # temp_unit
        res['temp_unit'] = profile['mode']
        timex = profile['timex']
        res['timex'] = timex
        timeindex = [max(0, v) if i > 0 else max(-1, v) for i, v in enumerate(profile['timeindex'])]
        res['charge_idx'] = (timeindex[0] if timeindex[0] > -1 else 0)
        res['drop_idx'] = (timeindex[6] if timeindex[6] > 0 else len(timex))
        bt = profile['temp2']
        res['temp'] = bt
        # charge_temp
        if timeindex[0] > -1:
            start = timex[timeindex[0]]
            res['charge_temp'] = bt[timeindex[0]]
        else:
            start = 0
        if timeindex[2] > 0:
            # FCs_time
            res['FCs_time'] = timex[timeindex[2]] - start
            # FCs_temp
            res['FCs_temp'] = bt[timeindex[2]]
        if timeindex[6] > 0:
            # DROP_time
            res['DROP_time'] = timex[timeindex[6]] - start
            # DROP_temp
            res['DROP_temp'] = bt[timeindex[6]]
        if len(timex) > timeindex[6]:
            total_time = timex[timeindex[6]] - start
        else:
            total_time = 0
        # DRY_time
        if timeindex[1] > 0:
            # DRY_time
            dry_time = timex[timeindex[1]] - start
            # DRY_percent
            if total_time > 0:
                res['DRY_percent'] = (dry_time / total_time) * 100.
            else:
                res['DRY_percent'] = 0
            res['DRY_time'] = dry_time
        # MAI_time
        if timeindex[1] > 0 and timeindex[2] > 0:
            # MAI_time
            mai_time = timex[timeindex[2]] - timex[timeindex[1]]
            # MAI_percent
            if total_time > 0:
                res['MAI_percent'] = (mai_time / total_time) * 100.
            else:
                res['MAI_percent'] = 0
            res['MAI_time'] = mai_time
        if timeindex[2] > 0 and timeindex[6] > 0:
            # DEV_time
            dev_time = timex[timeindex[6]] - timex[timeindex[2]]
            # DEV_percent
            if total_time > 0:
                res['DEV_percent'] = (dev_time / total_time) * 100.
            else:
                res['DEV_percent'] = 0
            res['DEV_time'] = dev_time
        # AUC
        if 'computed' in profile:
            comp = profile['computed']
            if 'AUC' in comp:
                res['AUC'] = comp['AUC']
            if 'BTU_batch' in comp:
                res['energy'] = self.qmc.convertHeat(comp['BTU_batch'], 0, 3)
            if 'CO2_batch' in comp:
                res['co2'] = comp['CO2_batch']
            if 'CO2_batch_per_green_kg' in comp:
                res['co2kg'] = comp['CO2_batch_per_green_kg']
        # color
        if 'ground_color' in profile:
            res['color'] = profile['ground_color']
        # cup
        if 'flavors' in profile:
            res['cupping'], _ = self.cuppingSum(profile['flavors'])
        return res

    # takes ranking data generated by profileRankingData(profile) and extracts the following as keyed string values in a dict:
    #  . "charge_temp"
    #  . "FCs_time"
    #  . "FCs_temp"
    #  . "DROP_time"
    #  . "DROP_temp"
    #  . "DRY_percent"
    #  . "MAI_percent"
    #  . "DEV_percent"
    #  . "AUC"
    #  . "color"
    #  . "cupping"
    #  . "energy"
    #  . "co2"
    #  . "co2kg"
    def rankingData2string(self, data: Dict[str, Any], units: bool = True) -> Dict[str, str]:
        res: Dict[str, str] = {}
        res['charge_temp_num'] = (
            f"{convertTemp(float(data['charge_temp']), (data['temp_unit'] if units else ''), self.qmc.mode):.2f}" if 'charge_temp' in data else '0')
        res['charge_temp'] = self.formatTemp(data, 'charge_temp', data['temp_unit'], units)
        res['FCs_time_num'] = (str(data['FCs_time']) if 'FCs_time' in data else '0')
        res['FCs_time'] = (self.eventtime2string(data['FCs_time']) if 'FCs_time' in data else '')
        res['FCs_temp_num'] = (
            f"{convertTemp(float(data['FCs_temp']), (data['temp_unit'] if units else ''), self.qmc.mode):.2f}" if 'FCs_temp' in data else '0')
        res['FCs_temp'] = self.formatTemp(data, 'FCs_temp', data['temp_unit'], units)
        res['DROP_time_num'] = (str(data['DROP_time']) if 'DROP_time' in data else '0')
        res['DROP_time'] = (self.eventtime2string(data['DROP_time']) if 'DROP_time' in data else '')
        res['DROP_temp_num'] = (
            f"{convertTemp(float(data['DROP_temp']), (data['temp_unit'] if units else ''), self.qmc.mode):.2f}" if 'DROP_temp' in data else '0')
        res['DROP_temp'] = self.formatTemp(data, 'DROP_temp', data['temp_unit'], units)
        res['color_num'] = (str(data['color']) if 'color' in data else '0')
        res['color'] = (f"{('#' if units else '')}{data['color']}" if 'color' in data and data['color'] != 0 else '')
        res['cupping'] = f"{data['cupping']:.2f}"
        res['DRY_percent_num'] = (f"{data['DRY_percent']:.1f}" if 'DRY_percent' in data else '0')
        res['DRY_percent'] = (f"{data['DRY_percent']:.1f}{('%' if units else '')}" if 'DRY_percent' in data else '')
        res['MAI_percent_num'] = (f"{data['MAI_percent']:.1f}" if 'MAI_percent' in data else '0')
        res['MAI_percent'] = (f"{data['MAI_percent']:.1f}{('%' if units else '')}" if 'MAI_percent' in data else '')
        res['DEV_percent_num'] = (f"{data['DEV_percent']:.1f}" if 'DEV_percent' in data else '0')
        res['DEV_percent'] = (f"{data['DEV_percent']:.1f}{('%' if units else '')}" if 'DEV_percent' in data else '')
        res['AUC_num'] = data.get('AUC', '0')
        res['AUC'] = data.get('AUC', '')
        res['energy_num'] = (f"{data['energy']:.1f}" if 'energy' in data else '0')
        res['energy'] = (f"{data['energy']:.1f}{'kWh' if units else ''}" if 'energy' in data else '')
        res['co2_num'] = (f"{data['co2']:.1f}" if 'co2' in data else '0')
        res['co2'] = (f"{data['co2']:.1f}{'g' if units else ''}" if 'co2' in data else '')
        res['co2kg_num'] = (f"{data['co2kg']:.1f}" if 'co2kg' in data else '0')
        res['co2kg'] = (f"{data['co2kg']:.1f}{'g' if units else ''}" if 'co2kg' in data else '')
        return res

    @staticmethod
    def rankingdataDef() -> Tuple[List[List[str]], List[str]]:
        field_index: List[str] = [
            'fld',  # field name as used in source list or an eval string
            'src',  # data source from where to pull fld [prof,comp,rank,prod,eval,]
            'typ',  # content type [text,int,float1,float2,float4,text2float1,text2float2,text2int,percent,time,bool,]
            'test0',  # test for a zero value and substitute an empty string
            'units',  # conversion units [temp,weight,volume,ror,] or maxlen when typ=="text"
            'name',  # translated field name for use in the header
        ]
        ranking_data_fields: List[List[str]] = [
            # fld,                   source,  typ,        test0,    units,   name
            ['id', 'prod', 'text', 'false', '', QApplication.translate('HTML Report Template', 'Batch')],
            ['datetime', 'prod', 'date', 'false', '', QApplication.translate('HTML Report Template', 'Time')],
            ['title', 'prod', 'text', 'false', '60', QApplication.translate('HTML Report Template', 'Profile')],
            ['weightin', 'comp', 'float1', 'false', 'weight',
             QApplication.translate('HTML Report Template', 'Weight In')],
            ['CHARGE_BT', 'comp', 'float1', 'false', 'temp',
             QApplication.translate('HTML Report Template', 'CHARGE BT')],
            ['FCs_time', 'comp', 'time', 'false', '', QApplication.translate('HTML Report Template', 'FCs Time')],
            ['FCs_BT', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'FCs BT')],
            ['DROP_time', 'comp', 'time', 'false', '', QApplication.translate('HTML Report Template', 'DROP Time')],
            ['DROP_BT', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'DROP BT')],
            ['DRY_percent', 'rank', 'percent', 'false', '',
             QApplication.translate('HTML Report Template', 'Dry Percent')],
            ['MAI_percent', 'rank', 'percent', 'false', '',
             QApplication.translate('HTML Report Template', 'MAI Percent')],
            ['DEV_percent', 'rank', 'percent', 'false', '',
             QApplication.translate('HTML Report Template', 'Dev Percent')],
            ['AUC', 'comp', 'int', 'false', '', QApplication.translate('HTML Report Template', 'AUC')],
            ['weight_loss', 'comp', 'percent', 'false', '',
             QApplication.translate('HTML Report Template', 'Weight Loss')],
            ['color', 'rank', 'text2int', 'false', '', QApplication.translate('HTML Report Template', 'Color')],
            ['cupping', 'rank', 'text2int', 'false', '', QApplication.translate('HTML Report Template', 'Cupping')],
            ['roastertype', 'prof', 'text', 'false', '', QApplication.translate('HTML Report Template', 'Roaster')],
            ['roastersize', 'prof', 'float1', 'true', '', QApplication.translate('HTML Report Template', 'Capacity')],
            ['operator', 'prof', 'text', 'false', '', QApplication.translate('HTML Report Template', 'Operator')],
            ['organization', 'prof', 'text', 'false', '',
             QApplication.translate('HTML Report Template', 'Organization')],
            ['drumspeed', 'prof', 'text2int', 'true', '', QApplication.translate('HTML Report Template', 'Drum Speed')],
            ['whole_color', 'prof', 'int', 'true', '', QApplication.translate('HTML Report Template', 'Whole Color')],
            ['ground_color', 'prof', 'int', 'true', '', QApplication.translate('HTML Report Template', 'Ground Color')],
            ['color_system', 'prof', 'text', 'false', '',
             QApplication.translate('HTML Report Template', 'Color System')],
            ['beansize_min', 'prof', 'text2int', 'true', '',
             QApplication.translate('HTML Report Template', 'Screen Min')],
            ['beansize_max', 'prof', 'text2int', 'true', '',
             QApplication.translate('HTML Report Template', 'Screen Max')],
            ['greens_temp', 'prof', 'float1', 'true', 'temp',
             QApplication.translate('HTML Report Template', 'Bean Temp')],
            ['CHARGE_ET', 'comp', 'float1', 'false', 'temp',
             QApplication.translate('HTML Report Template', 'CHARGE ET')],
            ['CHARGE_BT', 'comp', 'float1', 'false', 'temp',
             QApplication.translate('HTML Report Template', 'CHARGE BT')],
            ['TP_time', 'comp', 'time', 'false', '', QApplication.translate('HTML Report Template', 'TP Time')],
            ['TP_ET', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'TP ET')],
            ['TP_BT', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'TP BT')],
            ['DRY_time', 'comp', 'time', 'false', '', QApplication.translate('HTML Report Template', 'DRY Time')],
            ['DRY_ET', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'DRY ET')],
            ['DRY_BT', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'DRY BT')],
            ['FCs_time', 'comp', 'time', 'false', '', QApplication.translate('HTML Report Template', 'FCs Time')],
            ['FCs_ET', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'FCs ET')],
            ['FCs_BT', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'FCs BT')],
            ['FCe_time', 'comp', 'time', 'false', '', QApplication.translate('HTML Report Template', 'FCe Time')],
            ['FCe_ET', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'FCe ET')],
            ['FCe_BT', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'FCe BT')],
            ['SCs_time', 'comp', 'time', 'false', '', QApplication.translate('HTML Report Template', 'SCs Time')],
            ['SCs_ET', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'SCs ET')],
            ['SCs_BT', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'SCs BT')],
            ['SCe_time', 'comp', 'time', 'false', '', QApplication.translate('HTML Report Template', 'SCe Time')],
            ['SCe_ET', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'SCe ET')],
            ['SCe_BT', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'SCe BT')],
            ['DROP_time', 'comp', 'time', 'false', '', QApplication.translate('HTML Report Template', 'DROP Time')],
            ['DROP_ET', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'DROP ET')],
            ['DROP_BT', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'DROP BT')],
            ['COOL_time', 'comp', 'time', 'false', '', QApplication.translate('HTML Report Template', 'COOL Time')],
            ['COOL_ET', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'COOL ET')],
            ['COOL_BT', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'COOL BT')],
            ['totaltime', 'comp', 'time', 'false', '', QApplication.translate('HTML Report Template', 'Total Time')],
            ['dryphasetime', 'comp', 'time', 'false', '',
             QApplication.translate('HTML Report Template', 'Dry Phase Time')],
            ['midphasetime', 'comp', 'time', 'false', '',
             QApplication.translate('HTML Report Template', 'Mid Phase Time')],
            ['finishphasetime', 'comp', 'time', 'false', '',
             QApplication.translate('HTML Report Template', 'Finish Phase Time')],
            ['dry_phase_ror', 'comp', 'float1', 'false', 'ror',
             QApplication.translate('HTML Report Template', 'Dry Phase RoR')],
            ['mid_phase_ror', 'comp', 'float1', 'false', 'ror',
             QApplication.translate('HTML Report Template', 'Mid Phase RoR')],
            ['finish_phase_ror', 'comp', 'float1', 'false', 'ror',
             QApplication.translate('HTML Report Template', 'Finish Phase RoR')],
            ['dry_phase_delta_temp', 'comp', 'float1', 'false', 'tmep',
             QApplication.translate('HTML Report Template', 'Dry Phase Delta BT')],
            ['mid_phase_delta_temp', 'comp', 'float1', 'false', 'temp',
             QApplication.translate('HTML Report Template', 'Mid Phase Delta BT')],
            ['finish_phase_delta_temp', 'comp', 'float1', 'false', 'temp',
             QApplication.translate('HTML Report Template', 'Finish Phase Delta BT')],
            ["dsd['computed']['finish_phase_ror'] * (dsd['computed']['finishphasetime'] / 60)", 'eval', 'float1',
             'false', 'temp', QApplication.translate('HTML Report Template', 'Finish Phase Rise')],
            ['total_ror', 'comp', 'float1', 'false', 'ror',
             QApplication.translate('HTML Report Template', 'Total RoR')],
            ['fcs_ror', 'comp', 'float1', 'false', 'ror', QApplication.translate('HTML Report Template', 'FCs RoR')],
            ['MET', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'MET')],
            ['AUC', 'comp', 'int', 'false', '', QApplication.translate('HTML Report Template', 'AUC')],
            [
                "(dsd['computed']['AUCbegin'] if ('AUCbegin' in dsd['computed'] and 'AUCfromeventflag' in dsd['computed'] and dsd['computed']['AUCfromeventflag']) else '')",
                'eval', 'text', 'false', '', QApplication.translate('HTML Report Template', 'AUC Begin')],
            ['AUCbase', 'comp', 'float1', 'false', 'temp', QApplication.translate('HTML Report Template', 'AUC Base')],
            ['dry_phase_AUC', 'comp', 'int', 'false', '',
             QApplication.translate('HTML Report Template', 'Dry Phase AUC')],
            ['mid_phase_AUC', 'comp', 'int', 'false', '',
             QApplication.translate('HTML Report Template', 'Mid Phase AUC')],
            ['finish_phase_AUC', 'comp', 'int', 'false', '',
             QApplication.translate('HTML Report Template', 'Finish Phase AUC')],
            ['weightin', 'comp', 'float1', 'false', 'weight',
             QApplication.translate('HTML Report Template', 'Weight In')],
            ['weightout', 'comp', 'float1', 'false', 'weight',
             QApplication.translate('HTML Report Template', 'Weight Out')],
            ['weight_loss', 'comp', 'percent', 'false', '',
             QApplication.translate('HTML Report Template', 'Weight Loss')],
            ['volumein', 'comp', 'float1', 'false', 'volume',
             QApplication.translate('HTML Report Template', 'Volume In')],
            ['volumeout', 'comp', 'float1', 'false', 'volume',
             QApplication.translate('HTML Report Template', 'Volume Out')],
            ['volume_gain', 'comp', 'percent', 'false', '',
             QApplication.translate('HTML Report Template', 'Volume Gain')],
            ['green_density', 'comp', 'float1', 'false', '(g/l)',
             QApplication.translate('HTML Report Template', 'Green Density')],
            ['roasted_density', 'comp', 'float1', 'false', '(g/l)',
             QApplication.translate('HTML Report Template', 'Roasted Density')],
            ['moisture_greens', 'comp', 'percent', 'false', '',
             QApplication.translate('HTML Report Template', 'Moisture Greens')],
            ['moisture_roasted', 'comp', 'percent', 'false', '',
             QApplication.translate('HTML Report Template', 'Moisture Roasted')],
            ['moisture_loss', 'comp', 'percent', 'false', '',
             QApplication.translate('HTML Report Template', 'Moisture Loss')],
            ['organic_loss', 'comp', 'percent', 'false', '',
             QApplication.translate('HTML Report Template', 'Organic Loss')],
            ['ambient_humidity', 'comp', 'float1', 'false', '',
             QApplication.translate('HTML Report Template', 'Ambient Humidity')],
            ['ambient_pressure', 'comp', 'float1', 'false', '',
             QApplication.translate('HTML Report Template', 'Ambient Pressure')],
            ['ambient_temperature', 'comp', 'float1', 'false', 'temp',
             QApplication.translate('HTML Report Template', 'Ambient Temperature')],
            ['beans', 'prof', 'text', 'false', '90', QApplication.translate('HTML Report Template', 'Beans')],
            ['roastingnotes', 'prof', 'text', 'false', '90',
             QApplication.translate('HTML Report Template', 'Roasting Notes')],
            ['cuppingnotes', 'prof', 'text', 'false', '90',
             QApplication.translate('HTML Report Template', 'Cupping Notes')],
            ['heavyFC', 'prof', 'bool', 'false', '', QApplication.translate('HTML Report Template', 'Heavy FC')],
            ['lowFC', 'prof', 'bool', 'false', '', QApplication.translate('HTML Report Template', 'Low FC')],
            ['lightCut', 'prof', 'bool', 'false', '', QApplication.translate('HTML Report Template', 'Light Cut')],
            ['darkCut', 'prof', 'bool', 'false', '', QApplication.translate('HTML Report Template', 'Dark Cut')],
            ['drops', 'prof', 'bool', 'false', '', QApplication.translate('HTML Report Template', 'Drops')],
            ['oily', 'prof', 'bool', 'false', '', QApplication.translate('HTML Report Template', 'Oily')],
            ['uneven', 'prof', 'bool', 'false', '', QApplication.translate('HTML Report Template', 'Uneven')],
            ['tipping', 'prof', 'bool', 'false', '', QApplication.translate('HTML Report Template', 'Tipping')],
            ['scorching', 'prof', 'bool', 'false', '', QApplication.translate('HTML Report Template', 'Scorching')],
            ['divots', 'prof', 'bool', 'false', '', QApplication.translate('HTML Report Template', 'Divots')],
            ['mode', 'prof', 'text', 'false', '', QApplication.translate('HTML Report Template', 'Mode')],
            ['BTU_batch', 'comp', 'float1', 'false', '(BTU)',
             QApplication.translate('HTML Report Template', 'BTU Batch')],
            ['BTU_batch_per_green_kg', 'comp', 'float1', 'false', '(BTU)',
             QApplication.translate('HTML Report Template', 'BTU Batch per green kg')],
            ['CO2_batch', 'comp', 'float1', 'false', '(g)',
             QApplication.translate('HTML Report Template', 'CO2 Batch').replace('CO2', 'CO₂')],
            ['BTU_preheat', 'comp', 'float1', 'false', '(BTU)',
             QApplication.translate('HTML Report Template', 'BTU Preheat')],
            ['CO2_preheat', 'comp', 'float1', 'false', '(g)',
             QApplication.translate('HTML Report Template', 'CO2 Preheat').replace('CO2', 'CO₂')],
            ['BTU_bbp', 'comp', 'float1', 'false', '(BTU)', QApplication.translate('HTML Report Template', 'BTU BBP')],
            ['CO2_bbp', 'comp', 'float1', 'false', '(g)',
             QApplication.translate('HTML Report Template', 'CO2 BBP').replace('CO2', 'CO₂')],
            ['BTU_cooling', 'comp', 'float1', 'false', '(BTU)',
             QApplication.translate('HTML Report Template', 'BTU Cooling')],
            ['CO2_cooling', 'comp', 'float1', 'false', '(g)',
             QApplication.translate('HTML Report Template', 'CO2 Cooling').replace('CO2', 'CO₂')],
            ['BTU_roast', 'comp', 'float1', 'false', '(BTU)',
             QApplication.translate('HTML Report Template', 'BTU Roast')],
            ['BTU_roast_per_green_kg', 'comp', 'float1', 'false', '(BTU)',
             QApplication.translate('HTML Report Template', 'BTU Roast per green kg')],
            ['CO2_roast', 'comp', 'float1', 'false', '(g)',
             QApplication.translate('HTML Report Template', 'CO2 Roast').replace('CO2', 'CO₂')],
            ['CO2_batch_per_green_kg', 'comp', 'float1', 'false', '(g)',
             QApplication.translate('HTML Report Template', 'CO2 Batch per green kg').replace('CO2', 'CO₂')],
            ['BTU_LPG', 'comp', 'float1', 'false', '(BTU)', QApplication.translate('HTML Report Template', 'BTU LPG')],
            ['BTU_NG', 'comp', 'float1', 'false', '(BTU)', QApplication.translate('HTML Report Template', 'BTU NG')],
            ['BTU_ELEC', 'comp', 'float1', 'false', '(BTU)',
             QApplication.translate('HTML Report Template', 'BTU ELEC')],
            ['KWH_batch_per_green_kg', 'comp', 'float1', 'false', '(kWh/kg)',
             QApplication.translate('HTML Report Template', 'Efficiency Batch')],
            ['KWH_roast_per_green_kg', 'comp', 'float1', 'false', '(kWh/kg)',
             QApplication.translate('HTML Report Template', 'Efficiency Roast')],
        ]
        return ranking_data_fields, field_index

    def extendedRankingData2List(self, dsd: Optional[Dict[str, Any]] = None, rd: Optional[Dict[str, str]] = None,
                                 pd: Optional['ProductionDataStr'] = None, header: bool = False) -> List[str]:
        if dsd is None:
            dsd = {}
        if rd is None:
            rd = {}
        res = []
        weight_unit = self.qmc.weight[2]
        volume_unit = self.qmc.volume[2]
        temperature_unit = self.qmc.mode
        try:
            ranking_data_fields, field_index = self.rankingdataDef()
            if header:
                for rdf in ranking_data_fields:
                    name = rdf[field_index.index('name')]
                    units = rdf[field_index.index('units')]
                    if units == 'temp':
                        suffix = f' ({temperature_unit})'
                    elif units == 'volume':
                        suffix = f' ({volume_unit})'
                    elif units == 'weight':
                        suffix = f' ({weight_unit})'
                    elif units == 'ror':
                        suffix = f' ({temperature_unit}/min)'
                    elif units.startswith('('):
                        suffix = f' {units}'
                    else:
                        suffix = ''
                    hdr_name = f'{name}{suffix}'
                    res.append(hdr_name)
            else:
                for rdf in ranking_data_fields:
                    name = rdf[field_index.index('name')]
                    fld = rdf[field_index.index('fld')]
                    src = rdf[field_index.index('src')]
                    typ = rdf[field_index.index('typ')]
                    test0 = rdf[field_index.index('test0')]
                    units = rdf[field_index.index('units')]
                    if src == 'comp' and fld in dsd['computed']:
                        res_fld = dsd['computed'][fld]
                    elif src == 'prof' and fld in dsd:
                        res_fld = dsd[fld]
                    elif src == 'rank' and fld in rd:
                        res_fld = rd[fld]
                    elif src == 'prod' and pd is not None and fld in pd:
                        res_fld = pd[
                            fld]  # type: ignore # TypedDict key must be a string literal; expected one of ("id", "nr", "title", "datetime", "time", ...)
                    elif src == 'eval':
                        res_fld = eval(fld)  # pylint: disable=eval-used
                        if res_fld in {'None', None}:
                            res.append('')
                            continue
                    else:
                        res.append('')
                        continue

                    res_fldf: float = toFloat(res_fld)

                    if (test0 == 'true' and res_fldf > 0) or test0 == 'false':
                        if units == 'temp':
                            conv_fld = convertTemp(res_fldf, dsd['mode'], temperature_unit)
                        elif units == 'ror':
                            conv_fld = convertRoRstrict(res_fldf, dsd['mode'], temperature_unit)
                        elif units == 'volume':
                            conv_fld = self.convertVolume(res_fldf, 0, self.qmc.volume_units.index(volume_unit))
                        elif units == 'weight':
                            conv_fld = self.convertWeight(res_fldf, 0, self.qmc.weight_units.index(weight_unit))
                        else:
                            conv_fld = res_fldf

                        if typ == 'text':
                            res.append(f'{conv_fld}')
                        elif typ == 'int':
                            res.append(f'{conv_fld:.0f}')
                        elif typ == 'temp':
                            res.append(f'{conv_fld:.1f}')
                        elif typ == 'float1':
                            res.append(f'{conv_fld:.1f}')
                        elif typ == 'float2':
                            res.append(f'{conv_fld:.2f}')
                        elif typ == 'float4':
                            res.append(f'{conv_fld:.4f}')
                        elif typ == 'text2float1':
                            res.append(f'{toFloat(conv_fld):.1f}')
                        elif typ == 'text2float2':
                            res.append(f'{toFloat(conv_fld):.2f}')
                        elif typ == 'text2int':
                            res.append(f'{toInt(conv_fld):.0f}')
                        elif typ == 'percent':
                            res.append(f'{toFloat(conv_fld):.1f}')
                        elif typ == 'time':
                            m, s = divmod(conv_fld, 60)
                            res.append(f'{int(m):.0f}:{int(s):02.0f}')
                        elif typ == 'date':
                            assert isinstance(res_fld, datetime.datetime)
                            res.append(f'{QDateTime(res_fld).toPyDateTime()}')
                        elif typ == 'bool':
                            res.append(str(res_fld))
                        else:
                            res.append('')
                    else:
                        res.append('')
            return res
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' extendedRankingData2List() {0}').format(
                    str(e)), getattr(exc_tb, 'tb_lineno', '?'))
            return []

    def formatTemp(self, data: Dict[str, Any], k: str, unit: str, units: bool = True) -> str:
        fmt = '{0:.1f}' if self.qmc.LCDdecimalplaces else '{0:.0f}'
        return (fmt.format(convertTemp(data[k], unit, self.qmc.mode)) + (
            self.qmc.mode if units else '') if k in data else '')

    def rankingData2htmlentry(self, production_data: 'ProductionData', ranking_data: Dict[str, Any],
                              plot_color: Optional[List[float]] = None) -> str:
        import string as libstring
        HTML_REPORT_TEMPLATE = """<tr>
<td$color_code>$batch</td>
<td>$time</td>
<td>$title</td>
<td sorttable_customkey=\"$in_num\">$weightin</td>
<td sorttable_customkey=\"$charge_temp_num\">$charge_temp</td>
<td sorttable_customkey=\"$FCs_time_num\">$FCs_time</td>
<td sorttable_customkey=\"$FCs_temp_num\">$FCs_temp</td>
<td sorttable_customkey=\"$DROP_time_num\">$DROP_time</td>
<td sorttable_customkey=\"$DROP_temp_num\">$DROP_temp</td>
<td sorttable_customkey=\"$DRY_percent_num\">$DRY_percent</td>
<td sorttable_customkey=\"$MAI_percent_num\">$MAI_percent</td>
<td sorttable_customkey=\"$DEV_percent_num\">$DEV_percent</td>
<td sorttable_customkey=\"$AUC_num\">$AUC</td>
<td sorttable_customkey=\"$loss_num\">$weightloss</td>
<td sorttable_customkey=\"$color_num\">$color</td>
<td>$cupping</td>
<td sorttable_customkey=\"$energy_num\">$energy</td>
<td sorttable_customkey=\"$co2_num\">$co2</td>
<td sorttable_customkey=\"$co2kg_num\">$co2kg</td>
</tr>"""
        pd = self.productionData2string(production_data, units=False)
        rd = self.rankingData2string(ranking_data, units=False)
        batch_td_color = ''
        if plot_color is not None:
            batch_color: List[float] = [x * 100 for x in plot_color[0:3]]
            batch_color.append(0.7)
            batch_td_color = ' style="background-color: rgba(' + '%,'.join(map(str, batch_color)) + ')"'
        batch_html = pd.get('id', '')
        time_html = pd.get('time', '')
        title_html = pd.get('title', '')
        try:
            if 'roastUUID' in production_data and production_data['roastUUID'] is not None:
                roast_uuid = production_data['roastUUID']
                #                if plus.register.getPath(roast_uuid):
                #                    title_html = '<a href="artisan://roast/{0}">{1}</a>'.format(roast_uuid,title_html)
                title_html = f'<a href="artisan://roast/{roast_uuid}">{title_html}</a>'
                if bool(plus.sync.getSync(roast_uuid)):
                    time_html = f'<a href="{plus.util.roastLink(roast_uuid)}" target="_blank">{time_html}</a>'
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        weight_fmt = ('{0:.2f}' if self.qmc.weight[2] in {'Kg', 'lb', 'oz'} else '{0:.0f}')
        return libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
            color_code=batch_td_color,
            batch=batch_html,
            time=time_html,
            title=title_html,
            in_num=(weight_fmt.format(pd['weight_in_num']) if 'weight_in_num' in pd else ''),
            weightin=pd.get('weight_in', ''),
            charge_temp_num=rd['charge_temp_num'],
            charge_temp=rd['charge_temp'],
            FCs_time_num=rd['FCs_time_num'],
            FCs_time=rd['FCs_time'],
            FCs_temp_num=rd['FCs_temp_num'],
            FCs_temp=rd['FCs_temp'],
            DROP_time_num=rd['DROP_time_num'],
            DROP_time=rd['DROP_time'],
            DROP_temp_num=rd['DROP_temp_num'],
            DROP_temp=rd['DROP_temp'],
            DRY_percent_num=rd['DRY_percent_num'],
            DRY_percent=rd['DRY_percent'],
            MAI_percent_num=rd['MAI_percent_num'],
            MAI_percent=rd['MAI_percent'],
            DEV_percent_num=rd['DEV_percent_num'],
            DEV_percent=rd['DEV_percent'],
            AUC_num=rd['AUC_num'],
            AUC=rd['AUC'],
            loss_num=(f"{pd['weight_loss_num']:.2f}" if 'weight_loss_num' in pd else ''),
            weightloss=pd.get('weight_loss', ''),
            color_num=rd['color_num'],
            color=rd['color'],
            cupping=rd['cupping'],
            energy=rd['energy'],
            energy_num=rd['energy_num'],
            co2=rd['co2'],
            co2_num=rd['co2_num'],
            co2kg=rd['co2kg'],
            co2kg_num=rd['co2kg_num'],
        )

    def reportFiles(self) -> List[str]:
        import zipfile
        import tempfile
        # get profile filenames
        selected_files = self.ArtisanOpenFilesDialog(ext='*.alog *.zip')  # added zip files
        files = []
        for f in selected_files:
            if zipfile.is_zipfile(f):
                with zipfile.ZipFile(f) as zf:
                    ziptmpdir = tempfile.mkdtemp()
                    zf.extractall(ziptmpdir)
                    for n in zf.namelist():
                        nf = os.path.join(ziptmpdir, n)
                        if os.path.splitext(nf)[1] == '.alog':
                            files.append(nf)
            else:  # a normal *.alog file
                files.append(f)
        return files

    @pyqtSlot()
    @pyqtSlot(bool)
    def rankingPDFReport(self, _: bool = False) -> None:
        self.rankingReport(pdf=True)

    @pyqtSlot()
    @pyqtSlot(bool)
    def rankingHTMLReport(self, _: bool = False) -> None:
        self.rankingReport()

    def rankingReport(self, pdf: bool = False) -> None:
        try:
            import string as libstring
            # get profile filenames
            files = self.reportFiles()
            if files and len(files) > 0:
                prev_foreground_profile_path = self.curFile
                prev_backgroundpath = self.qmc.backgroundpath
                prev_background = self.qmc.background
                cont = self.qmc.reset(soundOn=False)
                if cont:
                    profiles = [self.deserialize(f) for f in files]
                    # let's sort by isodate
                    profiles = sorted(profiles,
                                      key=lambda p: (
                                          QDateTime(QDate.fromString(p['roastisodate'], Qt.DateFormat.ISODate),
                                                    QTime.fromString(p['roasttime'])).toMSecsSinceEpoch()
                                          if 'roastisodate' in p and 'roasttime' in p else 0))
                    with open(getResourcePath() + 'ranking-template.htm', encoding='utf-8') as myfile:
                        HTML_REPORT_TEMPLATE = myfile.read()
                    entries = ''
                    charges = 0.
                    charges_count = 0
                    charges_temp = 0.
                    charges_temp_count = 0
                    FCs_time = 0.
                    FCs_time_count = 0
                    FCs_temp = 0.
                    FCs_temp_count = 0
                    DROP_time = 0.
                    DROP_time_count = 0
                    DROP_temp = 0.
                    DROP_temp_count = 0
                    DRY_percent = 0.
                    DRY_percent_count = 0
                    MAI_percent = 0.
                    MAI_percent_count = 0
                    DEV_percent = 0.
                    DEV_percent_count = 0
                    AUC = 0.
                    AUC_count = 0
                    loss = 0.
                    loss_count = 0
                    colors_list = 0.
                    colors_count = 0
                    cuppings = 0.
                    cuppings_count = 0
                    energies = 0.
                    energies_count = 0
                    co2s = 0.
                    co2s_count = 0
                    co2kgs = 0.
                    co2kgs_count = 0
                    handles = []
                    labels = []
                    timex_list = []
                    stemp_list = []
                    cl_list = []
                    max_profiles = 20
                    color = iter(colormaps['tab20'](
                        numpy.linspace(0, 1, max_profiles)))  # @UndefinedVariable # pylint: disable=maybe-no-member
                    # collect data
                    #                    c = 1
                    min_start_time = max_end_time = 0
                    first_profile: bool = True
                    first_profile_event_time = 0
                    max_drop_time = 0
                    label_chr_nr = 0

                    delta_max: float = 1  # computed the delta max over all delta curves if visible

                    for p in profiles:
                        label = ''
                        pd = self.profileProductionData(p)
                        #                        c += 1
                        try:
                            cl = next(color)  # here to keep colors_list in sync with the pct graph colors_list
                        except Exception:  # pylint: disable=broad-except
                            color = iter(colormaps['tab20'](numpy.linspace(0, 1,
                                                                           max_profiles)))  # @UndefinedVariable # pylint: disable=maybe-no-member
                            cl = next(color)
                        try:
                            rd = self.profileRankingData(p)
                        except Exception as e:  # pylint: disable=broad-except
                            _log.exception(e)
                            _, _, exc_tb = sys.exc_info()
                            self.qmc.adderror((QApplication.translate('Error Message',
                                                                      'Exception (probably due to an empty profile):') + ' rankingReport() {0}').format(
                                str(e)), getattr(exc_tb, 'tb_lineno', '?'))
                            continue
                        i: float = 0
                        # o:float = 0
                        if 'weight' in pd and pd['weight'] is not None:
                            i = self.convertWeight(pd['weight'][0], self.qmc.weight_units.index(pd['weight'][2]),
                                                   self.qmc.weight_units.index(self.qmc.weight[2]))
                            # o = self.convertWeight(pd["weight"][1],self.qmc.weight_units.index(pd["weight"][2]),self.qmc.weight_units.index(self.qmc.weight[2]))
                        if i > 0:
                            charges += i
                            charges_count += 1
                        if 'charge_temp' in rd:
                            charges_temp += convertTemp(rd['charge_temp'], rd['temp_unit'], self.qmc.mode)
                            charges_temp_count += 1
                        if 'FCs_time' in rd:
                            FCs_time += rd['FCs_time']
                            FCs_time_count += 1
                        if 'FCs_temp' in rd:
                            FCs_temp += convertTemp(rd['FCs_temp'], rd['temp_unit'], self.qmc.mode)
                            FCs_temp_count += 1
                        if 'DROP_time' in rd:
                            if rd['DROP_time'] > max_drop_time:
                                max_drop_time = rd['DROP_time']
                            DROP_time += rd['DROP_time']
                            DROP_time_count += 1
                        if 'DROP_temp' in rd:
                            DROP_temp += convertTemp(rd['DROP_temp'], rd['temp_unit'], self.qmc.mode)
                            DROP_temp_count += 1
                        if 'DRY_percent' in rd:
                            DRY_percent += rd['DRY_percent']
                            DRY_percent_count += 1
                        if 'MAI_percent' in rd:
                            MAI_percent += rd['MAI_percent']
                            MAI_percent_count += 1
                        if 'DEV_percent' in rd:
                            DEV_percent += rd['DEV_percent']
                            DEV_percent_count += 1
                        # -- recompute AUC with actual settings
                        try:
                            AUCidx = max(0, self.AUCstartidx(p['timeindex'], p['computed']['TP_idx']))
                            if self.qmc.AUCbaseFlag:
                                # we take the base temperature from the BT at st
                                rtbt = p['temp2'][AUCidx]
                            else:
                                rtbt = self.qmc.AUCbase
                            rtbt = convertTemp(rtbt, self.qmc.mode, 'C')
                            ed = min(len(p['timex']), p['timeindex'][6])
                            BT_AUC: float = 0
                            for i in range(AUCidx, ed):
                                BT_AUC += self.calcAUC(rtbt, p['timex'], p['temp2'], i)
                            BT_AUC = int(round(BT_AUC / 60.))
                            rd['AUC'] = BT_AUC
                        except Exception:  # pylint: disable=broad-except
                            # 'TP_index' might not be in computedProfile and then we fail here
                            pass
                        # --
                        if 'AUC' in rd:
                            AUC += rd['AUC']
                            AUC_count += 1

                        if 'weight' in pd and pd['weight'] is not None and pd['weight'][0] > 0 and pd['weight'][1] > 0:
                            l = self.weight_loss(pd['weight'][0], pd['weight'][1])
                            if 0 < l < 100:
                                loss += l
                                loss_count += 1
                        if 'color' in rd and rd['color'] > 0:
                            colors_list += rd['color']
                            colors_count += 1
                        if rd['cupping'] > 0:
                            cuppings += rd['cupping']
                            cuppings_count += 1
                        if 'energy' in rd and rd['energy'] > 0:
                            energies += rd['energy']
                            energies_count += 1
                        if 'co2' in rd and rd['co2'] > 0:
                            co2s += rd['co2']
                            co2s_count += 1
                        if 'co2kg' in rd and rd['co2kg'] > 0:
                            co2kgs += rd['co2kg']
                            co2kgs_count += 1
                        if len(profiles) > max_profiles:
                            entries += self.rankingData2htmlentry(pd, rd, cl) + '\n'
                        # add BT curve to graph
                        elif self.qmc.ax is not None:
                            try:

                                if pd['batchnr'] > 0:
                                    label = pd['batchprefix'] + str(pd['batchnr'])
                                elif label_chr_nr < 26:
                                    label = str(libstring.ascii_uppercase[label_chr_nr])
                                    pd['batchnr'] = 0
                                    pd['batchprefix'] = label
                                    label_chr_nr = label_chr_nr + 1
                                # suppress default description
                                #                            if pd["title"] == QApplication.translate("Scope Title", "Roaster Scope"):
                                #                                pd["title"] = ""

                                entries += self.rankingData2htmlentry(pd, rd, cl) + '\n'

                                temp = [convertTemp(t, rd['temp_unit'], self.qmc.mode) for t in rd['temp']]
                                timex = rd['timex']
                                stemp = self.qmc.smooth_list(timex,
                                                             (fill_gaps(
                                                                 temp) if self.qmc.interpolateDropsflag else temp),
                                                             window_len=self.qmc.curvefilter,
                                                             decay_smoothing=not self.qmc.optimalSmoothing)
                                charge = max(0, rd['charge_idx'])  # start of visible data
                                drop = rd['drop_idx']  # end of visible data
                                stemp = numpy.concatenate((
                                    numpy.full(charge, numpy.nan, dtype=numpy.double),
                                    stemp[charge:drop],
                                    numpy.full(len(timex) - drop, numpy.nan, dtype=numpy.double)))
                                timeindex = [max(0, v) if i > 0 else max(-1, v) for i, v in enumerate(p['timeindex'])]
                                if len(timex) > rd['charge_idx']:
                                    if first_profile:
                                        # align with CHARGE
                                        delta = timex[rd['charge_idx']]
                                        # store relative time of align event of first profile
                                        # CHARGE, DRY, FCs, FCe, SCs, SCe, DROP
                                        first_profile_event_time = delta  # CHARGE
                                        for j in range(6, 0, -1):
                                            if self.qmc.alignEvent in [j] and timeindex[j]:
                                                first_profile_event_time = timex[timeindex[j]] - timex[rd['charge_idx']]
                                                break
                                    else:
                                        delta = timex[rd['charge_idx']]
                                        for j in range(6, 0, -1):
                                            if self.qmc.alignEvent in [j] and timeindex[j]:
                                                delta = delta + (timex[timeindex[j]] - timex[
                                                    rd['charge_idx']] - first_profile_event_time)
                                                break
                                else:
                                    delta = 0
                                timex = [t - delta for t in timex]
                                if len(timex) > charge:
                                    min_start_time = min(min_start_time, timex[charge])
                                if len(timex) > drop:
                                    max_end_time = max(max_end_time, timex[drop])
                                # cut-out only CHARGE to DROP

                                labels.append(label)
                                timex_list.append(timex)
                                stemp_list.append(stemp)
                                cl_list.append(cl)

                                if self.qmc.DeltaBTflag and self.qmc.delta_ax is not None:
                                    tx = numpy.array(timex)
                                    cf = self.qmc.curvefilter  # *2 # we smooth twice as heavy for PID/RoR calculation as for normal curve smoothing
                                    t1 = self.qmc.smooth_list(timex, (
                                        fill_gaps(temp) if self.qmc.interpolateDropsflag else temp), window_len=cf,
                                                              decay_smoothing=not self.qmc.optimalSmoothing)
                                    if len(t1) > 10 and len(tx) > 10:
                                        # we start RoR computation 10 readings after CHARGE to avoid this initial peak
                                        RoR_start = min(rd['charge_idx'] + 10, len(tx) - 1)
                                        deltas: Optional[List[Optional[float]]]
                                        _, deltas = self.qmc.recomputeDeltas(tx, RoR_start, drop, None, t1,
                                                                             optimalSmoothing=self.qmc.optimalSmoothing)
                                        if deltas is not None:
                                            delta_max = max(delta_max,
                                                            self.calcAutoDelta([], deltas, timeindex, False, True))
                                            if self.qmc.BTlinewidth > 1 and self.qmc.BTlinewidth == self.qmc.BTdeltalinewidth:
                                                dlinewidth = self.qmc.BTlinewidth - 1  # we render the delta lines a bit thinner
                                                dlinestyle = self.qmc.BTdeltalinestyle
                                            else:
                                                dlinewidth = self.qmc.BTdeltalinewidth
                                                dlinestyle = self.qmc.BTdeltalinestyle
                                            trans = self.qmc.delta_ax.transData
                                            self.qmc.ax.plot(tx, numpy.array(deltas), transform=trans,
                                                             markersize=self.qmc.BTdeltamarkersize,
                                                             marker=self.qmc.BTdeltamarker,
                                                             sketch_params=None, path_effects=[],
                                                             linewidth=dlinewidth, linestyle=dlinestyle,
                                                             drawstyle=self.qmc.BTdeltadrawstyle, color=cl, alpha=0.7)

                                first_profile = False

                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                                _, _, exc_tb = sys.exc_info()
                                self.qmc.adderror((QApplication.translate('Error Message',
                                                                          'Exception:') + ' rankingReport() {0}').format(
                                    str(e)), getattr(exc_tb, 'tb_lineno', '?'))

                    # draw BT curves on top of all others
                    if self.qmc.ax is not None:
                        for i, txl in enumerate(timex_list):
                            label = labels[i]
                            timex = txl
                            stemp = stemp_list[i]
                            cl = cl_list[i]
                            l_temp, = self.qmc.ax.plot(timex, stemp, markersize=self.qmc.BTmarkersize,
                                                       marker=self.qmc.BTmarker,
                                                       #                        sketch_params=None,path_effects=[PathEffects.withStroke(linewidth=self.qmc.BTlinewidth+self.qmc.patheffects,foreground=path_effects_color)],
                                                       sketch_params=None, path_effects=[],
                                                       linewidth=self.qmc.BTlinewidth, linestyle=self.qmc.BTlinestyle,
                                                       drawstyle=self.qmc.BTdrawstyle, color=cl, label=label)
                            handles.append(l_temp)

                    tmpdir = str(QDir.tempPath() + '/')
                    graph_image = ''
                    graph_image_pct = ''

                    prop = self.mpl_fontproperties.copy()
                    prop.set_size('x-small')

                    if self.qmc.ax is None or len(profiles) > max_profiles:
                        QMessageBox.information(self, QApplication.translate('Message', 'Ranking Report'),
                                                QApplication.translate('Message',
                                                                       'Ranking graphs are only generated up to {0} profiles').format(
                                                    str(max_profiles)))
                    else:
                        try:

                            # remove annotations, lines and other artists from background profile
                            try:
                                self.qmc.ax_annotations_clear()
                                for ll in [
                                    self.qmc.l_back1,
                                    self.qmc.l_back2,
                                    self.qmc.l_back3,
                                    self.qmc.l_back4,
                                    self.qmc.l_delta1B,
                                    self.qmc.l_delta2B
                                ]:
                                    if ll:
                                        try:
                                            ll.remove()
                                        except Exception:  # pylint: disable=broad-except
                                            pass
                                for a in [
                                    self.qmc.l_eventtype1dots,
                                    self.qmc.l_eventtype2dots,
                                    self.qmc.l_eventtype3dots,
                                    self.qmc.l_eventtype4dots,
                                    self.qmc.l_backgroundeventtype1dots,
                                    self.qmc.l_backgroundeventtype2dots,
                                    self.qmc.l_backgroundeventtype3dots,
                                    self.qmc.l_backgroundeventtype4dots]:
                                    if a:
                                        try:
                                            a.remove()
                                        except Exception:  # pylint: disable=broad-except
                                            pass

                                # we also have to remove those extra event annotations if in combo mode
                                if self.qmc.eventsGraphflag == 4:
                                    self.qmc.ax_combo_text_annotations_clear()
                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                            # we only adjust the upper limit of the delta axis automatically
                            if self.qmc.autodeltaxBT and self.qmc.delta_ax is not None:
                                self.qmc.delta_ax.set_ylim(self.qmc.zlimit_min, delta_max)
                            # adjust zgrid
                            if self.qmc.zgrid != 0:
                                d = delta_max - self.qmc.zlimit_min
                                steps = int(round(d / 5))
                                if steps > 50:
                                    steps = int(round(steps / 10)) * 10
                                elif steps > 10:
                                    steps = int(round(steps / 5)) * 5
                                auto_grid = max(2, steps)
                                self.qmc.zgrid = auto_grid
                                if self.qmc.delta_ax is not None:
                                    self.qmc.delta_ax.yaxis.set_major_locator(ticker.MultipleLocator(self.qmc.zgrid))
                                    self.qmc.delta_ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
                            # adjust time limits
                            self.qmc.ax.set_xlim(min_start_time - 15,
                                                 max_end_time + 15)  # we adjust the min, max time scale to ensure all data is visible
                            graph_image = 'roastlog-graph'
                            self.qmc.setProfileTitle('')
                            self.qmc.fig.suptitle('')
                            rcParams['path.effects'] = []
                            if len(handles) > 7:
                                ncol = int(math.ceil(len(handles) / 4.))
                            elif len(handles) > 3:
                                ncol = int(math.ceil(len(handles) / 2.))
                            else:
                                ncol = int(math.ceil(len(handles)))
                            self.qmc.ax.legend(handles, labels, loc=self.qmc.legendloc, ncol=ncol, fancybox=True,
                                               prop=prop, shadow=False)

                            # Remove and update the logo image
                            try:
                                if self.qmc.ai is not None:
                                    self.qmc.ai.remove()
                            except Exception:  # pylint: disable=broad-except
                                pass
                            try:
                                self.qmc.placelogoimage()
                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)

                            # generate graph
                            self.qmc.fig.set_layout_engine('none')
                            self.qmc.fig.canvas.draw()
                            # save graph
                            graph_image = str(QDir.cleanPath(QDir(tmpdir).absoluteFilePath(graph_image + '.svg')))
                            try:
                                os.remove(graph_image)
                            except OSError:
                                pass
                            self.qmc.fig.set_layout_engine('tight', **self.qmc.tight_layout_params)
                            self.qmc.fig.savefig(graph_image, transparent=True)

                            # add some random number to force HTML reloading
                            graph_image = path2url(graph_image)
                            graph_image = graph_image + '?dummy=' + str(int(libtime.time()))
                            graph_image = "<img alt='roast graph' style=\"width:100%;\" src='" + graph_image + "'>"

                        except Exception as e:  # pylint: disable=broad-except
                            _log.exception(e)
                            _, _, exc_tb = sys.exc_info()
                            self.qmc.adderror(
                                (QApplication.translate('Error Message', 'Exception:') + ' rankingReport() {0}').format(
                                    str(e)), getattr(exc_tb, 'tb_lineno', '?'))

                    try:
                        # Create a roast phase visualization graph

                        fig_height = 3.2  # in inches when there are 10 profiles, will be scaled for number of profiles
                        fig_width = 10  # in inches

                        # values that define the bars and spacing
                        barspacer = 2  # vertical space between bars
                        barheight = 18  # height of each bar
                        textoffset = 6  # shifts text annotations upward to toward middle of the bar
                        m = 10  # width of batch number field and drop time field
                        g = 2  # gap
                        n = m + g  # start of horiz stacked bar
                        ind = 7  # width of color legend indicator

                        # setup the font
                        if self.app.darkmode:
                            headerfontcolor = '#B2B2B2'
                        else:
                            headerfontcolor = '#707070'
                        fontcolor = '#303030'
                        lightfontcolor = 'grey'
                        prop.set_family(mpl.rcParams['font.family'])

                        # generate graph  ( not written to support MPL < v2.0 )
                        fig = Figure(figsize=(fig_width, (fig_height * len(profiles) / 10 + 0.2)))

                        ax = fig.add_subplot(111, frameon=False)
                        fig.subplots_adjust(left=0, right=1, top=1, bottom=0)

                        # no grid or tick marks
                        ax.grid(False)
                        if ax.axes is not None:
                            ax.axes.get_xaxis().set_ticks([])
                            ax.axes.get_yaxis().set_ticks([])

                        # set graph xy limits
                        ylim = (barheight + barspacer) * (1 + len(profiles))
                        xlim = m + g + 100 + g + m + 1
                        ax.set_ylim(0, ylim)
                        ax.set_xlim(0, xlim)

                        graph_image_pct = 'roastlog-graph-pct'

                        i = len(profiles)  # bar counter

                        # generate the legend at the top
                        facecolors = ('#00b950', '#ffb347', '#9f7960')
                        prop.set_size('medium')
                        ax.broken_barh([(n, g),  # Dry indicator
                                        (n + g + ind, g),  # MAI indicator
                                        (n + g + ind + g + ind, g)  # DEV indicator
                                        ],
                                       (i * (barheight + barspacer), barheight * 0.75), facecolors=facecolors
                                       )
                        ax.text(m / 2, i * (barheight + barspacer) + textoffset / 3, 'Nr', ha='center',
                                color=headerfontcolor, fontproperties=prop)
                        ax.text(1 + n + g, i * (barheight + barspacer) + textoffset / 3, 'Dry', ha='left',
                                color=headerfontcolor, fontproperties=prop)
                        ax.text(1 + n + g + ind + g, i * (barheight + barspacer) + textoffset / 3, 'Mai', ha='left',
                                color=headerfontcolor, fontproperties=prop)
                        ax.text(1 + n + g + ind + g + ind + g, i * (barheight + barspacer) + textoffset / 3, 'Dev',
                                ha='left', color=headerfontcolor, fontproperties=prop)
                        ax.text(n + 100 + 10 / 2, i * (barheight + barspacer) + textoffset / 3, 'Drop', ha='center',
                                color=headerfontcolor, fontproperties=prop)

                        # generate the bar graph
                        prop.set_size('small')
                        color = iter(colormaps['tab20'](
                            numpy.linspace(0, 1, max_profiles)))  # @UndefinedVariable # pylint: disable=maybe-no-member
                        label_chr_nr = 0
                        for p in profiles:
                            i -= 1
                            try:
                                cl = mcolors.to_hex(next(color)), '#00b950', '#ffb347', '#9f7960'
                            except Exception:  # pylint: disable=broad-except
                                color = iter(colormaps['tab20'](numpy.linspace(0, 1,
                                                                               max_profiles)))  # @UndefinedVariable # pylint: disable=maybe-no-member
                                cl = mcolors.to_hex(next(color)), '#00b950', '#ffb347', '#9f7960'
                            try:
                                rd = self.profileRankingData(p)
                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                                _, _, exc_tb = sys.exc_info()
                                self.qmc.adderror((QApplication.translate('Error Message',
                                                                          'Exception (probably due to an empty profile):') + ' rankingReport() {0}').format(
                                    str(e)), getattr(exc_tb, 'tb_lineno', '?'))
                                i += 1  # avoid a blank line
                                continue
                            pd = self.profileProductionData(p)
                            if pd['batchnr'] > 0:
                                label = (pd['batchprefix'] + str(pd['batchnr']))[:8]
                            elif label_chr_nr < 26:
                                label = str(libstring.ascii_uppercase[label_chr_nr])
                                label_chr_nr = label_chr_nr + 1
                            else:
                                label = ''
                            if 'DRY_percent' in rd and 'MAI_percent' in rd and 'DEV_percent' in rd:
                                ax.broken_barh([(0, m),
                                                (n, rd['DRY_percent']),
                                                (n + rd['DRY_percent'], rd['MAI_percent']),
                                                (n + rd['DRY_percent'] + rd['MAI_percent'], rd['DEV_percent']),
                                                (n + rd['DRY_percent'] + rd['MAI_percent'] + rd['DEV_percent'] + g,
                                                 m * rd['DROP_time'] / max_drop_time)
                                                ],
                                               (i * (barheight + barspacer), barheight), facecolors=cl
                                               )
                                ax.text(m / 2, i * (barheight + barspacer) + textoffset, label, ha='center',
                                        color=fontcolor, fontproperties=prop)
                                ax.text(n + rd['DRY_percent'] / 2, i * (barheight + barspacer) + textoffset,
                                        str(round(rd['DRY_percent'], 1)) + '%  ' + stringfromseconds(rd['DRY_time']),
                                        ha='center', color=fontcolor, fontproperties=prop)
                                ax.text(n + rd['DRY_percent'] + rd['MAI_percent'] / 2,
                                        i * (barheight + barspacer) + textoffset,
                                        str(round(rd['MAI_percent'], 1)) + '%  ' + stringfromseconds(rd['MAI_time']),
                                        ha='center', color=fontcolor, fontproperties=prop)
                                ax.text(n + rd['DRY_percent'] + rd['MAI_percent'] + rd['DEV_percent'] / 2,
                                        i * (barheight + barspacer) + textoffset,
                                        str(round(rd['DEV_percent'], 1)) + '%  ' + stringfromseconds(rd['DEV_time']),
                                        ha='center', color=fontcolor, fontproperties=prop)
                                ax.text(n + rd['DRY_percent'] + rd['MAI_percent'] + rd['DEV_percent'] + g + 1,
                                        i * (barheight + barspacer) + textoffset, stringfromseconds(rd['DROP_time']),
                                        ha='left', color=fontcolor, fontproperties=prop)
                            elif 'DEV_percent' in rd:  # has FCs but no Dry event
                                cl = cl[0], '#ffffff', cl[3]
                                missingDryevent = QApplication.translate('Message', 'Profile missing DRY event')
                                ax.broken_barh([(0, m),
                                                (n, 100 - rd['DEV_percent']),
                                                (n + 100 - rd['DEV_percent'], rd['DEV_percent']),
                                                (n + 100 + g, m * rd['DROP_time'] / max_drop_time)
                                                ],
                                               (i * (barheight + barspacer), barheight), facecolors=cl
                                               )
                                ax.text(m / 2, i * (barheight + barspacer) + textoffset, label, ha='center',
                                        color=fontcolor, fontproperties=prop)
                                ax.text(n + (100 - rd['DEV_percent']) / 2, i * (barheight + barspacer) + textoffset,
                                        missingDryevent, ha='center', color=lightfontcolor, fontproperties=prop)
                                ax.text(n + 100 - rd['DEV_percent'] + rd['DEV_percent'] / 2,
                                        i * (barheight + barspacer) + textoffset,
                                        str(round(rd['DEV_percent'], 1)) + '%  ' + stringfromseconds(rd['DEV_time']),
                                        ha='center', color=fontcolor, fontproperties=prop)
                                ax.text(n + 100 + g + 1, i * (barheight + barspacer) + textoffset,
                                        stringfromseconds(rd['DROP_time']), ha='left', color=fontcolor,
                                        fontproperties=prop)
                            else:  # no useful events
                                drop_time = rd.get('DROP_time', 0)
                                cl = cl[0], '#ffffff'
                                missingPhaseevents = QApplication.translate('Message', 'Profile missing phase events')
                                ax.broken_barh([(0, m),
                                                (n, 100),
                                                (n + 100 + g,
                                                 m * (0 if max_drop_time == 0 else drop_time / max_drop_time))
                                                ],
                                               (i * (barheight + barspacer), barheight), facecolors=cl
                                               )
                                ax.text(m / 2, i * (barheight + barspacer) + textoffset, label, ha='center',
                                        color=fontcolor, fontproperties=prop)
                                ax.text(n + 100 / 2, i * (barheight + barspacer) + textoffset, missingPhaseevents,
                                        ha='center', color=lightfontcolor, fontproperties=prop)
                                ax.text(n + 100 + g + 1, i * (barheight + barspacer) + textoffset,
                                        stringfromseconds(drop_time), ha='left', color=fontcolor, fontproperties=prop)

                        # save graph
                        graph_image_pct = str(QDir.cleanPath(QDir(tmpdir).absoluteFilePath(graph_image_pct + '.svg')))
                        try:
                            os.remove(graph_image_pct)
                        except OSError:
                            pass
                        fig.savefig(graph_image_pct, transparent=True)
                        # add some random number to force HTML reloading
                        graph_image_pct = path2url(graph_image_pct)
                        graph_image_pct = graph_image_pct + '?dummy=' + str(int(libtime.time()))
                        graph_image_pct = "<img alt='roast graph pct' style=\"width: 95%;\" src='" + graph_image_pct + "'>"

                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                        _, _, exc_tb = sys.exc_info()
                        self.qmc.adderror(
                            (QApplication.translate('Error Message', 'Exception:') + ' rankingReport() {0}').format(
                                str(e)), getattr(exc_tb, 'tb_lineno', '?'))

                    try:
                        # redraw original graph
                        if prev_foreground_profile_path:
                            self.loadFile(prev_foreground_profile_path)
                        if prev_backgroundpath:
                            self.loadbackground(prev_backgroundpath)
                            self.qmc.background = prev_background
                        self.qmc.timealign()
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)

                    weight_fmt = ('{0:.2f}' if self.qmc.weight[2] in {'Kg', 'lb', 'oz'} else '{0:.0f}')
                    html = libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
                        resources=str(getResourcePath()),
                        title=QApplication.translate('HTML Report Template', 'Roast Ranking'),
                        time=QApplication.translate('HTML Report Template', 'Date'),
                        profile=QApplication.translate('Label', 'Title'),
                        weightin=QApplication.translate('HTML Report Template', 'In'),
                        weightloss=QApplication.translate('HTML Report Template', 'Loss'),
                        colorHeader=QApplication.translate('HTML Report Template', 'Color'),
                        weight_unit=self.qmc.weight[2].lower(),
                        temp_unit=self.qmc.mode,
                        entries=entries,
                        charges_avg=(
                            weight_fmt.format(charges / charges_count) if charges_count > 0 and charges > 0 else ''),
                        charges_temp_avg=(
                            f'{charges_temp / charges_temp_count:.1f}' if charges_temp > 0 and charges_temp_count > 0 else ''),
                        FCs_time_avg=(self.eventtime2string(
                            FCs_time / FCs_time_count) if FCs_time > 0 and FCs_time_count > 0 else ''),
                        FCs_temp_avg=(
                            f'{FCs_temp / FCs_temp_count:.1f}' if FCs_temp > 0 and FCs_temp_count > 0 else ''),
                        DROP_time_avg=(self.eventtime2string(
                            DROP_time / DROP_time_count) if DROP_time > 0 and DROP_time_count > 0 else ''),
                        DROP_temp_avg=(
                            f'{DROP_temp / DROP_temp_count:.1f}' if DROP_temp > 0 and DROP_temp_count > 0 else ''),
                        DRY_percent_avg=(
                            f'{DRY_percent / DRY_percent_count:.1f}' if DRY_percent > 0 and DRY_percent_count > 0 else ''),
                        MAI_percent_avg=(
                            f'{MAI_percent / MAI_percent_count:.1f}' if MAI_percent > 0 and MAI_percent_count > 0 else ''),
                        DEV_percent_avg=(
                            f'{DEV_percent / DEV_percent_count:.1f}' if DEV_percent > 0 and DEV_percent_count > 0 else ''),
                        AUC_avg=(f'{AUC / AUC_count:.1f}' if AUC > 0 and AUC_count > 0 else ''),
                        loss_avg=(f'{loss / loss_count:.1f}' if loss_count > 0 and loss > 0 else ''),
                        colors_avg=(
                            f'{colors_list / colors_count:.1f}' if colors_list > 0 and colors_count > 0 else ''),
                        cup_avg=(f'{cuppings / cuppings_count:.2f}' if cuppings > 0 and cuppings_count > 0 else ''),
                        energy_avg=(f'{energies / energies_count:.2f}' if energies > 0 and energies_count > 0 else ''),
                        co2_avg=(f'{co2s / co2s_count:.2f}' if co2s > 0 and co2s_count > 0 else ''),
                        co2kg_avg=(f'{co2kgs / co2kgs_count:.2f}' if co2kgs > 0 and co2kgs_count > 0 else ''),
                        graph_image=graph_image,
                        graph_image_pct=graph_image_pct
                    )
                    try:
                        filename = str(QDir(tmpdir).filePath('RankingReport.html'))
                        try:
                            os.remove(filename)
                        except OSError:
                            pass
                        import codecs  # @Reimport
                        with codecs.open(filename, 'w', encoding='utf-8') as f:
                            for ht in html:
                                f.write(ht)
                        if platform.system() == 'Darwin':
                            full_path = 'file://' + filename  # Safari refuses to load the javascript lib (sorttable) otherwise
                        else:
                            full_path = 'file:///' + filename  # Explorer refuses to start otherwise

                        if pdf:
                            # select file
                            filename = self.ArtisanSaveFileDialog(msg='Export PDF', ext='*.pdf')
                            if filename:
                                self.html2pdf(full_path, filename, landscape=True)
                        else:
                            QDesktopServices.openUrl(QUrl(full_path, QUrl.ParsingMode.TolerantMode))

                    except OSError as e:
                        self.qmc.adderror(
                            (QApplication.translate('Error Message', 'IO Error:') + ' rankingReport() {0}').format(
                                str(e)))
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def rankingCSVReport(self, _: bool = False) -> None:  # get profile filenames
        import csv
        profiles = self.reportFiles()
        if profiles and len(profiles) > 0:
            # select file
            filename = self.ArtisanSaveFileDialog(msg='Export CSV', ext='*.csv')
            if filename:
                try:
                    # open file
                    with open(filename, 'w', newline='', encoding='utf-8') as outfile:
                        writer = csv.writer(outfile, delimiter='\t', quotechar='"')

                        # write header
                        extendedRankingHdr = self.extendedRankingData2List(header=True)
                        writer.writerow(extendedRankingHdr)

                        # write data
                        #                    c = 1
                        for p in profiles:
                            try:
                                #                            c += 1
                                dsd = self.deserialize(p)
                                pd = self.productionData2string(self.profileProductionData(dsd), units=False)
                                rd = self.rankingData2string(self.profileRankingData(dsd), units=False)
                                extendedRankingData = self.extendedRankingData2List(dsd, rd, pd)
                                writer.writerow(extendedRankingData)
                            except Exception as e:  # pylint: disable=broad-except
                                _a, _b, exc_tb = sys.exc_info()
                                self.qmc.adderror((QApplication.translate('Error Message',
                                                                          'Exception:') + ' rankingCSVReport() {0}').format(
                                    str(e)), getattr(exc_tb, 'tb_lineno', '?'))
                    self.sendmessage(
                        QApplication.translate('Message', 'CSV Ranking Report exported to {0}').format(filename))
                except OSError as x:
                    self.qmc.adderror((QApplication.translate('Error Message',
                                                              'Exception:') + ' Err [{0}] Can not write to file, perhaps it is open in an application or is write protected?').format(
                        x.errno))
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def rankingExcelReport(self, _: bool = False) -> None:
        # get profile filenames
        profiles = self.reportFiles()
        if profiles and len(profiles) > 0:
            # select file
            filename = self.ArtisanSaveFileDialog(msg='Export Excel', ext='*.xlsx')
            if filename:
                try:
                    # open file
                    from openpyxl import Workbook
                    from openpyxl.utils.cell import get_column_letter, \
                        column_index_from_string  # @UnusedImport # pylint: disable=unused-import # noqa: F401
                    from openpyxl.styles import Font, Fill, \
                        Alignment  # @UnusedImport # pylint: disable=unused-import # noqa: F401
                    wb = Workbook()
                    ws: Optional[
                        Worksheet] = wb.active  # type: ignore # Incompatible types in assignment (expression has type "Optional[_WorkbookChild]", variable has type "Optional[Worksheet]")
                    if ws is not None:
                        ws.title = QApplication.translate('HTML Report Template', 'Ranking Report')
                        bf = Font(name='Calibri', size='11', bold=True)
                        #                        ws.font = Font(name='Calibri',size='11') # type: ignore # has no attribute .font

                        # get the field definitions
                        ranking_data_fields, field_index = self.rankingdataDef()

                        # write header
                        widths: List[float] = [10] * len(ranking_data_fields)
                        weight_unit = self.qmc.weight[2]
                        volume_unit = self.qmc.volume[2]
                        temperature_unit = self.qmc.mode
                        col_ = 0
                        for i, rdf in enumerate(ranking_data_fields):
                            name: str = rdf[field_index.index('name')]
                            units: str = rdf[field_index.index('units')]
                            if units == 'temp':
                                suffix = f' ({temperature_unit})'
                            elif units == 'volume':
                                suffix = f' ({volume_unit})'
                            elif units == 'weight':
                                suffix = f' ({weight_unit})'
                            elif units == 'ror':
                                suffix = f' ({temperature_unit}/min)'
                            elif units.startswith('('):
                                suffix = f' {units}'
                            else:
                                suffix = ''
                            cell = ws.cell(column=i + 1, row=1, value=f'{name}{suffix}')
                            cell.font = bf
                            cell.alignment = Alignment(horizontal='center')
                            width = len(name + suffix) + 2.
                            if width > widths[i]:
                                widths[i] = width
                                ws.column_dimensions[get_column_letter(i + 1)].width = width

                        # write data
                        c = 1
                        for p in profiles:
                            try:
                                c += 1
                                dsd: Dict[str, Any] = self.deserialize(p)
                                rd = self.profileRankingData(dsd)
                                pd: 'ProductionDataStr' = self.productionData2string(self.profileProductionData(dsd),
                                                                                     units=False)
                                cnum = col_
                                for i, rdf in enumerate(ranking_data_fields):
                                    cnum += 1
                                    cr = f'{get_column_letter(cnum)}{c}'

                                    name = rdf[field_index.index('name')]
                                    fld: str = rdf[field_index.index('fld')]
                                    src: str = rdf[field_index.index('src')]
                                    typ: str = rdf[field_index.index('typ')]
                                    test0: str = rdf[field_index.index('test0')]
                                    units = rdf[field_index.index('units')]
                                    if src == 'comp' and fld in dsd['computed']:
                                        res_fld = dsd['computed'][fld]
                                    elif src == 'prof' and fld in dsd:
                                        res_fld = dsd[fld]
                                    elif src == 'rank' and fld in rd:
                                        res_fld = rd[fld]
                                    elif src == 'prod' and fld in pd:
                                        res_fld = pd[fld]  # type:ignore[literal-required]
                                    elif src == 'eval':
                                        res_fld = eval(fld)  # pylint: disable=eval-used
                                    else:
                                        continue

                                    if (test0 == 'true' and self.float2float(toFloat(res_fld)) > 0) or test0 == 'false':
                                        if units == 'temp':
                                            conv_fld = convertTemp(res_fld, dsd['mode'], temperature_unit)
                                        elif units == 'ror':
                                            conv_fld = convertRoRstrict(res_fld, dsd['mode'], temperature_unit)
                                        elif units == 'volume':
                                            conv_fld = self.convertVolume(res_fld, 0,
                                                                          self.qmc.volume_units.index(volume_unit))
                                        elif units == 'weight':
                                            conv_fld = self.convertWeight(res_fld, 0,
                                                                          self.qmc.weight_units.index(weight_unit))
                                        else:
                                            conv_fld = res_fld

                                        if typ == 'text':
                                            ws[cr] = conv_fld  # type: ignore
                                            width = len(str(conv_fld)) + 2.
                                            if re.match(r'[0-9]+', units) and width > float(units):
                                                width = float(units)
                                            if width > widths[i]:
                                                widths[i] = width
                                                ws.column_dimensions[get_column_letter(cnum)].width = width
                                            ws[cr].alignment = Alignment(wrap_text=True)
                                        elif typ == 'int':
                                            ws[cr] = conv_fld  # type: ignore
                                        elif typ == 'float1':
                                            ws[cr] = conv_fld  # type: ignore
                                            ws[cr].number_format = '0.0'
                                        elif typ == 'float2':
                                            ws[cr] = conv_fld  # type: ignore
                                            ws[cr].number_format = '0.00'
                                        elif typ == 'float4':
                                            ws[cr] = conv_fld  # type: ignore
                                            ws[cr].number_format = '0.0000'
                                        elif typ == 'text2float1':
                                            ws[cr] = self.float2float(toFloat(
                                                conv_fld))  # type: ignore #  Incompatible types in assignment (expression has type "float", target has type "str")
                                            ws[cr].number_format = '0.0'
                                        elif typ == 'text2float2':
                                            ws[cr] = self.float2float(toFloat(
                                                conv_fld))  # type: ignore # Incompatible types in assignment (expression has type "float", target has type "str")
                                            ws[cr].number_format = '0.00'
                                        elif typ == 'text2int':
                                            ws[cr] = toInt(conv_fld)  # type: ignore
                                            ws[cr].number_format = '0'
                                        elif typ == 'percent':
                                            ws[cr] = conv_fld / 100.  # type: ignore
                                            ws[cr].number_format = '0.0%'
                                        elif typ == 'time':
                                            h, m = divmod(conv_fld, 60)
                                            dt = datetime.time(int(h), int(m),
                                                               0)  # note that rounding h and m might lead to failure of .time() as round(59.99) = 60 which is >59 thus not accepted by .time()
                                            ws[
                                                cr] = dt  # type: ignore # Incompatible types in assignment (expression has type "time", target has type "str")
                                            ws[cr].number_format = 'H:MM'
                                        elif typ == 'date':
                                            ws[cr] = QDateTime(
                                                conv_fld).toPyDateTime()  # type: ignore # Incompatible types in assignment (expression has type "datetime", target has type "str")
                                            fmt = 'YYYY-MM-DD HH:MM'
                                            ws[cr].number_format = fmt
                                            width = len(fmt) + 2.
                                            if width > widths[i]:
                                                widths[i] = width
                                                ws.column_dimensions[get_column_letter(cnum)].width = width
                                        elif typ == 'bool':
                                            ws[cr] = str(conv_fld)

                            except Exception as e:  # pylint: disable=broad-except
                                _log.exception(e)
                                _a, _b, exc_tb = sys.exc_info()
                                self.qmc.adderror((QApplication.translate('Error Message',
                                                                          'Exception:') + ' rankingExcelReport() {0}').format(
                                    str(e)), getattr(exc_tb, 'tb_lineno', '?'))

                        # write trailer
                        if c > 1:
                            def avgFormat(c: str, s: int, e: int) -> str:
                                rng = f'{c}{s}:{c}{e}'
                                return f'=IF(SUMPRODUCT(--({rng}<>""))=0,"",AVERAGE({rng}))'

                            ws[f'A{c + 1}'] = QApplication.translate('HTML Report Template', 'AVG')
                            ws[f'A{c + 1}'].font = bf
                            cnum = col_
                            for rdf in ranking_data_fields:
                                cnum += 1
                                fld = rdf[field_index.index('fld')]
                                typ = rdf[field_index.index('typ')]
                                test0 = rdf[field_index.index('test0')]
                                cr = f'{get_column_letter(cnum)}{c + 1}'
                                cltr = get_column_letter(cnum)

                                if typ == 'text':
                                    pass
                                elif typ == 'int':
                                    ws[cr] = avgFormat(cltr, 2, c)
                                    ws[cr].font = bf
                                    ws[cr].number_format = '0'
                                elif typ == 'float1':
                                    ws[cr] = avgFormat(cltr, 2, c)
                                    ws[cr].font = bf
                                    ws[cr].number_format = '0.0'
                                elif typ == 'float2':
                                    ws[cr] = avgFormat(cltr, 2, c)
                                    ws[cr].font = bf
                                    ws[cr].number_format = '0.0'
                                elif typ == 'float4':
                                    ws[cr] = avgFormat(cltr, 2, c)
                                    ws[cr].font = bf
                                    ws[cr].number_format = '0.0000'
                                elif typ == 'text2float1':
                                    ws[cr] = avgFormat(cltr, 2, c)
                                    ws[cr].font = bf
                                    ws[cr].number_format = '0.0'
                                elif typ == 'text2float2':
                                    ws[cr] = avgFormat(cltr, 2, c)
                                    ws[cr].font = bf
                                    ws[cr].number_format = '0.00'
                                elif typ == 'text2int':
                                    ws[cr] = avgFormat(cltr, 2, c)
                                    ws[cr].font = bf
                                    ws[cr].number_format = '0'
                                elif typ == 'percent':
                                    ws[cr] = avgFormat(cltr, 2, c)
                                    ws[cr].font = bf
                                    ws[cr].number_format = '0.0%'
                                elif typ == 'time':
                                    ws[cr] = avgFormat(cltr, 2, c)
                                    ws[cr].font = bf
                                    ws[cr].number_format = 'H:MM'
                                elif typ == 'bool':
                                    pass

                    # close file
                    wb.save(filename)
                    self.sendmessage(
                        QApplication.translate('Message', 'Excel Ranking Report exported to {0}').format(filename))
                except OSError as x:
                    _log.exception(x)
                    self.qmc.adderror((QApplication.translate('Error Message',
                                                              'Exception:') + ' Err [{0}] Can not write to file, perhaps it is open in an application or is write protected?').format(
                        x.errno))
                    QApplication.beep()
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
                    _a, _b, exc_tb = sys.exc_info()
                    self.qmc.adderror(
                        (QApplication.translate('Error Message', 'Exception:') + ' rankingExcelReport() {0}').format(
                            str(e)), getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def pdfReport(self, _: bool = False) -> None:
        # select file
        filename = self.ArtisanSaveFileDialog(msg='Export PDF', ext='*.pdf')
        if filename:
            self.roastReport(pdf_filename=filename)

    @pyqtSlot()
    @pyqtSlot(bool)
    def htmlReport(self, _: bool = False) -> None:
        self.roastReport()

    def releaseQWebEngineView(self) -> None:
        try:  # sip not supported on older PyQt versions (RPi!)
            if self.pdf_page_layout is not None:
                sip.delete(self.pdf_page_layout)
            # print(sip.isdeleted(self.pdf_page_layout))
        except Exception:  # pylint: disable=broad-except
            pass
        self.pdf_page_layout = None
        try:  # sip not supported on older PyQt versions (RPi!)
            if self.html_loader is not None:
                sip.delete(self.html_loader)
            # print(sip.isdeleted(self.html_loader))
        except Exception:  # pylint: disable=broad-except
            pass
        self.html_loader = None

    # if batch_process is True, the QWebEngineView() is created only if self.html_loader is not None and never deleted
    # the caller is responsible to release that self.html_loader via releaseQWebEngineView()
    def html2pdf(self, html_file: str, pdf_file: str, landscape: bool = False, batch_process: bool = False) -> None:
        def release() -> None:
            if batch_process and self.html_loader is not None:
                try:
                    self.html_loader.page().pdfPrintingFinished.disconnect()  # type: ignore # "Callable[[str, bool], None]" has no attribute "disconnect"
                except Exception:  # pylint: disable=broad-except
                    pass
                try:
                    self.html_loader.loadFinished.disconnect()
                except Exception:  # pylint: disable=broad-except
                    pass
                try:
                    self.html_loader.renderProcessTerminated.disconnect()
                except Exception:  # pylint: disable=broad-except
                    pass
            else:
                self.releaseQWebEngineView()
            self.pdf_rendering = False

        @pyqtSlot(str, bool)
        def printing_finished(_file: str, _success: bool) -> None:
            release()

        @pyqtSlot(bool)
        def emit_pdf(ok: bool) -> None:
            if ok:
                if self.html_loader is not None and self.pdf_page_layout is not None:
                    page = self.html_loader.page()
                    if page is not None:
                        page.pdfPrintingFinished.connect(printing_finished)
                        page.printToPdf(pdf_file, self.pdf_page_layout)
                else:
                    self.pdf_rendering = False
            else:
                self.pdf_rendering = False

        @pyqtSlot('QWebEnginePage::RenderProcessTerminationStatus', int)
        def renderingTerminated(_terminationStatus: 'QWebEnginePage.RenderProcessTerminationStatus',
                                _exitCode: int) -> None:
            release()

        try:
            # we wait for a previous pdf conversion to terminate
            while self.pdf_rendering:
                QApplication.processEvents()
                libtime.sleep(0.001)
            self.pdf_rendering = True
            if self.html_loader is None:
                self.html_loader = QWebEngineView()  # pyright:ignore[reportPossiblyUnboundVariable]
                self.html_loader.setZoomFactor(1)
            if self.pdf_page_layout is None:
                # lazy imports
                # try:
                from PyQt6.QtCore import QMarginsF  # @UnusedImport @Reimport  @UnresolvedImport
                from PyQt6.QtGui import QPageSize  # @UnusedImport @Reimport  @UnresolvedImport
                # except ImportError:
                #     from PyQt5.QtCore import QMarginsF  # type: ignore # @UnusedImport @Reimport  @UnresolvedImport
                #     from PyQt5.QtGui import QPageSize  # type: ignore # @UnusedImport @Reimport  @UnresolvedImport
                if QPrinter().pageLayout().pageSize().id() == QPageSize.PageSizeId.Letter:
                    # Letter
                    ps = QPageSize(QPageSize.PageSizeId.Letter)
                    pu = QPageLayout.Unit.Inch
                    pm = QMarginsF(0.7, 0.7, 0.7, 0.7)
                else:
                    # A4
                    ps = QPageSize(QPageSize.PageSizeId.A4)
                    pu = QPageLayout.Unit.Millimeter
                    pm = QMarginsF(15, 15, 15, 15)
                if landscape:
                    po = QPageLayout.Orientation.Landscape
                else:
                    po = QPageLayout.Orientation.Portrait
                self.pdf_page_layout = QPageLayout(ps, po, pm, pu)
            if self.html_loader is not None:
                self.html_loader.renderProcessTerminated.connect(renderingTerminated)
                self.html_loader.loadFinished.connect(emit_pdf)
                self.html_loader.load(QUrl(html_file))
                # busy wait for the pdf conversion to terminate
                while self.pdf_rendering:
                    QApplication.processEvents()
                    libtime.sleep(0.001)
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    # if batch_process is True and pdf_filename is given, the caller needs to cleanup the QWebEngineView by calling self.releaseQWebEngineView() the after processing all reports
    def roastReport(self, pdf_filename: Optional[str] = None, batch_process: bool = False) -> None:
        import html as htmllib
        import string as libstring
        try:
            rcParams['path.effects'] = []
            with open(getResourcePath() + 'roast-template.htm', encoding='utf-8') as myfile:
                HTML_REPORT_TEMPLATE = myfile.read()
            beans_html = str(htmllib.escape(self.qmc.beans))
            if len(beans_html) > 43:
                beans_html = beans_html[:41] + '&hellip;'

            cp = self.computedProfileInformation()

            if 'CHARGE_ET' in cp and 'CHARGE_BT' in cp:
                charge = f"BT {cp['CHARGE_BT']:.0f}&deg;{self.qmc.mode} <br>ET {cp['CHARGE_ET']:.0f}{self.qmc.mode}"
            else:
                charge = '--'
            dryphase, midphase, finishphase, coolphase = self.phases2html(cp)
            etbta = '--'
            # Dave new way of presenting AUC
            if ('AUC' in cp and cp['AUC'] != 0):
                etbta = f"{cp['AUC']:.0f}C*min"
                if ('AUCbegin' in cp and cp['AUCbegin'] != '' and 'AUCbase' in cp):
                    etbta += f" [{cp['AUCbegin']},{cp['AUCbase']:.0f}{self.qmc.mode}]"
                elif 'AUCbase' in cp:
                    etbta += f" [{cp['AUCbase']:.0f}]"
            tmpdir = str(QDir.tempPath() + '/')
            graph_image = 'roastlog-graph'
            graph_image = str(QDir.cleanPath(QDir(tmpdir).absoluteFilePath(graph_image + '.svg')))
            try:
                os.remove(graph_image)
            except OSError:
                pass

            org_patheffects = self.qmc.patheffects
            if self.app.darkmode:
                self.qmc.patheffects = 0
            self.qmc.redraw(recomputeAllDeltas=False)

            self.qmc.fig.savefig(graph_image, transparent=True)
            # add some random number to force HTML reloading
            graph_image = path2url(graph_image)
            graph_image = graph_image + '?dummy=' + str(int(libtime.time()))

            # obtain flavor chart image
            self.qmc.flavorchart()
            flavor_image = 'roastlog-flavor'
            flavor_image = str(QDir.cleanPath(QDir(tmpdir).absoluteFilePath(flavor_image + '.svg')))
            try:
                os.remove(flavor_image)
            except OSError:
                pass
            self.qmc.fig.savefig(flavor_image, transparent=True)
            flavor_image = path2url(flavor_image)
            flavor_image = flavor_image + '?dummy=' + str(int(libtime.time()))
            # return screen to GRAPH profile mode
            if self.app.darkmode:
                self.qmc.patheffects = org_patheffects

            self.qmc.fig.clf()  # remove the flavorchart artists
            self.qmc.redraw(recomputeAllDeltas=False)
            met = '--'
            if 'MET' in cp:
                met = f"{cp['MET']:.0f}&deg;{self.qmc.mode}"
            ror = '--'
            if 'total_ror' in cp:
                ror = f"{cp['total_ror']:.0f}{uchr(176)}{self.qmc.mode}{QApplication.translate('Label', '/m')}"
            try:
                if self.qmc.density[0] != 0.0 and self.qmc.density_roasted[0] != 0.0:
                    percent = -1 * self.weight_loss(self.qmc.density[0], self.qmc.density_roasted[0])
                    density = self.volume_weight2html(self.qmc.density[0], self.qmc.density_roasted[0], 'g/l', percent)
                elif 'set_density' in cp:
                    density = f"{cp['set_density']:.1f}g/l (set)"
                else:
                    density = '--'
            except Exception:  # pylint: disable=broad-except
                density = '--'
            if self.qmc.weight[0] != 0.0 and self.qmc.weight[1] != 0.0:
                weight = self.volume_weight2html(self.qmc.weight[0], self.qmc.weight[1], self.qmc.weight[2],
                                                 cp['weight_loss'])
            else:
                weight = '--'
            if self.qmc.volume[0] != 0.0 and self.qmc.volume[1] != 0.0:
                volume = self.volume_weight2html(self.qmc.volume[0], self.qmc.volume[1], self.qmc.volume[2],
                                                 cp['volume_gain'])
            else:
                volume = '--'
            moisture = ''
            if 'moisture_greens' in cp:
                moisture = f"{cp['moisture_greens']:.0f}% ({QApplication.translate('Label', 'greens')})"
                if 'moisture_roasted' in cp:
                    moisture += '<br>'
            if 'moisture_roasted' in cp:
                moisture += f"{cp['moisture_roasted']:.0f}% ({QApplication.translate('Label', 'roasted')})"

            humidity = ''
            if 'ambient_humidity' in cp:
                humidity += f"{cp['ambient_humidity']:.0f}%"
                if 'ambient_temperature' in cp:
                    humidity += f" at {cp['ambient_temperature']:.0f}{self.qmc.mode}"
            elif 'ambient_temperature' in cp:
                humidity += f"{cp['ambient_temperature']:.0f}{self.qmc.mode}"
            if 'ambient_pressure' in cp:
                if len(humidity) != 0:
                    humidity += ', '
                humidity += f"{cp['ambient_pressure']:.0f}hPa"
            if len(humidity) == 0:
                humidity = '--'
            if self.qmc.whole_color or self.qmc.ground_color:
                if self.qmc.whole_color:
                    wcolor = str(self.qmc.whole_color)
                else:
                    wcolor = '--'
                if self.qmc.ground_color:
                    gcolor = str(self.qmc.ground_color)
                else:
                    gcolor = '--'
                color = wcolor + '/' + gcolor
                if self.qmc.color_system_idx:
                    color = color + ' (' + self.qmc.color_systems[self.qmc.color_system_idx] + ')'
            else:
                color = '--'
            if 'BTU_batch' in cp and cp['BTU_batch']:
                energy = f"{self.qmc.convertHeat(cp['BTU_batch'], 0, 3):.1f}kWh"
            else:
                energy = '--'
            if 'CO2_batch' in cp and cp['CO2_batch']:
                CO2 = f"{cp['CO2_batch']:.1f}g"
                if 'CO2_batch_per_green_kg' in cp:
                    CO2 += f" ({self.float2float(cp['CO2_batch_per_green_kg'])}g/kg)"
            else:
                CO2 = '--'
            if 'det' in cp:
                cm_tuple = f"{cp['det']:.1f}/{cp['dbt']:.1f}{uchr(176)}{self.qmc.mode}"
            else:
                cm_tuple = '--'
            if self.qmc.titleB is None or self.qmc.titleB == '':
                background_html = '--'
            else:
                if self.qmc.roastbatchnrB == 0:
                    titleB = self.qmc.titleB
                else:
                    titleB = self.qmc.roastbatchprefixB + str(self.qmc.roastbatchnrB) + ' ' + self.qmc.titleB
                background_html = titleB
            if self.qmc.alarmsfile:
                alarms = str(os.path.basename(self.qmc.alarmsfile))
            else:
                alarms = '--'
            if self.qmc.roastbatchnr == 0:
                batch = ''
            else:
                batch = self.qmc.roastbatchprefix + str(self.qmc.roastbatchnr) + ' '
            datetime_html = self.qmc.roastdate.date().toString() + ', ' + self.qmc.roastdate.time().toString()[:-3]
            # add artisan or artisan.plus links to title, background and beans if possible
            title_html = str(htmllib.escape(batch)) + str(htmllib.escape(self.qmc.title))
            if self.qmc.roastUUID is not None and self.qmc.roastUUID != '':
                #                if plus.register.getPath(self.qmc.roastUUID):
                #                    title_html = '<a href="artisan://roast/' + self.qmc.roastUUID + '">' + title_html + "</a>"
                title_html = '<a href="artisan://roast/' + self.qmc.roastUUID + '">' + title_html + '</a>'
                if bool(plus.sync.getSync(self.qmc.roastUUID)):
                    datetime_html = f'<a href="{plus.util.roastLink(self.qmc.roastUUID)}" target="_blank">{datetime_html}</a>'
            #            if self.qmc.background and self.qmc.titleB is not None and self.qmc.titleB != "" and self.qmc.backgroundUUID is not None and plus.register.getPath(self.qmc.backgroundUUID):
            #                background_html = '<a href="artisan://roast/' + self.qmc.backgroundUUID + '">' + background_html + "</a>"
            if self.qmc.background and self.qmc.titleB is not None and self.qmc.titleB != '' and self.qmc.backgroundUUID is not None:
                background_html = '<a href="artisan://roast/' + self.qmc.backgroundUUID + '">' + background_html + '</a>'
            if beans_html is not None and beans_html != '' and self.qmc.plus_coffee is not None:
                beans_html = f'<a href="{plus.util.coffeeLink(self.qmc.plus_coffee)}" target="_blank">{beans_html}</a>'
                # note that blends are hard to link back as it requires to link component by component
            cupping_score, cupping_all_default = self.cuppingSum(self.qmc.flavors)
            cupping_notes = self.note2html(self.qmc.cuppingnotes).strip()
            special_events = self.specialevents2html().strip()
            html = libstring.Template(HTML_REPORT_TEMPLATE).safe_substitute(
                title=title_html,
                titlecolor=QColor(self.qmc.palette['title']).name(),
                doc=QApplication.translate('HTML Report Template', 'Roasting Report'),
                datatime_label=QApplication.translate('HTML Report Template', 'Date:'),
                datetime=datetime_html,
                beans_label=QApplication.translate('HTML Report Template', 'Beans:'),
                beans=beans_html,
                weight_label=QApplication.translate('HTML Report Template', 'Weight:'),
                weight=weight,
                #                degree_label=QApplication.translate("HTML Report Template", "Degree:"),
                #                degree=degree,
                volume_label=QApplication.translate('HTML Report Template', 'Volume:'),
                volume=volume,
                roaster_label=QApplication.translate('HTML Report Template', 'Roaster:'),
                roaster=str(htmllib.escape(self.qmc.roastertype)),
                operator_label=QApplication.translate('HTML Report Template', 'Operator:'),
                operator=str(htmllib.escape(self.qmc.operator)),
                organization_label=QApplication.translate('HTML Report Template', 'Organization:'),
                organization=str(htmllib.escape(self.qmc.organization)),
                cup_label=('' if cupping_all_default else QApplication.translate('HTML Report Template', 'Cupping:')),
                cup=('' if cupping_all_default else str(self.float2float(cupping_score))),
                color_label=QApplication.translate('HTML Report Template', 'Color:'),
                color=color,
                energy_label=QApplication.translate('HTML Report Template', 'Energy:'),
                energy=energy,
                CO2_label=QApplication.translate('HTML Report Template', 'CO2:').replace('CO2', 'CO₂'),
                CO2=CO2,
                charge_label=QApplication.translate('HTML Report Template', 'CHARGE:'),
                charge=charge,
                size_label=QApplication.translate('HTML Report Template', 'Size:'),
                size='--' if (self.qmc.beansize_max == 0 and self.qmc.beansize_min == 0) else (str(round(
                    int(self.qmc.beansize_min))) if self.qmc.beansize_min != 0 else ''
                                                                                               ) + ('/' if (
                        self.qmc.beansize_max != 0 and self.qmc.beansize_min != 0) else '') + (str(round(
                    int(self.qmc.beansize_max))) if (self.qmc.beansize_max != 0) else ''),
                density_label=QApplication.translate('HTML Report Template', 'Density:'),
                density=density,
                moisture_label=QApplication.translate('HTML Report Template', 'Moisture:'),
                moisture=moisture,
                humidity_label=QApplication.translate('HTML Report Template', 'Ambient:'),
                humidity=humidity,
                TP_label=QApplication.translate('HTML Report Template', 'TP:'),
                TP=self.event2html(cp, 'TP_time', 'TP_BT'),
                DRY_label=QApplication.translate('HTML Report Template', 'DRY:'),
                DRY=self.event2html(cp, 'DRY_time', 'DRY_BT'),
                FCs_label=QApplication.translate('HTML Report Template', 'FCs:'),
                FCs=self.event2html(cp, 'FCs_time', 'FCs_BT'),
                FCe_label=QApplication.translate('HTML Report Template', 'FCe:'),
                FCe=self.event2html(cp, 'FCe_time', 'FCe_BT'),
                SCs_label=QApplication.translate('HTML Report Template', 'SCs:'),
                SCs=self.event2html(cp, 'SCs_time', 'SCs_BT'),
                SCe_label=QApplication.translate('HTML Report Template', 'SCe:'),
                SCe=self.event2html(cp, 'SCe_time', 'SCe_BT'),
                drop_label=QApplication.translate('HTML Report Template', 'DROP:'),
                drop=self.event2html(cp, 'DROP_time', 'DROP_BT'),
                cool_label=QApplication.translate('HTML Report Template', 'COOL:'),
                cool=self.event2html(cp, 'COOL_time', None, 'DROP_time'),
                met_label=QApplication.translate('HTML Report Template', 'MET:'),
                met=met,
                cm_label=QApplication.translate('HTML Report Template', 'CM:'),
                cm_tuple=cm_tuple,
                dry_phase_label=QApplication.translate('HTML Report Template', 'Drying:'),
                dry_phase=dryphase,
                mid_phase_label=QApplication.translate('HTML Report Template', 'Maillard:'),
                mid_phase=midphase,
                finish_phase_label=QApplication.translate('HTML Report Template', 'Finishing:'),
                finish_phase=finishphase,
                cool_phase_label=QApplication.translate('HTML Report Template', 'Cooling:'),
                cool_phase=coolphase,
                background_label=QApplication.translate('HTML Report Template', 'Background:'),
                background=background_html,
                alarms_label=QApplication.translate('HTML Report Template', 'Alarms:'),
                alarms=alarms,
                ror_label=QApplication.translate('HTML Report Template', 'RoR:'),
                ror=ror,
                etbta_label=QApplication.translate('HTML Report Template', 'AUC:'),
                etbta=etbta,
                roasting_notes_label=(QApplication.translate('HTML Report Template',
                                                             'Roasting Notes') if self.qmc.roastingnotes != '' else ''),
                roasting_notes=self.note2html(self.qmc.roastingnotes),
                roast_attributes=self.roastattributes(),
                graph_image=graph_image,
                flavor_image=flavor_image,
                show_cupping=('none' if cupping_all_default else 'inline'),
                specialevents_label=QApplication.translate('HTML Report Template', 'Events'),
                specialevents=special_events,
                show_special_events=('none' if special_events == '' else 'inline'),
                cupping_notes_label=(QApplication.translate('HTML Report Template',
                                                            'Cupping Notes') if self.qmc.cuppingnotes != '' else ''),
                cupping_notes=cupping_notes)
            f = None
            try:
                filename = str(QDir(tmpdir).filePath('Roastlog.html'))
                try:
                    os.remove(filename)
                except OSError:
                    pass
                import codecs  # @Reimport
                with codecs.open(filename, 'w', encoding='utf-8') as f:
                    for ht in html:
                        f.write(ht)
                if platform.system() == 'Darwin':
                    full_path = 'file://' + filename  # Safari refuses to load the javascript lib (sorttable) otherwise
                else:
                    full_path = 'file:///' + filename  # Explorer refuses to start otherwise
                if pdf_filename:
                    self.html2pdf(full_path, pdf_filename, batch_process=batch_process)
                else:
                    QDesktopServices.openUrl(QUrl(full_path, QUrl.ParsingMode.TolerantMode))

            except OSError as e:
                _log.exception(e)
                self.qmc.adderror(
                    (QApplication.translate('Error Message', 'IO Error:') + ' htmlReport() {0}').format(str(e)))
            finally:
                if f:
                    f.close()
                # we only trigger a redraw if a watermark is displayed to fix its aspect ratio
                if self.logofilename != '':
                    self.qmc.redraw(recomputeAllDeltas=False)

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' htmlReport() {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

    # returns a string with all the activated roast attributes
    def roastattributes(self) -> str:
        res = []
        if self.qmc.heavyFC_flag:
            res.append(QApplication.translate('CheckBox', 'Heavy FC'))
        if self.qmc.lowFC_flag:
            res.append(QApplication.translate('CheckBox', 'Low FC'))
        if self.qmc.lightCut_flag:
            res.append(QApplication.translate('CheckBox', 'Light Cut'))
        if self.qmc.darkCut_flag:
            res.append(QApplication.translate('CheckBox', 'Dark Cut'))
        if self.qmc.drops_flag:
            res.append(QApplication.translate('CheckBox', 'Drops'))
        if self.qmc.oily_flag:
            res.append(QApplication.translate('CheckBox', 'Oily'))
        if self.qmc.uneven_flag:
            res.append(QApplication.translate('CheckBox', 'Uneven'))
        if self.qmc.tipping_flag:
            res.append(QApplication.translate('CheckBox', 'Tipping'))
        if self.qmc.scorching_flag:
            res.append(QApplication.translate('CheckBox', 'Scorching'))
        if self.qmc.divots_flag:
            res.append(QApplication.translate('CheckBox', 'Divots'))
        if len(res) > 0:
            return '\n<center><pre>' + ', '.join(res) + '</pre></center>'
        return ''

    # returns the overall cupping score and as second value a flag if True indicating that all individual ratings were set to their default value
    def cuppingSum(self, flavors: List[float]) -> Tuple[float, bool]:
        score = 0.
        all_default = True
        nflavors = len(flavors)
        for i in range(nflavors):
            score += flavors[i]
            if flavors[i] != self.qmc.flavors_default_value:
                all_default = False
        score /= (nflavors)
        score *= 10.
        return score, all_default

    @staticmethod
    def volume_weight2html(amount: float, out: float, unit: str, change: float) -> str:
        if amount:
            return f'{amount:.1f}{unit}<br>{out}{unit} ({change:.1f}%)'
        return '--'

    def phases2html(self, cp: 'ComputedProfileInformation') -> Tuple[str, str, str, str]:
        dryphase = midphase = finishphase = coolphase = '--'
        if 'totaltime' in cp:
            totaltime = cp['totaltime']
            if totaltime:
                # dryphase
                if 'dryphasetime' in cp:
                    dryphasetime = cp['dryphasetime']
                    dryphase = f"{stringfromseconds(cp['dryphasetime'])} ({int(round(dryphasetime * 100. / totaltime))}%)"
                    if 'dry_phase_ror' in cp:
                        dryphase += f"<br>{cp['dry_phase_ror']:.1f}{uchr(176)}{self.qmc.mode}/min"
                    if 'dry_phase_delta_temp' in cp:
                        dryphase += f"<br>{cp['dry_phase_delta_temp']:.1f}{uchr(176)}{self.qmc.mode}"
                # midphase
                if 'midphasetime' in cp:
                    midphasetime = cp['midphasetime']
                    midphase = f"{stringfromseconds(cp['midphasetime'])} ({int(round(midphasetime * 100. / totaltime))}%)"
                    if 'mid_phase_ror' in cp:
                        midphase += f"<br>{cp['mid_phase_ror']:.1f}{uchr(176)}{self.qmc.mode}/min"
                    if 'mid_phase_delta_temp' in cp:
                        midphase += f"<br>{cp['mid_phase_delta_temp']:.1f}{uchr(176)}{self.qmc.mode}"
                # finishphase
                if 'finishphasetime' in cp:
                    finishphasetime = cp['finishphasetime']
                    finishphase = f"{stringfromseconds(cp['finishphasetime'])} ({int(round(finishphasetime * 100. / totaltime))}%)"
                    if 'finish_phase_ror' in cp:
                        finishphase += f"<br>{cp['finish_phase_ror']:.1f}{uchr(176)}{self.qmc.mode}/min"
                    if 'finish_phase_delta_temp' in cp:
                        finishphase += f"<br>{cp['finish_phase_delta_temp']:.1f}{uchr(176)}{self.qmc.mode}"
                # coolphase
                if 'coolphasetime' in cp:
                    coolphasetime = cp['coolphasetime']
                    coolphase = f"{stringfromseconds(cp['coolphasetime'])} ({int(round(coolphasetime * 100. / totaltime))}%)"
        return dryphase, midphase, finishphase, coolphase

    def event2html(self, cp: 'ComputedProfileInformation', time_key: str, BT_key: Optional[str],
                   prev_time_key: Optional[str] = None) -> str:
        cpd = cast(Dict[str, Any], cp)
        if prev_time_key is not None and prev_time_key in cpd and time_key in cpd:
            return f'{stringfromseconds(cpd[time_key])} ({stringfromseconds(cpd[time_key] - cpd[prev_time_key])}m)'
        if time_key in cpd and BT_key is not None and BT_key in cpd:
            return f'{stringfromseconds(cpd[time_key])} ({cpd[BT_key]:.0f}&deg;{self.qmc.mode})'
        return '--'

    def specialevents2html(self) -> str:
        html = ''
        if self.qmc.specialevents and len(self.qmc.specialevents) > 0:
            html += '\n<table cellpadding="10" cellspacing="8">\n'
            if self.qmc.timeindex[0] != -1:
                start = self.qmc.timex[self.qmc.timeindex[0]]
            else:
                start = 0
            # sort events by time/index
            sevents = sorted(zip(self.qmc.specialevents, range(len(self.qmc.specialevents))))
            seventsString = []
            seventsType = []
            seventsValue = []
            for sev in sevents:
                sorted_pos = sev[1]
                seventsString.append(self.qmc.specialeventsStrings[sorted_pos])
                seventsType.append(self.qmc.specialeventstype[sorted_pos])
                seventsValue.append(self.qmc.specialeventsvalue[sorted_pos])
            for i, _ in enumerate(self.qmc.specialevents):
                # add BT/ET
                temps = ''
                formatString = '%.1fF' if self.qmc.mode == 'F' else '%.1f&deg;C'
                if self.qmc.temp1[sevents[i][0]] == -1 and self.qmc.temp2[sevents[i][0]] == -1:
                    temps += ' -- '
                elif self.qmc.temp1[sevents[i][0]] == -1:
                    temps += formatString % self.qmc.temp2[sevents[i][0]]
                elif self.qmc.temp2[sevents[i][0]] == -1:
                    temps += formatString % self.qmc.temp1[sevents[i][0]]
                else:
                    temps += formatString % self.qmc.temp2[sevents[i][0]] + ' / ' + formatString % self.qmc.temp1[
                        sevents[i][0]]
                # add DeltaBT / DeltaET
                deltas = ''
                if self.qmc.mode == 'F':
                    formatString = '%.1fF/min'
                # else:
                #     formatString = '%.1f&deg;C/min'
                try:
                    if (self.qmc.delta1[sevents[i][0]] is None or self.qmc.delta1[sevents[i][0]] == -1) and \
                            (self.qmc.delta2[sevents[i][0]] is None or self.qmc.delta2[sevents[i][0]] == -1):
                        deltas += ' -- '
                    elif self.qmc.delta1[sevents[i][0]] is None or self.qmc.delta1[sevents[i][0]] == -1:
                        deltas += formatString % self.qmc.delta2[sevents[i][0]]
                    elif self.qmc.delta2[sevents[i][0]] is None or self.qmc.delta2[sevents[i][0]] == -1:
                        deltas += formatString % self.qmc.delta1[sevents[i][0]]
                    else:
                        deltas += formatString % self.qmc.delta2[sevents[i][0]] + ' / ' + formatString % \
                                  self.qmc.delta1[sevents[i][0]]
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
                html += ('<tr>' +
                         '\n<td>' + str(i + 1) + '</td><td>' +
                         stringfromseconds(self.qmc.timex[sevents[i][0]] - start) +
                         "</td><td align='right'>" + temps + '</td><td>' +
                         "</td><td align='right'>" + deltas + '</td><td>' + seventsString[i] + (
                             '</td></tr>\n' if seventsType[i] == 4 else ('</td><td>(' + str(
                                 self.qmc.etypesf(seventsType[i])) + ' ' + self.qmc.eventsvalues(
                                 seventsValue[i]) + ')</td></tr>\n')))
            html += '</table>\n'
        return html

    @staticmethod
    def note2html(notes: str) -> str:
        notes_html = ''
        for nts in notes:
            if nts == '\t':
                notes_html += ' &nbsp&nbsp&nbsp&nbsp '
            elif nts == '\n':
                notes_html += '<br>\n'
            else:
                notes_html += str(nts)
        if notes_html != '':
            notes_html = '<br>' + notes_html
        return notes_html

    # returns the index of the lowest point in BT; return -1 if no such value found
    def findTP(self) -> int:
        return self.findTPint(self.qmc.timeindex, self.qmc.timex, self.qmc.temp2)

    @staticmethod
    def findTPint(timeindex: List[int], timex: List[float], temp: List[float]) -> int:
        TP: float = 1000
        idx: int = 0
        start: int = 0
        end: int = len(timex)
        # try to consider only indices until the roast end and not beyond
        EOR_index = end
        if timeindex[6]:
            EOR_index = timeindex[6]
        if start < EOR_index < end:
            end = EOR_index
        # try to consider only indices until FCs and not beyond
        FCs_index = end
        if timeindex[2]:
            FCs_index = timeindex[2]
        if start < FCs_index < end:
            end = FCs_index
        # try to consider only indices from start of roast on and not before
        SOR_index = start
        if timeindex[0] != -1:
            SOR_index = timeindex[0]
        if start < SOR_index < end:
            start = SOR_index
        for i in range(end - 1, start - 1, -1):
            if temp[i] > 0 and temp[i] < TP:
                TP = temp[i]
                idx = i
        return idx

    # returns the index of the end of the dry phase (returns -1 if dry end cannot be determined)
    # if given, starts at TP_index and looks forward, otherwise it looks backwards from end of roast (EoR)
    # find index with smallest abs() difference between self.qmc.phases[1] and BT (temp2)
    # phasesindex=1 => find DRY
    # phasesindex=2 => find FCs
    # NOTE: if there is no BT, this fails to deliver proper results!
    def findDryEnd(self, TP_index: Optional[int] = None, phasesindex: int = 1) -> int:
        sd: float = 1000
        nsd: float = 1000
        index: int = 0
        start: int = 0
        end: int = len(self.qmc.timex)
        # try to consider only indices until the roast end and not beyond
        EOR_index = end
        if self.qmc.timeindex[6]:
            EOR_index = self.qmc.timeindex[6]
        if start < EOR_index < end:
            end = EOR_index
        # try to consider only indices until FCs and not beyond
        FCs_index = end
        if self.qmc.timeindex[2]:
            FCs_index = self.qmc.timeindex[2]
        if start < FCs_index < end:
            end = FCs_index
        # try to consider only indices from start of roast on and not before
        SOR_index = start
        if self.qmc.timeindex[0] != -1:
            SOR_index = self.qmc.timeindex[0]
        if start < SOR_index < end:
            start = SOR_index
        # try to consider only indices from TP of roast on and not before
        TP = TP_index
        # if TP not yet computed, let's try to compute it
        if TP is None:
            TP = self.findTP()
        if start < TP < end:
            start = TP
        for i in range(end - 1, start - 1, -1):
            nsd = abs(self.qmc.temp2[i] - self.qmc.phases[phasesindex])
            if nsd < sd:
                sd = nsd
                index = i
        return index

    def checkTop(self, d: float, offset: float, dpre_dpost_diff: float, p0: float, p1: float, p2: float, p3: float,
                 p4: float, p5: float, twice: bool = False) -> bool:
        d1 = p0 - p1
        d2 = p1 - p2
        # --
        d3 = p4 - p3
        d4 = p5 - p4
        dpre = (d1 + d2) / 2.0
        dpost = (d3 + d4) / 2.0

        f = self.qmc.btbreak_params['f']
        maxdpre = self.qmc.btbreak_params['maxdpre']
        f_dtwice = self.qmc.btbreak_params['f_dtwice']

        # scale parameters for temperature units
        if self.qmc.mode == 'F':
            f *= 1.8
            d *= 1.8
            maxdpre *= 1.8
            dpre_dpost_diff *= 1.8

        if twice:
            d = d * f_dtwice

        # improved variant requesting for a certain minimum delta between the reading of interest and the next two post event legs:
        return bool(d3 < d and d4 < d and ((abs(dpost) > min(maxdpre, offset + (f * abs(dpre))))
                                           or (dpost < 0 and dpre < 0 and (-dpre - dpost) > dpre_dpost_diff)))

    # returns (negative) offset o>0 to current index i pointing to the index i-o at which a BTbreak was recognized or 0 if no BT break could be detected
    # i the index of the last reading to be considered to proof that i-2 (or i-4) is the index of the BT break
    # idea:
    # . average delta before i-2 is not negative
    # . average delta after i-2 is negative and twice as high (absolute) as the one before
    # d is minimum temperature delta of the two legs after the event to prevent too early recognition based on noise
    def BTbreak(self, i: int, event: str) -> int:
        # Compensate for fast sample rates
        if self.qmc.delay < self.qmc.btbreak_params['delay'][self.qmc.autoDropMode][2]:
            sampleMode = 2
        elif self.qmc.delay < self.qmc.btbreak_params['delay'][self.qmc.autoDropMode][1]:
            sampleMode = 1
        else:
            sampleMode = 0

        if event in {'DROP', 'drop'}:
            d = self.qmc.btbreak_params['d_drop'][self.qmc.autoDropMode][sampleMode]
            offset = self.qmc.btbreak_params['offset_drop'][self.qmc.autoDropMode][sampleMode]
            dpre_dpost_diff = self.qmc.btbreak_params['dpre_dpost_diff'][self.qmc.autoDropMode][sampleMode]
        else:  # CHARGE
            d = self.qmc.btbreak_params['d_charge'][self.qmc.autoChargeMode][sampleMode]
            offset = self.qmc.btbreak_params['offset_charge'][self.qmc.autoChargeMode][sampleMode]
            dpre_dpost_diff = self.qmc.btbreak_params['dpre_dpost_diff'][self.qmc.autoChargeMode][sampleMode]

        if len(self.qmc.timex) > 5 and 4 < i < len(
                self.qmc.timex):  # 'i>4' prevents reading temp2[-1] or worse when using BTbreak post recording
            if self.checkTop(d, offset, dpre_dpost_diff, self.qmc.temp2[i - 5], self.qmc.temp2[i - 4],
                             self.qmc.temp2[i - 3], self.qmc.temp2[i - 2], self.qmc.temp2[i - 1], self.qmc.temp2[i]):
                return self.qmc.btbreak_params['tight']
            if len(self.qmc.timex) > 10 and i > 10 and self.checkTop(d, offset, dpre_dpost_diff, self.qmc.temp2[i - 10],
                                                                     self.qmc.temp2[i - 8], self.qmc.temp2[i - 6],
                                                                     self.qmc.temp2[i - 4], self.qmc.temp2[i - 2],
                                                                     self.qmc.temp2[i], twice=True):
                return self.qmc.btbreak_params['loose']
        return 0

    # updates AUC guide (expected time to hit target AUC; self.qmc.AUCguideTime) based on current AUC, target, base, and RoR
    def updateAUCguide(self) -> None:
        if (len(self.qmc.delta2) > 0 and self.qmc.delta2[-1] is not None and self.qmc.delta2[
            -1] > 0 and  # we have a positive BT RoR
                self.qmc.TPalarmtimeindex is not None and  # we passed TP
                self.qmc.AUCvalue > 0):  # there is already some AUC available

            # so let's compute the AUCtarget
            if self.qmc.AUCtargetFlag and self.qmc.backgroundprofile is not None and self.qmc.AUCbackground > 0:
                # background AUC as target
                target = self.qmc.AUCbackground
            else:
                # use target AUC as specified by the user
                target = self.qmc.AUCtarget
            if target > 0 and target > self.qmc.AUCvalue:
                # only recompute AUC guid if a sensible target exists and the AUC target is not reached
                # so let's compute the AUCbase
                if self.qmc.AUCbegin == 0 and self.qmc.timeindex[0] > -1:  # start after CHARGE
                    idx = self.qmc.timeindex[0]
                elif self.qmc.AUCbegin == 1 and self.qmc.TPalarmtimeindex:  # start ater TP
                    idx = self.qmc.TPalarmtimeindex
                elif self.qmc.AUCbegin == 2 and self.qmc.timeindex[1] > 0:  # DRY END
                    idx = self.qmc.timeindex[1]
                elif self.qmc.AUCbegin == 3 and self.qmc.timeindex[2] > 0:  # FC START
                    idx = self.qmc.timeindex[2]
                else:
                    idx = -1
                if idx > -1:  # we passed the AUCbegin event
                    if self.qmc.AUCbaseFlag:
                        # we take the base temperature from the BT at st
                        tbase = self.qmc.temp2[idx]
                    else:
                        tbase = self.qmc.AUCbase
                    tbase = convertTemp(tbase, self.qmc.mode, 'C')
                    if tbase > 0 and len(self.qmc.temp2) > 0:
                        bt = convertTemp(self.qmc.temp2[-1], self.qmc.mode, 'C')
                        if bt > tbase:
                            # the time (in minutes) to reach the AUC target under the given base and current BT RoR
                            # is the positive root of the following equation
                            #   RoR/2*t^2 + (BT - base)*t + (AUCcurrent - AUCtarget) = 0
                            ror = convertRoR(self.qmc.delta2[-1], self.qmc.mode, 'C')  # BT RoR
                            if ror is not None:
                                roots = [r for r in numpy.roots([ror / 2.0, bt - tbase, self.qmc.AUCvalue - target]) if
                                         r > 0]
                                if len(roots) > 0:
                                    ts = self.qmc.timeclock.elapsed() / 1000.
                                    self.qmc.AUCguideTime = ts + roots[
                                        0] * 60  # takes the first positive root and calculates the time in seconds until the target AUC is reached
                                if self.qmc.l_AUCguide is not None:
                                    if self.qmc.AUCguideTime > 0 and self.qmc.AUCguideTime < self.qmc.endofx:
                                        self.qmc.l_AUCguide.set_xdata(self.qmc.AUCguideTime)
                                        self.qmc.l_AUCguide.set_visible(True)
                                    else:
                                        self.qmc.l_AUCguide.set_visible(False)

    def AUCstartidx(self, timeindex: List[int], TPindex: Optional[int]) -> int:
        if self.qmc.AUCbegin == 0 and timeindex[0] > -1:  # start after CHARGE
            return timeindex[0]
        if self.qmc.AUCbegin == 1 and TPindex is not None:  # start ater TP
            return TPindex
        if self.qmc.AUCbegin == 2 and timeindex[1] > 0:  # DRY END
            return timeindex[1]
        if self.qmc.AUCbegin == 3 and timeindex[2] > 0:  # FC START
            return timeindex[2]
        return -1

    def thisAUC(self, idx: int, timex: List[float], temp: List[float], mode: str) -> float:
        if self.qmc.AUCbaseFlag:
            # we take the base temperature from the BT at st
            if len(temp) > idx and temp[idx] is not None and temp[idx] != -1:
                tbase = temp[idx]
            else:
                # no proper base temperature available, return AUC=0
                return 0
        else:
            tbase = self.qmc.AUCbase
        tbase = convertTemp(tbase, mode, 'C')
        return self.calcAUC(tbase, timex, temp) / 60.

    # updates the running AUC variables self.qmc.AUCvalue and self.qmc.AUCsinceFCs during recording
    def updateAUC(self) -> None:
        idx = self.AUCstartidx(self.qmc.timeindex, self.qmc.TPalarmtimeindex)
        if idx > -1:  # we passed the AUCbegin event
            thisAUC = self.thisAUC(idx, self.qmc.timex, self.qmc.temp2, self.qmc.mode)
            self.qmc.AUCvalue += thisAUC
            if self.qmc.timeindex[2] > 0:
                self.qmc.AUCsinceFCs += thisAUC
            else:
                self.qmc.AUCsinceFCs = 0
        else:
            self.qmc.AUCvalue = 0
            self.qmc.AUCsinceFCs = 0

    # calculates the area underneath the temp curve between the last two measurements
    #  base: the base temperature in C
    #  timex: the list of time points
    #  temp: the list of temperature values
    #  i: index relative to i-1 the area is calculated. If omitted, the last elements in the list are used
    #  temp2: if temp2 is given, then the area between temp1 and temp2 is calculated, assuming temp1>temp2, and the base is ignored
    # result is in C*seconds
    def calcAUC(self, base: float, timex: List[float], temp: List[float], i: int = -1,
                temp2: Optional[List[float]] = None) -> float:
        if len(timex) > 1 and len(temp) > 1 and (i == -1 or (0 < i < min(len(timex), len(temp)))) and temp[
            i] is not None and temp[i] != -1 and temp[i - 1] is not None and temp[i - 1] != -1:
            # at least two readings available
            dt = timex[i] - timex[i - 1]
            t1 = convertTemp(temp[i], self.qmc.mode, 'C')
            if t1 > 500:
                t1 = 0
            t2 = convertTemp(temp[i - 1], self.qmc.mode, 'C')
            if t2 > 500:
                t2 = 0
            ta = (max(0, t1) + max(0, t2)) / 2.0
            if temp2 is None or len(temp2) < 2 or (i != -1 and len(temp2) < i + 1):
                return max(0, ta - base) * dt
            e1 = convertTemp(temp2[i], self.qmc.mode, 'C')
            if e1 > 500:
                e1 = 0
            e2 = convertTemp(temp2[i - 1], self.qmc.mode, 'C')
            if e2 > 500:
                e2 = 0
            ea = (max(0, e1) + max(0, e2)) / 2.0
            return max(0, ta - ea) * dt
        return 0

    # calculate the AREA under BT and ET (always in C!)
    # from "start" to "end" (defaults to CHARGE to DROP)
    # and use "rt" as reference temperature (area above "rt" and below ET/BT)
    # if background=True, use the background time and temperature values
    # returns AUC(ET-BT), AUC(ET), AUC(BT), AUCbegin_idx
    def ts(self, start: Optional[int] = None, end: Optional[int] = None, tp: Optional[int] = None,
           background: bool = False) -> Tuple[int, int, int, int]:
        if background:
            timeindex = self.qmc.timeindexB[:]
            timex = self.qmc.timeB[:]
            temp1 = self.qmc.temp1B[:]
            temp2 = self.qmc.temp2B[:]
        else:
            timeindex = self.qmc.timeindex[:]
            timex = self.qmc.timex[:]
            temp1 = self.qmc.temp1[:]
            temp2 = self.qmc.temp2[:]
        return self.profileAUC(timeindex, timex, temp1, temp2, start, end, tp)

    def profileAUC(self, timeindex: List[int], timex: List[float], temp1: List[float], temp2: List[float],
                   start: Optional[int] = None, end: Optional[int] = None, tp: Optional[int] = None) -> Tuple[
        int, int, int, int]:
        delta = ET = BT = 0.0
        AUCbegin_idx: int = 0
        if (start == 0 and end == 0) or (start and (start < 0 or (start == 0 and timeindex[0] < 0))) or (
                len(timex) == 0):
            return 0, 0, 0, 0
        try:
            if tp:
                TP_index = tp
            elif self.qmc.AUCbegin == 1:
                if self.qmc.TPalarmtimeindex:
                    TP_index = self.qmc.TPalarmtimeindex
                else:
                    TP_index = self.findTPint(timeindex, timex, temp2)
            else:
                TP_index = -1

            if self.qmc.AUCbegin == 0 and timeindex[0] > -1:  # CHARGE
                AUCbegin_idx = timeindex[0]
            elif self.qmc.AUCbegin == 1 and TP_index > -1:  # TP
                AUCbegin_idx = TP_index
            elif self.qmc.AUCbegin == 2 and timeindex[1] > 0:  # DRY END
                AUCbegin_idx = timeindex[1]
            elif self.qmc.AUCbegin == 3 and timeindex[2] > 0:  # FC START
                AUCbegin_idx = timeindex[2]
            else:
                AUCbegin_idx = 0

            st = AUCbegin_idx if start is None else start

            ed = min(len(timex), (end or timeindex[6]))

            if self.qmc.AUCbaseFlag:
                # we take the base temperature from the BT at st
                rtet = temp1[AUCbegin_idx]
                rtbt = temp2[AUCbegin_idx]
            else:
                rtet = rtbt = self.qmc.AUCbase
            rtet = convertTemp(rtet, self.qmc.mode, 'C')
            rtbt = convertTemp(rtbt, self.qmc.mode, 'C')

            for i in range(st, ed):
                ET += self.calcAUC(rtet, timex, temp1, i)
                BT += self.calcAUC(rtbt, timex, temp2, i)
                delta += self.calcAUC(rtbt, timex, temp1, i, temp2)
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror((QApplication.translate('Error Message', 'Exception:') + ' ts() {0}').format(str(e)),
                              getattr(exc_tb, 'tb_lineno', '?'))
        return int(round(delta / 60.)), int(round(ET / 60.)), int(round(BT / 60.)), AUCbegin_idx

    # Find rate of change of each phase. TP_index (by self.findTP()) is the index of the TP and dryEndIndex that of the end of drying (by self.findDryEnd())
    # Note: For the dryphase, the RoR for the dryphase is calculated for the segment starting from TP ending at DE
    # returns -1 if data is not available
    def RoR(self, TP_index: int, dryEndIndex: int) -> Tuple[float, float, float, float, float, float]:
        midphasetime = self.qmc.statisticstimes[2]
        finishphasetime = self.qmc.statisticstimes[3]
        BTdrycross = None
        rc1 = rc2 = rc3 = 0.
        dt1 = dt2 = dt3 = -1.
        divisor: float = 0
        LP: float = 0.
        temp: List[float] = self.qmc.temp2
        if not self.qmc.BTcurve and self.qmc.ETcurve:
            # if just the ET curve is shown we report based on ET data
            temp = self.qmc.temp1
        if -1 < dryEndIndex < len(temp):
            BTdrycross = temp[dryEndIndex]
        if BTdrycross is not None and self.qmc.greens_temp > 0:
            LP = self.qmc.greens_temp
            # avoid dividing by zero
            divisor = self.qmc.timex[dryEndIndex] - self.qmc.timex[self.qmc.timeindex[0]]
        elif BTdrycross is not None and -1 < TP_index < min(1000, len(temp)) and dryEndIndex:
            LP = temp[TP_index]
            # avoid dividing by zero
            divisor = self.qmc.timex[dryEndIndex] - self.qmc.timex[TP_index]
        if BTdrycross is not None and divisor != 0 and is_proper_temp(BTdrycross):
            rc1 = ((BTdrycross - LP) / divisor) * 60.
            dt1 = BTdrycross - LP
        if self.qmc.timeindex[2]:
            if midphasetime and BTdrycross and is_proper_temp(BTdrycross) and is_proper_temp(
                    temp[self.qmc.timeindex[2]]):
                rc2 = ((temp[self.qmc.timeindex[2]] - BTdrycross) / midphasetime) * 60.
                dt2 = temp[self.qmc.timeindex[2]] - BTdrycross
            if finishphasetime and is_proper_temp(temp[self.qmc.timeindex[6]]) and is_proper_temp(
                    temp[self.qmc.timeindex[2]]):
                rc3 = ((temp[self.qmc.timeindex[6]] - temp[self.qmc.timeindex[2]]) / finishphasetime) * 60.
                dt3 = temp[self.qmc.timeindex[6]] - temp[self.qmc.timeindex[2]]
        return (rc1, rc2, rc3, dt1, dt2, dt3)

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewErrorLog(self, _: bool = False) -> None:
        if self.error_dlg is None:
            self.error_dlg = errorDlg(self, self)
            if self.error_dlg is not None:
                self.error_dlg.setModal(False)
                self.error_dlg.show()
        if self.error_dlg is not None:
            self.error_dlg.raise_()
            self.error_dlg.activateWindow()

    #            QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewSerialLog(self, _: bool = False) -> None:
        if self.serial_dlg is None:
            self.serial_dlg = serialLogDlg(self, self)
            if self.serial_dlg is not None:
                self.serial_dlg.setModal(False)
                self.serial_dlg.show()
        if self.serial_dlg is not None:
            self.serial_dlg.raise_()
            self.serial_dlg.activateWindow()

    #            QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewplatform(self, _: bool = False) -> None:
        from artisanlib.platformdlg import platformDlg
        platformDLG = platformDlg(self, self)
        platformDLG.setModal(False)
        platformDLG.show()
        platformDLG.activateWindow()

    #        QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def viewMessageLog(self, _: bool = False) -> None:
        if self.message_dlg is None:
            self.message_dlg = messageDlg(self, self)
            if self.message_dlg is not None:
                self.message_dlg.setModal(False)
                self.message_dlg.show()
        if self.message_dlg is not None:
            self.message_dlg.raise_()
            self.message_dlg.activateWindow()

    #            QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def helpAbout(self, _: bool = False) -> None:
        # pylint: disable=consider-using-f-string
        coredevelopers = '<br>Rafael Cobo, Marko Luther &amp; Dave Baxter'
        contribs = ['<br>' + uchr(199) + 'etin Barut, Marcio Carnerio, Bradley Collins, ',
                    'Sebastien Delgrande, Kalle Deligeorgakis, Jim Gall, ',
                    'Frans Goddijn, Rich Helms, Kyle Iseminger, Ingo, ',
                    'Savvas Kiretsis, Lukas Kolbe, David Lahoz, ',
                    'Runar Ostnes, Carlos Pascual, Claudia Raddatz, ',
                    'Matthew Sewell, Bertrand Souville, Minoru Yoshida, ',
                    "Wa'il, Alex Fan, Piet Dijk, Rubens Gardelli, ",
                    'David Trebilcock, Zolt' + uchr(225) + 'n Kis, Miroslav Stankovic, ',
                    'Barrie Fairley, Ziv Sade, Nicholas Seckar, ',
                    'Morten M' + uchr(252) + 'nchow',
                    ', Andrzej Kie' + uchr(322) + 'basi' + uchr(324) + 'ski, Marco Cremonese, Josef Gander',
                    ', Paolo Scimone, Google, eightbit11, Phidgets, Hottop, Yoctopuce, Taras Prokopyuk',
                    ', Reiss Gunson (Londinium), Ram Evgi (Coffee-Tech), Rob Gardner, Jaroslav Tu' + uchr(
                        269) + 'ek (doubleshot)',
                    ', Nick Watson, Azis Nawawi, Rit Multi, Joongbae Dave Cho (the Chambers), Probat, Andreas Bader, Dario Ernst',
                    ', Nicolas (Marvell Street Coffee Roasters), Randy (Buckeye Coffee), Moshe Spinell',
                    ', Morris Beume (Morris.Coffee), Michael Herbert, Bill (San Franciscan Roaster), Chistopher Feran',
                    ', Coffed, Bono Gargolov, Rodrigo Ramos (King Caf' + uchr(
                        233) + 's), Nico Bigler, Saeed Abdinasab, Lewis Li',
                    ', Fotis Lefas (Coffee Lovers, Editors & Trainers), Leo Huang (Rainforest Coffee Institute)<br>'
                    ]
        contributors = ''.join(contribs)
        box = QMessageBox(self)

        # create a html QString
        from scipy import __version__ as SCIPY_VERSION_STR  # type: ignore # @UnresolvedImport
        from pymodbus import __version__ as PYMODBUS_VERSION_STR
        build = ''
        if __build__ != '0':
            build = ' build ' + __build__
        name = (application_viewer_name if self.app.artisanviewerMode else application_name)
        otherlibs = ''
        try:
            from Phidget22.Phidget import Phidget as PhidgetDriver  # type: ignore
            phidgetlibversion = PhidgetDriver.getLibraryVersion()
            otherlibs += ', ' + phidgetlibversion
        except Exception as e:  # pylint: disable=broad-except
            _log.debug(e)
        try:
            from Phidget22 import __version__ as phidget_lib_version  # type: ignore # @UnresolvedImport
            otherlibs += f' ({phidget_lib_version})'
        except Exception:  # pylint: disable=broad-except
            pass
        try:
            yocto_version = YAPI.GetAPIVersion()  # type:ignore[reportPossibleUnboundVariable,unused-ignore]
            otherlibs += ', Yoctopuce ' + yocto_version
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
        box.about(self,
                  QApplication.translate('About', 'About'),
                  """<h2>{0} {1}{16} ({2})</h2>
                  <p>
                  <small>Python {3}, Qt {4}, PyQt {5}, Matplotlib {6}, NumPy {7}, SciPy {8}, pymodbus {13}{17}</small>
                  </p>
                  <p>{18}</p>
                  <p><b>{9}</b><small>{10}</small></p>
                  <p><b>{11}</b><small>{12}</small></p>
                  <p><b>{14}</b><br><small>{15}</small></p>
                  """.format(  # noqa: UP030
                      name,
                      str(__version__),
                      str(__revision__),
                      platform.python_version(),
                      qVersion(),
                      PYQT_VERSION_STR,
                      mpl.__version__,
                      numpy.__version__,
                      SCIPY_VERSION_STR,
                      QApplication.translate('About', 'Core Developers'),
                      coredevelopers,
                      QApplication.translate('About', 'Contributors'),
                      contributors,
                      PYMODBUS_VERSION_STR,
                      QApplication.translate('About', 'License'),
                      '<a href="http://www.gnu.org/copyleft/gpl.html">GNU Public Licence (GPLv3.0)</a>',
                      build,
                      otherlibs,
                      '<a href="https://artisan-scope.org">https://artisan-scope.org</a>'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def showAboutQt(self, _: bool = False) -> None:
        # pylint: disable=no-self-use # used as slot
        self.app.aboutQt()

    @pyqtSlot()
    @pyqtSlot(bool)
    def helpHelp(self, _: bool = False) -> None:  # pylint: disable=no-self-use # used as slot
        QDesktopServices.openUrl(QUrl('https://artisan-scope.org/help/', QUrl.ParsingMode.TolerantMode))

    @pyqtSlot()
    @pyqtSlot(bool)
    def checkUpdate(self, _: bool = False) -> None:
        update_url = '<a href="https://artisan-scope.org">https://artisan-scope.org</a>'
        update_str = QApplication.translate('About',
                                            'There was a problem retrieving the latest version information.  Please check your Internet connection, try again later, or check manually.')
        try:
            import requests
            r = requests.get('https://api.github.com/repos/artisan-roaster-scope/artisan/releases/latest',
                             timeout=(2, 4))
            tag_name = r.json()['tag_name']
            match = re.search(r'[\d\.]+', tag_name)
            if match is not None:
                latest = match.group(0)
                if latest > __version__:
                    update_str = QApplication.translate('About', 'A new release is available.')
                    update_str += '<br/><a href="https://github.com/artisan-roaster-scope/artisan/blob/master/wiki/ReleaseHistory.md">'
                    update_str += QApplication.translate('About', 'Show Change list')
                    update_str += '<br/><a href="https://github.com/artisan-roaster-scope/artisan/releases/tag/' + str(
                        tag_name) + '">'
                    update_str += QApplication.translate('About', 'Download Release') + ' ' + str(tag_name)
                elif latest == __version__:
                    update_str = QApplication.translate('About', 'You are using the latest release.')
                elif latest < __version__:
                    update_str = QApplication.translate('About', 'You are using a beta continuous build.')
                    update_str += '<br/><br/>' + QApplication.translate('About',
                                                                        'You will see a notice here once a new official release is available.')
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _a, _b, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' checkUpdate() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

        box = QMessageBox(self)
        box.about(self,
                  QApplication.translate('About', 'Update status'),
                  f"""<p>{update_str}</p>{update_url}""")

    def applicationscreenshot(self) -> None:
        imag = self.grab()
        fmt = 'png'
        initialPath = QDir.currentPath() + '/ArtisanScreenshot.' + fmt
        fileName = QFileDialog.getSaveFileName(self, 'Artisan ScreenShot',
                                               initialPath,
                                               f'{fmt.upper()} Files (*.{fmt});;All Files (*)')[0]
        if fileName:
            imag.save(fileName, fmt)

    def desktopscreenshot(self) -> None:
        screen = QApplication.primaryScreen()
        if screen is not None:
            try:
                imag = screen.grabWindow()  # QApplication.desktop() has been removed in Qt6
            except Exception:  # pylint: disable-broad-except
                imag = screen.grabWindow(QApplication.desktop().winId())  # type: ignore  #PyQt5
            fmt = 'png'
            initialPath = QDir.currentPath() + '/DesktopScreenshot.' + fmt
            fileName = QFileDialog.getSaveFileName(self, 'Desktop ScreenShot',
                                                   initialPath,
                                                   f'{fmt.upper()} Files (*.{fmt});;All Files (*)')[0]
            if fileName:
                imag.save(fileName, fmt)

    @pyqtSlot()
    @pyqtSlot(bool)
    def calibratedelay(self, _: bool = False) -> None:
        from artisanlib.sampling import SamplingDlg
        samplingDl = SamplingDlg(self, self)
        samplingDl.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def setcommport(self, _: bool = False) -> None:
        from artisanlib.ports import comportDlg
        dialog = comportDlg(self, self)
        if dialog.exec():
            # we stop the HOTTOP loop to trigger a new connect with the potential changed serial port settings
            if self.qmc.device == 53 and self.hottop:
                # disconnect HOTTOP
                self.hottop.stop()
            # set serial port
            self.ser.comport = str(dialog.comportEdit.getSelection())
            self.ser.baudrate = int(str(dialog.baudrateComboBox.currentText()))  # int changes QString to int
            self.ser.bytesize = int(str(dialog.bytesizeComboBox.currentText()))
            self.ser.stopbits = int(str(dialog.stopbitsComboBox.currentText()))
            self.ser.parity = str(dialog.parityComboBox.currentText())
            self.ser.timeout = self.float2float(toFloat(comma2dot(str(dialog.timeoutEdit.text()))))
            # set modbus port
            self.modbus.comport = str(dialog.modbus_comportEdit.getSelection())
            self.modbus.baudrate = int(str(dialog.modbus_baudrateComboBox.currentText()))  # int changes QString to int
            self.modbus.bytesize = int(str(dialog.modbus_bytesizeComboBox.currentText()))
            self.modbus.stopbits = int(str(dialog.modbus_stopbitsComboBox.currentText()))
            self.modbus.parity = str(dialog.modbus_parityComboBox.currentText())
            self.modbus.timeout = max(0.3, self.float2float(
                toFloat(str(dialog.modbus_timeoutEdit.text()))))  # minimum serial timeout should be 300ms
            try:
                self.modbus.modbus_serial_extra_read_delay = toInt(dialog.modbus_Serial_delayEdit.text()) / 1000
            except Exception:  # pylint: disable=broad-except
                pass
            self.modbus.serial_readRetries = dialog.modbus_Serial_retriesComboBox.currentIndex()
            try:
                self.modbus.IP_timeout = self.float2float(toFloat(str(dialog.modbus_IP_timeoutEdit.text())))
            except Exception:  # pylint: disable=broad-except
                pass
            self.modbus.IP_retries = dialog.modbus_IP_retriesComboBox.currentIndex()
            self.modbus.PID_slave_ID = int(str(dialog.modbus_PIDslave_Edit.text()))
            self.modbus.PID_SV_register = int(str(dialog.modbus_SVregister_Edit.text()))
            self.modbus.PID_p_register = int(str(dialog.modbus_Pregister_Edit.text()))
            self.modbus.PID_i_register = int(str(dialog.modbus_Iregister_Edit.text()))
            self.modbus.PID_d_register = int(str(dialog.modbus_Dregister_Edit.text()))
            self.modbus.PID_OFF_action = s2a(toString(dialog.modbus_pid_off.text()))
            self.modbus.PID_ON_action = s2a(toString(dialog.modbus_pid_on.text()))

            for i in range(self.modbus.channels):
                try:
                    inputSlaveEdit = dialog.modbus_inputSlaveEdits[i]
                    if inputSlaveEdit is not None:
                        self.modbus.inputSlaves[i] = int(inputSlaveEdit.text())
                except Exception:  # pylint: disable=broad-except
                    self.modbus.inputSlaves[i] = 0
                try:
                    inputRegisterEdit = dialog.modbus_inputRegisterEdits[i]
                    if inputRegisterEdit is not None:
                        self.modbus.inputRegisters[i] = int(inputRegisterEdit.text())
                except Exception:  # pylint: disable=broad-except
                    self.modbus.inputRegisters[i] = 0
                try:
                    inputCode = dialog.modbus_inputCodes[i]
                    if inputCode is not None:
                        self.modbus.inputCodes[i] = int(inputCode.currentText())
                except Exception:  # pylint: disable=broad-except
                    self.modbus.inputCodes[i] = 3
                try:
                    inputDiv = dialog.modbus_inputDivs[i]
                    if inputDiv is not None:
                        self.modbus.inputDivs[i] = inputDiv.currentIndex()
                except Exception:  # pylint: disable=broad-except
                    self.modbus.inputDivs[i] = 0
                try:
                    inputMode = dialog.modbus_inputModes[i]
                    if inputMode is not None:
                        self.modbus.inputModes[i] = str(inputMode.currentText())
                except Exception:  # pylint: disable=broad-except
                    self.modbus.inputModes[i] = 'C'
                inputDecode = dialog.modbus_inputDecodes[i]
                if inputDecode is not None:
                    if inputDecode.currentIndex() == 4:
                        self.modbus.inputBCDsAsInt[i] = True
                        self.modbus.inputFloatsAsInt[i] = False
                        self.modbus.inputFloats[i] = False
                        self.modbus.inputBCDs[i] = False
                        self.modbus.inputSigned[i] = False
                    elif inputDecode.currentIndex() == 1:
                        self.modbus.inputBCDsAsInt[i] = False
                        self.modbus.inputFloatsAsInt[i] = True
                        self.modbus.inputFloats[i] = False
                        self.modbus.inputBCDs[i] = False
                        self.modbus.inputSigned[i] = False
                    elif inputDecode.currentIndex() == 6:
                        self.modbus.inputBCDsAsInt[i] = False
                        self.modbus.inputFloatsAsInt[i] = False
                        self.modbus.inputFloats[i] = True
                        self.modbus.inputBCDs[i] = False
                        self.modbus.inputSigned[i] = False
                    elif inputDecode.currentIndex() == 5:
                        self.modbus.inputBCDsAsInt[i] = False
                        self.modbus.inputFloatsAsInt[i] = False
                        self.modbus.inputFloats[i] = False
                        self.modbus.inputBCDs[i] = True
                        self.modbus.inputSigned[i] = False
                    elif inputDecode.currentIndex() == 2:
                        self.modbus.inputBCDsAsInt[i] = False
                        self.modbus.inputFloatsAsInt[i] = False
                        self.modbus.inputFloats[i] = False
                        self.modbus.inputBCDs[i] = False
                        self.modbus.inputSigned[i] = True
                    elif inputDecode.currentIndex() == 3:
                        self.modbus.inputBCDsAsInt[i] = False
                        self.modbus.inputFloatsAsInt[i] = True
                        self.modbus.inputFloats[i] = False
                        self.modbus.inputBCDs[i] = False
                        self.modbus.inputSigned[i] = True
                    else:  # index 0
                        self.modbus.inputBCDsAsInt[i] = False
                        self.modbus.inputFloatsAsInt[i] = False
                        self.modbus.inputFloats[i] = False
                        self.modbus.inputBCDs[i] = False
                        self.modbus.inputSigned[i] = False

            self.modbus.SVmultiplier = dialog.modbus_SVmultiplier.currentIndex()
            self.modbus.PIDmultiplier = dialog.modbus_PIDmultiplier.currentIndex()
            self.modbus.byteorderLittle = bool(dialog.modbus_littleEndianBytes.isChecked())
            self.modbus.wordorderLittle = bool(dialog.modbus_littleEndianWords.isChecked())
            self.modbus.optimizer = bool(dialog.modbus_optimize.isChecked())
            self.modbus.fetch_max_blocks = bool(dialog.modbus_full_block.isChecked())
            self.modbus.reset_socket = bool(dialog.modbus_reset.isChecked())
            self.modbus.type = int(dialog.modbus_type.currentIndex())
            # self.modbus.host = str(dialog.modbus_hostEdit.text())修改host
            self.modbus.host = str(self.deviceAddressEdit.text())
            try:
                self.modbus.port = int(str(dialog.modbus_portEdit.text()))
            except Exception:  # pylint: disable=broad-except
                pass

            # WebSocket Setup
            self.ws.host = str(dialog.ws_hostEdit.text()).strip()
            self.ws.port = int(str(dialog.ws_portEdit.text()))
            self.ws.path = str(dialog.ws_pathEdit.text()).strip()
            self.ws.machineID = int(str(dialog.ws_machineIDEdit.text()))
            self.ws.connect_timeout = float(dialog.ws_connect_timeout.value())
            self.ws.reconnect_interval = float(dialog.ws_reconnect_timeout.value())
            self.ws.request_timeout = float(dialog.ws_request_timeout.value())
            self.ws.id_node = str(dialog.ws_messageID.text()).strip()
            self.ws.machine_node = str(dialog.ws_machineID.text()).strip()
            self.ws.command_node = str(dialog.ws_command.text()).strip()
            self.ws.data_node = str(dialog.ws_data.text()).strip()
            self.ws.pushMessage_node = str(dialog.ws_message.text())
            self.ws.request_data_command = str(dialog.ws_data_request.text()).strip()
            self.ws.charge_message = str(dialog.ws_charge.text()).strip()
            self.ws.drop_message = str(dialog.ws_drop.text()).strip()
            self.ws.STARTonCHARGE = bool(dialog.ws_STARTonCHARGE.isChecked())
            self.ws.OFFonDROP = bool(dialog.ws_OFFonDROP.isChecked())
            self.ws.addEvent_message = str(dialog.ws_event_message.text()).strip()
            self.ws.event_node = str(dialog.ws_event.text()).strip()
            self.ws.DRY_node = str(dialog.ws_DRY.text()).strip()
            self.ws.FCs_node = str(dialog.ws_FCs.text()).strip()
            self.ws.FCe_node = str(dialog.ws_FCe.text()).strip()
            self.ws.SCs_node = str(dialog.ws_SCs.text()).strip()
            self.ws.SCe_node = str(dialog.ws_SCe.text()).strip()

            for i in range(self.ws.channels):
                self.ws.channel_requests[i] = str(dialog.ws_requestEdits[i].text()).strip()
                self.ws.channel_nodes[i] = str(dialog.ws_nodeEdits[i].text()).strip()
                self.ws.channel_modes[i] = int(dialog.ws_modeCombos[i].currentIndex())

            # S7 Setup
            self.s7.host = str(dialog.s7_hostEdit.text())
            self.s7.port = int(str(dialog.s7_portEdit.text()))
            self.s7.rack = int(str(dialog.s7_rackEdit.text()))
            self.s7.slot = int(str(dialog.s7_slotEdit.text()))
            for i in range(self.s7.channels):
                self.s7.area[i] = dialog.s7_areaCombos[i].currentIndex()
                self.s7.db_nr[i] = int(str(dialog.s7_dbEdits[i].text()))
                self.s7.start[i] = int(str(dialog.s7_startEdits[i].text()))
                self.s7.type[i] = dialog.s7_typeCombos[i].currentIndex()
                self.s7.div[i] = dialog.s7_divCombos[i].currentIndex()
                self.s7.mode[i] = dialog.s7_modeCombos[i].currentIndex()
            self.s7.PID_area = dialog.s7_PIDarea.currentIndex()
            self.s7.PID_db_nr = int(str(dialog.s7_PIDdb_nr_Edit.text()))
            self.s7.PID_SV_register = int(str(dialog.s7_SVregister_Edit.text()))
            self.s7.SVmultiplier = dialog.s7_SVmultiplier.currentIndex()
            self.s7.SVtype = dialog.s7_SVtype.currentIndex()
            self.s7.PIDmultiplier = dialog.s7_PIDmultiplier.currentIndex()
            self.s7.PID_p_register = int(str(dialog.s7_Pregister_Edit.text()))
            self.s7.PID_i_register = int(str(dialog.s7_Iregister_Edit.text()))
            self.s7.PID_d_register = int(str(dialog.s7_Dregister_Edit.text()))
            self.s7.PID_OFF_action = s2a(toString(dialog.s7_pid_off.text()))
            self.s7.PID_ON_action = s2a(toString(dialog.s7_pid_on.text()))
            self.s7.optimizer = bool(dialog.s7_optimize.isChecked())
            self.s7.fetch_max_blocks = bool(dialog.s7_full_block.isChecked())

            # set scale port
            self.scale.device = str(
                dialog.scale_deviceEdit.currentText())  # unicode() changes QString to a python string
            if self.scale.device in self.scale.bluetooth_devices and not self.app.getBluetoothPermission():
                self.scale.device = None
                message: str = QApplication.translate('Message',
                                                      'Bluetooth scale cannot be connected while permission for Artisan to access Bluetooth is denied')
                QMessageBox.information(self, QApplication.translate('Message', 'Bluetooth access denied'), message)
            self.scale.comport = str(dialog.scale_comportEdit.getSelection())
            self.scale.baudrate = int(str(dialog.scale_baudrateComboBox.currentText()))  # int changes QString to int
            self.scale.bytesize = int(str(dialog.scale_bytesizeComboBox.currentText()))
            self.scale.stopbits = int(str(dialog.scale_stopbitsComboBox.currentText()))
            self.scale.parity = str(dialog.scale_parityComboBox.currentText())
            self.scale.timeout = self.float2float(toFloat(comma2dot(str(dialog.scale_timeoutEdit.text()))))
            # set color port
            self.color.device = str(
                dialog.color_deviceEdit.currentText())  # unicode() changes QString to a python string
            self.color.comport = str(dialog.color_comportEdit.getSelection())
            self.color.baudrate = int(str(dialog.color_baudrateComboBox.currentText()))  # int changes QString to int
            self.color.bytesize = int(str(dialog.color_bytesizeComboBox.currentText()))
            self.color.stopbits = int(str(dialog.color_stopbitsComboBox.currentText()))
            self.color.parity = str(dialog.color_parityComboBox.currentText())
            self.color.timeout = self.float2float(toFloat(comma2dot(str(dialog.color_timeoutEdit.text()))))

    #        # deleteLater() will not work here as the dialog is still bound via the parent
    #        dialog.deleteLater() # now we explicitly allow the dialog an its widgets to be GCed
    #        # the following will immediately release the memory despite this parent link
    #        QApplication.processEvents() # we ensure events concerning this dialog are processed before deletion
    #        try:
    #            sip.delete(dialog)
    #            #print(sip.isdeleted(dialog))
    #        except Exception: # pylint: disable=broad-except
    #            pass
    #        #self.closeEventSettings() # save all app settings

    def toggleHottopControl(self) -> None:
        if self.HottopControlActive:
            self.HottopControlOff()
        else:
            self.HottopControlOn()

    def HottopControlOff(self) -> None:
        if self.hottop is not None:
            res = self.hottop.releaseHottopControl()
            if res:
                if self.HottopControlActive:
                    self.sendmessage(QApplication.translate('Message', 'Hottop control turned off'))
                self.HottopControlActive = False
                self.buttonCONTROL.setStyleSheet(self.pushbuttonstyles['PID'])

    def HottopControlOn(self) -> None:
        if self.superusermode:  # Hottop control mode can for now activated only in super user mode
            if self.hottop is not None:
                res = self.hottop.takeHottopControl()
                if res:
                    self.hottop.setHottop(drum_motor=True)
                    self.buttonCONTROL.setStyleSheet(self.pushbuttonstyles['PIDactive'])
                    if not self.HottopControlActive:
                        self.sendmessage(QApplication.translate('Message', 'Hottop control turned on'))
                    self.HottopControlActive = True
        else:
            QMessageBox.warning(self, QApplication.translate('Message', 'Warning'), QApplication.translate('Message',
                                                                                                           'To control a Hottop you need to activate the super user mode via a right click on the timer LCD first!'))

    @pyqtSlot(bool)
    def PIDcontrol(self, _: bool = False) -> None:
        # FUJI/DELTA pid
        if self.qmc.device in {0, 26}:
            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.KeyboardModifier.ControlModifier and self.qmc.device == 0:
                # a right-click on the Control button will toggle PID Standby on and off
                standby = self.fujipid.getONOFFstandby()
                if standby == 0:
                    # standby is off (=0), turn it on (=1)
                    self.fujipid.setONOFFstandby(1)
                    self.sendmessage(QApplication.translate('Message', 'PID set to OFF'))
                elif standby == 1:
                    # standby is on (=1), turn it off (=0)
                    self.fujipid.setONOFFstandby(0)
                    self.sendmessage(QApplication.translate('Message', 'PID set to ON'))
            else:
                dialog: Union[PXG4pidDlgControl, PXRpidDlgControl, DTApidDlgControl, PID_DlgControl]
                if self.ser.controlETpid[0] == 0:
                    dialog = PXG4pidDlgControl(self, self)
                elif self.ser.controlETpid[0] == 1:
                    dialog = PXRpidDlgControl(self, self)
                elif self.ser.controlETpid[0] == 2:
                    dialog = DTApidDlgControl(self, self)
                else:  # self.ser.controlETpid[0] == 4: # Fuji PXF
                    dialog = PXG4pidDlgControl(self, self)
                # modeless style dialog
                dialog.setModal(False)
                # dialog.show()
                # dialog.setFixedSize(dialog.size())
        # Hottop
        elif self.qmc.device == 53:
            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.KeyboardModifier.ControlModifier:
                dialog = PID_DlgControl(self, self, self.PID_DlgControl_activeTab)
                # modeless style dialog
                dialog.show()
            else:
                # self.pidcontrol.togglePID()
                self.toggleHottopControl()
        # all other devices
        else:
            modifiers = QApplication.keyboardModifiers()
            if modifiers == Qt.KeyboardModifier.ControlModifier:
                self.pidcontrol.togglePID()
            else:
                dialog = PID_DlgControl(self, self, self.PID_DlgControl_activeTab)
                # modeless style dialog
                # dialog.show()

    #                dialog.setFixedSize(dialog.size())  # this badly interacts with keeping the window geometry in qsettings

    @pyqtSlot()
    @pyqtSlot(bool)
    def deviceassigment(self, _: bool = False) -> None:
        from artisanlib.devices import DeviceAssignmentDlg
        dialog = DeviceAssignmentDlg(self, self, self.DeviceAssignmentDlg_activeTab)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def showstatistics(self, _: bool = False) -> None:
        from artisanlib.statistics import StatisticsDlg
        dialog = StatisticsDlg(self, self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def Windowconfig(self, _: bool = False) -> None:
        from artisanlib.axis import WindowsDlg
        dialog = WindowsDlg(self, self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def autosaveconf(self, _: bool = False) -> None:
        from artisanlib.autosave import autosaveDlg
        dialog = autosaveDlg(self, self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def batchconf(self, _: bool = False) -> None:
        from artisanlib.batches import batchDlg
        dialog = batchDlg(self, self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def calculator(self, _: bool = False) -> None:
        from artisanlib.calculator import calculatorDlg
        dialog = calculatorDlg(self, self)
        dialog.setModal(False)
        dialog.show()

    #        QApplication.processEvents()

    @pyqtSlot()
    @pyqtSlot(bool)
    def loadSettings_triggered(self, _: bool = False) -> None:
        _log.info('menu load settings')
        self.loadSettings()

    def loadSettings(self, fn: Optional[str] = None, remember: bool = True, reset: bool = True,
                     machine: bool = False, theme: bool = False, reload: bool = True) -> None:
        try:
            filename = fn if fn else self.ArtisanOpenFileDialog()
            if filename:
                try:
                    self.stopActivities()
                    saveCurfile = self.curFile
                    res = self.settingsLoad(filename, machine=machine, theme=theme, redraw=not reset)
                    if res and reset:
                        flag_temp = self.qmc.roastpropertiesflag
                        self.qmc.roastpropertiesflag = 1  # ensure that all roast properties are reset!
                        self.qmc.reset(soundOn=False, fireResetAction=False,
                                       redraw=not (reload and saveCurfile is not None))
                        self.qmc.roastpropertiesflag = flag_temp
                        if reload and saveCurfile is not None:
                            self.loadFile(saveCurfile)
                    if res and remember:
                        # update recentSettings menu
                        settings = QSettings()
                        files = toStringList(settings.value('recentSettingList'))
                        try:
                            removeAll(files, filename)
                        except ValueError:
                            pass
                        files.insert(0, filename)
                        del files[self.MaxRecentFiles:]
                        settings.setValue('recentSettingList', files)
                        for widget in QApplication.topLevelWidgets():
                            if isinstance(widget, ApplicationWindow):
                                widget.updateRecentSettingActions()
                        self.sendmessage(
                            QApplication.translate('Message', f'Settings loaded {self.strippedName(filename)}'))
                    elif not res and remember:
                        # remove file from the recent file list
                        settings = QSettings()
                        files = toStringList(settings.value('recentSettingList'))
                        try:
                            removeAll(files, filename)
                        except ValueError:
                            pass
                        settings.setValue('recentSettingList', files)
                        for widget in QApplication.topLevelWidgets():
                            if isinstance(widget, ApplicationWindow):
                                widget.updateRecentSettingActions()
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
                    # remove file from the recent file list
                    settings = QSettings()
                    files = toStringList(settings.value('recentSettingList'))
                    try:
                        removeAll(files, filename)
                    except ValueError:
                        pass
                    settings.setValue('recentSettingList', files)
                    for widget in QApplication.topLevelWidgets():
                        if isinstance(widget, ApplicationWindow):
                            widget.updateRecentSettingActions()
            else:
                self.sendmessage(QApplication.translate('Message', 'Cancelled'))
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' loadSettings() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

    def updateRecentSettingActions(self) -> None:
        settings = QSettings()
        files = toStringList(settings.value('recentSettingList'))
        strippedNames = list(map(self.strippedName, files))
        numRecentSettings = min(len(files), self.MaxRecentFiles)

        for i in range(numRecentSettings):
            strippedName = self.strippedName(files[i])
            if strippedNames.count(strippedName) > 1:
                text = f'&{strippedName} ({self.strippedDir(files[i])})'
            else:
                text = f'&{strippedName}'
            self.recentSettingActs[i].setText(text)
            self.recentSettingActs[i].setData(files[i])
            self.recentSettingActs[i].setVisible(True)

        for j in range(numRecentSettings, self.MaxRecentFiles):
            self.recentSettingActs[j].setVisible(False)

    @pyqtSlot(bool)
    def openRecentSetting(self, _checked: bool = False) -> None:
        action = self.sender()
        if action and hasattr(action, 'data'):
            fname = toString(action.data())
            if os.path.isfile(fname):
                _log.info('menu load recent settings: %s', fname)
                self.loadSettings(fn=fname, remember=True)
            else:
                settings = QSettings()
                files = toStringList(settings.value('recentSettingList'))
                try:
                    removeAll(files, fname)
                except ValueError:
                    pass
                settings.setValue('recentSettingList', files)
                for widget in QApplication.topLevelWidgets():
                    if isinstance(widget, ApplicationWindow):
                        widget.updateRecentSettingActions()
                self.sendmessage(QApplication.translate('Message', 'Settings not found'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def saveSettings(self, _: bool = False) -> None:
        path = QDir()
        path.setPath(self.getDefaultPath())
        fname = path.absoluteFilePath(QApplication.translate('Message', 'artisan-settings'))
        filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Settings'), path=fname,
                                              ext='*.aset')
        if filename:
            self.settingspath = filename
            if self.closeEventSettings(filename):
                self.sendmessage(QApplication.translate('Message', 'Settings saved'))
                # update recentSettings menu
                settings = QSettings()
                files = toStringList(settings.value('recentSettingList'))
                try:
                    removeAll(files, filename)
                except ValueError:
                    pass
                files.insert(0, filename)
                del files[self.MaxRecentFiles:]
                settings.setValue('recentSettingList', files)
                for widget in QApplication.topLevelWidgets():
                    if isinstance(widget, ApplicationWindow):
                        widget.updateRecentSettingActions()
        else:
            self.sendmessage(QApplication.translate('Message', 'Cancelled'))

    def updateRecentThemeActions(self) -> None:
        settings = QSettings()
        files = toStringList(settings.value('recentThemeList'))
        files.sort()
        strippedNames = list(map(self.strippedName, files))
        numRecentThemes = min(len(files), self.MaxRecentFiles)

        for i in range(numRecentThemes):
            strippedName = self.strippedName(files[i])
            if strippedNames.count(strippedName) > 1:
                text = f'&{strippedName} ({self.strippedDir(files[i])})'
            else:
                text = f'&{strippedName}'
            self.recentThemeActs[i].setText(text)
            self.recentThemeActs[i].setData(files[i])
            self.recentThemeActs[i].setVisible(True)

        for j in range(numRecentThemes, self.MaxRecentFiles):
            self.recentThemeActs[j].setVisible(False)

    @pyqtSlot(bool)
    def openRecentTheme(self, _checked: bool = False) -> None:
        action = self.sender()
        if action and hasattr(action, 'data'):
            fname = toString(action.data())
            if os.path.isfile(fname):
                self.loadSettings_theme(fn=fname)
            else:
                settings = QSettings()
                files = toStringList(settings.value('recentThemeList'))
                try:
                    removeAll(files, fname)
                except ValueError:
                    pass
                settings.setValue('recentThemeList', files)
                for widget in QApplication.topLevelWidgets():
                    if isinstance(widget, ApplicationWindow):
                        widget.updateRecentThemeActions()
                self.sendmessage(QApplication.translate('Message', 'Settings not found'))

    @pyqtSlot(bool)
    def saveSettings_theme(self, _: bool = False) -> None:
        path = QDir()
        path.setPath(self.getDefaultPath())
        path.setPath(os.path.join(getResourcePath(), 'Themes', 'User'))
        fname = path.absoluteFilePath(QApplication.translate('Message', 'artisan-theme'))
        filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Theme'), path=fname,
                                              ext='*.athm')
        if filename:
            self.closeEventSettings_theme(filename)
            self.sendmessage(QApplication.translate('Message', 'Theme saved'))
            # update recentTheme menu
            settings = QSettings()
            files = toStringList(settings.value('recentThemeList'))
            try:
                removeAll(files, filename)
            except ValueError:
                pass
            files.insert(0, filename)
            del files[self.MaxRecentFiles:]
            settings.setValue('recentThemeList', files)
            for widget in QApplication.topLevelWidgets():
                if isinstance(widget, ApplicationWindow):
                    widget.updateRecentThemeActions()
            self.themeMenu.clear()
            self.populateThemeMenu()
        else:
            self.sendmessage(QApplication.translate('Message', 'Cancelled'))

    @pyqtSlot(bool)
    def loadSettings_theme_Slot(self, _: bool = False) -> None:
        self.loadSettings_theme()

    def loadSettings_theme(self, fn: Optional[str] = None, remember: bool = True, reset: bool = False) -> None:
        try:
            if fn:
                filename = fn
            else:
                filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message', 'Load Theme'), ext='*.athm')
            if filename:
                string = QApplication.translate('Message', 'Load theme {0}?').format(os.path.basename(filename))
                reply = QMessageBox.question(self, QApplication.translate('Message', 'Adjust Theme Related Settings'),
                                             string,
                                             QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.Cancel)
                if reply == QMessageBox.StandardButton.Cancel:
                    return
                try:
                    res = self.settingsLoad(filename, theme=True)
                    self.sendmessage(QApplication.translate('Message', 'Loaded theme {0}').format(filename))
                    if reset:
                        self.qmc.reset(soundOn=False)
                    if res and remember:
                        # update recentSettings menu
                        settings = QSettings()
                        files = toStringList(settings.value('recentThemeList'))
                        try:
                            removeAll(files, filename)
                        except ValueError:
                            pass
                        files.insert(0, filename)
                        del files[self.MaxRecentFiles:]
                        settings.setValue('recentThemeList', files)
                        for widget in QApplication.topLevelWidgets():
                            if isinstance(widget, ApplicationWindow):
                                widget.updateRecentThemeActions()
                                self.sendmessage(QApplication.translate('Message', 'Theme loaded'))
                        self.themeMenu.clear()
                        self.populateThemeMenu()
                    else:
                        # remove file from the recent file list
                        settings = QSettings()
                        files = toStringList(settings.value('recentThemeList'))
                        try:
                            removeAll(files, filename)
                        except ValueError:
                            pass
                        settings.setValue('recentThemeList', files)
                        for widget in QApplication.topLevelWidgets():
                            if isinstance(widget, ApplicationWindow):
                                widget.updateRecentThemeActions()
                        self.themeMenu.clear()
                        self.populateThemeMenu()
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
                    # remove file from the recent file list
                    settings = QSettings()
                    files = toStringList(settings.value('recentThemeList'))
                    try:
                        removeAll(files, filename)
                    except ValueError:
                        pass
                    settings.setValue('recentThemeList', files)
                    for widget in QApplication.topLevelWidgets():
                        if isinstance(widget, ApplicationWindow):
                            widget.updateRecentThemeActions()
                    self.themeMenu.clear()
                    self.populateThemeMenu()
            else:
                self.sendmessage(QApplication.translate('Message', 'Cancelled'))
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' loadSettings_theme() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def largeLCDs(self, _: bool = False) -> None:
        if self.largeLCDs_dialog is None:
            self.largeLCDs_dialog = LargeMainLCDs(self, self)
            self.largeLCDs_dialog.setModal(False)
            self.LargeLCDsFlag = True
            self.lcdsAction.setChecked(True)
            self.largeLCDs_dialog.show()
        else:
            self.largeLCDs_dialog.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largeDeltaLCDs(self, _: bool = False) -> None:
        if self.largeDeltaLCDs_dialog is None:
            self.largeDeltaLCDs_dialog = LargeDeltaLCDs(self, self)
            self.largeDeltaLCDs_dialog.setModal(False)
            self.LargeDeltaLCDsFlag = True
            self.deltalcdsAction.setChecked(True)
            self.largeDeltaLCDs_dialog.show()
        else:
            self.largeDeltaLCDs_dialog.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largePIDLCDs(self, _: bool = False) -> None:
        if self.largePIDLCDs_dialog is None:
            self.largePIDLCDs_dialog = LargePIDLCDs(self, self)
            self.largePIDLCDs_dialog.setModal(False)
            self.LargePIDLCDsFlag = True
            self.pidlcdsAction.setChecked(True)
            self.largePIDLCDs_dialog.show()
        else:
            self.largePIDLCDs_dialog.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largeScaleLCDs(self, _: bool = False) -> None:
        if self.largeScaleLCDs_dialog is None:
            self.largeScaleLCDs_dialog = LargeScaleLCDs(self, self)
            self.largeScaleLCDs_dialog.setModal(False)
            self.LargeScaleLCDsFlag = True
            self.scalelcdsAction.setChecked(True)
            self.largeScaleLCDs_dialog.show()
        else:
            self.largeScaleLCDs_dialog.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largeExtraLCDs(self, _: bool = False) -> None:
        if self.largeExtraLCDs_dialog is None:
            self.largeExtraLCDs_dialog = LargeExtraLCDs(self, self)
            self.largeExtraLCDs_dialog.setModal(False)
            self.LargeExtraLCDsFlag = True
            self.extralcdsAction.setChecked(True)
            self.largeExtraLCDs_dialog.show()
        else:
            self.largeExtraLCDs_dialog.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def largePhasesLCDs(self, _: bool = False) -> None:
        if self.largePhasesLCDs_dialog is None:
            self.largePhasesLCDs_dialog = LargePhasesLCDs(self, self)
            self.largePhasesLCDs_dialog.setModal(False)
            self.LargePhasesLCDsFlag = True
            self.phaseslcdsAction.setChecked(True)
            self.updatePhasesLCDs()
            self.largePhasesLCDs_dialog.show()
        else:
            self.largePhasesLCDs_dialog.close()

    @pyqtSlot()
    @pyqtSlot(bool)
    def graphwheel(self, _: bool = False) -> None:
        if self.qmc.designerflag:
            self.stopdesigner()
        if self.wheeldialog is None:
            # remove the standard fig axis to trigger their recreation
            self.qmc.ax = None
            self.qmc.delta_ax = None
            from artisanlib.wheels import WheelDlg
            self.wheeldialog = WheelDlg(self, self)
        if self.qmc.wheelflag:
            self.redrawOnResize = True
            self.qmc.exitviewmode()
            self.enableEditMenus()
            self.showControls()
            self.updateReadingsLCDsVisibility()
            self.updateSlidersVisibility()
            self.update_minieventline_visibility()
            self.updateExtraButtonsVisibility()
        else:
            self.redrawOnResize = False
            self.hideControls()
            self.hideLCDs(False)
            self.hideSliders(False)
            self.hide_minieventline(False)
            self.hideExtraButtons()
            self.disableEditMenus(wheel=True)
            self.qmc.connectWheel()
            if self.wheelpath and self.wheelpath != '':
                try:
                    self.loadWheel(self.wheelpath)
                    self.wheeldialog.createdatatable()
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
                    self.settingspath = ''
            self.qmc.drawWheel()

    @pyqtSlot()
    @pyqtSlot(bool)
    def background(self, _: bool = False) -> None:
        from artisanlib.background import backgroundDlg
        dialog = backgroundDlg(self, self, self.backgroundDlg_activeTab)
        dialog.show()

    def deleteBackground(self) -> None:
        self.qmc.background = False
        self.qmc.backgroundprofile = None
        self.qmc.backgroundprofile_moved_x = 0
        self.qmc.backgroundprofile_moved_y = 0
        self.qmc.backgroundpath = ''
        self.qmc.backgroundUUID = None
        self.qmc.titleB = ''
        self.qmc.roastbatchnrB = 0
        self.qmc.roastbatchprefixB = ''
        self.qmc.roastbatchposB = 1
        self.qmc.temp1B, self.qmc.temp2B, self.qmc.temp1BX, self.qmc.temp2BX, self.qmc.timeB = [], [], [], [], []
        # smoothed versions of the background courves
        self.qmc.stemp1B = numpy.empty(0)
        self.qmc.stemp2B = numpy.empty(0)
        self.qmc.stemp1BX = []
        self.qmc.stemp2BX = []
        self.qmc.extraname1B, self.qmc.extraname2B = [], []
        self.qmc.backgroundEvents, self.qmc.backgroundEtypes = [], []
        self.qmc.backgroundEvalues, self.qmc.backgroundEStrings, self.qmc.backgroundFlavors = [], [], []
        self.qmc.timeindexB = [-1, 0, 0, 0, 0, 0, 0, 0]
        self.qmc.TP_time_B_loaded = None
        self.qmc.AUCbackground = -1
        self.qmc.l_background_annotations = []
        self.qmc.analysisresultsstr = ''
        self.qmc.resetlinecountcaches()
        self.qmc.deleteAnnoPositions(foreground=False, background=True)
        self.sendmessage(QApplication.translate('Message', 'Background profile removed'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def switchETBT(self, _: bool = False) -> None:  # pylint: disable=no-self-use # used as slot
        t2 = self.qmc.temp2
        self.qmc.temp2 = self.qmc.temp1
        self.qmc.temp1 = t2
        self.qmc.redraw(recomputeAllDeltas=True)
        self.qmc.fileDirtySignal.emit()

    @pyqtSlot()
    @pyqtSlot(bool)
    def switch(self, _: bool = False) -> None:
        if not self.qmc.checkSaved():
            return
        try:
            foreground_profile_path = self.curFile
            background_profile_path = self.qmc.backgroundpath
            background_deleted = False
            if background_profile_path:
                # load background into foreground
                self.loadFile(background_profile_path)
            # if there is a plotter or analyzer generated background curve bring it to the foreground
            elif len(self.qmc.temp1B) > 2:
                _timex = self.qmc.timeB[:]
                _temp1 = self.qmc.temp1B[:]
                _temp2 = self.qmc.temp2B[:]
                _sampling_interval = self.qmc.profile_sampling_interval
                # use foreground events if the background has no CHARGE
                if self.qmc.timeindexB[0] == -1:
                    _timeindex = self.qmc.timeindex[:]
                else:
                    _timeindex = self.qmc.timeindexB[:]
                # clear the background
                self.deleteBackground()
                background_deleted = True

                flag_temp = self.qmc.roastpropertiesflag
                self.qmc.roastpropertiesflag = 1  # ensure that all roast properties are reset!
                self.qmc.reset(soundOn=False)
                self.qmc.roastpropertiesflag = flag_temp
                self.qmc.timex = _timex[:]
                self.qmc.temp1 = _temp1[:]
                self.qmc.temp2 = _temp2[:]
                self.qmc.timeindex = _timeindex[:]
                for x in range(len(self.qmc.extradevices)):
                    self.qmc.extratemp1[x] = [-1.] * len(self.qmc.timex)
                    self.qmc.extratemp2[x] = [-1.] * len(self.qmc.timex)
                    self.qmc.extratimex[x] = self.qmc.timex[:]
                self.qmc.profile_sampling_interval = _sampling_interval
                if not foreground_profile_path:
                    self.qmc.redraw(recomputeAllDeltas=True)
                self.qmc.fileDirtySignal.emit()
            else:
                # reset
                self.qmc.reset(soundOn=False)
            if foreground_profile_path:
                # load foreground into background
                self.loadbackground(foreground_profile_path)
                self.qmc.background = not self.qmc.hideBgafterprofileload
                self.qmc.timealign(redraw=True, recompute=True)
            # delete background
            elif not background_deleted:
                self.deleteBackground()
            if foreground_profile_path or background_profile_path:
                self.qmc.redraw(recomputeAllDeltas=True)
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def flavorchart(self, _: bool = False) -> None:
        self.redrawOnResize = False  # disable the redraw triggered on resize (eg. by hiding widgets) that replaces the logo icon
        self.hideControls()
        self.hideLCDs(False)
        self.hideSliders(False)
        self.hideExtraButtons()
        from artisanlib.cup_profile import flavorDlg
        dialog = flavorDlg(self, self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def designerTriggered(self, _: bool = False) -> None:
        if self.qmc.designerflag:
            self.stopdesigner()
        else:
            if self.qmc.ai:
                try:
                    self.qmc.ai.remove()
                except Exception:  # pylint: disable=broad-except
                    pass
            self.startdesigner()

    def startdesigner(self) -> None:
        self.hideLCDs(False)
        self.hideSliders(False)
        self.hide_minieventline(False)
        self.hideExtraButtons()
        self.qmc.designer()

    def stopdesigner(self) -> None:
        self.enableEditMenus()
        self.qmc.clear_designer()
        self.qmc.convert_designer()
        self.updateReadingsLCDsVisibility()
        self.updateSlidersVisibility()
        self.update_minieventline_visibility()
        self.updateExtraButtonsVisibility()

    @pyqtSlot()
    @pyqtSlot(bool)
    def editgraph(self, _: bool = False) -> None:
        if self.editgraphdialog is not False:  # Roast Properties dialog is not blocked!
            from artisanlib.roast_properties import editGraphDlg
            self.editgraphdialog = editGraphDlg(self, self, self.editGraphDlg_activeTab)
            self.editgraphdialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def editphases(self, _: bool = False) -> None:
        from artisanlib.phases import phasesGraphDlg
        dialog = phasesGraphDlg(self, self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def eventsconf(self, _: bool = False) -> None:
        from artisanlib.events import EventsDlg
        dialog = EventsDlg(self, self, self.EventsDlg_activeTab)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def alarmconfig(self, _: bool = False) -> None:
        if self.qmc.device != 18 or self.simulator is not None:
            from artisanlib.alarms import AlarmDlg
            dialog = AlarmDlg(self, self, self.AlarmDlg_activeTab)
            dialog.show()
        else:
            QMessageBox.information(self, QApplication.translate('Message', 'Alarm Config'),
                                    QApplication.translate('Message', 'Alarms are not available for device None'))

    def switchLanguageFlag(self, loc: str, value: bool) -> None:
        try:
            self.language_menu_actions[loc].setChecked(value)
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    @pyqtSlot()
    @pyqtSlot(bool)
    def change_local_action(self, _: bool = False) -> None:
        sender_action = self.sender()
        new_locale = next((local for local, action in self.language_menu_actions.items() if sender_action == action),
                          'en')
        self.changelocale(new_locale)

    def changelocale(self, languagelocale: str) -> None:
        if self.locale_str != languagelocale:
            string = QApplication.translate('Message', 'Switching the language needs a restart. Restart now?')
            reply = QMessageBox.warning(self, QApplication.translate('Message', 'Restart'), string,
                                        QMessageBox.StandardButton.Cancel | QMessageBox.StandardButton.Yes)
            if reply == QMessageBox.StandardButton.Yes:
                # switch old flag off
                self.switchLanguageFlag(self.locale_str, False)
                # check if etypes are unmodified by user and in that case, remove etypes from settings to avoid overwriting of translations:
                # switch new flag on
                self.switchLanguageFlag(languagelocale, True)
                settings = QSettings()
                settings.setValue('locale', languagelocale)
                self.close()
            else:
                self.switchLanguageFlag(languagelocale, False)
        else:
            # if the current selected language is selected it got unflagged. Tick it again!
            self.switchLanguageFlag(self.locale_str, True)

    # takes the weight of the green and roasted coffee as floats and
    # returns the weight loss in percentage as float
    @staticmethod
    def weight_loss(green: float, roasted: float) -> float:
        if float(green) == 0.0 or float(green) < float(roasted):
            return 0.
        return 100. * ((float(green) - float(roasted)) / float(green))

    # takes the weight of the green and roasted coffee as floats and
    # returns the weight loss in percentage as float
    @staticmethod
    def volume_increase(green: float, roasted: float) -> float:
        if float(green) == 0.0 or float(green) > float(roasted):
            return 0.
        return 100. * ((float(roasted) - float(green)) / float(green))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importK202(self, _: bool = False) -> None:
        import csv
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message', 'Import K202 CSV'))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.OpenModeFlag.ReadOnly):
                    raise OSError(str(f.errorString()))
                with open(filename, encoding='utf-8') as csvFile:
                    csvReader = csv.DictReader(csvFile, ['Date', 'Time', 'T1', 'T1unit', 'T2', 'T2unit'],
                                               delimiter='\t')
                    zero_t = None
                    roastdate = None
                    unit = None
                    for item in csvReader:
                        try:
                            # set date
                            if roastdate is None:
                                roastdate = QDateTime(QDate.fromString(item['Date'], "dd'.'MM'.'yyyy"), QTime())
                                self.qmc.roastdate = roastdate
                                self.qmc.roastepoch = self.qmc.roastdate.toSecsSinceEpoch()
                                self.qmc.roasttzoffset = 0
                            # set zero
                            if zero_t is None:
                                date = QDate.fromString(item['Date'], "dd'.'MM'.'yyyy")
                                zero = QDateTime()
                                zero.setDate(date)
                                zero.setTime(QTime.fromString(item['Time'], "hh':'mm':'ss"))
                                zero_t = zero.toSecsSinceEpoch()
                            # set temperature mode
                            if not unit:
                                unit = item['T1unit']
                                if unit == 'F' and self.qmc.mode == 'C':
                                    self.qmc.celsiusMode()
                                if unit == 'C' and self.qmc.mode == 'F':
                                    self.qmc.celsiusMode()
                            # add one measurement
                            dt = QDateTime()
                            dt.setDate(QDate.fromString(item['Date'], "dd'.'MM'.'yyyy"))
                            dt.setTime(QTime.fromString(item['Time'], "hh':'mm':'ss"))
                            self.qmc.timex.append(float(dt.toSecsSinceEpoch() - zero_t))
                            self.qmc.temp1.append(float(item['T1'].replace(',', '.')))
                            self.qmc.temp2.append(float(item['T2'].replace(',', '.')))
                        except ValueError:
                            pass
                # swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x, y: x + y, self.qmc.temp2)) > freduce(lambda x, y: x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                self.autoAdjustAxis()
                self.sendmessage(QApplication.translate('Message', 'K202 file loaded successfully'))
                self.qmc.redraw()
        except OSError as ex:
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' importK202(): {0}').format(str(ex)))
        except ValueError as ex:
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Value Error:') + ' importK202(): {0}').format(str(ex)))
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _a, _b, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' importK202() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importK204(self, _: bool = False) -> None:
        import csv
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message', 'Import K204 CSV'))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.OpenModeFlag.ReadOnly):
                    raise OSError(str(f.errorString()))
                with open(filename, encoding='utf-8') as csvFile:
                    csvReader = csv.DictReader(csvFile, ['Date', 'Time', 'T1', 'T2', 'T3', 'T4'], delimiter='\t')
                    zero_t = None
                    roastdate = None
                    # we add an extra device if needed
                    if len(self.qmc.extradevices) == 0:
                        self.addDevice()
                    for item in csvReader:
                        try:
                            # set date
                            if roastdate is None:
                                roastdate = QDateTime(QDate.fromString(item['Date'], "dd'.'MM'.'yyyy"), QTime())
                                self.qmc.roastdate = roastdate
                                self.qmc.roastepoch = self.qmc.roastdate.toSecsSinceEpoch()
                                self.qmc.roasttzoffset = 0
                            # set zero
                            if zero_t is None:
                                date = QDate.fromString(item['Date'], "dd'.'MM'.'yyyy")
                                zero = QDateTime()
                                zero.setDate(date)
                                zero.setTime(QTime.fromString(item['Time'], "hh':'mm':'ss"))
                                zero_t = zero.toSecsSinceEpoch()
                            # The K204 export does not contain a trace of the temperature mode.
                            # We have to assume here that the mode was set correctly before the import.
                            # add one measurement
                            dt = QDateTime()
                            dt.setDate(QDate.fromString(item['Date'], "dd'.'MM'.'yyyy"))
                            dt.setTime(QTime.fromString(item['Time'], "hh':'mm':'ss"))
                            tx = float(dt.toSecsSinceEpoch() - zero_t)
                            self.qmc.timex.append(tx)
                            t1 = float(item['T1'].replace(',', '.'))
                            if t1 > 800 or t1 < 0.0:
                                t1 = 0.0
                            self.qmc.temp1.append(t1)
                            t2 = float(item['T2'].replace(',', '.'))
                            if t2 > 800 or t2 < 0.0:
                                t2 = 0.0
                            self.qmc.temp2.append(t2)
                            if len(self.qmc.extradevices) > 0:
                                self.qmc.extratimex[0].append(tx)
                                t3 = float(item['T3'].replace(',', '.'))
                                if t3 > 800 or t3 < 0.0:
                                    t3 = 0.0
                                self.qmc.extratemp1[0].append(t3)
                                t4 = float(item['T4'].replace(',', '.'))
                                if t4 > 800 or t4 < 0.0:
                                    t2 = 0.0
                                self.qmc.extratemp2[0].append(t4)
                        except ValueError:
                            pass
                # swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x, y: x + y, self.qmc.temp2)) > freduce(lambda x, y: x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                self.autoAdjustAxis()
                self.sendmessage(QApplication.translate('Message', 'K204 file loaded successfully'))
                self.qmc.redraw()
        except OSError as ex:
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' importK204(): {0}').format(str(ex)))
        except ValueError as ex:
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Value Error:') + ' importK204(): {0}').format(str(ex)))
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _a, _b, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' importK204() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

    # normalize xml tags and attributes to lower case
    def normalize_tags(self, root: 'XMLElement') -> None:
        root.tag = root.tag.lower()
        for child in root:
            self.normalize_tags(child)

    def normalize_attr(self, root: 'XMLElement') -> None:
        for attr, value in root.attrib.items():
            norm_attr = attr.lower()
            if norm_attr != attr:
                root.set(norm_attr, value)
                root.attrib.pop(attr)
        for child in root:
            self.normalize_attr(child)

    @pyqtSlot()
    @pyqtSlot(bool)
    def importPilot(self,
                    _: bool = False) -> None:  # pyright: ignore [reportGeneralTypeIssues] # Code is too complex to analyze; reduce complexity by refactoring into subroutines or reducing
        try:
            import xml.etree.ElementTree as ET
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message', 'Import Probat Recipe'))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                tree = ET.ElementTree(file=filename)
                root = tree.getroot()
                self.normalize_tags(root)  # normalize tags to lower case
                self.normalize_attr(root)  # normalize attributes to lower case

                if root.tag == 'history':
                    date = root.find('historydate')
                    time = root.find('historytime')
                    if date is not None and time is not None:
                        date_str = date.text
                        time_str = time.text
                        if date_str is not None and time_str is not None:
                            self.qmc.roastdate = QDateTime(QDate.fromString(date_str, 'M/d/yyyy'),
                                                           QTime.fromString(time_str, 'h:mm AP'))

                title = root.find('roasttype')
                if title is None:
                    self.qmc.title = str(os.path.basename(filename))
                else:
                    self.qmc.title = str(title.text)

                beans = root.find('coffeetype')
                if beans is not None and beans.text is not None:
                    self.qmc.beans = str(beans.text)

                roaster = root.find('roaster')
                if roaster is not None and roaster.text is not None:
                    self.qmc.roastertype = str(roaster.text)

                chargestr = root.find('charge')
                if chargestr is None:
                    chargestr = root.find('chargingcapacity')
                if chargestr is not None:  # contains floating point number; default unit Kg
                    try:
                        weight_in_str = chargestr.text
                        if weight_in_str is not None:
                            self.qmc.weight = (float(weight_in_str), self.qmc.weight[1], 'Kg')
                    except Exception:  # pylint: disable=broad-except
                        pass

                dischargestr = root.find('dischargingcapacity')
                if dischargestr is not None:  # contains floating point number; default unit Kg
                    try:
                        weight_out_str = dischargestr.text
                        if weight_out_str is not None:
                            self.qmc.weight = (self.qmc.weight[0], float(weight_out_str), 'Kg')
                    except Exception:  # pylint: disable=broad-except
                        pass

                colorstr = root.find('coffeecolor')
                if colorstr is not None:
                    c = None
                    if colorstr.text is not None:
                        for e in colorstr.text.strip().split():
                            try:
                                c = int(e)
                                break
                            except Exception:  # pylint: disable=broad-except
                                pass
                    if c:
                        self.qmc.ground_color = c

                notes = root.find('notes')
                if notes is not None and notes.text is not None:
                    self.qmc.roastingnotes = str(notes.text)

                recipedata = None
                historydata = None
                recipedata = tree.find('recipedata')
                m = None
                if recipedata is not None:
                    m = recipedata.get('temp_unit')
                else:
                    mt = tree.find('recipedata_temp_unit')
                    if mt is not None:
                        m = mt.text
                if m is None:
                    historydata = tree.find('historydata')
                    if historydata is not None:
                        m = historydata.get('temp_unit')
                    else:
                        mt = tree.find('historydata_temp_unit')
                        if mt is not None:
                            m = mt.text
                if m is not None:
                    m = m.lower()
                    if m == 'c' and self.qmc.mode == 'F':
                        self.qmc.celsiusMode()
                    elif m == 'f' and self.qmc.mode == 'C':
                        self.qmc.celsiusMode()

                # add extra device if needed
                for __ in range(max(0, 1 - len(self.qmc.extradevices))):
                    self.addDevice()
                if self.qmc.extraname1[0] == 'Extra 1':
                    self.qmc.extraname1[0] = 'Burner'

                diagrampoints = None
                if recipedata is not None:
                    diagrampoints = tree.find('recipedata/diagrampoints')
                if diagrampoints is None:
                    diagrampoints = tree.find('diagrampoints')
                if diagrampoints is None:
                    diagrampoints = tree.find('historydata')
                last_timez = 0.
                if diagrampoints is not None:
                    for elem in diagrampoints.findall('data'):
                        time_entry = elem.find('time')
                        if time_entry is None:
                            time_entry = elem.find('stime')
                        if time_entry is None or time_entry.text is None:
                            last_timez = last_timez + 1
                            timez = last_timez
                        else:
                            timez = float(stringtoseconds(time_entry.text))
                            last_timez = timez
                        self.qmc.timex.append(timez)
                        self.qmc.temp1.append(-1)
                        temp_entry = elem.find('temperature')
                        if temp_entry is None:
                            temp_entry = elem.find('ntemperature')
                        if temp_entry is not None:
                            bt = temp_entry.text
                            if bt is not None:
                                bt = bt.replace(',', '.')
                                self.qmc.temp2.append(float(bt))
                                self.qmc.extratimex[0].append(timez)
                                burner_entry = elem.find('burnercapacity')
                                if burner_entry is None:
                                    burner_entry = elem.find('nburnercapacity')
                                if burner_entry is not None:
                                    burner = burner_entry.text
                                    if burner is not None:
                                        burner = burner.replace(',', '.')
                                        self.qmc.extratemp1[0].append(float(burner))
                                        self.qmc.extratemp2[0].append(-1)

                if len(self.qmc.timex) > 2:
                    self.qmc.profile_sampling_interval = (self.qmc.timex[-1] - self.qmc.timex[0]) / (
                            len(self.qmc.timex) - 1)
                self.qmc.updateDeltaSamples()

                # set CHARGE and DROP
                self.qmc.timeindex[0] = 0
                self.qmc.timeindex[6] = max(0, len(self.qmc.timex) - 1)

                if recipedata is not None:
                    switchpoints = tree.find('recipedata/switchpoints')
                else:
                    switchpoints = tree.find('switchpoints')
                if switchpoints is not None:
                    for elem in switchpoints.findall('data'):
                        time_entry = elem.find('time')
                        if time_entry is None:
                            time_entry = elem.find('stime')
                        if time_entry is not None:
                            time_str = time_entry.text
                            if time_str is not None:
                                time = float(stringtoseconds(time_str))
                                burner_entry = elem.find('burnercapacity')
                                if burner_entry is None:
                                    burner_entry = elem.find('nburnercapacity')
                                if burner_entry is not None:
                                    burner = burner_entry.text
                                    if burner is not None:
                                        self.qmc.addEvent(
                                            self.qmc.time2index(time),
                                            3,
                                            '',
                                            self.qmc.str2eventsvalue(burner))

                self.autoAdjustAxis()

                self.sendmessage(QApplication.translate('Message', 'Probat Pilot data imported successfully'))
                self.qmc.redraw()
                self.qmc.fileDirtySignal.emit()
        except OSError as ex:
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' importPilot(): {0}').format(str(ex)))
        except ValueError as ex:
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Value Error:') + ' importPilot(): {0}').format(str(ex)))
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _a, _b, exc_tb = sys.exc_info()
            self.sendmessage(QApplication.translate('Message', 'Import Probat Pilot failed'))
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' importPilot() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

    #    @pyqtSlot()
    #    @pyqtSlot(bool)
    #    def importBullet(self,_=False):
    #        try:
    #            from artisanlib.aillio import extractProfileRoasTime
    #            self.importExternal(extractProfileRoasTime,QApplication.translate('Message','Import Aillio RoasTime'),'*.json')
    #        except Exception as e: # pylint: disable=broad-except
    #            _log.exception(e)

    #    @pyqtSlot()
    #    @pyqtSlot(bool)
    #    def importBulletURL(self,_=False):
    #        try:
    #            from artisanlib.aillio import extractProfileRoastWorld
    #            self.importExternalURL(extractProfileRoastWorld, QApplication.translate('Message','Import Aillio Roast.World URL'))
    #        except Exception as e: # pylint: disable=broad-except
    #            _log.exception(e)

    @pyqtSlot(str)
    def comparatorAddProfileSlot(self, filename: str) -> None:
        if self.comparator is not None:
            self.comparator.addProfiles([filename])

    @pyqtSlot('QUrl')
    def comparatorAddProfileURLSlot(self, url: QUrl) -> None:
        if self.comparator is not None:
            self.comparator.addProfileFromURL(self.artisanURLextractor, url)

    @pyqtSlot('QUrl')
    def importArtisanURLSlot(self, url: QUrl) -> None:
        self.importExternalURL(self.artisanURLextractor, url=url)

    # url a QUrl
    def importExternalURL(self, extractor: Callable[[QUrl, 'ApplicationWindow'], Optional['ProfileData']],
                          message: str = '', url: Optional[QUrl] = None) -> None:
        try:
            res: bool = self.qmc.reset(redraw=True, soundOn=False)
            if not res:
                return
            if res:
                if url is None:
                    url = self.ArtisanOpenURLDialog(msg=message)
                if url is None:
                    return
                try:
                    obj = extractor(url, self)
                    res = self.setProfile(None, obj) if obj else False
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
                if res:
                    self.orderEvents()
                    # update etypes combo box
                    self.etypeComboBox.clear()
                    self.etypeComboBox.addItems(self.qmc.etypes)
                    # profiles was adjusted, ensure that it does not overwrite the original file on saving
                    self.qmc.fileDirtySignal.emit()
                    self.curFile = None
                    # clear annotation cache
                    self.qmc.l_annotations_dict = {}
                    self.qmc.l_event_flags_dict = {}
                    # Plot everything
                    self.qmc.redraw()
                    message = QApplication.translate('Message', '{0} imported').format(url.toString())
                    self.sendmessage(message)
                else:
                    message = QApplication.translate('Message', 'an error occurred on importing {0}').format(
                        url.toString())
                    self.sendmessage(message)

        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' {1} {0}').format(str(ex), message),
                getattr(exc_tb, 'tb_lineno', '?'))

    def importExternal(self, extractor: Callable[[str, 'ApplicationWindow'], 'ProfileData'], message: str,
                       extension: str) -> None:
        try:
            filename = self.ArtisanOpenFileDialog(msg=message, ext=extension)
            if len(filename) == 0:
                return
            res = self.qmc.reset(redraw=False, soundOn=False)
            if res:
                obj: 'ProfileData' = extractor(filename, self)
                res = self.setProfile(filename, obj)

            if res:
                # update etypes combo box
                self.etypeComboBox.clear()
                self.etypeComboBox.addItems(self.qmc.etypes)
                # profiles was adjusted, ensure that it does not overwrite the original file on saving
                self.qmc.fileDirtySignal.emit()
                self.curFile = None
                # clear annotation cache
                self.qmc.l_annotations_dict = {}
                self.qmc.l_event_flags_dict = {}
                # Plot everything
                self.qmc.redraw()
                message = QApplication.translate('Message', '{0} imported').format(filename)
                self.sendmessage(message)

        except OSError as ex:
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' {1}: {0}').format(str(ex), message))
        except ValueError as ex:
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Value Error:') + ' {1}: {0}').format(str(ex), message))
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' {1} {0}').format(str(ex), message),
                getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importCropster(self, _: bool = False) -> None:
        from artisanlib.cropster import extractProfileCropsterXLS
        self.importExternal(extractProfileCropsterXLS, QApplication.translate('Message', 'Import Cropster XLS'),
                            '*.xls')

    @pyqtSlot()
    @pyqtSlot(bool)
    def importRoastLog(self, _: bool = False) -> None:
        from artisanlib.roastlog import extractProfileRoastLog
        self.importExternalURL(extractProfileRoastLog, QApplication.translate('Message', 'Import RoastLog URL'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importRoastPATH(self, _: bool = False) -> None:
        from artisanlib.roastpath import extractProfileRoastPathHTML
        self.importExternalURL(extractProfileRoastPathHTML, QApplication.translate('Message', 'Import RoastPATH URL'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importGiesen(self, _: bool = False) -> None:
        from artisanlib.giesen import extractProfileGiesenCSV
        self.importExternal(extractProfileGiesenCSV, QApplication.translate('Message', 'Import Giesen CSV'), '*.csv')

    @pyqtSlot()
    @pyqtSlot(bool)
    def importPetroncini(self, _: bool = False) -> None:
        from artisanlib.petroncini import extractProfilePetronciniCSV
        self.importExternal(extractProfilePetronciniCSV, QApplication.translate('Message', 'Import Petroncini CSV'),
                            '*.csv')

    @pyqtSlot()
    @pyqtSlot(bool)
    def importIkawaURL(self, _: bool = False) -> None:
        from artisanlib.ikawa import extractProfileIkawaURL
        self.importExternalURL(extractProfileIkawaURL, QApplication.translate('Message', 'Import IKAWA URL'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def importIkawa(self, _: bool = False) -> None:
        from artisanlib.ikawa import extractProfileIkawaCSV
        self.importExternal(extractProfileIkawaCSV, QApplication.translate('Message', 'Import IKAWA CSV'), '*.csv')

    @pyqtSlot()
    @pyqtSlot(bool)
    def importLoring(self, _: bool = False) -> None:
        from artisanlib.loring import extractProfileLoringCSV
        self.importExternal(extractProfileLoringCSV, QApplication.translate('Message', 'Import Loring CSV'), '*.csv')

    @pyqtSlot()
    @pyqtSlot(bool)
    def importRubasse(self, _: bool = False) -> None:
        from artisanlib.rubasse import extractProfileRubasseCSV
        self.importExternal(extractProfileRubasseCSV, QApplication.translate('Message', 'Import Rubasse CSV'), '*.csv')

    @pyqtSlot()
    @pyqtSlot(bool)
    def importHH506RA(self, _: bool = False) -> None:
        import csv
        try:
            filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message', 'Import HH506RA CSV'))
            if len(filename) == 0:
                return
            if self.qmc.reset():
                f = QFile(filename)
                if not f.open(QIODevice.OpenModeFlag.ReadOnly):
                    raise OSError(str(f.errorString()))
                with open(filename, encoding='utf-8') as csvFile:
                    data = csv.reader(csvFile, delimiter='\t')
                    # read file header
                    header = next(data)
                    zero = QDateTime()
                    date = QDateTime(QDate.fromString(header[0].split('Date:')[1], "yyyy'/'MM'/'dd"), QTime())
                    self.qmc.roastdate = date
                    self.qmc.roastepoch = self.qmc.roastdate.toSecsSinceEpoch()
                    self.qmc.roasttzoffset = 0
                    zero.setDate(date.date())
                    zero.setTime(QTime.fromString(header[1].split('Time:')[1], "hh':'mm':'ss"))
                    zero_t = zero.toSecsSinceEpoch()
                    # read column headers
                    fields = next(data)
                    unit = None
                    # read data
                    for row in data:
                        items = list(zip(fields, row))
                        item = {}
                        for (name, value) in items:
                            item[name] = value.strip()
                        # set temperature mode
                        if not unit:
                            unit = item['Unit']
                            if unit == 'F' and self.qmc.mode == 'C':
                                self.qmc.celsiusMode()
                            if unit == 'C' and self.qmc.mode == 'F':
                                self.qmc.celsiusMode()
                        # add one measurement
                        dt = QDateTime()
                        dt.setDate(QDate.fromString(item['Date'], "yyyy'/'MM'/'dd"))
                        dt.setTime(QTime.fromString(item['Time'], "hh':'mm':'ss"))
                        self.qmc.timex.append(float(dt.toSecsSinceEpoch() - zero_t))
                        self.qmc.temp1.append(float(item['T1']))
                        self.qmc.temp2.append(float(item['T2']))
                # swap temperature curves if needed such that BT is the lower and ET the upper one
                if (freduce(lambda x, y: x + y, self.qmc.temp2)) > freduce(lambda x, y: x + y, self.qmc.temp1):
                    tmp = self.qmc.temp1
                    self.qmc.temp1 = self.qmc.temp2
                    self.qmc.temp2 = tmp
                self.qmc.endofx = self.qmc.timex[-1]
                self.autoAdjustAxis()
                self.sendmessage(QApplication.translate('Message', 'HH506RA file loaded successfully'))
                self.qmc.redraw()
        except OSError as ex:
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' importHH506RA(): {0}').format(str(ex)))
        except ValueError as ex:
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Value Error:') + ' importHH506RA(): {0}').format(str(ex)))
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _a, _b, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' importHH506RA() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_0_1(self, _: bool = False) -> None:
        self.resizeImgToSize(0, 0, 'PNG')

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_0_1_JPEG(self, _: bool = False) -> None:
        self.resizeImgToSize(0, 0, 'JPEG')

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_0_1_BMP(self, _: bool = False) -> None:
        self.resizeImgToSize(0, 0, 'BMP')

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_1200_1(self, _: bool = False) -> None:
        self.resizeImgToSize(1200, 0)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_800_1(self, _: bool = False) -> None:
        self.resizeImgToSize(800, 0)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_700_1(self, _: bool = False) -> None:
        self.resizeImgToSize(700, 0)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_620_1(self, _: bool = False) -> None:
        self.resizeImgToSize(620, 0)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_600_1(self, _: bool = False) -> None:
        self.resizeImgToSize(600, 0)

    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImg_500_1(self, _: bool = False) -> None:
        self.resizeImgToSize(500, 0)

    # Facebook
    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImgSize_1200_628(self, _: bool = False) -> None:
        self.resizeImgToSize(1200, 628, 'JPEG')

    # Instagram
    @pyqtSlot()
    @pyqtSlot(bool)
    def resizeImgSize_1080_608(self, _: bool = False) -> None:
        self.resizeImgToSize(1080, 608, 'JPEG')

    @pyqtSlot()
    @pyqtSlot(bool)
    def saveVectorGraph_SVG(self, _: bool = False) -> None:
        self.saveVectorGraph(extension='*.svg')

    @pyqtSlot()
    @pyqtSlot(bool)
    def saveVectorGraph_PDF(self, _: bool = False) -> None:
        self.saveVectorGraph(extension='*.pdf')

    # resizes and saves graph to a new width w and h preserving maximal image quality independent of screen resolution
    def resizeImgToSize(self, w: int, h: int, filetype: str = 'PNG', fname: str = '') -> None:
        try:
            fileext = '.png'
            if filetype == 'JPEG':
                fileext = '.jpg'
            elif filetype == 'BMP':
                fileext = '.bmp'
            if fname == '' or fname is None:
                filename = self.ArtisanSaveFileDialog(
                    msg=QApplication.translate('Message', 'Save Graph as') + ' ' + filetype, ext='*' + fileext)
            else:
                filename = fname
            if filename:
                if not filename.endswith(fileext):
                    filename += fileext

                x, y = self.qmc.fig.get_size_inches()

                adjust_fig_size = False
                fig_dpi = 300
                if w == 0 and h == 0:
                    # high-res, keep aspect ratio as is
                    fig_dpi = 300
                elif w != 0:
                    # compute fig_dpi to achieve the requested width
                    fig_dpi = w / x
                if w != 0 and h != 0:
                    # fig_dpi is already computed to achieve the requested width
                    # now adjust the height
                    adjust_fig_size = True
                if adjust_fig_size:
                    self.qmc.fig.set_size_inches(w / fig_dpi, h / fig_dpi)
                    res_x = int(w)
                    res_y = int(h)
                else:
                    res_x = int(x * fig_dpi)
                    res_y = int(y * fig_dpi)
                if len(self.logofilename) > 0 or self.qmc.logoimg is not None:
                    self.qmc.redraw()
                    self.qmc.placelogoimage()
                if fileext == '.png':
                    batch_nr_str = ('' if self.qmc.roastbatchnrB == 0 else self.qmc.roastbatchprefixB + str(
                        self.qmc.roastbatchnrB) + ' ')
                    metadata = {
                        'Title': f'{batch_nr_str}{self.qmc.title}',
                        'Author': getpass.getuser(),
                        'Description': f'Artisan Roast Profile {batch_nr_str}{self.qmc.title}',
                        'Software': f'Artisan v{__version__}, https://artisan-scope.org/'
                    }
                else:
                    metadata = None
                self.qmc.fig.savefig(filename,
                                     dpi=fig_dpi,
                                     backend='agg',
                                     transparent=(self.qmc.palette['canvas'] is None or self.qmc.palette[
                                         'canvas'] == 'None'),
                                     # bbox_inches='tight',
                                     # backend='pgf', # slow and fails on # characters in TeX backend
                                     facecolor=str(self.qmc.palette['canvas']),
                                     edgecolor=None,
                                     metadata=metadata
                                     )  # transparent=True is need to get the delta curves and legend drawn

                if adjust_fig_size:
                    # reset figure size
                    self.qmc.fig.set_size_inches(x, y)
                    # and redraw
                    if self.qmc.wheelflag:
                        self.qmc.drawWheel()
                    else:
                        self.qmc.lazyredraw_on_resize_timer.start(2)

                self.sendmessage(
                    QApplication.translate('Message', '{0}  size({1},{2}) saved').format(str(filename), str(res_x),
                                                                                         str(res_y)))

        except OSError as ex:
            self.qmc.adderror((QApplication.translate('Error Message', 'IO Error:') + ' resize() {0}').format(str(ex)))
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    def saveVectorGraph(self, extension: str = '*.pdf', fname: str = '') -> None:
        try:
            if fname == '' or fname is None:
                if extension == '*.pdf':
                    filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Graph as PDF'),
                                                          ext=extension)
                else:
                    filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Graph as SVG'),
                                                          ext=extension)
            else:
                filename = fname
            extension = extension.replace('*', '')
            if filename:
                if extension not in filename:
                    filename += extension
                    # mpl.rcParams['pdf.fonttype'] = 3   # 3 or 42
                    # mpl.rc('pdf', fonttype=3)
                batch_nr_str = ('' if self.qmc.roastbatchnrB == 0 else self.qmc.roastbatchprefixB + str(
                    self.qmc.roastbatchnrB) + ' ')
                if extension == '*.pdf':
                    metadata = {
                        'Title': f'{batch_nr_str}{self.qmc.title}',
                        'Author': getpass.getuser(),
                        'Subject': f'Artisan Roast Profile {batch_nr_str}{self.qmc.title}',
                        'Keywords': ', '.join(filter(None, ['Artisan', 'Roast Profile', batch_nr_str])),
                        'Creator': f'Artisan v{__version__}, https://artisan-scope.org/'
                    }
                else:  # SVG
                    metadata = {
                        'Title': f'{batch_nr_str}{self.qmc.title}',
                        'Creator': getpass.getuser(),
                        'Description': f'Artisan Roast Profile {batch_nr_str}{self.qmc.title}',
                        'Keywords': ', '.join(filter(None, ['Artisan', 'Roast Profile', batch_nr_str])),
                        'Publisher': f'Artisan v{__version__}, https://artisan-scope.org/'
                    }
                    if self.curFile is not None:
                        metadata['Source'] = Path(self.curFile).name

                self.qmc.fig.savefig(filename,
                                     transparent=(self.qmc.palette['canvas'] is None or self.qmc.palette[
                                         'canvas'] == 'None'),
                                     # bbox_inches='tight',
                                     # backend='pgf', # slow and fails on # characters in TeX backend
                                     facecolor=str(self.qmc.palette['canvas']),
                                     edgecolor=None,
                                     metadata=metadata
                                     )  # transparent=True is need to get the delta curves and legend drawn
                self.qmc.updateBackground()  # that redraw is needed to avoid the "transparent flicker"

                self.sendmessage(QApplication.translate('Message', '{0} saved').format(str(filename)))
        except OSError as ex:
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' saveVectorGraph() {0}').format(str(ex)))
        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)

    # displays Dialog for the setting of the curves parameters (like RoR, Filters,..)
    @pyqtSlot()
    @pyqtSlot(bool)
    def setCurves(self, _: bool = False) -> None:
        from artisanlib.curves import CurvesDlg
        curvesDlg = CurvesDlg(self, self, self.CurveDlg_activeTab)
        curvesDlg.show()

    # used by WheelGraphDlg()
    # wrap values in unicode(.) if and only if those are of type string
    def getWheelGraph(self) -> 'Wheel':
        wheel: Wheel = {}
        # two dimension lists
        wheel['wheelnames'] = self.qmc.wheelnames
        wheel['segmentlengths'] = self.qmc.segmentlengths
        wheel['segmentsalpha'] = self.qmc.segmentsalpha
        wheel['wradii'] = self.qmc.wradii
        wheel['startangle'] = self.qmc.startangle
        wheel['projection'] = self.qmc.projection
        wheel['wheeltextsize'] = self.qmc.wheeltextsize
        wheel['wheelcolor'] = self.qmc.wheelcolor
        wheel['wheelparent'] = self.qmc.wheellabelparent
        wheel['wheeledge'] = self.qmc.wheeledge
        wheel['wheellinewidth'] = self.qmc.wheellinewidth
        wheel['wheellinecolor'] = self.qmc.wheellinecolor
        wheel['wheeltextcolor'] = self.qmc.wheeltextcolor
        wheel['wheelaspect'] = self.qmc.wheelaspect
        return wheel

    def loadWheel(self, filename: str) -> None:
        f = None
        try:
            f = QFile(filename)
            if not f.open(QIODevice.OpenModeFlag.ReadOnly):
                raise OSError(f.errorString())
            stream = QTextStream(f)
            firstChar = stream.read(1)
            if firstChar == '{':
                f.close()
                wheel = cast('Wheel', self.deserialize(filename))
                self.qmc.wheelnames = wheel['wheelnames']
                self.qmc.segmentlengths = wheel['segmentlengths']
                self.qmc.segmentsalpha = wheel['segmentsalpha']
                self.qmc.wradii = wheel['wradii']
                self.qmc.startangle = wheel['startangle']
                self.qmc.projection = wheel['projection']
                self.qmc.wheeltextsize = wheel['wheeltextsize']
                self.qmc.wheelcolor = wheel['wheelcolor']
                self.qmc.wheellabelparent = wheel['wheelparent']
                self.qmc.wheeledge = wheel['wheeledge']
                self.qmc.wheellinewidth = wheel['wheellinewidth']
                self.qmc.wheellinecolor = wheel['wheellinecolor']
                if 'wheeltextcolor' in wheel:
                    self.qmc.wheeltextcolor = wheel['wheeltextcolor']
                self.qmc.wheelaspect = wheel.get('wheelaspect', 1.0)
                message = QApplication.translate('Message', 'Wheel {0} loaded').format(str(filename))
                self.sendmessage(message)
            else:
                message = QApplication.translate('Message', 'Invalid Wheel graph format')
                self.sendmessage(message)
                return
        #            message =QApplication.translate("Message","Wheel Graph opened successfully")
        #            self.sendmessage(message)
        except OSError as ex:
            _, _, exc_tb = sys.exc_info()
            _log.error(ex)
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' loadWheel() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return
        except ValueError as ex:
            _, _, exc_tb = sys.exc_info()
            _log.error(ex)
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Value Error:') + ' loadWheel() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' loadWheel() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return
        finally:
            if f:
                f.close()

    def standardButtonsVisibility(self) -> None:
        if self.lowerbuttondialog.isVisible():
            self.lowerbuttondialog.setVisible(False)
            self.messagelabel.setVisible(False)
        else:
            self.lowerbuttondialog.setVisible(True)
            self.messagelabel.setVisible(True)

    def toggleextraeventrows(self) -> None:
        if self.extrabuttondialogs.isVisible():
            self.hideExtraButtons()
        else:
            self.showExtraButtons()

    @staticmethod
    def clearBoxLayout(layout: QLayout) -> None:
        while layout.count():
            item = layout.takeAt(0)
            if item is not None:
                widget = item.widget()
                if widget is not None:
                    widget.deleteLater()

    # applies button label substitutions like \t => eventname, \0 => ON,...
    def substButtonLabel(self, buttonNr: int, label: str, eventtype: int) -> str:
        et: int = eventtype
        res: str = label
        if et > 4:
            et = et - 5
        if et < 4:
            res = res.replace('\\t', self.qmc.etypes[et])
        state: int = 0
        if len(self.buttonStates) > buttonNr > -1:
            state = self.buttonStates[buttonNr]
        for var, subst in [
            ('\\0', QApplication.translate('Label', 'OFF')),
            ('\\1', QApplication.translate('Label', 'ON')),
            ('\\2', (QApplication.translate('Label', 'ON') if state else QApplication.translate('Label', 'OFF'))),
            ('\\3', (QApplication.translate('Label', 'OFF') if state else QApplication.translate('Label', 'ON'))),
            ('\\s', QApplication.translate('Label', 'START')),
            ('\\p', QApplication.translate('Label', 'STOP')),
            ('\\S', (QApplication.translate('Label', 'STOP') if state else QApplication.translate('Label', 'START'))),
            ('\\P', (QApplication.translate('Label', 'START') if state else QApplication.translate('Label', 'STOP'))),
            ('\\o', QApplication.translate('Label', 'OPEN')),
            ('\\c', QApplication.translate('Label', 'CLOSE')),
            ('\\O', (QApplication.translate('Label', 'CLOSE') if state else QApplication.translate('Label', 'OPEN'))),
            ('\\C', (QApplication.translate('Label', 'OPEN') if state else QApplication.translate('Label', 'CLOSE'))),
            ('\\a', QApplication.translate('Label', 'AUTO')),
            ('\\m', QApplication.translate('Label', 'MANUAL')),
            ('\\A', (QApplication.translate('Label', 'MANUAL') if state else QApplication.translate('Label', 'AUTO'))),
            ('\\M', (QApplication.translate('Label', 'AUTO') if state else QApplication.translate('Label', 'MANUAL'))),
            ('\\q', self.qmc.etypes[0]),
            ('\\w', self.qmc.etypes[1]),
            ('\\e', self.qmc.etypes[2]),
            ('\\r', self.qmc.etypes[3]),
            ('\\i', QApplication.translate('Label', 'STIRRER')),
            ('\\f', QApplication.translate('Label', 'FILL')),
            ('\\r', QApplication.translate('Label', 'RELEASE')),
            ('\\h', QApplication.translate('Label', 'HEATING')),
            ('\\l', QApplication.translate('Label', 'COOLING'))
        ]:
            res = res.replace(var, subst)
        return res

    # orders extra event buttons based on max number of buttons
    @pyqtSlot()
    def realignbuttons(self) -> None:
        # clear buttons
        self.clearBoxLayout(self.e1buttonbarLayout)
        self.clearBoxLayout(self.e2buttonbarLayout)
        self.clearBoxLayout(self.e3buttonbarLayout)
        self.clearBoxLayout(self.e4buttonbarLayout)

        self.extraeventbuttonround = []

        self.buttonlist = []
        self.buttonStates = []
        # hide all extra button rows
        self.e1buttondialog.setVisible(False)
        self.e2buttondialog.setVisible(False)
        self.e3buttondialog.setVisible(False)
        self.e4buttondialog.setVisible(False)

        row1count = 0
        row2count = 0
        row3count = 0
        row4count = 0

        for i, eet in enumerate(self.extraeventstypes):

            # next button in this group is hidden
            next_hidden = (
                    i % self.buttonlistmaxlen < self.buttonlistmaxlen - 1 and  # at least one more places in the group
                    i + 1 < len(self.extraeventstypes) and  # there is one more button
                    not self.extraeventsvisibility[i + 1])  # and the next one is hidden
            # previous button in this group is hidden
            prev_hidden = (i % self.buttonlistmaxlen > 0 and  # at least one previous place in this group
                           i > 0 and  # there is more than one button in total
                           not self.extraeventsvisibility[i - 1])  # and the previous one is hidden

            if (i % self.buttonlistmaxlen) == 0:  # left-most button in the row
                if i == len(self.extraeventstypes) - 1 or next_hidden:
                    # a singleton button in a one element bar
                    self.extraeventbuttonround.append(3)
                else:
                    # the left-most button in this bar
                    self.extraeventbuttonround.append(1)
            elif ((i % self.buttonlistmaxlen) < self.buttonlistmaxlen - 1) and i != len(self.extraeventstypes) - 1:
                # a button in the middle of this bar
                if prev_hidden and next_hidden:
                    # we round both sides
                    self.extraeventbuttonround.append(3)
                elif prev_hidden:
                    # we start a new rounded-group
                    self.extraeventbuttonround.append(1)
                elif next_hidden:
                    self.extraeventbuttonround.append(2)
                else:
                    # squared button
                    self.extraeventbuttonround.append(0)
            # the right-most button in this bar
            elif prev_hidden:
                self.extraeventbuttonround.append(3)
            else:
                self.extraeventbuttonround.append(2)

            p = QPushButton()
            p.setAutoDefault(False)
            p.setStyleSheet(self.extraEventButtonStyle(i))
            p.setMinimumHeight(
                [self.standard_button_tiny_height, self.standard_button_small_height, self.standard_button_height][
                    self.buttonsize])

            p.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

            p.setText(self.substButtonLabel(i, self.extraeventslabels[i], eet))
            p.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            p.clicked.connect(self.recordextraevent_slot)
            self.buttonlist.append(p)
            self.buttonStates.append(0)
            # add button to row
            if row1count < self.buttonlistmaxlen:
                self.e1buttonbarLayout.addWidget(self.buttonlist[i])
                if not self.extraeventsvisibility[i]:
                    self.e1buttonbarLayout.addSpacing(5)
                row1count += 1
            elif row2count < self.buttonlistmaxlen:
                self.e2buttonbarLayout.addWidget(self.buttonlist[i])
                if not self.extraeventsvisibility[i]:
                    self.e2buttonbarLayout.addSpacing(5)
                row2count += 1
            elif row3count < self.buttonlistmaxlen:
                self.e3buttonbarLayout.addWidget(self.buttonlist[i])
                if not self.extraeventsvisibility[i]:
                    self.e3buttonbarLayout.addSpacing(5)
                row3count += 1
            else:
                self.e4buttonbarLayout.addWidget(self.buttonlist[i])
                if not self.extraeventsvisibility[i]:
                    self.e4buttonbarLayout.addSpacing(5)
                row4count += 1
        if self.e1buttonbarLayout.count() > 0:
            self.e1buttondialog.setVisible(True)
            self.e1buttonbarLayout.insertStretch(0)
            self.e1buttonbarLayout.insertStretch(self.e1buttonbarLayout.count())
        if self.e2buttonbarLayout.count() > 0:
            self.e2buttondialog.setVisible(True)
            self.e2buttonbarLayout.insertStretch(0)
            self.e2buttonbarLayout.insertStretch(self.e2buttonbarLayout.count())
        if self.e3buttonbarLayout.count() > 0:
            self.e3buttondialog.setVisible(True)
            self.e3buttonbarLayout.insertStretch(0)
            self.e3buttonbarLayout.insertStretch(self.e3buttonbarLayout.count())
        if self.e4buttonbarLayout.count() > 0:
            self.e4buttondialog.setVisible(True)
            self.e4buttonbarLayout.insertStretch(0)
            self.e4buttonbarLayout.insertStretch(self.e4buttonbarLayout.count())
        self.settooltip()
        self.buttonsAction.setEnabled(bool(len(self.extraeventslabels) > 0))
        if self.app.artisanviewerMode:
            self.buttonsAction.setEnabled(False)
        self.update_extraeventbuttons_visibility()

    # assigns tooltips to extra event buttons
    def settooltip(self) -> None:
        for i, bl in enumerate(self.buttonlist):
            if self.show_extrabutton_tooltips:
                try:
                    tip = QApplication.translate('Tooltip', '<b>Label</b>= ') + self.extraeventslabels[i] + '<br>'
                    tip += QApplication.translate('Tooltip', '<b>Description </b>= ') + self.extraeventsdescriptions[
                        i] + '<br>'
                    tip += QApplication.translate('Tooltip', '<b>Type </b>= ') + self.qmc.etypesf(
                        self.extraeventstypes[i]) + '<br>'
                    if self.extraeventstypes[i] != 4:  # no tips for 4: no event type set
                        tip += QApplication.translate('Tooltip', '<b>Value </b>= ') + self.qmc.eventsvalues(
                            self.extraeventsvalues[i]) + '<br>'
                        # + str(int(round((self.extraeventsvalues[i]-1)*10.)))  + "<br>"
                    tip += QApplication.translate('Tooltip', '<b>Documentation </b>= ') + self.extraeventsactionstrings[
                        i] + '<br>'
                    tip += QApplication.translate('Tooltip', '<b>Button# </b>= ') + str(i + 1)
                    bl.setToolTip(tip)
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
            else:
                bl.setToolTip('')

    @pyqtSlot()
    def update_extraeventbuttons_visibility(self) -> None:
        for i, bl in enumerate(self.buttonlist):
            try:
                if self.extraeventsvisibility[i]:
                    bl.setVisible(True)
                else:
                    bl.setVisible(False)
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)

    # returns the number of palette named label or None
    def findPalette(self, label: str) -> Optional[int]:
        for i, bp in enumerate(self.buttonpalette):
            if bp[25] == label:
                return i
        return None

    # transfers current buttons to a palette number
    def transferbuttonsto(self, pindex: int) -> None:
        self.buttonpalette[pindex] = self.makePalette()
        self.buttonpalettemaxlen[pindex] = self.buttonlistmaxlen
        self.sendmessage(f"{QApplication.translate('Message', 'Buttons copied to Palette #')}{pindex}")

    # action not returning anything
    @pyqtSlot(int)
    def setbuttonsfromAction(self, pindex: int) -> None:
        self.setbuttonsfrom(pindex)

    def paletteValid(self, palette: 'Palette') -> bool:
        return (len(palette) == self.palette_entries and
                len(palette[0]) == len(palette[1]) == len(palette[2]) == len(palette[3]) == len(palette[4]) and
                len(palette[0]) == len(palette[5]) == len(palette[6]) == len(palette[7]) == len(palette[8]) and
                self.eventsliders == len(palette[9]) == len(palette[10]) == len(palette[11]) == len(palette[12]) and
                self.eventsliders == len(palette[13]) == len(palette[14]) == len(palette[15]) == len(palette[16]) and
                self.eventsliders == len(palette[17]) == len(palette[18]) == len(palette[19]) == len(palette[20]) and
                self.eventsliders == len(palette[21]) == len(palette[23]) == len(palette[23]) == len(palette[24]) and
                self.eventsliders == len(palette[26]) == len(palette[27]))

    # restores a palette number to current buttons
    # returns 1 on success and 0 on failure
    def setbuttonsfrom(self, pindex: int) -> int:
        copy: Palette = self.buttonpalette[pindex]
        if self.paletteValid(copy):
            self.extraeventstypes = copy[0][:]
            self.extraeventsvalues = copy[1][:]
            self.extraeventsactions = copy[2][:]
            self.extraeventsvisibility = copy[3][:]
            self.extraeventsactionstrings = copy[4][:]
            self.extraeventslabels = copy[5][:]
            self.extraeventsdescriptions = copy[6][:]
            self.extraeventbuttoncolor = copy[7][:]
            self.extraeventbuttontextcolor = copy[8][:]
            self.eventslidervisibilities = copy[9][:]
            self.eventslideractions = copy[10][:]
            self.eventslidercommands = copy[11][:]
            self.eventslideroffsets = copy[12][:]
            self.eventsliderfactors = copy[13][:]
            self.eventquantifieractive = copy[14][:]
            self.eventquantifiersource = copy[15][:]
            self.eventquantifiermin = copy[16][:]
            self.eventquantifiermax = copy[17][:]
            self.eventquantifiercoarse = copy[18][:]
            self.eventslidermin = copy[19][:]
            self.eventslidermax = copy[20][:]
            self.eventslidercoarse = copy[21][:]
            self.eventslidertemp = copy[22][:]
            self.eventsliderunits = copy[23][:]
            self.eventsliderBernoulli = copy[24][:]
            self.buttonpalette_label = copy[25]
            self.eventquantifieraction = copy[26][:]
            self.eventquantifierSV = copy[27][:]
            #
            self.buttonlistmaxlen = self.buttonpalettemaxlen[pindex]
            self.realignbuttons()
            self.updateSlidersProperties()
            self.lastbuttonpressed = -1
            self.sendmessage(QApplication.translate('Message',
                                                    'Palette #%i restored') % pindex)  # pylint: disable=consider-using-f-string
            return 1  # success
        self.sendmessage(
            QApplication.translate('Message', 'Palette #%i empty') % pindex)  # pylint: disable=consider-using-f-string
        return 0  # failed

    def encodeTreeStrings(self, tree: Any) -> Any:
        return self.mapTree(tree, encodeLocal)

    def decodeTreeStrings(self, tree: Any) -> Any:
        return self.mapTree(tree, decodeLocal)

    # converts tuples to lists
    def mapTree(self, tree: Any, f: Callable[[Optional[str]], Optional[str]]) -> Any:
        if isinstance(tree, (list, tuple)):
            return [self.mapTree(e, f) for e in tree]
        if isinstance(tree, str):
            return f(tree)
        return tree

    def backuppaletteeventbuttons(self, pal: List['Palette'], maxlen: List[int]) -> None:
        palette = {}
        # convert labels to unicode
        for i, pa in enumerate(pal):
            k = str(i)
            palette[k] = self.encodeTreeStrings(pa)
        palette['maxlen'] = maxlen
        try:
            filename = self.ArtisanSaveFileDialog(msg=QApplication.translate('Message', 'Save Palettes'), ext='*.apal')
            if filename:
                # write
                self.serialize(filename, palette)
                self.sendmessage(QApplication.translate('Message', 'Palettes saved'))
        except OSError as ex:
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' backuppaletteeventbuttons(): {0}').format(
                    str(ex)))

    def loadPalettesSlot(self, filename: str) -> None:
        self.getPalettes(filename, self.buttonpalette)

    def getPalettes(self, filename: str, pal: List['Palette']) -> None:
        maxlen = self.loadPalettes(filename, pal)
        if maxlen is not None:
            self.buttonpalettemaxlen = maxlen

    def makePalette(self, empty: bool = True) -> 'Palette':
        # by default an empty (non paletteValid() palette is returned
        # if empty is set to False, a valid palette from the current event settings is generated
        if empty:
            return cast('Palette', tuple([[]] * 25 + [''] + [[]] * 2))
        return (
            self.extraeventstypes[:],
            self.extraeventsvalues[:],
            self.extraeventsactions[:],
            self.extraeventsvisibility[:],
            self.extraeventsactionstrings[:],
            self.extraeventslabels[:],
            self.extraeventsdescriptions[:],
            self.extraeventbuttoncolor[:],
            self.extraeventbuttontextcolor[:],
            #
            self.eventslidervisibilities[:],
            self.eventslideractions[:],
            self.eventslidercommands[:],
            self.eventslideroffsets[:],
            self.eventsliderfactors[:],
            #
            self.eventquantifieractive[:],
            self.eventquantifiersource[:],
            self.eventquantifiermin[:],
            self.eventquantifiermax[:],
            self.eventquantifiercoarse[:],
            self.eventslidermin[:],
            self.eventslidermax[:],
            #
            self.eventslidercoarse[:],
            self.eventslidertemp[:],
            self.eventsliderunits[:],
            self.eventsliderBernoulli[:],
            self.buttonpalette_label,
            #
            self.eventquantifieraction[:],
            self.eventquantifierSV[:]
        )

    def loadPalettes(self, filename: str, input_pal: List['Palette']) -> Optional[List[int]]:
        try:
            f = QFile(filename)
            if not f.open(QIODevice.OpenModeFlag.ReadOnly):
                raise OSError(f.errorString())
            stream = QTextStream(f)
            firstChar = stream.read(1)
            if firstChar == '{':
                f.close()
                palette = self.deserialize(filename)  # externally each palette is a list of lists
                buttonpalettemaxlen = list(map(int, palette['maxlen']))
                for i in range(10):  # 10 palettes (0-9)
                    pal = palette[str(i)]
                    if pal is not None:
                        pk = self.decodeTreeStrings(pal)
                        if len(pk):
                            event_button_types: List[int] = [int(y) for y in pk[0]]
                            event_button_values: List[float] = [float(y) for y in pk[1]]
                            event_button_actions: List[int] = [int(y) for y in pk[2]]
                            event_button_visibility: List[int] = [int(y) for y in pk[3]]
                            event_button_action_strings: List[str] = [str(y) for y in pk[4]]
                            event_button_labels: List[str] = [str(y) for y in pk[5]]
                            event_button_descriptions: List[str] = [str(y) for y in pk[6]]
                            event_button_colors: List[str] = [str(y) for y in pk[7]]
                            event_button_text_colors: List[str] = [str(y) for y in pk[8]]
                            # read in extended palette data containing slider settings:
                            slider_visibilities: List[int] = ([int(y) for y in pk[9]] if len(pk) > 9 else pal[i][9][:])
                            slider_actions: List[int] = ([int(y) for y in pk[10]] if len(pk) > 10 else pal[i][10][:])
                            slider_commands: List[str] = ([str(y) for y in pk[11]] if len(pk) > 11 else pal[i][11][:])
                            slider_offsets: List[float] = (
                                [float(y) for y in pk[12]] if len(pk) > 12 else pal[i][12][:])
                            slider_factors: List[float] = (
                                [float(y) for y in pk[13]] if len(pk) > 13 else pal[i][13][:])
                            #
                            slider_quantifier_active: List[int] = (
                                [int(y) for y in pk[14]] if len(pk) > 14 else pal[i][14][:])
                            slider_quantifier_sources: List[int] = (
                                [int(y) for y in pk[15]] if len(pk) > 15 else pal[i][15][:])
                            slider_quantifier_min: List[int] = (
                                [int(y) for y in pk[16]] if len(pk) > 16 else pal[i][16][:])
                            slider_quantifier_max: List[int] = (
                                [int(y) for y in pk[17]] if len(pk) > 17 else pal[i][17][:])
                            slider_quantifier_coarse: List[int] = (
                                [int(y) for y in pk[18]] if len(pk) > 18 else pal[i][18][:])
                            slider_slider_min: List[int] = ([int(y) for y in pk[19]] if len(pk) > 19 else pal[i][19][:])
                            slider_slider_max: List[int] = ([int(y) for y in pk[20]] if len(pk) > 20 else pal[i][20][:])
                            #
                            slider_slider_coarse: List[int] = (
                                [int(y) for y in pk[21]] if len(pk) > 21 else pal[i][21][:])
                            slider_slider_temp_flags: List[int] = (
                                [int(y) for y in pk[22]] if len(pk) > 22 else pal[i][22][:])
                            slider_slider_units: List[str] = (
                                [str(y) for y in pk[23]] if len(pk) > 23 else pal[i][23][:])
                            slider_slider_bernoulli_flags: List[int] = (
                                [int(y) for y in pk[24]] if len(pk) > 24 else pal[i][24][:])
                            #
                            label = (str(pk[25]) if len(pk) > 25 else self.buttonpalette_default_label)
                            #
                            slider_quantifier_action_flags = (
                                [int(y) for y in pk[26]] if len(pk) > 26 else pal[i][26][:])
                            slider_quantifier_SV_flags = ([int(y) for y in pk[27]] if len(pk) > 27 else pal[i][27][:])

                            #
                            nextpalette: Palette = (
                                event_button_types,
                                event_button_values,
                                event_button_actions,
                                event_button_visibility,
                                event_button_action_strings,
                                event_button_labels,
                                event_button_descriptions,
                                event_button_colors,
                                event_button_text_colors,
                                slider_visibilities,
                                slider_actions,
                                slider_commands,
                                slider_offsets,
                                slider_factors,
                                slider_quantifier_active,
                                slider_quantifier_sources,
                                slider_quantifier_min,
                                slider_quantifier_max,
                                slider_quantifier_coarse,
                                slider_slider_min,
                                slider_slider_max,
                                slider_slider_coarse,
                                slider_slider_temp_flags,
                                slider_slider_units,
                                slider_slider_bernoulli_flags,
                                label,
                                slider_quantifier_action_flags,
                                slider_quantifier_SV_flags)
                            input_pal[i] = nextpalette
                message = QApplication.translate('Message', 'Palettes loaded')
                self.sendmessage(message)
                return buttonpalettemaxlen
            message = QApplication.translate('Message', 'Invalid palettes file format')
            self.sendmessage(message)
            return None
        except OSError as ex:
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' loadPalettes() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return None
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' loadPalettes() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return None

    #    def restorepaletteeventbuttons(self, pal):
    #        filename = self.ArtisanOpenFileDialog(msg=QApplication.translate('Message','Load Palettes'),path=self.profilepath)
    #        if filename:
    #            self.getPalettes(filename,pal)

    @pyqtSlot(str)
    def loadAlarms(self, filename: str) -> None:
        try:
            from json import load as json_load
            with open(filename, encoding='utf-8') as infile:
                alarms = json_load(infile)
            self.qmc.alarmflag = alarms['alarmflags']
            self.qmc.alarmguard = alarms['alarmguards']
            self.qmc.alarmnegguard = alarms['alarmnegguards']
            self.qmc.alarmtime = alarms['alarmtimes']
            self.qmc.alarmoffset = alarms['alarmoffsets']
            self.qmc.alarmcond = alarms['alarmconds']
            self.qmc.alarmsource = alarms['alarmsources']
            self.qmc.alarmtemperature = alarms['alarmtemperatures']
            self.qmc.alarmaction = alarms['alarmactions']
            self.qmc.alarmbeep = alarms['alarmbeep']
            self.qmc.alarmstrings = alarms['alarmstrings']
            try:
                self.qmc.alarmsetlabel = alarms['alarmsetlabel']
            except Exception:  # pylint: disable=broad-except
                self.qmc.alarmsetlabel = ''
            message = QApplication.translate('Message', 'Alarms loaded')
            self.sendmessage(message)
        except OSError as ex:
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'IO Error:') + ' loadAlarms() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' loadAlarms() {0}').format(str(ex)),
                getattr(exc_tb, 'tb_lineno', '?'))
            return

    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesALL(self, _: bool = False) -> None:
        self.analysisfitCurves(-1)

    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesLN(self, _: bool = False) -> None:
        self.analysisfitCurves(0)

    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesX2(self, _: bool = False) -> None:
        self.analysisfitCurves(2)

    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesX3(self, _: bool = False) -> None:
        self.analysisfitCurves(3)

    @pyqtSlot()
    @pyqtSlot(bool)
    def analysisfitCurvesBkgnd(self, _: bool = False) -> None:
        self.analysisfitCurves(4)

    @pyqtSlot()
    @pyqtSlot(bool)
    def clearResults(self, _: bool = False) -> None:
        if self.qmc.analyzer_connect_id is not None:
            self.qmc.fig.canvas.mpl_disconnect(self.qmc.analyzer_connect_id)
        self.segmentresultsanno = None
        self.analysisresultsanno = None
        self.autoAdjustAxis()
        self.qmc.redraw(recomputeAllDeltas=True)

    def analysisfitCurves(self, exp: int = -1) -> None:
        curvefit_starttime = 0.
        curvefit_endtime = 0.
        analysis_starttime = 0.
        analysis_endtime = 0.
        resultstr = ''
        # curve fit results
        cfr = {}  # use dict to allow more flexible expansion

        # exp == 0 -> ln(), 1 -> unused, 2 -> quadratic, 3 -> cubic, 4 -> bkgnd, -1 -> all of 0,2,and 3
        # check for any roast data
        if not self.qmc.timeindex[0] > -1:
            self.sendmessage(QApplication.translate('Error Message', 'Analyze: CHARGE event required, none found'))
            return
        # check for finished roast
        if not self.qmc.timeindex[6]:
            self.sendmessage(QApplication.translate('Error Message', 'Analyze: DROP event required, none found'))
            return

        # Save the background annotations setting and then disable
        orig_backgroundDetails = self.qmc.backgroundDetails
        self.qmc.backgroundDetails = False

        # prevent accidental overwrite of the original file
        self.qmc.fileDirtySignal.emit()
        self.curFile = None

        # initialize progress dialog
        progress: QProgressDialog = QProgressDialog(QApplication.translate('Message', 'Fitting curves...'), '', 0, 3,
                                                    self)
        progress.setCancelButton(None)
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setAutoClose(True)
        progress.show()
        QApplication.processEvents()

        restoreF: bool = False

        try:
            # initialize the results
            resultstr = ''

            # run all analysis in celsius
            if self.qmc.mode == 'F':
                restoreF = True
                self.qmc.convertTemperature('C', silent=True, setdefaultaxes=False)
                smooth = True
                decay_smoothing_p = not self.qmc.optimalSmoothing
                recomputeAllDeltas = True
                self.qmc.smoothETBT(smooth, recomputeAllDeltas, decay_smoothing_p)
                self.qmc.smoothETBTBkgnd(recomputeAllDeltas, decay_smoothing_p)
            else:
                restoreF = False

            chargetime = self.qmc.timex[self.qmc.timeindex[0]]

            # drytime is either the DRY event or as set in the Phases dialog
            if self.qmc.timeindex[1]:
                # use the DRY event
                drytime = self.qmc.timex[self.qmc.timeindex[1] - 1]  # one sample before DE
            else:
                # use the phases dialog value
                i = self.findDryEnd(phasesindex=1)
                drytime = self.qmc.timex[i - 1]  # one sample before DE

            # fcstime is either the FCs event or as set in the Phases dialog
            # NOTE - if phases time is used the deltaRoR @FCs will return zeros.
            if self.qmc.timeindex[2]:
                # use the FCS event
                fcstime = self.qmc.timex[self.qmc.timeindex[2]]
            else:
                # use the phases dialog value
                i = self.findDryEnd(phasesindex=2)
                fcstime = self.qmc.timex[i]

            # set the interval of interest
            if self.qmc.analysisstartchoice == 1:  # 120 sec before FCs
                analysis_starttime = fcstime - 120
            elif self.qmc.analysisstartchoice == 2:  # Custom
                analysis_starttime = self.qmc.analysisoffset + chargetime
            else:  # DRY END
                analysis_starttime = drytime
            analysis_endtime = self.qmc.timex[self.qmc.timeindex[6]]

            # set the curve fit time
            if self.qmc.curvefitstartchoice == 1:  # 120 sec before FCs
                curvefit_starttime = fcstime - 120
            elif self.qmc.curvefitstartchoice == 2:  # Custom
                curvefit_starttime = self.qmc.curvefitoffset + chargetime
            else:
                curvefit_starttime = drytime
            curvefit_endtime = self.qmc.timex[self.qmc.timeindex[6]]

            # natural log needs a curve fit point sometime earlier than drytime.  Pick one after TP if it exists. Otherwise after CHARGE.
            tpidx = self.findTP()
            if tpidx > 1:
                tptime = self.qmc.timex[tpidx]
                curvefit_starttime_ln = .25 * (drytime - tptime) + tptime
            else:
                curvefit_starttime_ln = .33 * (drytime - chargetime) + chargetime

            # Parameters to curve fit the profile to the existing background.  Respects the background alignment set in the Background Dialog.
            if exp == 4:
                # check for finished background roast
                if not self.qmc.background:
                    self.sendmessage(
                        QApplication.translate('Error Message', 'Analyze: no background profile data available'))
                    return
                if not (self.qmc.timeindexB[0] > -1 and self.qmc.timeindexB[6]):
                    self.sendmessage(QApplication.translate('Error Message',
                                                            'Analyze: background profile requires CHARGE and DROP events'))
                    return

                # set curvefit_starttime to match analysis_starttime
                curvefit_starttime = analysis_starttime
                # set curvefit_starttime analysis_endtime to the earlier of DROP or background DROP
                droptime = self.qmc.timex[self.qmc.timeindex[6]]
                droptimeB = self.qmc.timeB[self.qmc.timeindexB[6]]
                if droptime > droptimeB:
                    curvefit_endtime = droptimeB
                    analysis_endtime = droptimeB

            # replace a nan value with '--'. returns a string
            def replNan(x: Any) -> str:
                if isinstance(x, str):
                    return x
                return '--' if numpy.isnan(x) else f'{x:.2f}'

            res = {}

            # background
            if exp == 4:
                cfr['equ_background'] = QApplication.translate('Label', 'Bkgnd')
                res = self.analysisGetResults(exp=4, curvefit_starttime=curvefit_starttime,
                                              curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime,
                                              analysis_endtime=analysis_endtime)
                cfr['dbt_background'] = replNan(res['mse_BT'])
                cfr['dbt_background_r'] = replNan(res['rmse_BT'])
                cfr['ror_fcs_delta_background'] = replNan(res['ror_fcs_delta'])
                cfr['ror_min_delta_background'] = replNan(res['ror_min_delta'])
                cfr['ror_maxmin_delta_background'] = f"{replNan(res['ror_max_delta'])}/{replNan(res['ror_min_delta'])}"
                progress.setValue(3)
            # ln() or all
            if exp in [0, -1]:
                res = self.analysisGetResults(exp=0, curvefit_starttime=curvefit_starttime_ln,
                                              curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime,
                                              analysis_endtime=analysis_endtime)
                cfr['equ_naturallog'] = res['equ']
                cfr['dbt_naturallog'] = replNan(res['mse_BT'])
                cfr['dbt_naturallog_r'] = replNan(res['rmse_BT'])
                cfr['ror_fcs_delta_naturallog'] = replNan(res['ror_fcs_delta'])
                cfr['ror_min_delta_naturallog'] = replNan(res['ror_min_delta'])
                cfr['ror_maxmin_delta_naturallog'] = f"{replNan(res['ror_max_delta'])}/{replNan(res['ror_min_delta'])}"
                progress.setValue(1 if exp == -1 else 3)
            # cubic or all
            if exp in [3, -1]:
                res = self.analysisGetResults(exp=3, curvefit_starttime=curvefit_starttime,
                                              curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime,
                                              analysis_endtime=analysis_endtime)
                cfr['equ_cubic'] = res['equ']
                cfr['dbt_cubic'] = replNan(res['mse_BT'])
                cfr['dbt_cubic_r'] = replNan(res['rmse_BT'])
                cfr['ror_fcs_delta_cubic'] = replNan(res['ror_fcs_delta'])
                cfr['ror_min_delta_cubic'] = replNan(res['ror_min_delta'])
                cfr['ror_maxmin_delta_cubic'] = f"{replNan(res['ror_max_delta'])}/{replNan(res['ror_min_delta'])}"
                progress.setValue(2 if exp == -1 else 3)
            # quadratic or all
            if exp in [2, -1]:
                res = self.analysisGetResults(exp=2, curvefit_starttime=curvefit_starttime,
                                              curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime,
                                              analysis_endtime=analysis_endtime)
                cfr['equ_quadratic'] = res['equ']
                cfr['dbt_quadratic'] = replNan(res['mse_BT'])
                cfr['dbt_quadratic_r'] = replNan(res['rmse_BT'])
                cfr['ror_fcs_delta_quadratic'] = replNan(res['ror_fcs_delta'])
                cfr['ror_min_delta_quadratic'] = replNan(res['ror_min_delta'])
                cfr['ror_maxmin_delta_quadratic'] = f"{replNan(res['ror_max_delta'])}/{replNan(res['ror_min_delta'])}"
                progress.setValue(3)

            # build the results table
            import prettytable  # @UnresolvedImport
            tbl = prettytable.PrettyTable()
            tbl.field_names = [' ',
                               QApplication.translate('Label', 'RMSE BT'),
                               QApplication.translate('Label', 'MSE BT'),
                               QApplication.translate('Label', 'RoR') + ' \u0394 ' + QApplication.translate('Label',
                                                                                                            '@FCs'),
                               QApplication.translate('Label', 'Max+/Max- RoR') + ' \u0394']
            tbl.float_format = '5.2'
            if 'equ_background' in cfr and 'dbt_background' in cfr and 'ror_fcs_delta_background' in cfr and 'ror_maxmin_delta_background' in cfr:
                tbl.add_row([QApplication.translate('Label', 'Bkgnd'), cfr['dbt_background_r'], cfr['dbt_background'],
                             cfr['ror_fcs_delta_background'], cfr['ror_maxmin_delta_background']])
            if 'equ_quadratic' in cfr and 'dbt_quadratic' in cfr and 'ror_fcs_delta_quadratic' in cfr and 'ror_maxmin_delta_quadratic' in cfr:
                tbl.add_row(
                    [QApplication.translate('Label', 'x') + '\u00b2', cfr['dbt_quadratic_r'], cfr['dbt_quadratic'],
                     cfr['ror_fcs_delta_quadratic'], cfr['ror_maxmin_delta_quadratic']])
            if 'equ_cubic' in cfr and 'dbt_cubic' in cfr and 'ror_fcs_delta_cubic' in cfr and 'ror_maxmin_delta_cubic' in cfr:
                tbl.add_row([QApplication.translate('Label', 'x') + '\u00b3', cfr['dbt_cubic_r'], cfr['dbt_cubic'],
                             cfr['ror_fcs_delta_cubic'], cfr['ror_maxmin_delta_cubic']])
            if 'equ_naturallog' in cfr and 'dbt_naturallog' in cfr and 'ror_fcs_delta_naturallog' in cfr and 'ror_maxmin_delta_naturallog' in cfr:
                tbl.add_row([QApplication.translate('Label', 'ln()'), cfr['dbt_naturallog_r'], cfr['dbt_naturallog'],
                             cfr['ror_fcs_delta_naturallog'], cfr['ror_maxmin_delta_naturallog']])
            resultstr = 'Curve Fit Analysis\n'
            resultstr += tbl.get_string(sortby=None)

            cfr['segmentresultstr'] = res['segmentresultstr']

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' analysisfitCurves(): {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

        try:
            # convert back to Fahrenheit if the profile was converted to Celsius
            if restoreF:
                self.qmc.convertTemperature('FA', silent=True, setdefaultaxes=False)

            # create the results annotation and update the graph
            if len(resultstr) > 0:
                self.analysisShowResults(cfr, resultstr, curvefit_starttime=curvefit_starttime,
                                         curvefit_endtime=curvefit_endtime, analysis_starttime=analysis_starttime,
                                         analysis_endtime=analysis_endtime)

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' analysisfitCurves(): {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

        progress.cancel()
        del progress
        # restore the background annotations setting
        self.qmc.backgroundDetails = orig_backgroundDetails

    # returns True as first result if draggable text box artist is contained in the given events region and
    # and it is the one in the region with the highest z-order, otherwise False
    # a dict of properties is returned as second argument
    def draggable_text_box_picker(self, artist: 'Artist', evt: 'MouseEvent') -> Tuple[bool, Dict[Any, Any]]:
        try:
            if self.segmentresultsanno is not None and self.analysisresultsanno is not None:
                # in case the analyzer boxes are displayed
                seg_contained, seg_prop = self.segmentresultsanno.contains(evt)
                ana_contained, ana_prop = self.analysisresultsanno.contains(evt)
                segment_zorder = self.segmentresultsanno.get_zorder()
                analysis_zorder = self.analysisresultsanno.get_zorder()
                if artist == self.segmentresultsanno:
                    if seg_contained and (not ana_contained or segment_zorder > analysis_zorder):
                        # a click on the segmentresult box, but not on the analysisresult box, or the segment box is in front
                        # ensure that the z-order of the segment box is higher than that of the analysis box as the bitblit brings the segment box to the front
                        self.segmentresultsanno.set_zorder(max(segment_zorder, analysis_zorder))
                        self.analysisresultsanno.set_zorder(min(segment_zorder, analysis_zorder))
                        return True, seg_prop
                    # no click on the the segment box, or the analysis box is clicked too and in front
                    return False, {}
                if artist == self.analysisresultsanno:
                    if ana_contained and (not seg_contained or segment_zorder < analysis_zorder):
                        # a click on the analysisresult box, but not on the segmentresult box, or the analyzer box is in front
                        # ensure that the z-order of the analyse box is higher than that of the segment box as the bitblit brings the segment box to the front
                        self.segmentresultsanno.set_zorder(min(segment_zorder, analysis_zorder))
                        self.analysisresultsanno.set_zorder(max(segment_zorder, analysis_zorder))
                        return True, ana_prop
                    # no click on the the analysis box, or the segment box is clicked too and in front
                    return False, {}
                if not seg_contained and not ana_contained:
                    # neither of the two analyzer boxes was clicked, check the given artist is contained in the event region
                    return artist.contains(evt)
                # one of the two analyzer boxes was clicked, we ignore all other artists that might be contained in the events region
                return False, {}
            # if analyzer boxes are not available we call the standard picker
            return artist.contains(evt)
        except Exception as ex:  # pylint: disable=broad-except
            _log.exception(ex)
            return False, {}

    def analysisShowResults(self, cfr: Dict[str, Any], resultstr: str, curvefit_starttime: float = 0,
                            curvefit_endtime: float = 0, analysis_starttime: float = 0,
                            analysis_endtime: float = 0) -> None:
        if self.qmc.ax is None:
            return
        self.qmc.redraw(recomputeAllDeltas=True)

        if len(resultstr) == 0:
            resultstr = self.qmc.analysisresultsstr
        else:
            self.qmc.analysisresultsstr = resultstr
        try:
            # draw analysis mask
            a = self.qmc.alpha['analysismask'] / 2
            fc = self.qmc.palette['analysismask']
            z = 20
            self.qmc.ax.axvspan(self.qmc.ax.get_xlim()[0], curvefit_starttime, facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(curvefit_endtime, self.qmc.ax.get_xlim()[1], facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(curvefit_starttime, curvefit_endtime, ymin=0, ymax=0.025, facecolor=fc, alpha=a,
                                zorder=z)
            self.qmc.ax.axvspan(curvefit_starttime, curvefit_endtime, ymin=0.975, ymax=1.00, facecolor=fc, alpha=a,
                                zorder=z)

            self.qmc.ax.axvspan(self.qmc.ax.get_xlim()[0], analysis_starttime, facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(analysis_endtime, self.qmc.ax.get_xlim()[1], facecolor=fc, alpha=a, zorder=z)
            self.qmc.ax.axvspan(analysis_starttime, analysis_endtime, ymin=0, ymax=0.025, facecolor=fc, alpha=a,
                                zorder=z)
            self.qmc.ax.axvspan(analysis_starttime, analysis_endtime, ymin=0.975, ymax=1.00, facecolor=fc, alpha=a,
                                zorder=z)

            # show warning if the analysis starts earlier than curve fit
            if curvefit_starttime > analysis_starttime:
                string = QApplication.translate('Message',
                                                'Warning: The start of the analysis interval of interest is earlier than the start of curve fitting.\nCorrect this on the Config>Curves>Analyze tab.')
                QMessageBox.warning(self, QApplication.translate('Message', 'Analysis earlier than Curve fit'), string)

            # reset the annotation location if the origin is out of the screen
            for dim in self.qmc.analysisresultsloc:
                if dim >= 1 or dim <= 0:
                    self.qmc.analysisresultsloc = self.qmc.analysisresultsloc_default

            # reset the annotation location if the origin is out of the screen
            for dim in self.qmc.segmentresultsloc:
                if dim >= 1 or dim <= 0:
                    self.qmc.segmentresultsloc = self.qmc.segmentresultsloc_default

            if self.qmc.locale_str in {'ja', 'ko', 'zh_CN', 'zh_TW'}:
                # monospace font with Chinese characters
                self.set_mpl_fontproperties(getResourcePath() + 'WenQuanYiZenHeiMonoMedium.ttf')
                fontfamily = 'WenQuanYi Zen Hei Mono'
            else:
                fontfamily = 'monospace'

            # create the segment results annotation box
            a = self.qmc.alpha['statsanalysisbkgnd']
            fc = self.qmc.palette['statsanalysisbkgnd']
            tc = self.labelBorW(fc)
            if 'segmentresultstr' in cfr:
                segmentresultstr = cfr['segmentresultstr']

                self.segmentresultsanno = self.qmc.ax.annotate(segmentresultstr, xy=self.qmc.segmentresultsloc,
                                                               xycoords='axes fraction',
                                                               ha='left', va='center',
                                                               fontfamily=fontfamily,
                                                               fontsize='x-small',
                                                               color=tc,
                                                               zorder=30,
                                                               picker=False,
                                                               bbox={'boxstyle': 'round', 'fc': fc, 'alpha': a})
                try:
                    self.segmentresultsanno.set_in_layout(False)  # remove from tight_layout calculation
                    self.segmentresultsanno.draggable(use_blit=True)
                    self.segmentresultsanno.set_picker(self.draggable_text_box_picker)
                except Exception:  # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                    pass

            # create the analysis results annotation box
            a = self.qmc.alpha['statsanalysisbkgnd']
            fc = self.qmc.palette['statsanalysisbkgnd']
            tc = self.labelBorW(fc)
            self.analysisresultsanno = self.qmc.ax.annotate(resultstr, xy=self.qmc.analysisresultsloc,
                                                            xycoords='axes fraction',
                                                            ha='left', va='center',
                                                            fontfamily=fontfamily,
                                                            fontsize='x-small',
                                                            color=tc,
                                                            zorder=31,
                                                            picker=False,
                                                            bbox={'boxstyle': 'round', 'fc': fc, 'alpha': a})
            try:
                self.analysisresultsanno.set_in_layout(False)  # remove from tight_layout calculation
                self.analysisresultsanno.draggable(use_blit=True)
                self.analysisresultsanno.set_picker(self.draggable_text_box_picker)
            except Exception:  # pylint: disable=broad-except # set_in_layout not available in mpl<3.x
                pass
            self.qmc.analyzer_connect_id = self.qmc.fig.canvas.mpl_connect('button_release_event', self.qmc.onrelease)
            self.qmc.fig.canvas.draw()

        except Exception as e:  # pylint: disable=broad-except
            _log.exception(e)
            _, _, exc_tb = sys.exc_info()
            self.qmc.adderror(
                (QApplication.translate('Error Message', 'Exception:') + ' analysisShowResults(): {0}').format(str(e)),
                getattr(exc_tb, 'tb_lineno', '?'))

    def analysisGetResults(self, exp: int = 2, curvefit_starttime: float = 0, curvefit_endtime: float = 0,
                           analysis_starttime: float = 0, analysis_endtime: float = 0) -> Dict[str, Any]:

        res = {}  # use dict for the results

        if exp != 4:  # not using existing background so perform a curve fit that sets the background
            res['equ'] = self.qmc.lnRegression(power=exp, curvefit_starttime=curvefit_starttime,
                                               curvefit_endtime=curvefit_endtime, plot=False)
            self.deleteBackground()
            self.setbackgroundequ(EQU=['', res['equ']], recomputeAllDeltas=True,
                                  doDraw=False)  # redraw() called from setbackgroundequ()
            _log.debug("res['equ'] %s", res['equ'])

        result = self.curveSimilarity2(exp=exp, analysis_starttime=analysis_starttime,
                                       analysis_endtime=analysis_endtime)

        return {**result, **res}

    def setbackgroundequ(self, foreground: bool = False, EQU: Optional[List[str]] = None,
                         recomputeAllDeltas: bool = False, doDraw: bool = True) -> None:
        if EQU is None:
            EQU = ['', '']
        # Check for incompatible vars from in the equations
        incompatiblevars = ['P', 'F', '$', '#']
        error = ''
        for iv in incompatiblevars:
            if iv in EQU[0]:
                error = f'P1: \n-{iv}\n\n[{EQU[0]}]'
            elif iv in EQU[1]:
                error = f'P2: \n-{iv}\n\n[{EQU[1]}]'

        if error:
            string = QApplication.translate('Message',
                                            'Incompatible variables found in %s') % error  # pylint: disable=consider-using-f-string
            QMessageBox.warning(self, QApplication.translate('Message', 'Assignment problem'), string)
        else:
            try:
                equ = EQU[0]
                equ2 = EQU[1]
                if len(equ) or len(equ2):
                    self.qmc.resetlines()
                    # create x range
                    x_range: List[float] = []
                    if len(self.qmc.timex) > 1:
                        x_range = self.qmc.timex[:]
                        if not foreground and self.qmc.timeindex[0] > -1:
                            toff = self.qmc.timex[self.qmc.timeindex[0]]
                        else:
                            toff = 0
                    else:
                        x_range = list(range(int(self.qmc.startofx), int(self.qmc.endofx)))
                        toff = 0
                    # create y range
                    y_range: List[float] = []
                    y_range2: List[float] = []
                    for xr in x_range:
                        y_range.append(self.qmc.eval_math_expression(equ, xr, t_offset=toff))
                        y_range2.append(self.qmc.eval_math_expression(equ2, xr, t_offset=toff))

                    # if foreground flag passed, set EQUs as ET BT instead of background
                    if foreground:
                        self.qmc.timex = x_range[:]
                        self.qmc.temp1 = y_range[:]
                        self.qmc.temp2 = y_range2[:]
                        self.qmc.redraw(recomputeAllDeltas=True)
                        # make extra devices not visible
                        for x in range(len(self.qmc.extradevices)):
                            self.qmc.extratemp1[x] = [-1.] * len(x_range)
                            self.qmc.extratemp2[x] = [-1.] * len(x_range)
                            self.qmc.extratimex[x] = x_range[:]
                        self.sendmessage(QApplication.translate('Message', 'Y1 = [%s] ; Y2 = [%s]' % (
                            EQU[0], EQU[1])))  # noqa: UP031 # pylint: disable=consider-using-f-string

                    else:
                        self.qmc.timeB = x_range[:]
                        self.qmc.temp1B = y_range[:]
                        self.qmc.stemp1B = numpy.array(y_range[:])
                        self.qmc.temp2B = y_range2[:]
                        self.qmc.stemp2B = numpy.array(self.qmc.temp2B[:])
                        for i in range(8):
                            self.qmc.timeindexB[i] = 0
                        self.qmc.timeindexB[0] = -1
                        if self.qmc.timeindex[0] > -1 and self.qmc.timeindex[6]:
                            # we copy the CHARGE and DROP from the foreground to allow alignment
                            t1 = self.qmc.timex[self.qmc.timeindex[0]]
                            self.qmc.timeindexB[0] = max(-1, self.qmc.backgroundtime2index(t1))
                            if self.qmc.timeindex[1]:
                                t_DE = self.qmc.timex[self.qmc.timeindex[1]]
                                self.qmc.timeindexB[1] = max(0, self.qmc.backgroundtime2index(t_DE))
                            if self.qmc.timeindex[2]:
                                t_FCs = self.qmc.timex[self.qmc.timeindex[2]]
                                self.qmc.timeindexB[2] = max(0, self.qmc.backgroundtime2index(t_FCs))
                            t2 = self.qmc.timex[self.qmc.timeindex[6]]
                            self.qmc.timeindexB[6] = max(0, self.qmc.backgroundtime2index(t2))
                        self.qmc.background = True
                        self.qmc.backgroundprofile = {}
                        self.qmc.backgroundprofile_moved_x = 0
                        self.qmc.backgroundprofile_moved_y = 0
                        if doDraw:
                            self.qmc.redraw(recomputeAllDeltas=recomputeAllDeltas)
                            self.sendmessage(QApplication.translate('Message', 'B1 = [%s] ; B2 = [%s]' % (
                                EQU[0], EQU[1])))  # noqa: UP031 # pylint: disable=consider-using-f-string
                        else:
                            decay_smoothing_p = not self.qmc.optimalSmoothing
                            self.qmc.smoothETBTBkgnd(recomputeAllDeltas, decay_smoothing_p)

            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
                _, _, exc_tb = sys.exc_info()
                self.qmc.adderror(
                    (QApplication.translate('Error Message', 'Exception:') + ' setbackgroundequ(): {0}').format(str(e)),
                    getattr(exc_tb, 'tb_lineno', '?'))

    @pyqtSlot()
    @pyqtSlot(bool)
    def transform(self, _: bool = False) -> None:
        from artisanlib.transposer import profileTransformatorDlg
        dialog = profileTransformatorDlg(self, self)
        dialog.show()

    @pyqtSlot()
    @pyqtSlot(bool)
    def roastCompare(self, _: bool = False) -> None:
        if self.comparator is not None:
            self.comparator.close()
        else:
            foreground = self.curFile
            background = (self.qmc.backgroundpath if self.qmc.background else None)
            if self.qmc.reset():
                filenames = []
                if foreground is not None and foreground.strip() != '':
                    filenames.append(foreground)
                if background is not None and background.strip() != '':
                    filenames.append(background)
                if len(filenames) == 0:
                    filenames = self.reportFiles()
                if filenames and len(filenames) > 0:
                    self.deleteBackground()
                    # disable "green flag" menu:
                    try:
                        self.ntb.disable_edit_curve_parameters()
                    except Exception as e:  # pylint: disable=broad-except
                        _log.exception(e)
                    from artisanlib.comparator import roastCompareDlg
                    self.comparator = roastCompareDlg(self, self, foreground, background)
                    self.comparator.addProfiles(filenames)
                    self.comparator.show()
            self.roastCompareAction.setChecked(bool(self.comparator))

    @pyqtSlot()
    @pyqtSlot(bool)
    def simulate(self, _: bool = False) -> None:
        modifiers = QApplication.keyboardModifiers()
        control_modifier = modifiers == Qt.KeyboardModifier.ControlModifier  # command/apple key on macOS, Control key on Windows
        alt_modifier = modifiers == Qt.KeyboardModifier.AltModifier  # OPTION on macOS, ALT on Windows
        shift_modifier = modifiers == Qt.KeyboardModifier.ShiftModifier  # SHIFT
        if self.simulator is not None:
            if control_modifier or alt_modifier or shift_modifier:
                # if a modifier we change the speed instead of leaving the simulator (shift: 1x, alt: 2x, control: 4x):
                speed = 1
                if alt_modifier:
                    speed = 2
                elif control_modifier:
                    speed = 4
                self.qmc.timeclock.setBase(1000 * speed)
                self.qmc.updateDeltaSamples()  # to get the delta_spans right
                self.sendmessage(QApplication.translate('Message', 'Simulator started @{}x').format(speed))
                self.simulatorAction.setChecked(True)
            else:
                # we leave the simulator
                self.simulator = None
                self.qmc.timeclock.setBase(1000)
                self.sample_loop_running = True  # we enable the sampling loop again that might have been stopped during the simulation via a timerLCD click
                self.buttonONOFF.setStyleSheet(self.pushbuttonstyles['OFF'])
                self.buttonSTARTSTOP.setStyleSheet(self.pushbuttonstyles['STOP'])
                self.qmc.updateDeltaSamples()  # to get the delta_spans right
                self.sendmessage(QApplication.translate('Message', 'Simulator stopped'))
                self.updateWindowTitle()
                self.enableLoadImportConvertMenus()
                self.qmc.redraw(recomputeAllDeltas=False)
        else:
            try:
                if self.curFile is None:
                    filename = self.ArtisanOpenFileDialog(ext='*.alog', path=self.simulatorpath)
                else:
                    filename = self.curFile
                if filename:
                    self.disableLoadImportConvertMenus()
                    f = QFile(filename)
                    if not f.open(QFile.OpenModeFlag.ReadOnly):
                        raise OSError(f.errorString())
                    stream = QTextStream(f)
                    firstChar = stream.read(1)
                    if firstChar == '{':
                        f.close()
                        # meta_modifier = modifiers == Qt.KeyboardModifier.MetaModifier # Control on macOS, Meta/Windows on Windows
                        speed = 1
                        if alt_modifier:
                            speed = 2
                        elif control_modifier:
                            speed = 4
                        self.qmc.timeclock.setBase(1000 * speed)
                        self.simulator = Simulator(self.qmc.mode, self.deserialize(filename))
                        self.simulatorpath = filename
                        self.buttonONOFF.setStyleSheet(self.pushbuttonstyles_simulator['OFF'])
                        self.buttonSTARTSTOP.setStyleSheet(self.pushbuttonstyles_simulator['STOP'])
                        self.qmc.updateDeltaSamples()  # to get the delta_spans right
                        self.sendmessage(QApplication.translate('Message', 'Simulator started @{}x').format(speed))
                        self.updateWindowTitle()
                    else:
                        self.sendmessage(QApplication.translate('Message', 'Invalid artisan format'))
            except Exception as e:  # pylint: disable=broad-except
                _log.exception(e)
            self.simulatorAction.setChecked(bool(self.simulator))


###########################################################################################################################################
###########################################################################################################################################


def excepthook(excType: type, excValue: BaseException, tracebackobj: Optional['TracebackType']) -> None:
    """Global function to catch unhandled exceptions.

    @param excType exception type
    @param excValue exception value
    @param tracebackobj traceback object
    """
    _log.error('Logging an uncaught exception',
               exc_info=(excType, excValue, tracebackobj))
    import traceback
    separator = '' * 80
    #    logFile = 'simple.log'
    notice = \
        """An unhandled exception occurred. Please report the problem on Github:<br>""" \
        """<a href='https://github.com/artisan-roaster-scope/artisan/issues'>https://github.com/artisan-roaster-scope/artisan/issues</a><br><br>""" \
        """When reporting this issue, please include your settings file (export <br>""" \
        """via menu Help >> Save Settings) and the details below.<br><br>""" \
        """An entry has been written to the error log (menu Help >> Error).<br><br>"""
    versionInfo = f'Version: {__version__}, revision: {__revision__}<br>'
    timeString = libtime.strftime('%Y-%m-%d, %H:%M:%S')

    tbinfofile = io.StringIO()

    traceback.print_tb(tracebackobj, None, tbinfofile)
    tbinfofile.seek(0)
    tbinfo = tbinfofile.read()
    errmsg = f'{str(excType)}: \n{str(excValue)} (line: {getattr(tracebackobj, "tb_lineno", "?")})'
    stack = []
    variables = ''
    tb: Optional[TracebackType] = tracebackobj
    while tb:
        stack.append(tb.tb_frame)
        tb = tb.tb_next

    for frame in stack:
        variables += f'{frame.f_code.co_filename}::{frame.f_code.co_name}:{frame.f_lineno}\n'
        for k, value in frame.f_locals.items():
            variables += f'\t{k:>20}'
            try:
                s = str(value)
            except Exception:  # pylint: disable=broad-except
                s = '<???>'
            variables += f'{s}\n'
    sections = [timeString, separator, errmsg]
    msg = '\n'.join(sections)
    detailedmsg = '\n'.join([tbinfo, separator, variables])

    #    try:
    #        with open(logFile, 'w', encoding='utf-8') as f:
    #            f.write(msg)
    #            f.write(detailedmsg)
    #            f.write(versionInfo)
    #    except OSError:
    #        pass
    try:
        aw = None
        for widget in QApplication.topLevelWidgets():
            if isinstance(widget, ApplicationWindow):
                aw = widget
                break
        if aw is not None:
            if hasattr(aw, 'qmc'):
                aw.qmc.adderror('Error: ' + detailedmsg)
            errorbox = QMessageBox()
            errorbox.about(aw, detailedmsg, f'{notice}{versionInfo}{msg}')

            # using a (native) QErrorMessage dialog which does not allow styled text like bold/links
    #            from PyQt6.QtWidgets import QErrorMessage
    #            em = QErrorMessage(aw)
    #            em.showMessage(f'{notice}{versionInfo}{msg}')

    except Exception as e:
        _log.exception(e)


sys.excepthook = excepthook

# the following avoids the "No document could be created" dialog and the Console message
# "The Artisan Profile type doesn't map to any NSDocumentClass." on startup (since pyobjc-core 3.1.1)
if sys.platform.startswith('darwin'):
    from Cocoa import NSDocument  # type: ignore # @UnresolvedImport # pylint: disable=import-error,no-name-in-module


    class Document(NSDocument):  # type: ignore # pylint: disable= too-few-public-methods
        #        def windowNibName(self):
        #            return None #"Document"
        def makeWindowControllers(self) -> None:
            pass


def qt_message_handler(mode: QtMsgType, context: 'QMessageLogContext', message: Optional[str]) -> None:
    if mode == QtMsgType.QtInfoMsg:
        mode_str = 'INFO'
    elif mode == QtMsgType.QtWarningMsg:
        mode_str = 'WARNING'
    elif mode == QtMsgType.QtCriticalMsg:
        mode_str = 'CRITICAL'
    elif mode == QtMsgType.QtFatalMsg:
        mode_str = 'FATAL'
    else:
        mode_str = 'DEBUG'
    _log.info('qt_message_handler: line: %s, func: %s(), file: %s  %s: %s',
              context.line, context.function, context.file, mode_str, message)


def initialize_locale(my_app: Artisan) -> str:
    if QSettings().contains('resetqsettings') and not toInt(QSettings().value('resetqsettings')):
        locale = toString(QSettings().value('locale'))
        if locale is None or locale == 'en_US' or locale == 'None':
            locale = 'en'
    else:
        locale = ''

    qt_translation_modules: List[str] = [
        'qtbase',
        'qtconnectivity',
        'qtwebengine'
    ]

    supported_languages: List[str] = [
        'ar',
        'da',
        'de',
        'el',
        'en',
        'es',
        'fa',
        'fi',
        'fr',
        'gd',
        'he',
        'hu',
        'id',
        'it',
        'ja',
        'ko',
        'lv',
        'nl',
        'no',
        'pt',
        'pt_BR',
        'pl',
        #        "ru",
        'sk',
        'sv',
        'th',
        'tr',
        'uk',
        'vi',
        'zh_CN',
        'zh_TW',
    ]

    if len(locale) == 0:
        if platform.system() == 'Darwin':
            from Cocoa import \
                NSUserDefaults  # type:ignore[import-not-found,unused-ignore]  # @UnresolvedImport # pylint: disable=import-error,no-name-in-module
            defs = NSUserDefaults.standardUserDefaults()
            langs = defs.objectForKey_('AppleLanguages')
            if langs.objectAtIndex_(0)[:7] == 'zh_Hans':
                locale = 'zh_CN'
            elif langs.objectAtIndex_(0)[:7] == 'zh_Hant':
                locale = 'zh_TW'
            elif len(langs.objectAtIndex_(0)) > 4 and langs.objectAtIndex_(0)[:3] in {'zh_', 'pt_'}:
                locale = langs.objectAtIndex_(0)[:5]
            else:
                locale = langs.objectAtIndex_(0)[:2]
        else:
            lname = QLocale.system().name()
            if lname[:7] == 'zh_Hans':
                locale = 'zh_CN'
            elif lname[:7] == 'zh_Hant':
                locale = 'zh_TW'
            elif len(lname) > 4 and lname[:2] in {'zh_', 'pt_'}:
                locale = lname[:5]
            else:
                locale = lname[:2]
        if locale == 'zh':
            locale = 'zh_CN'
        if locale in supported_languages:
            QSettings().setValue('locale', locale)

    if locale is None or len(locale) == 0 or locale == 'None':
        locale = 'en'

    # load Qt default translations from QLibrary
    try:
        try:
            qt_trans_path = QLibraryInfo.path(QLibraryInfo.LibraryPath.TranslationsPath)
        except Exception:  # pylint: disable=broad-except
            qt_trans_path = QLibraryInfo.location(QLibraryInfo.TranslationsPath)  # type: ignore

        trans_paths: List[str] = []
        # add the translations path for binary installations
        if sys.platform.startswith('darwin'):
            trans_paths.append(QApplication.applicationDirPath() + '/../translations')
        else:
            trans_paths.append(QApplication.applicationDirPath() + '/translations')
        # add the translations path for source installations
        trans_paths.append('translations')

        # load Qt translations
        for qt_trans_module in qt_translation_modules:
            # each QTranslator can only hold one file
            qtTranslator: QTranslator = QTranslator(my_app)
            qt_qm_file: str = f'{qt_trans_module}_{locale}'
            for trans_path in [qt_trans_path] + trans_paths:  # start with the default PyQt/Qt translations location
                if qtTranslator.load(qt_qm_file, trans_path):
                    _log.info('loading qt translations %s from %s', qt_qm_file, trans_path)
                    break
            my_app.installTranslator(qtTranslator)

        # load Artisan translations
        appTranslator: QTranslator = QTranslator(my_app)
        artisan_qm_file: str = f'artisan_{locale}'
        for trans_path in trans_paths:
            if appTranslator.load(artisan_qm_file, trans_path):
                _log.info('loading Artisan translations %s from %s', artisan_qm_file, trans_path)
                break
        my_app.installTranslator(appTranslator)
    except Exception as e:
        _log.exception(e)

    return locale


def main() -> None:
    # suppress all Qt messages
    qInstallMessageHandler(qt_message_handler)

    # suppress all warnings
    warnings.filterwarnings('ignore')

    artisanviewerFirstStart: bool = False

    if app.artisanviewerMode:
        app.setApplicationName(
            application_viewer_name)  # needed by QSettings() to store windows geometry in operating system
        viewersettings = QSettings()
        if not viewersettings.contains('Mode'):
            artisanviewerFirstStart = True
        del viewersettings

    locale_str = initialize_locale(app)
    _log.info('locale: %s', locale_str)

    appWindow = ApplicationWindow(locale=locale_str, WebEngineSupport=QtWebEngineSupport,
                                  artisanviewerFirstStart=artisanviewerFirstStart)

    app.setActivationWindow(appWindow, activateOnMessage=False)  # set the activation window for the QtSingleApplication

    # only here deactivating the app napping seems to have an effect
    if sys.platform.startswith('darwin'):
        import \
            appnope  # pyright: ignore # @UnresolvedImport # type: ignore # pylint: disable=import-error,redefined-outer-name
        appnope.nope()

    if locale_str in {'ar', 'he', 'fa'}:
        QApplication.setLayoutDirection(Qt.LayoutDirection.RightToLeft)
    else:
        QApplication.setLayoutDirection(Qt.LayoutDirection.LeftToRight)

    start_time = libtime.process_time()  # begin of settings load
    # fill self.defaultSettings with default app QSettings values before loading app settings from system via settingsLoad()
    appWindow.saveAllSettings(QSettings(), appWindow.defaultSettings,
                              read_defaults=True)  # don't save any settings, but just read in the defaults
    appWindow.settingsLoad(redraw=False)  # redraw is triggered later in the startup process again
    appWindow.restoreExtraDeviceSettingsBackup()  # load settings backup if it exists (like on RESET)
    _log.info('loaded %s settings in %.2fs', len(QSettings().allKeys()), libtime.process_time() - start_time)

    # inform the user the debug logging is on
    if debugLogLevelActive():
        appWindow.sendmessage(QApplication.translate('Message', 'debug logging ON'))

    appWindow.show()
    # 画表格的线
    try:
        if sys.argv and len(sys.argv) > 1:
            argv_file = str(sys.argv[1])

            if platform.system() in {'Windows', 'Linux'}:
                # send argv_file to running instance and exit this one
                if app.isRunning():
                    # reformat a file path to a url form
                    if re.match(r'^.:', argv_file):
                        argv_file = QUrl.fromLocalFile(
                            argv_file).toString()  # here we don't want a local file, preserve the windows file:///
                    app.sendMessage(argv_file)
                    sys.exit(0)
                # otherwise if an artisan://roast url open it in this instance, if not a url do normal file processing
                elif re.match(r'artisan://[roast|profile]', argv_file):
                    url = QUrl()
                    url.setUrl(argv_file)
                    app.open_url(url)
            # on Linux (and RPi), local argv_file paths may contain percent encoded spaces %20 and a file:// URL prefix
            if platform.system() == 'Linux':
                from urllib.parse import unquote_plus
                argv_file_decoded = unquote_plus(argv_file)
                u = QUrl(unquote_plus(argv_file_decoded))
                if u.isLocalFile():
                    argv_file = u.toLocalFile()
                else:
                    argv_file = argv_file_decoded

            qfile = QFileInfo(argv_file)
            file_suffix = qfile.suffix()
            if file_suffix == 'alog':
                # load Artisan profile on double-click on *.alog file
                appWindow.loadFile(argv_file)
            elif file_suffix == 'alrm':
                # load Artisan alarms on double-click on *.alrm file
                appWindow.loadAlarms(argv_file)
            elif file_suffix == 'apal':
                # load Artisan palettes on double-click on *.apal file
                appWindow.getPalettes(argv_file, appWindow.buttonpalette)
            elif file_suffix == 'aset':
                # load Artisan settings on double-click on *.aset file
                appWindow.loadSettings(fn=argv_file)
            elif file_suffix == 'athm':
                # load Artisan settings on double-click on *.athm file
                appWindow.loadSettings(fn=argv_file, reset=False)
        else:
            # we try to reload the last loaded profile or background
            if appWindow.lastLoadedProfile:
                try:
                    appWindow.loadFile(appWindow.lastLoadedProfile)
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
            elif appWindow.logofilename != '':  # ensure background image aspect ratio is calculated
                appWindow.qmc.reset(redraw=False, soundOn=False)
            if appWindow.lastLoadedBackground and appWindow.lastLoadedBackground != '' and not appWindow.curFile:
                try:
                    appWindow.loadbackground(appWindow.lastLoadedBackground)
                    appWindow.qmc.background = not appWindow.qmc.hideBgafterprofileload
                    if not appWindow.lastLoadedProfile and not (appWindow.logofilename != '' and appWindow.logoimgflag):
                        # this extra redraw is not needed if a watermark is loaded as it is triggered by the resize-redraw mechanism
                        appWindow.qmc.timealign(redraw=False)
                        appWindow.autoAdjustAxis(
                            background=appWindow.qmc.background and (not len(appWindow.qmc.timex) > 3))
                        appWindow.qmc.redraw()
                    else:
                        appWindow.qmc.timealign(redraw=True, recompute=True)
                except Exception as e:  # pylint: disable=broad-except
                    _log.exception(e)
                    appWindow.qmc.background = False
                    appWindow.qmc.backgroundprofile = None
                    appWindow.qmc.backgroundprofile_moved_x = 0
                    appWindow.qmc.backgroundprofile_moved_y = 0
            if not appWindow.lastLoadedBackground and not appWindow.lastLoadedProfile:
                # redraw once to get geometry right
                appWindow.qmc.redraw(False)
    except Exception as e:  # pylint: disable=broad-except
        _log.exception(e)

    # write gc debug messages to stdout
    #    gc.set_debug(gc.DEBUG_STATS)

    #    if platform.system() == 'Windows' and appFrozen():
    #        try:
    #            sys.stderr = sys.stdout
    #        except Exception: # pylint: disable=broad-except
    #            pass

    QTimer.singleShot(700, appWindow.qmc.startPhidgetManager)
    #    QTimer.singleShot(1, appWindow.fileQuit) # uncomment to measure startup/quit turnaround times

    # the following line is to trap numpy warnings that occur in the Cup Profile dialog if all values are set to 0
    with numpy.errstate(invalid='ignore', divide='ignore', over='ignore', under='ignore'):
        # the next line is needed to capture MPL warnings (emitted through logging) of the format
        # "UserWarning: Glyph 231 (\N{LATIN SMALL LETTER C WITH CEDILLA}) missing from current font."
        logging.captureWarnings(True)
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            with suppress_stdout_stderr():
                app.exec()
        # alternative:
        # ret = app.exec()
        # app = None
        # sys.exit()

# the following seems to create issue on Mac and Windows builds on exit
#    del aw
#    del app
#    sys.exit(0)

##############################################################################################################################################
##############################################################################################################################################
